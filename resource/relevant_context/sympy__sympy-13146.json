{"instance_id": "sympy__sympy-13146", "identified_spans": [{"file_path": "sympy/core/evalf.py", "span_ids": ["EvalfMixin.evalf"], "content": [{"span_id": "EvalfMixin.evalf", "start_line": 1340, "end_line": 1419, "content": ["    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n", "        \"\"\"\n", "        Evaluate the given formula to an accuracy of n digits.\n", "        Optional keyword arguments:\n", "\n", "            subs=<dict>\n", "                Substitute numerical values for symbols, e.g.\n", "                subs={x:3, y:1+pi}. The substitutions must be given as a\n", "                dictionary.\n", "\n", "            maxn=<integer>\n", "                Allow a maximum temporary working precision of maxn digits\n", "                (default=100)\n", "\n", "            chop=<bool>\n", "                Replace tiny real or imaginary parts in subresults\n", "                by exact zeros (default=False)\n", "\n", "            strict=<bool>\n", "                Raise PrecisionExhausted if any subresult fails to evaluate\n", "                to full accuracy, given the available maxprec\n", "                (default=False)\n", "\n", "            quad=<str>\n", "                Choose algorithm for numerical quadrature. By default,\n", "                tanh-sinh quadrature is used. For oscillatory\n", "                integrals on an infinite interval, try quad='osc'.\n", "\n", "            verbose=<bool>\n", "                Print debug information (default=False)\n", "\n", "        \"\"\"\n", "        from sympy import Float, Number\n", "        n = n if n is not None else 15\n", "\n", "        if subs and is_sequence(subs):\n", "            raise TypeError('subs must be given as a dictionary')\n", "\n", "        # for sake of sage that doesn't like evalf(1)\n", "        if n == 1 and isinstance(self, Number):\n", "            from sympy.core.expr import _mag\n", "            rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n", "            m = _mag(rv)\n", "            rv = rv.round(1 - m)\n", "            return rv\n", "\n", "        if not evalf_table:\n", "            _create_evalf_table()\n", "        prec = dps_to_prec(n)\n", "        options = {'maxprec': max(prec, int(maxn*LG10)), 'chop': chop,\n", "               'strict': strict, 'verbose': verbose}\n", "        if subs is not None:\n", "            options['subs'] = subs\n", "        if quad is not None:\n", "            options['quad'] = quad\n", "        try:\n", "            result = evalf(self, prec + 4, options)\n", "        except NotImplementedError:\n", "            # Fall back to the ordinary evalf\n", "            v = self._eval_evalf(prec)\n", "            if v is None:\n", "                return self\n", "            try:\n", "                # If the result is numerical, normalize it\n", "                result = evalf(v, prec, options)\n", "            except NotImplementedError:\n", "                # Probably contains symbols or unknown functions\n", "                return v\n", "        re, im, re_acc, im_acc = result\n", "        if re:\n", "            p = max(min(prec, re_acc), 1)\n", "            re = Float._new(re, p)\n", "        else:\n", "            re = S.Zero\n", "        if im:\n", "            p = max(min(prec, im_acc), 1)\n", "            im = Float._new(im, p)\n", "            return re + im*S.ImaginaryUnit\n", "        else:\n", "            return re\n"]}]}, {"file_path": "sympy/simplify/powsimp.py", "span_ids": ["powsimp"], "content": [{"span_id": "powsimp", "start_line": 17, "end_line": 483, "content": ["def powsimp(expr, deep=False, combine='all', force=False, measure=count_ops):\n", "    \"\"\"\n", "    reduces expression by combining powers with similar bases and exponents.\n", "\n", "    Notes\n", "    =====\n", "\n", "    If deep is True then powsimp() will also simplify arguments of\n", "    functions. By default deep is set to False.\n", "\n", "    If force is True then bases will be combined without checking for\n", "    assumptions, e.g. sqrt(x)*sqrt(y) -> sqrt(x*y) which is not true\n", "    if x and y are both negative.\n", "\n", "    You can make powsimp() only combine bases or only combine exponents by\n", "    changing combine='base' or combine='exp'.  By default, combine='all',\n", "    which does both.  combine='base' will only combine::\n", "\n", "         a   a          a                          2x      x\n", "        x * y  =>  (x*y)   as well as things like 2   =>  4\n", "\n", "    and combine='exp' will only combine\n", "    ::\n", "\n", "         a   b      (a + b)\n", "        x * x  =>  x\n", "\n", "    combine='exp' will strictly only combine exponents in the way that used\n", "    to be automatic.  Also use deep=True if you need the old behavior.\n", "\n", "    When combine='all', 'exp' is evaluated first.  Consider the first\n", "    example below for when there could be an ambiguity relating to this.\n", "    This is done so things like the second example can be completely\n", "    combined.  If you want 'base' combined first, do something like\n", "    powsimp(powsimp(expr, combine='base'), combine='exp').\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import powsimp, exp, log, symbols\n", "    >>> from sympy.abc import x, y, z, n\n", "    >>> powsimp(x**y*x**z*y**z, combine='all')\n", "    x**(y + z)*y**z\n", "    >>> powsimp(x**y*x**z*y**z, combine='exp')\n", "    x**(y + z)*y**z\n", "    >>> powsimp(x**y*x**z*y**z, combine='base', force=True)\n", "    x**y*(x*y)**z\n", "\n", "    >>> powsimp(x**z*x**y*n**z*n**y, combine='all', force=True)\n", "    (n*x)**(y + z)\n", "    >>> powsimp(x**z*x**y*n**z*n**y, combine='exp')\n", "    n**(y + z)*x**(y + z)\n", "    >>> powsimp(x**z*x**y*n**z*n**y, combine='base', force=True)\n", "    (n*x)**y*(n*x)**z\n", "\n", "    >>> x, y = symbols('x y', positive=True)\n", "    >>> powsimp(log(exp(x)*exp(y)))\n", "    log(exp(x)*exp(y))\n", "    >>> powsimp(log(exp(x)*exp(y)), deep=True)\n", "    x + y\n", "\n", "    Radicals with Mul bases will be combined if combine='exp'\n", "\n", "    >>> from sympy import sqrt, Mul\n", "    >>> x, y = symbols('x y')\n", "\n", "    Two radicals are automatically joined through Mul:\n", "\n", "    >>> a=sqrt(x*sqrt(y))\n", "    >>> a*a**3 == a**4\n", "    True\n", "\n", "    But if an integer power of that radical has been\n", "    autoexpanded then Mul does not join the resulting factors:\n", "\n", "    >>> a**4 # auto expands to a Mul, no longer a Pow\n", "    x**2*y\n", "    >>> _*a # so Mul doesn't combine them\n", "    x**2*y*sqrt(x*sqrt(y))\n", "    >>> powsimp(_) # but powsimp will\n", "    (x*sqrt(y))**(5/2)\n", "    >>> powsimp(x*y*a) # but won't when doing so would violate assumptions\n", "    x*y*sqrt(x*sqrt(y))\n", "\n", "    \"\"\"\n", "    from sympy.matrices.expressions.matexpr import MatrixSymbol\n", "\n", "    def recurse(arg, **kwargs):\n", "        _deep = kwargs.get('deep', deep)\n", "        _combine = kwargs.get('combine', combine)\n", "        _force = kwargs.get('force', force)\n", "        _measure = kwargs.get('measure', measure)\n", "        return powsimp(arg, _deep, _combine, _force, _measure)\n", "\n", "    expr = sympify(expr)\n", "\n", "    if (not isinstance(expr, Basic) or isinstance(expr, MatrixSymbol) or (\n", "            expr.is_Atom or expr in (exp_polar(0), exp_polar(1)))):\n", "        return expr\n", "\n", "    if deep or expr.is_Add or expr.is_Mul and _y not in expr.args:\n", "        expr = expr.func(*[recurse(w) for w in expr.args])\n", "\n", "    if expr.is_Pow:\n", "        return recurse(expr*_y, deep=False)/_y\n", "\n", "    if not expr.is_Mul:\n", "        return expr\n", "\n", "    # handle the Mul\n", "    if combine in ('exp', 'all'):\n", "        # Collect base/exp data, while maintaining order in the\n", "        # non-commutative parts of the product\n", "        c_powers = defaultdict(list)\n", "        nc_part = []\n", "        newexpr = []\n", "        coeff = S.One\n", "        for term in expr.args:\n", "            if term.is_Rational:\n", "                coeff *= term\n", "                continue\n", "            if term.is_Pow:\n", "                term = _denest_pow(term)\n", "            if term.is_commutative:\n", "                b, e = term.as_base_exp()\n", "                if deep:\n", "                    b, e = [recurse(i) for i in [b, e]]\n", "                if b.is_Pow or b.func is exp:\n", "                    # don't let smthg like sqrt(x**a) split into x**a, 1/2\n", "                    # or else it will be joined as x**(a/2) later\n", "                    b, e = b**e, S.One\n", "                c_powers[b].append(e)\n", "            else:\n", "                # This is the logic that combines exponents for equal,\n", "                # but non-commutative bases: A**x*A**y == A**(x+y).\n", "                if nc_part:\n", "                    b1, e1 = nc_part[-1].as_base_exp()\n", "                    b2, e2 = term.as_base_exp()\n", "                    if (b1 == b2 and\n", "                            e1.is_commutative and e2.is_commutative):\n", "                        nc_part[-1] = Pow(b1, Add(e1, e2))\n", "                        continue\n", "                nc_part.append(term)\n", "\n", "        # add up exponents of common bases\n", "        for b, e in ordered(iter(c_powers.items())):\n", "            # allow 2**x/4 -> 2**(x - 2); don't do this when b and e are\n", "            # Numbers since autoevaluation will undo it, e.g.\n", "            # 2**(1/3)/4 -> 2**(1/3 - 2) -> 2**(1/3)/4\n", "            if (b and b.is_Number and not all(ei.is_Number for ei in e) and \\\n", "                    coeff is not S.One and\n", "                    b not in (S.One, S.NegativeOne)):\n", "                m = multiplicity(abs(b), abs(coeff))\n", "                if m:\n", "                    e.append(m)\n", "                    coeff /= b**m\n", "            c_powers[b] = Add(*e)\n", "        if coeff is not S.One:\n", "            if coeff in c_powers:\n", "                c_powers[coeff] += S.One\n", "            else:\n", "                c_powers[coeff] = S.One\n", "\n", "        # convert to plain dictionary\n", "        c_powers = dict(c_powers)\n", "\n", "        # check for base and inverted base pairs\n", "        be = list(c_powers.items())\n", "        skip = set()  # skip if we already saw them\n", "        for b, e in be:\n", "            if b in skip:\n", "                continue\n", "            bpos = b.is_positive or b.is_polar\n", "            if bpos:\n", "                binv = 1/b\n", "                if b != binv and binv in c_powers:\n", "                    if b.as_numer_denom()[0] is S.One:\n", "                        c_powers.pop(b)\n", "                        c_powers[binv] -= e\n", "                    else:\n", "                        skip.add(binv)\n", "                        e = c_powers.pop(binv)\n", "                        c_powers[b] -= e\n", "\n", "        # check for base and negated base pairs\n", "        be = list(c_powers.items())\n", "        _n = S.NegativeOne\n", "        for i, (b, e) in enumerate(be):\n", "            if ((-b).is_Symbol or b.is_Add) and -b in c_powers:\n", "                if (b.is_positive in (0, 1) or e.is_integer):\n", "                    c_powers[-b] += c_powers.pop(b)\n", "                    if _n in c_powers:\n", "                        c_powers[_n] += e\n", "                    else:\n", "                        c_powers[_n] = e\n", "\n", "        # filter c_powers and convert to a list\n", "        c_powers = [(b, e) for b, e in c_powers.items() if e]\n", "\n", "        # ==============================================================\n", "        # check for Mul bases of Rational powers that can be combined with\n", "        # separated bases, e.g. x*sqrt(x*y)*sqrt(x*sqrt(x*y)) ->\n", "        # (x*sqrt(x*y))**(3/2)\n", "        # ---------------- helper functions\n", "\n", "        def ratq(x):\n", "            '''Return Rational part of x's exponent as it appears in the bkey.\n", "            '''\n", "            return bkey(x)[0][1]\n", "\n", "        def bkey(b, e=None):\n", "            '''Return (b**s, c.q), c.p where e -> c*s. If e is not given then\n", "            it will be taken by using as_base_exp() on the input b.\n", "            e.g.\n", "                x**3/2 -> (x, 2), 3\n", "                x**y -> (x**y, 1), 1\n", "                x**(2*y/3) -> (x**y, 3), 2\n", "                exp(x/2) -> (exp(a), 2), 1\n", "\n", "            '''\n", "            if e is not None:  # coming from c_powers or from below\n", "                if e.is_Integer:\n", "                    return (b, S.One), e\n", "                elif e.is_Rational:\n", "                    return (b, Integer(e.q)), Integer(e.p)\n", "                else:\n", "                    c, m = e.as_coeff_Mul(rational=True)\n", "                    if c is not S.One:\n", "                        if m.is_integer:\n", "                            return (b, Integer(c.q)), m*Integer(c.p)\n", "                        return (b**m, Integer(c.q)), Integer(c.p)\n", "                    else:\n", "                        return (b**e, S.One), S.One\n", "            else:\n", "                return bkey(*b.as_base_exp())\n", "\n", "        def update(b):\n", "            '''Decide what to do with base, b. If its exponent is now an\n", "            integer multiple of the Rational denominator, then remove it\n", "            and put the factors of its base in the common_b dictionary or\n", "            update the existing bases if necessary. If it has been zeroed\n", "            out, simply remove the base.\n", "            '''\n", "            newe, r = divmod(common_b[b], b[1])\n", "            if not r:\n", "                common_b.pop(b)\n", "                if newe:\n", "                    for m in Mul.make_args(b[0]**newe):\n", "                        b, e = bkey(m)\n", "                        if b not in common_b:\n", "                            common_b[b] = 0\n", "                        common_b[b] += e\n", "                        if b[1] != 1:\n", "                            bases.append(b)\n", "        # ---------------- end of helper functions\n", "\n", "        # assemble a dictionary of the factors having a Rational power\n", "        common_b = {}\n", "        done = []\n", "        bases = []\n", "        for b, e in c_powers:\n", "            b, e = bkey(b, e)\n", "            if b in common_b.keys():\n", "                common_b[b] = common_b[b] + e\n", "            else:\n", "                common_b[b] = e\n", "            if b[1] != 1 and b[0].is_Mul:\n", "                bases.append(b)\n", "        c_powers = [(b, e) for b, e in common_b.items() if e]\n", "        bases.sort(key=default_sort_key)  # this makes tie-breaking canonical\n", "        bases.sort(key=measure, reverse=True)  # handle longest first\n", "        for base in bases:\n", "            if base not in common_b:  # it may have been removed already\n", "                continue\n", "            b, exponent = base\n", "            last = False  # True when no factor of base is a radical\n", "            qlcm = 1  # the lcm of the radical denominators\n", "            while True:\n", "                bstart = b\n", "                qstart = qlcm\n", "\n", "                bb = []  # list of factors\n", "                ee = []  # (factor's expo. and it's current value in common_b)\n", "                for bi in Mul.make_args(b):\n", "                    bib, bie = bkey(bi)\n", "                    if bib not in common_b or common_b[bib] < bie:\n", "                        ee = bb = []  # failed\n", "                        break\n", "                    ee.append([bie, common_b[bib]])\n", "                    bb.append(bib)\n", "                if ee:\n", "                    # find the number of extractions possible\n", "                    # e.g. [(1, 2), (2, 2)] -> min(2/1, 2/2) -> 1\n", "                    min1 = ee[0][1]/ee[0][0]\n", "                    for i in range(len(ee)):\n", "                        rat = ee[i][1]/ee[i][0]\n", "                        if rat < 1:\n", "                            break\n", "                        min1 = min(min1, rat)\n", "                    else:\n", "                        # update base factor counts\n", "                        # e.g. if ee = [(2, 5), (3, 6)] then min1 = 2\n", "                        # and the new base counts will be 5-2*2 and 6-2*3\n", "                        for i in range(len(bb)):\n", "                            common_b[bb[i]] -= min1*ee[i][0]\n", "                            update(bb[i])\n", "                        # update the count of the base\n", "                        # e.g. x**2*y*sqrt(x*sqrt(y)) the count of x*sqrt(y)\n", "                        # will increase by 4 to give bkey (x*sqrt(y), 2, 5)\n", "                        common_b[base] += min1*qstart*exponent\n", "                if (last  # no more radicals in base\n", "                    or len(common_b) == 1  # nothing left to join with\n", "                    or all(k[1] == 1 for k in common_b)  # no rad's in common_b\n", "                        ):\n", "                    break\n", "                # see what we can exponentiate base by to remove any radicals\n", "                # so we know what to search for\n", "                # e.g. if base were x**(1/2)*y**(1/3) then we should\n", "                # exponentiate by 6 and look for powers of x and y in the ratio\n", "                # of 2 to 3\n", "                qlcm = lcm([ratq(bi) for bi in Mul.make_args(bstart)])\n", "                if qlcm == 1:\n", "                    break  # we are done\n", "                b = bstart**qlcm\n", "                qlcm *= qstart\n", "                if all(ratq(bi) == 1 for bi in Mul.make_args(b)):\n", "                    last = True  # we are going to be done after this next pass\n", "            # this base no longer can find anything to join with and\n", "            # since it was longer than any other we are done with it\n", "            b, q = base\n", "            done.append((b, common_b.pop(base)*Rational(1, q)))\n", "\n", "        # update c_powers and get ready to continue with powsimp\n", "        c_powers = done\n", "        # there may be terms still in common_b that were bases that were\n", "        # identified as needing processing, so remove those, too\n", "        for (b, q), e in common_b.items():\n", "            if (b.is_Pow or b.func is exp) and \\\n", "                    q is not S.One and not b.exp.is_Rational:\n", "                b, be = b.as_base_exp()\n", "                b = b**(be/q)\n", "            else:\n", "                b = root(b, q)\n", "            c_powers.append((b, e))\n", "        check = len(c_powers)\n", "        c_powers = dict(c_powers)\n", "        assert len(c_powers) == check  # there should have been no duplicates\n", "        # ==============================================================\n", "\n", "        # rebuild the expression\n", "        newexpr = expr.func(*(newexpr + [Pow(b, e) for b, e in c_powers.items()]))\n", "        if combine == 'exp':\n", "            return expr.func(newexpr, expr.func(*nc_part))\n", "        else:\n", "            return recurse(expr.func(*nc_part), combine='base') * \\\n", "                recurse(newexpr, combine='base')\n", "\n", "    elif combine == 'base':\n", "\n", "        # Build c_powers and nc_part.  These must both be lists not\n", "        # dicts because exp's are not combined.\n", "        c_powers = []\n", "        nc_part = []\n", "        for term in expr.args:\n", "            if term.is_commutative:\n", "                c_powers.append(list(term.as_base_exp()))\n", "            else:\n", "                nc_part.append(term)\n", "\n", "        # Pull out numerical coefficients from exponent if assumptions allow\n", "        # e.g., 2**(2*x) => 4**x\n", "        for i in range(len(c_powers)):\n", "            b, e = c_powers[i]\n", "            if not (all(x.is_nonnegative for x in b.as_numer_denom()) or e.is_integer or force or b.is_polar):\n", "                continue\n", "            exp_c, exp_t = e.as_coeff_Mul(rational=True)\n", "            if exp_c is not S.One and exp_t is not S.One:\n", "                c_powers[i] = [Pow(b, exp_c), exp_t]\n", "\n", "        # Combine bases whenever they have the same exponent and\n", "        # assumptions allow\n", "        # first gather the potential bases under the common exponent\n", "        c_exp = defaultdict(list)\n", "        for b, e in c_powers:\n", "            if deep:\n", "                e = recurse(e)\n", "            c_exp[e].append(b)\n", "        del c_powers\n", "\n", "        # Merge back in the results of the above to form a new product\n", "        c_powers = defaultdict(list)\n", "        for e in c_exp:\n", "            bases = c_exp[e]\n", "\n", "            # calculate the new base for e\n", "\n", "            if len(bases) == 1:\n", "                new_base = bases[0]\n", "            elif e.is_integer or force:\n", "                new_base = expr.func(*bases)\n", "            else:\n", "                # see which ones can be joined\n", "                unk = []\n", "                nonneg = []\n", "                neg = []\n", "                for bi in bases:\n", "                    if bi.is_negative:\n", "                        neg.append(bi)\n", "                    elif bi.is_nonnegative:\n", "                        nonneg.append(bi)\n", "                    elif bi.is_polar:\n", "                        nonneg.append(\n", "                            bi)  # polar can be treated like non-negative\n", "                    else:\n", "                        unk.append(bi)\n", "                if len(unk) == 1 and not neg or len(neg) == 1 and not unk:\n", "                    # a single neg or a single unk can join the rest\n", "                    nonneg.extend(unk + neg)\n", "                    unk = neg = []\n", "                elif neg:\n", "                    # their negative signs cancel in groups of 2*q if we know\n", "                    # that e = p/q else we have to treat them as unknown\n", "                    israt = False\n", "                    if e.is_Rational:\n", "                        israt = True\n", "                    else:\n", "                        p, d = e.as_numer_denom()\n", "                        if p.is_integer and d.is_integer:\n", "                            israt = True\n", "                    if israt:\n", "                        neg = [-w for w in neg]\n", "                        unk.extend([S.NegativeOne]*len(neg))\n", "                    else:\n", "                        unk.extend(neg)\n", "                        neg = []\n", "                    del israt\n", "\n", "                # these shouldn't be joined\n", "                for b in unk:\n", "                    c_powers[b].append(e)\n", "                # here is a new joined base\n", "                new_base = expr.func(*(nonneg + neg))\n", "                # if there are positive parts they will just get separated\n", "                # again unless some change is made\n", "\n", "                def _terms(e):\n", "                    # return the number of terms of this expression\n", "                    # when multiplied out -- assuming no joining of terms\n", "                    if e.is_Add:\n", "                        return sum([_terms(ai) for ai in e.args])\n", "                    if e.is_Mul:\n", "                        return prod([_terms(mi) for mi in e.args])\n", "                    return 1\n", "                xnew_base = expand_mul(new_base, deep=False)\n", "                if len(Add.make_args(xnew_base)) < _terms(new_base):\n", "                    new_base = factor_terms(xnew_base)\n", "\n", "            c_powers[new_base].append(e)\n", "\n", "        # break out the powers from c_powers now\n", "        c_part = [Pow(b, ei) for b, e in c_powers.items() for ei in e]\n", "\n", "        # we're done\n", "        return expr.func(*(c_part + nc_part))\n", "\n", "    else:\n", "        raise ValueError(\"combine must be one of ('all', 'exp', 'base').\")\n"]}]}, {"file_path": "sympy/simplify/simplify.py", "span_ids": ["simplify"], "content": [{"span_id": "simplify", "start_line": 385, "end_line": 613, "content": ["def simplify(expr, ratio=1.7, measure=count_ops, fu=False):\n", "    \"\"\"\n", "    Simplifies the given expression.\n", "\n", "    Simplification is not a well defined term and the exact strategies\n", "    this function tries can change in the future versions of SymPy. If\n", "    your algorithm relies on \"simplification\" (whatever it is), try to\n", "    determine what you need exactly  -  is it powsimp()?, radsimp()?,\n", "    together()?, logcombine()?, or something else? And use this particular\n", "    function directly, because those are well defined and thus your algorithm\n", "    will be robust.\n", "\n", "    Nonetheless, especially for interactive use, or when you don't know\n", "    anything about the structure of the expression, simplify() tries to apply\n", "    intelligent heuristics to make the input expression \"simpler\".  For\n", "    example:\n", "\n", "    >>> from sympy import simplify, cos, sin\n", "    >>> from sympy.abc import x, y\n", "    >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n", "    >>> a\n", "    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n", "    >>> simplify(a)\n", "    x + 1\n", "\n", "    Note that we could have obtained the same result by using specific\n", "    simplification functions:\n", "\n", "    >>> from sympy import trigsimp, cancel\n", "    >>> trigsimp(a)\n", "    (x**2 + x)/x\n", "    >>> cancel(_)\n", "    x + 1\n", "\n", "    In some cases, applying :func:`simplify` may actually result in some more\n", "    complicated expression. The default ``ratio=1.7`` prevents more extreme\n", "    cases: if (result length)/(input length) > ratio, then input is returned\n", "    unmodified.  The ``measure`` parameter lets you specify the function used\n", "    to determine how complex an expression is.  The function should take a\n", "    single argument as an expression and return a number such that if\n", "    expression ``a`` is more complex than expression ``b``, then\n", "    ``measure(a) > measure(b)``.  The default measure function is\n", "    :func:`count_ops`, which returns the total number of operations in the\n", "    expression.\n", "\n", "    For example, if ``ratio=1``, ``simplify`` output can't be longer\n", "    than input.\n", "\n", "    ::\n", "\n", "        >>> from sympy import sqrt, simplify, count_ops, oo\n", "        >>> root = 1/(sqrt(2)+3)\n", "\n", "    Since ``simplify(root)`` would result in a slightly longer expression,\n", "    root is returned unchanged instead::\n", "\n", "       >>> simplify(root, ratio=1) == root\n", "       True\n", "\n", "    If ``ratio=oo``, simplify will be applied anyway::\n", "\n", "        >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n", "        True\n", "\n", "    Note that the shortest expression is not necessary the simplest, so\n", "    setting ``ratio`` to 1 may not be a good idea.\n", "    Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n", "    choice.\n", "\n", "    You can easily define your own measure function based on what you feel\n", "    should represent the \"size\" or \"complexity\" of the input expression.  Note\n", "    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n", "    good metrics, but have other problems (in this case, the measure function\n", "    may slow down simplify too much for very large expressions).  If you don't\n", "    know what a good metric would be, the default, ``count_ops``, is a good\n", "    one.\n", "\n", "    For example:\n", "\n", "    >>> from sympy import symbols, log\n", "    >>> a, b = symbols('a b', positive=True)\n", "    >>> g = log(a) + log(b) + log(a)*log(1/b)\n", "    >>> h = simplify(g)\n", "    >>> h\n", "    log(a*b**(-log(a) + 1))\n", "    >>> count_ops(g)\n", "    8\n", "    >>> count_ops(h)\n", "    5\n", "\n", "    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n", "    However, we may not like how ``simplify`` (in this case, using\n", "    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n", "    to reduce this would be to give more weight to powers as operations in\n", "    ``count_ops``.  We can do this by using the ``visual=True`` option:\n", "\n", "    >>> print(count_ops(g, visual=True))\n", "    2*ADD + DIV + 4*LOG + MUL\n", "    >>> print(count_ops(h, visual=True))\n", "    2*LOG + MUL + POW + SUB\n", "\n", "    >>> from sympy import Symbol, S\n", "    >>> def my_measure(expr):\n", "    ...     POW = Symbol('POW')\n", "    ...     # Discourage powers by giving POW a weight of 10\n", "    ...     count = count_ops(expr, visual=True).subs(POW, 10)\n", "    ...     # Every other operation gets a weight of 1 (the default)\n", "    ...     count = count.replace(Symbol, type(S.One))\n", "    ...     return count\n", "    >>> my_measure(g)\n", "    8\n", "    >>> my_measure(h)\n", "    14\n", "    >>> 15./8 > 1.7 # 1.7 is the default ratio\n", "    True\n", "    >>> simplify(g, measure=my_measure)\n", "    -log(a)*log(b) + log(a) + log(b)\n", "\n", "    Note that because ``simplify()`` internally tries many different\n", "    simplification strategies and then compares them using the measure\n", "    function, we get a completely different result that is still different\n", "    from the input expression by doing this.\n", "    \"\"\"\n", "    expr = sympify(expr)\n", "\n", "    try:\n", "        return expr._eval_simplify(ratio=ratio, measure=measure)\n", "    except AttributeError:\n", "        pass\n", "\n", "    original_expr = expr = signsimp(expr)\n", "\n", "    from sympy.simplify.hyperexpand import hyperexpand\n", "    from sympy.functions.special.bessel import BesselBase\n", "    from sympy import Sum, Product\n", "\n", "    if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n", "        return expr\n", "\n", "    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n", "        if isinstance(expr, Function) and hasattr(expr, \"inverse\"):\n", "            if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \\\n", "               isinstance(expr.args[0], expr.inverse(argindex=1)):\n", "                return simplify(expr.args[0].args[0], ratio=ratio,\n", "                                measure=measure, fu=fu)\n", "        return expr.func(*[simplify(x, ratio=ratio, measure=measure, fu=fu)\n", "                         for x in expr.args])\n", "\n", "    # TODO: Apply different strategies, considering expression pattern:\n", "    # is it a purely rational function? Is there any trigonometric function?...\n", "    # See also https://github.com/sympy/sympy/pull/185.\n", "\n", "    def shorter(*choices):\n", "        '''Return the choice that has the fewest ops. In case of a tie,\n", "        the expression listed first is selected.'''\n", "        if not has_variety(choices):\n", "            return choices[0]\n", "        return min(choices, key=measure)\n", "\n", "    expr = bottom_up(expr, lambda w: w.normal())\n", "    expr = Mul(*powsimp(expr).as_content_primitive())\n", "    _e = cancel(expr)\n", "    expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n", "    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n", "\n", "    if ratio is S.Infinity:\n", "        expr = expr2\n", "    else:\n", "        expr = shorter(expr2, expr1, expr)\n", "    if not isinstance(expr, Basic):  # XXX: temporary hack\n", "        return expr\n", "\n", "    expr = factor_terms(expr, sign=False)\n", "\n", "    # hyperexpand automatically only works on hypergeometric terms\n", "    expr = hyperexpand(expr)\n", "\n", "    expr = piecewise_fold(expr)\n", "\n", "    if expr.has(BesselBase):\n", "        expr = besselsimp(expr)\n", "\n", "    if expr.has(TrigonometricFunction) and not fu or expr.has(\n", "            HyperbolicFunction):\n", "        expr = trigsimp(expr, deep=True)\n", "\n", "    if expr.has(log):\n", "        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n", "\n", "    if expr.has(CombinatorialFunction, gamma):\n", "        expr = combsimp(expr)\n", "\n", "    if expr.has(Sum):\n", "        expr = sum_simplify(expr)\n", "\n", "    if expr.has(Product):\n", "        expr = product_simplify(expr)\n", "\n", "    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n", "    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n", "    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n", "        short = exptrigsimp(short, simplify=False)\n", "\n", "    # get rid of hollow 2-arg Mul factorization\n", "    hollow_mul = Transform(\n", "        lambda x: Mul(*x.args),\n", "        lambda x:\n", "        x.is_Mul and\n", "        len(x.args) == 2 and\n", "        x.args[0].is_Number and\n", "        x.args[1].is_Add and\n", "        x.is_commutative)\n", "    expr = short.xreplace(hollow_mul)\n", "\n", "    numer, denom = expr.as_numer_denom()\n", "    if denom.is_Add:\n", "        n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n", "        if n is not S.One:\n", "            expr = (numer*n).expand()/d\n", "\n", "    if expr.could_extract_minus_sign():\n", "        n, d = fraction(expr)\n", "        if d != 0:\n", "            expr = signsimp(-n/(-d))\n", "\n", "    if measure(expr) > ratio*measure(original_expr):\n", "        expr = original_expr\n", "\n", "    return expr\n"]}]}]}