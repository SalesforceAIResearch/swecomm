{"instance_id": "sympy__sympy-21379", "identified_spans": [{"file_path": "sympy/assumptions/assume.py", "span_ids": ["assuming"], "content": [{"span_id": "assuming", "start_line": 459, "end_line": 481, "content": ["@contextmanager\n", "def assuming(*assumptions):\n", "    \"\"\"\n", "    Context manager for assumptions.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.assumptions import assuming, Q, ask\n", "    >>> from sympy.abc import x, y\n", "    >>> print(ask(Q.integer(x + y)))\n", "    None\n", "    >>> with assuming(Q.integer(x), Q.integer(y)):\n", "    ...     print(ask(Q.integer(x + y)))\n", "    True\n", "    \"\"\"\n", "    old_global_assumptions = global_assumptions.copy()\n", "    global_assumptions.update(assumptions)\n", "    try:\n", "        yield\n", "    finally:\n", "        global_assumptions.clear()\n", "        global_assumptions.update(old_global_assumptions)\n"]}]}, {"file_path": "sympy/core/evalf.py", "span_ids": ["evalf_piecewise"], "content": [{"span_id": "evalf_piecewise", "start_line": 910, "end_line": 924, "content": ["def evalf_piecewise(expr, prec, options):\n", "    from sympy import Float, Integer\n", "    if 'subs' in options:\n", "        expr = expr.subs(evalf_subs(prec, options['subs']))\n", "        newopts = options.copy()\n", "        del newopts['subs']\n", "        if hasattr(expr, 'func'):\n", "            return evalf(expr, prec, newopts)\n", "        if type(expr) == float:\n", "            return evalf(Float(expr), prec, newopts)\n", "        if type(expr) == int:\n", "            return evalf(Integer(expr), prec, newopts)\n", "\n", "    # We still have undefined symbols\n", "    raise NotImplementedError\n"]}]}, {"file_path": "sympy/core/symbol.py", "span_ids": ["Symbol", "Symbol.__new__", "_filter_assumptions", "Symbol._eval_subs"], "content": [{"span_id": "Symbol", "start_line": 183, "end_line": 207, "content": ["class Symbol(AtomicExpr, Boolean):\n", "    \"\"\"\n", "    Assumptions:\n", "       commutative = True\n", "\n", "    You can override the default assumptions in the constructor.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import symbols\n", "    >>> A,B = symbols('A,B', commutative = False)\n", "    >>> bool(A*B != B*A)\n", "    True\n", "    >>> bool(A*B*2 == 2*A*B) == True # multiplication by scalars is commutative\n", "    True\n", "\n", "    \"\"\"\n", "\n", "    is_comparable = False\n", "\n", "    __slots__ = ('name',)\n", "\n", "    is_Symbol = True\n", "    is_symbol = True\n"]}, {"span_id": "Symbol.__new__", "start_line": 261, "end_line": 272, "content": ["    def __new__(cls, name, **assumptions):\n", "        \"\"\"Symbols are identified by name and assumptions::\n", "\n", "        >>> from sympy import Symbol\n", "        >>> Symbol(\"x\") == Symbol(\"x\")\n", "        True\n", "        >>> Symbol(\"x\", real=True) == Symbol(\"x\", real=False)\n", "        False\n", "\n", "        \"\"\"\n", "        cls._sanitize(assumptions, cls)\n", "        return Symbol.__xnew_cached_(cls, name, **assumptions)\n"]}, {"span_id": "_filter_assumptions", "start_line": 47, "end_line": 56, "content": ["def _filter_assumptions(kwargs):\n", "    \"\"\"Split the given dict into assumptions and non-assumptions.\n", "    Keys are taken as assumptions if they correspond to an\n", "    entry in ``_assume_defined``.\n", "    \"\"\"\n", "    assumptions, nonassumptions = map(dict, sift(kwargs.items(),\n", "        lambda i: i[0] in _assume_defined,\n", "        binary=True))\n", "    Symbol._sanitize(assumptions)\n", "    return assumptions, nonassumptions\n"]}, {"span_id": "Symbol._eval_subs", "start_line": 310, "end_line": 313, "content": ["    def _eval_subs(self, old, new):\n", "        from sympy.core.power import Pow\n", "        if old.is_Pow:\n", "            return Pow(self, S.One, evaluate=False)._eval_subs(old, new)\n"]}]}, {"file_path": "sympy/functions/elementary/hyperbolic.py", "span_ids": ["sinh", "cosh", "tanh", "sinh.eval", "cosh.fdiff"], "content": [{"span_id": "sinh", "start_line": 72, "end_line": 90, "content": ["class sinh(HyperbolicFunction):\n", "    r\"\"\"\n", "    sinh(x) is the hyperbolic sine of x.\n", "\n", "    The hyperbolic sine function is $\\frac{e^x - e^{-x}}{2}$.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import sinh\n", "    >>> from sympy.abc import x\n", "    >>> sinh(x)\n", "    sinh(x)\n", "\n", "    See Also\n", "    ========\n", "\n", "    cosh, tanh, asinh\n", "    \"\"\"\n"]}, {"span_id": "cosh", "start_line": 275, "end_line": 293, "content": ["class cosh(HyperbolicFunction):\n", "    r\"\"\"\n", "    cosh(x) is the hyperbolic cosine of x.\n", "\n", "    The hyperbolic cosine function is $\\frac{e^x + e^{-x}}{2}$.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import cosh\n", "    >>> from sympy.abc import x\n", "    >>> cosh(x)\n", "    cosh(x)\n", "\n", "    See Also\n", "    ========\n", "\n", "    sinh, tanh, acosh\n", "    \"\"\"\n"]}, {"span_id": "tanh", "start_line": 505, "end_line": 523, "content": ["class tanh(HyperbolicFunction):\n", "    r\"\"\"\n", "    tanh(x) is the hyperbolic tangent of x.\n", "\n", "    The hyperbolic tangent function is $\\frac{\\sinh(x)}{\\cosh(x)}$.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import tanh\n", "    >>> from sympy.abc import x\n", "    >>> tanh(x)\n", "    tanh(x)\n", "\n", "    See Also\n", "    ========\n", "\n", "    sinh, cosh, atanh\n", "    \"\"\"\n"]}, {"span_id": "sinh.eval", "start_line": 107, "end_line": 157, "content": ["    @classmethod\n", "    def eval(cls, arg):\n", "        from sympy import sin\n", "\n", "        arg = sympify(arg)\n", "\n", "        if arg.is_Number:\n", "            if arg is S.NaN:\n", "                return S.NaN\n", "            elif arg is S.Infinity:\n", "                return S.Infinity\n", "            elif arg is S.NegativeInfinity:\n", "                return S.NegativeInfinity\n", "            elif arg.is_zero:\n", "                return S.Zero\n", "            elif arg.is_negative:\n", "                return -cls(-arg)\n", "        else:\n", "            if arg is S.ComplexInfinity:\n", "                return S.NaN\n", "\n", "            i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n", "\n", "            if i_coeff is not None:\n", "                return S.ImaginaryUnit * sin(i_coeff)\n", "            else:\n", "                if _coeff_isneg(arg):\n", "                    return -cls(-arg)\n", "\n", "            if arg.is_Add:\n", "                x, m = _peeloff_ipi(arg)\n", "                if m:\n", "                    return sinh(m)*cosh(x) + cosh(m)*sinh(x)\n", "\n", "            if arg.is_zero:\n", "                return S.Zero\n", "\n", "            if arg.func == asinh:\n", "                return arg.args[0]\n", "\n", "            if arg.func == acosh:\n", "                x = arg.args[0]\n", "                return sqrt(x - 1) * sqrt(x + 1)\n", "\n", "            if arg.func == atanh:\n", "                x = arg.args[0]\n", "                return x/sqrt(1 - x**2)\n", "\n", "            if arg.func == acoth:\n", "                x = arg.args[0]\n", "                return 1/(sqrt(x - 1) * sqrt(x + 1))\n"]}, {"span_id": "cosh.fdiff", "start_line": 295, "end_line": 299, "content": ["    def fdiff(self, argindex=1):\n", "        if argindex == 1:\n", "            return sinh(self.args[0])\n", "        else:\n", "            raise ArgumentIndexError(self, argindex)\n"]}]}, {"file_path": "sympy/polys/polyerrors.py", "span_ids": ["PolynomialError"], "content": [{"span_id": "PolynomialError", "start_line": 114, "end_line": 116, "content": ["@public\n", "class PolynomialError(BasePolynomialError):\n", "    pass\n"]}]}, {"file_path": "sympy/printing/pycode.py", "span_ids": ["AbstractPythonCodePrinter._print_Piecewise"], "content": [{"span_id": "AbstractPythonCodePrinter._print_Piecewise", "start_line": 239, "end_line": 260, "content": ["    def _print_Piecewise(self, expr):\n", "        result = []\n", "        i = 0\n", "        for arg in expr.args:\n", "            e = arg.expr\n", "            c = arg.cond\n", "            if i == 0:\n", "                result.append('(')\n", "            result.append('(')\n", "            result.append(self._print(e))\n", "            result.append(')')\n", "            result.append(' if ')\n", "            result.append(self._print(c))\n", "            result.append(' else ')\n", "            i += 1\n", "        result = result[:-1]\n", "        if result[-1] == 'True':\n", "            result = result[:-2]\n", "            result.append(')')\n", "        else:\n", "            result.append(' else None)')\n", "        return ''.join(result)\n"]}]}]}