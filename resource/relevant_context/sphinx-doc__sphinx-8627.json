{"instance_id": "sphinx-doc__sphinx-8627", "identified_spans": [{"file_path": "sphinx/ext/autodoc/__init__.py", "span_ids": ["AttributeDocumenter.update_annotations", "AttributeDocumenter.get_doc", "DataDocumenter.add_directive_header", "AttributeDocumenter", "DataDocumenter.get_doc", "AttributeDocumenter.add_directive_header", "DataDocumenter"], "content": [{"span_id": "AttributeDocumenter.update_annotations", "start_line": 2380, "end_line": 2402, "content": ["    def update_annotations(self, parent: Any) -> None:\n", "        \"\"\"Update __annotations__ to support type_comment and so on.\"\"\"\n", "        try:\n", "            annotations = dict(inspect.getannotations(parent))\n", "            parent.__annotations__ = annotations\n", "\n", "            for cls in inspect.getmro(parent):\n", "                try:\n", "                    module = safe_getattr(cls, '__module__')\n", "                    qualname = safe_getattr(cls, '__qualname__')\n", "\n", "                    analyzer = ModuleAnalyzer.for_module(module)\n", "                    analyzer.analyze()\n", "                    for (classname, attrname), annotation in analyzer.annotations.items():\n", "                        if classname == qualname and attrname not in annotations:\n", "                            annotations[attrname] = annotation\n", "                except (AttributeError, PycodeError):\n", "                    pass\n", "        except AttributeError:\n", "            pass\n", "        except TypeError:\n", "            # Failed to set __annotations__ (built-in, extensions, etc.)\n", "            pass\n"]}, {"span_id": "AttributeDocumenter.get_doc", "start_line": 2471, "end_line": 2485, "content": ["    def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n", "        # Check the attribute has a docstring-comment\n", "        comment = self.get_attribute_comment(self.parent, self.objpath[-1])\n", "        if comment:\n", "            return [comment]\n", "\n", "        try:\n", "            # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain\n", "            # a docstring from the value which descriptor returns unexpectedly.\n", "            # ref: https://github.com/sphinx-doc/sphinx/issues/7805\n", "            orig = self.config.autodoc_inherit_docstrings\n", "            self.config.autodoc_inherit_docstrings = False  # type: ignore\n", "            return super().get_doc(encoding, ignore)\n", "        finally:\n", "            self.config.autodoc_inherit_docstrings = orig  # type: ignore\n"]}, {"span_id": "DataDocumenter.add_directive_header", "start_line": 1922, "end_line": 1944, "content": ["    def add_directive_header(self, sig: str) -> None:\n", "        super().add_directive_header(sig)\n", "        sourcename = self.get_sourcename()\n", "        if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():\n", "            pass\n", "        elif self.options.annotation:\n", "            self.add_line('   :annotation: %s' % self.options.annotation,\n", "                          sourcename)\n", "        else:\n", "            # obtain annotation for this data\n", "            annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)\n", "            if self.objpath[-1] in annotations:\n", "                objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n", "                self.add_line('   :type: ' + objrepr, sourcename)\n", "\n", "            try:\n", "                if self.options.no_value or self.should_suppress_value_header():\n", "                    pass\n", "                else:\n", "                    objrepr = object_description(self.object)\n", "                    self.add_line('   :value: ' + objrepr, sourcename)\n", "            except ValueError:\n", "                pass\n"]}, {"span_id": "AttributeDocumenter", "start_line": 2323, "end_line": 2338, "content": ["class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type: ignore\n", "                          TypeVarMixin, RuntimeInstanceAttributeMixin,\n", "                          UninitializedInstanceAttributeMixin, NonDataDescriptorMixin,\n", "                          DocstringStripSignatureMixin, ClassLevelDocumenter):\n", "    \"\"\"\n", "    Specialized Documenter subclass for attributes.\n", "    \"\"\"\n", "    objtype = 'attribute'\n", "    member_order = 60\n", "    option_spec = dict(ModuleLevelDocumenter.option_spec)\n", "    option_spec[\"annotation\"] = annotation_option\n", "    option_spec[\"no-value\"] = bool_option\n", "\n", "    # must be higher than the MethodDocumenter, else it will recognize\n", "    # some non-data descriptors as methods\n", "    priority = 10\n"]}, {"span_id": "DataDocumenter.get_doc", "start_line": 1965, "end_line": 1971, "content": ["    def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n", "        # Check the variable has a docstring-comment\n", "        comment = self.get_module_comment(self.objpath[-1])\n", "        if comment:\n", "            return [comment]\n", "        else:\n", "            return super().get_doc(encoding, ignore)\n"]}, {"span_id": "AttributeDocumenter.add_directive_header", "start_line": 2428, "end_line": 2449, "content": ["    def add_directive_header(self, sig: str) -> None:\n", "        super().add_directive_header(sig)\n", "        sourcename = self.get_sourcename()\n", "        if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():\n", "            pass\n", "        elif self.options.annotation:\n", "            self.add_line('   :annotation: %s' % self.options.annotation, sourcename)\n", "        else:\n", "            # obtain type annotation for this attribute\n", "            annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)\n", "            if self.objpath[-1] in annotations:\n", "                objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n", "                self.add_line('   :type: ' + objrepr, sourcename)\n", "\n", "            try:\n", "                if self.options.no_value or self.should_suppress_value_header():\n", "                    pass\n", "                else:\n", "                    objrepr = object_description(self.object)\n", "                    self.add_line('   :value: ' + objrepr, sourcename)\n", "            except ValueError:\n", "                pass\n"]}, {"span_id": "DataDocumenter", "start_line": 1873, "end_line": 1883, "content": ["class DataDocumenter(GenericAliasMixin, NewTypeMixin, TypeVarMixin,\n", "                     UninitializedGlobalVariableMixin, ModuleLevelDocumenter):\n", "    \"\"\"\n", "    Specialized Documenter subclass for data items.\n", "    \"\"\"\n", "    objtype = 'data'\n", "    member_order = 40\n", "    priority = -10\n", "    option_spec = dict(ModuleLevelDocumenter.option_spec)\n", "    option_spec[\"annotation\"] = annotation_option\n", "    option_spec[\"no-value\"] = bool_option\n"]}]}, {"file_path": "sphinx/ext/autodoc/importer.py", "span_ids": ["import_object"], "content": [{"span_id": "import_object", "start_line": 77, "end_line": 140, "content": ["def import_object(modname: str, objpath: List[str], objtype: str = '',\n", "                  attrgetter: Callable[[Any, str], Any] = safe_getattr,\n", "                  warningiserror: bool = False) -> Any:\n", "    if objpath:\n", "        logger.debug('[autodoc] from %s import %s', modname, '.'.join(objpath))\n", "    else:\n", "        logger.debug('[autodoc] import %s', modname)\n", "\n", "    try:\n", "        module = None\n", "        exc_on_importing = None\n", "        objpath = list(objpath)\n", "        while module is None:\n", "            try:\n", "                module = import_module(modname, warningiserror=warningiserror)\n", "                logger.debug('[autodoc] import %s => %r', modname, module)\n", "            except ImportError as exc:\n", "                logger.debug('[autodoc] import %s => failed', modname)\n", "                exc_on_importing = exc\n", "                if '.' in modname:\n", "                    # retry with parent module\n", "                    modname, name = modname.rsplit('.', 1)\n", "                    objpath.insert(0, name)\n", "                else:\n", "                    raise\n", "\n", "        obj = module\n", "        parent = None\n", "        object_name = None\n", "        for attrname in objpath:\n", "            parent = obj\n", "            logger.debug('[autodoc] getattr(_, %r)', attrname)\n", "            mangled_name = mangle(obj, attrname)\n", "            obj = attrgetter(obj, mangled_name)\n", "            logger.debug('[autodoc] => %r', obj)\n", "            object_name = attrname\n", "        return [module, parent, object_name, obj]\n", "    except (AttributeError, ImportError) as exc:\n", "        if isinstance(exc, AttributeError) and exc_on_importing:\n", "            # restore ImportError\n", "            exc = exc_on_importing\n", "\n", "        if objpath:\n", "            errmsg = ('autodoc: failed to import %s %r from module %r' %\n", "                      (objtype, '.'.join(objpath), modname))\n", "        else:\n", "            errmsg = 'autodoc: failed to import %s %r' % (objtype, modname)\n", "\n", "        if isinstance(exc, ImportError):\n", "            # import_module() raises ImportError having real exception obj and\n", "            # traceback\n", "            real_exc, traceback_msg = exc.args\n", "            if isinstance(real_exc, SystemExit):\n", "                errmsg += ('; the module executes module level statement '\n", "                           'and it might call sys.exit().')\n", "            elif isinstance(real_exc, ImportError) and real_exc.args:\n", "                errmsg += '; the following exception was raised:\\n%s' % real_exc.args[0]\n", "            else:\n", "                errmsg += '; the following exception was raised:\\n%s' % traceback_msg\n", "        else:\n", "            errmsg += '; the following exception was raised:\\n%s' % traceback.format_exc()\n", "\n", "        logger.debug(errmsg)\n", "        raise ImportError(errmsg) from exc\n"]}]}, {"file_path": "sphinx/ext/autodoc/typehints.py", "span_ids": ["restify", "get_type_hints"], "content": []}, {"file_path": "sphinx/util/typing.py", "span_ids": ["_restify_py36", "stringify", "_restify_py37"], "content": [{"span_id": "_restify_py36", "start_line": 163, "end_line": 281, "content": ["def _restify_py36(cls: Optional[\"Type\"]) -> str:\n", "    module = getattr(cls, '__module__', None)\n", "    if module == 'typing':\n", "        if getattr(cls, '_name', None):\n", "            qualname = cls._name\n", "        elif getattr(cls, '__qualname__', None):\n", "            qualname = cls.__qualname__\n", "        elif getattr(cls, '__forward_arg__', None):\n", "            qualname = cls.__forward_arg__\n", "        elif getattr(cls, '__origin__', None):\n", "            qualname = stringify(cls.__origin__)  # ex. Union\n", "        else:\n", "            qualname = repr(cls).replace('typing.', '')\n", "    elif hasattr(cls, '__qualname__'):\n", "        qualname = '%s.%s' % (module, cls.__qualname__)\n", "    else:\n", "        qualname = repr(cls)\n", "\n", "    if (isinstance(cls, typing.TupleMeta) and  # type: ignore\n", "            not hasattr(cls, '__tuple_params__')):  # for Python 3.6\n", "        params = cls.__args__\n", "        if params:\n", "            param_str = ', '.join(restify(p) for p in params)\n", "            return ':class:`%s`\\\\ [%s]' % (qualname, param_str)\n", "        else:\n", "            return ':class:`%s`' % qualname\n", "    elif isinstance(cls, typing.GenericMeta):\n", "        params = None\n", "        if hasattr(cls, '__args__'):\n", "            # for Python 3.5.2+\n", "            if cls.__args__ is None or len(cls.__args__) <= 2:  # type: ignore  # NOQA\n", "                params = cls.__args__  # type: ignore\n", "            elif cls.__origin__ == Generator:  # type: ignore\n", "                params = cls.__args__  # type: ignore\n", "            else:  # typing.Callable\n", "                args = ', '.join(restify(arg) for arg in cls.__args__[:-1])  # type: ignore\n", "                result = restify(cls.__args__[-1])  # type: ignore\n", "                return ':class:`%s`\\\\ [[%s], %s]' % (qualname, args, result)\n", "        elif hasattr(cls, '__parameters__'):\n", "            # for Python 3.5.0 and 3.5.1\n", "            params = cls.__parameters__  # type: ignore\n", "\n", "        if params:\n", "            param_str = ', '.join(restify(p) for p in params)\n", "            return ':class:`%s`\\\\ [%s]' % (qualname, param_str)\n", "        else:\n", "            return ':class:`%s`' % qualname\n", "    elif (hasattr(typing, 'UnionMeta') and\n", "            isinstance(cls, typing.UnionMeta) and  # type: ignore\n", "            hasattr(cls, '__union_params__')):  # for Python 3.5\n", "        params = cls.__union_params__\n", "        if params is not None:\n", "            if len(params) == 2 and params[1] is NoneType:\n", "                return ':obj:`Optional`\\\\ [%s]' % restify(params[0])\n", "            else:\n", "                param_str = ', '.join(restify(p) for p in params)\n", "                return ':obj:`%s`\\\\ [%s]' % (qualname, param_str)\n", "        else:\n", "            return ':obj:`%s`' % qualname\n", "    elif (hasattr(cls, '__origin__') and\n", "          cls.__origin__ is typing.Union):  # for Python 3.5.2+\n", "        params = cls.__args__\n", "        if params is not None:\n", "            if len(params) > 1 and params[-1] is NoneType:\n", "                if len(params) > 2:\n", "                    param_str = \", \".join(restify(p) for p in params[:-1])\n", "                    return ':obj:`Optional`\\\\ [:obj:`Union`\\\\ [%s]]' % param_str\n", "                else:\n", "                    return ':obj:`Optional`\\\\ [%s]' % restify(params[0])\n", "            else:\n", "                param_str = ', '.join(restify(p) for p in params)\n", "                return ':obj:`Union`\\\\ [%s]' % param_str\n", "        else:\n", "            return ':obj:`Union`'\n", "    elif (isinstance(cls, typing.CallableMeta) and  # type: ignore\n", "          getattr(cls, '__args__', None) is not None and\n", "          hasattr(cls, '__result__')):  # for Python 3.5\n", "        # Skipped in the case of plain typing.Callable\n", "        args = cls.__args__\n", "        if args is None:\n", "            return qualname\n", "        elif args is Ellipsis:\n", "            args_str = '...'\n", "        else:\n", "            formatted_args = (restify(a) for a in args)  # type: ignore\n", "            args_str = '[%s]' % ', '.join(formatted_args)\n", "\n", "        return ':class:`%s`\\\\ [%s, %s]' % (qualname, args_str, stringify(cls.__result__))\n", "    elif (isinstance(cls, typing.TupleMeta) and  # type: ignore\n", "          hasattr(cls, '__tuple_params__') and\n", "          hasattr(cls, '__tuple_use_ellipsis__')):  # for Python 3.5\n", "        params = cls.__tuple_params__\n", "        if params is not None:\n", "            param_strings = [restify(p) for p in params]\n", "            if cls.__tuple_use_ellipsis__:\n", "                param_strings.append('...')\n", "            return ':class:`%s`\\\\ [%s]' % (qualname, ', '.join(param_strings))\n", "        else:\n", "            return ':class:`%s`' % qualname\n", "    elif hasattr(cls, '__qualname__'):\n", "        if cls.__module__ == 'typing':\n", "            return ':class:`%s`' % cls.__qualname__\n", "        else:\n", "            return ':class:`%s.%s`' % (cls.__module__, cls.__qualname__)\n", "    elif hasattr(cls, '_name'):\n", "        # SpecialForm\n", "        if cls.__module__ == 'typing':\n", "            return ':obj:`%s`' % cls._name\n", "        else:\n", "            return ':obj:`%s.%s`' % (cls.__module__, cls._name)\n", "    elif hasattr(cls, '__name__'):\n", "        # not a class (ex. TypeVar)\n", "        return ':obj:`%s.%s`' % (cls.__module__, cls.__name__)\n", "    else:\n", "        # others (ex. Any)\n", "        if cls.__module__ == 'typing':\n", "            return ':obj:`%s`' % qualname\n", "        else:\n", "            return ':obj:`%s.%s`' % (cls.__module__, qualname)\n"]}, {"span_id": "stringify", "start_line": 284, "end_line": 312, "content": ["def stringify(annotation: Any) -> str:\n", "    \"\"\"Stringify type annotation object.\"\"\"\n", "    from sphinx.util import inspect  # lazy loading\n", "\n", "    if isinstance(annotation, str):\n", "        if annotation.startswith(\"'\") and annotation.endswith(\"'\"):\n", "            # might be a double Forward-ref'ed type.  Go unquoting.\n", "            return annotation[1:-1]\n", "        else:\n", "            return annotation\n", "    elif isinstance(annotation, TypeVar):\n", "        return annotation.__name__\n", "    elif inspect.isNewType(annotation):\n", "        # Could not get the module where it defiend\n", "        return annotation.__name__\n", "    elif not annotation:\n", "        return repr(annotation)\n", "    elif annotation is NoneType:\n", "        return 'None'\n", "    elif (getattr(annotation, '__module__', None) == 'builtins' and\n", "          hasattr(annotation, '__qualname__')):\n", "        return annotation.__qualname__\n", "    elif annotation is Ellipsis:\n", "        return '...'\n", "\n", "    if sys.version_info >= (3, 7):  # py37+\n", "        return _stringify_py37(annotation)\n", "    else:\n", "        return _stringify_py36(annotation)\n"]}, {"span_id": "_restify_py37", "start_line": 108, "end_line": 160, "content": ["def _restify_py37(cls: Optional[\"Type\"]) -> str:\n", "    \"\"\"Convert python class to a reST reference.\"\"\"\n", "    from sphinx.util import inspect  # lazy loading\n", "\n", "    if (inspect.isgenericalias(cls) and\n", "            cls.__module__ == 'typing' and cls.__origin__ is Union):\n", "        # Union\n", "        if len(cls.__args__) > 1 and cls.__args__[-1] is NoneType:\n", "            if len(cls.__args__) > 2:\n", "                args = ', '.join(restify(a) for a in cls.__args__[:-1])\n", "                return ':obj:`Optional`\\\\ [:obj:`Union`\\\\ [%s]]' % args\n", "            else:\n", "                return ':obj:`Optional`\\\\ [%s]' % restify(cls.__args__[0])\n", "        else:\n", "            args = ', '.join(restify(a) for a in cls.__args__)\n", "            return ':obj:`Union`\\\\ [%s]' % args\n", "    elif inspect.isgenericalias(cls):\n", "        if getattr(cls, '_name', None):\n", "            if cls.__module__ == 'typing':\n", "                text = ':class:`%s`' % cls._name\n", "            else:\n", "                text = ':class:`%s.%s`' % (cls.__module__, cls._name)\n", "        else:\n", "            text = restify(cls.__origin__)\n", "\n", "        if not hasattr(cls, '__args__'):\n", "            pass\n", "        elif all(is_system_TypeVar(a) for a in cls.__args__):\n", "            # Suppress arguments if all system defined TypeVars (ex. Dict[KT, VT])\n", "            pass\n", "        elif cls.__module__ == 'typing' and cls._name == 'Callable':\n", "            args = ', '.join(restify(a) for a in cls.__args__[:-1])\n", "            text += r\"\\ [[%s], %s]\" % (args, restify(cls.__args__[-1]))\n", "        elif cls.__args__:\n", "            text += r\"\\ [%s]\" % \", \".join(restify(a) for a in cls.__args__)\n", "\n", "        return text\n", "    elif hasattr(cls, '__qualname__'):\n", "        if cls.__module__ == 'typing':\n", "            return ':class:`%s`' % cls.__qualname__\n", "        else:\n", "            return ':class:`%s.%s`' % (cls.__module__, cls.__qualname__)\n", "    elif hasattr(cls, '_name'):\n", "        # SpecialForm\n", "        if cls.__module__ == 'typing':\n", "            return ':obj:`%s`' % cls._name\n", "        else:\n", "            return ':obj:`%s.%s`' % (cls.__module__, cls._name)\n", "    elif isinstance(cls, ForwardRef):\n", "        return ':class:`%s`' % cls.__forward_arg__\n", "    else:\n", "        # not a class (ex. TypeVar)\n", "        return ':obj:`%s.%s`' % (cls.__module__, cls.__name__)\n"]}]}]}