{"instance_id": "django__django-14997", "identified_spans": [{"file_path": "django/db/backends/sqlite3/schema.py", "span_ids": ["DatabaseSchemaEditor._remake_table", "DatabaseSchemaEditor.alter_field", "DatabaseSchemaEditor"], "content": [{"span_id": "DatabaseSchemaEditor._remake_table", "start_line": 142, "end_line": 307, "content": ["    def _remake_table(self, model, create_field=None, delete_field=None, alter_field=None):\n", "        \"\"\"\n", "        Shortcut to transform a model from old_model into new_model\n", "\n", "        This follows the correct procedure to perform non-rename or column\n", "        addition operations based on SQLite's documentation\n", "\n", "        https://www.sqlite.org/lang_altertable.html#caution\n", "\n", "        The essential steps are:\n", "          1. Create a table with the updated definition called \"new__app_model\"\n", "          2. Copy the data from the existing \"app_model\" table to the new table\n", "          3. Drop the \"app_model\" table\n", "          4. Rename the \"new__app_model\" table to \"app_model\"\n", "          5. Restore any index of the previous \"app_model\" table.\n", "        \"\"\"\n", "        # Self-referential fields must be recreated rather than copied from\n", "        # the old model to ensure their remote_field.field_name doesn't refer\n", "        # to an altered field.\n", "        def is_self_referential(f):\n", "            return f.is_relation and f.remote_field.model is model\n", "        # Work out the new fields dict / mapping\n", "        body = {\n", "            f.name: f.clone() if is_self_referential(f) else f\n", "            for f in model._meta.local_concrete_fields\n", "        }\n", "        # Since mapping might mix column names and default values,\n", "        # its values must be already quoted.\n", "        mapping = {f.column: self.quote_name(f.column) for f in model._meta.local_concrete_fields}\n", "        # This maps field names (not columns) for things like unique_together\n", "        rename_mapping = {}\n", "        # If any of the new or altered fields is introducing a new PK,\n", "        # remove the old one\n", "        restore_pk_field = None\n", "        if getattr(create_field, 'primary_key', False) or (\n", "                alter_field and getattr(alter_field[1], 'primary_key', False)):\n", "            for name, field in list(body.items()):\n", "                if field.primary_key:\n", "                    field.primary_key = False\n", "                    restore_pk_field = field\n", "                    if field.auto_created:\n", "                        del body[name]\n", "                        del mapping[field.column]\n", "        # Add in any created fields\n", "        if create_field:\n", "            body[create_field.name] = create_field\n", "            # Choose a default and insert it into the copy map\n", "            if not create_field.many_to_many and create_field.concrete:\n", "                mapping[create_field.column] = self.quote_value(\n", "                    self.effective_default(create_field)\n", "                )\n", "        # Add in any altered fields\n", "        if alter_field:\n", "            old_field, new_field = alter_field\n", "            body.pop(old_field.name, None)\n", "            mapping.pop(old_field.column, None)\n", "            body[new_field.name] = new_field\n", "            if old_field.null and not new_field.null:\n", "                case_sql = \"coalesce(%(col)s, %(default)s)\" % {\n", "                    'col': self.quote_name(old_field.column),\n", "                    'default': self.quote_value(self.effective_default(new_field))\n", "                }\n", "                mapping[new_field.column] = case_sql\n", "            else:\n", "                mapping[new_field.column] = self.quote_name(old_field.column)\n", "            rename_mapping[old_field.name] = new_field.name\n", "        # Remove any deleted fields\n", "        if delete_field:\n", "            del body[delete_field.name]\n", "            del mapping[delete_field.column]\n", "            # Remove any implicit M2M tables\n", "            if delete_field.many_to_many and delete_field.remote_field.through._meta.auto_created:\n", "                return self.delete_model(delete_field.remote_field.through)\n", "        # Work inside a new app registry\n", "        apps = Apps()\n", "\n", "        # Work out the new value of unique_together, taking renames into\n", "        # account\n", "        unique_together = [\n", "            [rename_mapping.get(n, n) for n in unique]\n", "            for unique in model._meta.unique_together\n", "        ]\n", "\n", "        # Work out the new value for index_together, taking renames into\n", "        # account\n", "        index_together = [\n", "            [rename_mapping.get(n, n) for n in index]\n", "            for index in model._meta.index_together\n", "        ]\n", "\n", "        indexes = model._meta.indexes\n", "        if delete_field:\n", "            indexes = [\n", "                index for index in indexes\n", "                if delete_field.name not in index.fields\n", "            ]\n", "\n", "        constraints = list(model._meta.constraints)\n", "\n", "        # Provide isolated instances of the fields to the new model body so\n", "        # that the existing model's internals aren't interfered with when\n", "        # the dummy model is constructed.\n", "        body_copy = copy.deepcopy(body)\n", "\n", "        # Construct a new model with the new fields to allow self referential\n", "        # primary key to resolve to. This model won't ever be materialized as a\n", "        # table and solely exists for foreign key reference resolution purposes.\n", "        # This wouldn't be required if the schema editor was operating on model\n", "        # states instead of rendered models.\n", "        meta_contents = {\n", "            'app_label': model._meta.app_label,\n", "            'db_table': model._meta.db_table,\n", "            'unique_together': unique_together,\n", "            'index_together': index_together,\n", "            'indexes': indexes,\n", "            'constraints': constraints,\n", "            'apps': apps,\n", "        }\n", "        meta = type(\"Meta\", (), meta_contents)\n", "        body_copy['Meta'] = meta\n", "        body_copy['__module__'] = model.__module__\n", "        type(model._meta.object_name, model.__bases__, body_copy)\n", "\n", "        # Construct a model with a renamed table name.\n", "        body_copy = copy.deepcopy(body)\n", "        meta_contents = {\n", "            'app_label': model._meta.app_label,\n", "            'db_table': 'new__%s' % strip_quotes(model._meta.db_table),\n", "            'unique_together': unique_together,\n", "            'index_together': index_together,\n", "            'indexes': indexes,\n", "            'constraints': constraints,\n", "            'apps': apps,\n", "        }\n", "        meta = type(\"Meta\", (), meta_contents)\n", "        body_copy['Meta'] = meta\n", "        body_copy['__module__'] = model.__module__\n", "        new_model = type('New%s' % model._meta.object_name, model.__bases__, body_copy)\n", "\n", "        # Create a new table with the updated schema.\n", "        self.create_model(new_model)\n", "\n", "        # Copy data from the old table into the new table\n", "        self.execute(\"INSERT INTO %s (%s) SELECT %s FROM %s\" % (\n", "            self.quote_name(new_model._meta.db_table),\n", "            ', '.join(self.quote_name(x) for x in mapping),\n", "            ', '.join(mapping.values()),\n", "            self.quote_name(model._meta.db_table),\n", "        ))\n", "\n", "        # Delete the old table to make way for the new\n", "        self.delete_model(model, handle_autom2m=False)\n", "\n", "        # Rename the new table to take way for the old\n", "        self.alter_db_table(\n", "            new_model, new_model._meta.db_table, model._meta.db_table,\n", "            disable_constraints=False,\n", "        )\n", "\n", "        # Run deferred SQL on correct table\n", "        for sql in self.deferred_sql:\n", "            self.execute(sql)\n", "        self.deferred_sql = []\n", "        # Fix any PK-removed field\n", "        if restore_pk_field:\n", "            restore_pk_field.primary_key = True\n"]}, {"span_id": "DatabaseSchemaEditor.alter_field", "start_line": 101, "end_line": 140, "content": ["    def alter_field(self, model, old_field, new_field, strict=False):\n", "        if not self._field_should_be_altered(old_field, new_field):\n", "            return\n", "        old_field_name = old_field.name\n", "        table_name = model._meta.db_table\n", "        _, old_column_name = old_field.get_attname_column()\n", "        if (new_field.name != old_field_name and\n", "                not self.connection.features.supports_atomic_references_rename and\n", "                self._is_referenced_by_fk_constraint(table_name, old_column_name, ignore_self=True)):\n", "            if self.connection.in_atomic_block:\n", "                raise NotSupportedError((\n", "                    'Renaming the %r.%r column while in a transaction is not '\n", "                    'supported on SQLite < 3.26 because it would break referential '\n", "                    'integrity. Try adding `atomic = False` to the Migration class.'\n", "                ) % (model._meta.db_table, old_field_name))\n", "            with atomic(self.connection.alias):\n", "                super().alter_field(model, old_field, new_field, strict=strict)\n", "                # Follow SQLite's documented procedure for performing changes\n", "                # that don't affect the on-disk content.\n", "                # https://sqlite.org/lang_altertable.html#otheralter\n", "                with self.connection.cursor() as cursor:\n", "                    schema_version = cursor.execute('PRAGMA schema_version').fetchone()[0]\n", "                    cursor.execute('PRAGMA writable_schema = 1')\n", "                    references_template = ' REFERENCES \"%s\" (\"%%s\") ' % table_name\n", "                    new_column_name = new_field.get_attname_column()[1]\n", "                    search = references_template % old_column_name\n", "                    replacement = references_template % new_column_name\n", "                    cursor.execute('UPDATE sqlite_master SET sql = replace(sql, %s, %s)', (search, replacement))\n", "                    cursor.execute('PRAGMA schema_version = %d' % (schema_version + 1))\n", "                    cursor.execute('PRAGMA writable_schema = 0')\n", "                    # The integrity check will raise an exception and rollback\n", "                    # the transaction if the sqlite_master updates corrupt the\n", "                    # database.\n", "                    cursor.execute('PRAGMA integrity_check')\n", "            # Perform a VACUUM to refresh the database representation from\n", "            # the sqlite_master table.\n", "            with self.connection.cursor() as cursor:\n", "                cursor.execute('VACUUM')\n", "        else:\n", "            super().alter_field(model, old_field, new_field, strict=strict)\n"]}, {"span_id": "DatabaseSchemaEditor", "start_line": 13, "end_line": 19, "content": ["class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n", "\n", "    sql_delete_table = \"DROP TABLE %(table)s\"\n", "    sql_create_fk = None\n", "    sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n", "    sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n", "    sql_delete_unique = \"DROP INDEX %(name)s\"\n"]}]}, {"file_path": "django/db/models/constraints.py", "span_ids": ["UniqueConstraint", "UniqueConstraint.__init__"], "content": [{"span_id": "UniqueConstraint", "start_line": 93, "end_line": 93, "content": ["class UniqueConstraint(BaseConstraint):\n"]}, {"span_id": "UniqueConstraint.__init__", "start_line": 94, "end_line": 160, "content": ["    def __init__(\n", "        self,\n", "        *expressions,\n", "        fields=(),\n", "        name=None,\n", "        condition=None,\n", "        deferrable=None,\n", "        include=None,\n", "        opclasses=(),\n", "    ):\n", "        if not name:\n", "            raise ValueError('A unique constraint must be named.')\n", "        if not expressions and not fields:\n", "            raise ValueError(\n", "                'At least one field or expression is required to define a '\n", "                'unique constraint.'\n", "            )\n", "        if expressions and fields:\n", "            raise ValueError(\n", "                'UniqueConstraint.fields and expressions are mutually exclusive.'\n", "            )\n", "        if not isinstance(condition, (type(None), Q)):\n", "            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n", "        if condition and deferrable:\n", "            raise ValueError(\n", "                'UniqueConstraint with conditions cannot be deferred.'\n", "            )\n", "        if include and deferrable:\n", "            raise ValueError(\n", "                'UniqueConstraint with include fields cannot be deferred.'\n", "            )\n", "        if opclasses and deferrable:\n", "            raise ValueError(\n", "                'UniqueConstraint with opclasses cannot be deferred.'\n", "            )\n", "        if expressions and deferrable:\n", "            raise ValueError(\n", "                'UniqueConstraint with expressions cannot be deferred.'\n", "            )\n", "        if expressions and opclasses:\n", "            raise ValueError(\n", "                'UniqueConstraint.opclasses cannot be used with expressions. '\n", "                'Use django.contrib.postgres.indexes.OpClass() instead.'\n", "            )\n", "        if not isinstance(deferrable, (type(None), Deferrable)):\n", "            raise ValueError(\n", "                'UniqueConstraint.deferrable must be a Deferrable instance.'\n", "            )\n", "        if not isinstance(include, (type(None), list, tuple)):\n", "            raise ValueError('UniqueConstraint.include must be a list or tuple.')\n", "        if not isinstance(opclasses, (list, tuple)):\n", "            raise ValueError('UniqueConstraint.opclasses must be a list or tuple.')\n", "        if opclasses and len(fields) != len(opclasses):\n", "            raise ValueError(\n", "                'UniqueConstraint.fields and UniqueConstraint.opclasses must '\n", "                'have the same number of elements.'\n", "            )\n", "        self.fields = tuple(fields)\n", "        self.condition = condition\n", "        self.deferrable = deferrable\n", "        self.include = tuple(include) if include else ()\n", "        self.opclasses = opclasses\n", "        self.expressions = tuple(\n", "            F(expression) if isinstance(expression, str) else expression\n", "            for expression in expressions\n", "        )\n", "        super().__init__(name)\n"]}]}]}