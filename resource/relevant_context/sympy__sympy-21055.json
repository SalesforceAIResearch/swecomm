{"instance_id": "sympy__sympy-21055", "identified_spans": [{"file_path": "sympy/assumptions/refine.py", "span_ids": ["refine_abs", "refine", "impl"], "content": [{"span_id": "refine_abs", "start_line": 69, "end_line": 105, "content": ["def refine_abs(expr, assumptions):\n", "    \"\"\"\n", "    Handler for the absolute value.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import Q, Abs\n", "    >>> from sympy.assumptions.refine import refine_abs\n", "    >>> from sympy.abc import x\n", "    >>> refine_abs(Abs(x), Q.real(x))\n", "    >>> refine_abs(Abs(x), Q.positive(x))\n", "    x\n", "    >>> refine_abs(Abs(x), Q.negative(x))\n", "    -x\n", "\n", "    \"\"\"\n", "    from sympy.core.logic import fuzzy_not\n", "    from sympy import Abs\n", "    arg = expr.args[0]\n", "    if ask(Q.real(arg), assumptions) and \\\n", "            fuzzy_not(ask(Q.negative(arg), assumptions)):\n", "        # if it's nonnegative\n", "        return arg\n", "    if ask(Q.negative(arg), assumptions):\n", "        return -arg\n", "    # arg is Mul\n", "    if isinstance(arg, Mul):\n", "        r = [refine(abs(a), assumptions) for a in arg.args]\n", "        non_abs = []\n", "        in_abs = []\n", "        for i in r:\n", "            if isinstance(i, Abs):\n", "                in_abs.append(i.args[0])\n", "            else:\n", "                non_abs.append(i)\n", "        return Mul(*non_abs) * Abs(Mul(*in_abs))\n"]}, {"span_id": "refine", "start_line": 9, "end_line": 66, "content": ["def refine(expr, assumptions=True):\n", "    \"\"\"\n", "    Simplify an expression using assumptions.\n", "\n", "    Explanation\n", "    ===========\n", "\n", "    Unlike :func:`~.simplify()` which performs structural simplification\n", "    without any assumption, this function transforms the expression into\n", "    the form which is only valid under certain assumptions. Note that\n", "    ``simplify()`` is generally not done in refining process.\n", "\n", "    Refining boolean expression involves reducing it to ``True`` or\n", "    ``False``. Unlike :func:~.`ask()`, the expression will not be reduced\n", "    if the truth value cannot be determined.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import refine, sqrt, Q\n", "    >>> from sympy.abc import x\n", "    >>> refine(sqrt(x**2), Q.real(x))\n", "    Abs(x)\n", "    >>> refine(sqrt(x**2), Q.positive(x))\n", "    x\n", "\n", "    >>> refine(Q.real(x), Q.positive(x))\n", "    True\n", "    >>> refine(Q.positive(x), Q.real(x))\n", "    Q.positive(x)\n", "\n", "    See Also\n", "    ========\n", "\n", "    sympy.simplify.simplify.simplify : Structural simplification without assumptions.\n", "    sympy.assumptions.ask.ask : Query for boolean expressions using assumptions.\n", "    \"\"\"\n", "    if not isinstance(expr, Basic):\n", "        return expr\n", "\n", "    if not expr.is_Atom:\n", "        args = [refine(arg, assumptions) for arg in expr.args]\n", "        # TODO: this will probably not work with Integral or Polynomial\n", "        expr = expr.func(*args)\n", "    if hasattr(expr, '_eval_refine'):\n", "        ref_expr = expr._eval_refine(assumptions)\n", "        if ref_expr is not None:\n", "            return ref_expr\n", "    name = expr.__class__.__name__\n", "    handler = handlers_dict.get(name, None)\n", "    if handler is None:\n", "        return expr\n", "    new_expr = handler(expr, assumptions)\n", "    if (new_expr is None) or (expr == new_expr):\n", "        return expr\n", "    if not isinstance(new_expr, Expr):\n", "        return new_expr\n", "    return refine(new_expr, assumptions)\n"]}, {"span_id": "impl", "start_line": 376, "end_line": 384, "content": ["handlers_dict = {\n", "    'Abs': refine_abs,\n", "    'Pow': refine_Pow,\n", "    'atan2': refine_atan2,\n", "    're': refine_re,\n", "    'im': refine_im,\n", "    'sign': refine_sign,\n", "    'MatrixElement': refine_matrixelement\n", "}  # type: Dict[str, Callable[[Expr, Boolean], Expr]]\n"]}]}, {"file_path": "sympy/functions/elementary/complexes.py", "span_ids": ["Abs.eval", "Abs", "arg", "arg.eval"], "content": [{"span_id": "Abs.eval", "start_line": 528, "end_line": 616, "content": ["    @classmethod\n", "    def eval(cls, arg):\n", "        from sympy.simplify.simplify import signsimp\n", "        from sympy.core.function import expand_mul\n", "        from sympy.core.power import Pow\n", "\n", "        if hasattr(arg, '_eval_Abs'):\n", "            obj = arg._eval_Abs()\n", "            if obj is not None:\n", "                return obj\n", "        if not isinstance(arg, Expr):\n", "            raise TypeError(\"Bad argument type for Abs(): %s\" % type(arg))\n", "        # handle what we can\n", "        arg = signsimp(arg, evaluate=False)\n", "        n, d = arg.as_numer_denom()\n", "        if d.free_symbols and not n.free_symbols:\n", "            return cls(n)/cls(d)\n", "\n", "        if arg.is_Mul:\n", "            known = []\n", "            unk = []\n", "            for t in arg.args:\n", "                if t.is_Pow and t.exp.is_integer and t.exp.is_negative:\n", "                    bnew = cls(t.base)\n", "                    if isinstance(bnew, cls):\n", "                        unk.append(t)\n", "                    else:\n", "                        known.append(Pow(bnew, t.exp))\n", "                else:\n", "                    tnew = cls(t)\n", "                    if isinstance(tnew, cls):\n", "                        unk.append(t)\n", "                    else:\n", "                        known.append(tnew)\n", "            known = Mul(*known)\n", "            unk = cls(Mul(*unk), evaluate=False) if unk else S.One\n", "            return known*unk\n", "        if arg is S.NaN:\n", "            return S.NaN\n", "        if arg is S.ComplexInfinity:\n", "            return S.Infinity\n", "        if arg.is_Pow:\n", "            base, exponent = arg.as_base_exp()\n", "            if base.is_extended_real:\n", "                if exponent.is_integer:\n", "                    if exponent.is_even:\n", "                        return arg\n", "                    if base is S.NegativeOne:\n", "                        return S.One\n", "                    return Abs(base)**exponent\n", "                if base.is_extended_nonnegative:\n", "                    return base**re(exponent)\n", "                if base.is_extended_negative:\n", "                    return (-base)**re(exponent)*exp(-S.Pi*im(exponent))\n", "                return\n", "            elif not base.has(Symbol): # complex base\n", "                # express base**exponent as exp(exponent*log(base))\n", "                a, b = log(base).as_real_imag()\n", "                z = a + I*b\n", "                return exp(re(exponent*z))\n", "        if isinstance(arg, exp):\n", "            return exp(re(arg.args[0]))\n", "        if isinstance(arg, AppliedUndef):\n", "            return\n", "        if arg.is_Add and arg.has(S.Infinity, S.NegativeInfinity):\n", "            if any(a.is_infinite for a in arg.as_real_imag()):\n", "                return S.Infinity\n", "        if arg.is_zero:\n", "            return S.Zero\n", "        if arg.is_extended_nonnegative:\n", "            return arg\n", "        if arg.is_extended_nonpositive:\n", "            return -arg\n", "        if arg.is_imaginary:\n", "            arg2 = -S.ImaginaryUnit * arg\n", "            if arg2.is_extended_nonnegative:\n", "                return arg2\n", "        # reject result if all new conjugates are just wrappers around\n", "        # an expression that was already in the arg\n", "        conj = signsimp(arg.conjugate(), evaluate=False)\n", "        new_conj = conj.atoms(conjugate) - arg.atoms(conjugate)\n", "        if new_conj and all(arg.has(i.args[0]) for i in new_conj):\n", "            return\n", "        if arg != conj and arg != -conj:\n", "            ignore = arg.atoms(Abs)\n", "            abs_free_arg = arg.xreplace({i: Dummy(real=True) for i in ignore})\n", "            unk = [a for a in abs_free_arg.free_symbols if a.is_extended_real is None]\n", "            if not unk or not all(conj.has(conjugate(u)) for u in unk):\n", "                return sqrt(expand_mul(arg*conj))\n"]}, {"span_id": "Abs", "start_line": 454, "end_line": 516, "content": ["class Abs(Function):\n", "    \"\"\"\n", "    Return the absolute value of the argument.\n", "\n", "    Explanation\n", "    ===========\n", "\n", "    This is an extension of the built-in function abs() to accept symbolic\n", "    values.  If you pass a SymPy expression to the built-in abs(), it will\n", "    pass it automatically to Abs().\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import Abs, Symbol, S, I\n", "    >>> Abs(-1)\n", "    1\n", "    >>> x = Symbol('x', real=True)\n", "    >>> Abs(-x)\n", "    Abs(x)\n", "    >>> Abs(x**2)\n", "    x**2\n", "    >>> abs(-x) # The Python built-in\n", "    Abs(x)\n", "    >>> Abs(3*x + 2*I)\n", "    sqrt(9*x**2 + 4)\n", "    >>> Abs(8*I)\n", "    8\n", "\n", "    Note that the Python built-in will return either an Expr or int depending on\n", "    the argument::\n", "\n", "        >>> type(abs(-1))\n", "        <... 'int'>\n", "        >>> type(abs(S.NegativeOne))\n", "        <class 'sympy.core.numbers.One'>\n", "\n", "    Abs will always return a sympy object.\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    arg : Expr\n", "        Real or complex expression.\n", "\n", "    Returns\n", "    =======\n", "\n", "    expr : Expr\n", "        Absolute value returned can be an expression or integer depending on\n", "        input arg.\n", "\n", "    See Also\n", "    ========\n", "\n", "    sign, conjugate\n", "    \"\"\"\n", "\n", "    is_extended_real = True\n", "    is_extended_negative = False\n", "    is_extended_nonnegative = True\n", "    unbranched = True\n", "    _singularities = True  # non-holomorphic\n"]}, {"span_id": "arg", "start_line": 700, "end_line": 740, "content": ["class arg(Function):\n", "    \"\"\"\n", "    Returns the argument (in radians) of a complex number. For a positive\n", "    number, the argument is always 0.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.functions import arg\n", "    >>> from sympy import I, sqrt\n", "    >>> arg(2.0)\n", "    0\n", "    >>> arg(I)\n", "    pi/2\n", "    >>> arg(sqrt(2) + I*sqrt(2))\n", "    pi/4\n", "    >>> arg(sqrt(3)/2 + I/2)\n", "    pi/6\n", "    >>> arg(4 + 3*I)\n", "    atan(3/4)\n", "    >>> arg(0.8 + 0.6*I)\n", "    0.643501108793284\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    arg : Expr\n", "        Real or complex expression.\n", "\n", "    Returns\n", "    =======\n", "\n", "    value : Expr\n", "        Returns arc tangent of arg measured in radians.\n", "\n", "    \"\"\"\n", "\n", "    is_extended_real = True\n", "    is_real = True\n", "    is_finite = True\n", "    _singularities = True  # non-holomorphic\n"]}, {"span_id": "arg.eval", "start_line": 742, "end_line": 761, "content": ["    @classmethod\n", "    def eval(cls, arg):\n", "        if isinstance(arg, exp_polar):\n", "            return periodic_argument(arg, oo)\n", "        if not arg.is_Atom:\n", "            c, arg_ = factor_terms(arg).as_coeff_Mul()\n", "            if arg_.is_Mul:\n", "                arg_ = Mul(*[a if (sign(a) not in (-1, 1)) else\n", "                    sign(a) for a in arg_.args])\n", "            arg_ = sign(c)*arg_\n", "        else:\n", "            arg_ = arg\n", "        if arg_.atoms(AppliedUndef):\n", "            return\n", "        x, y = arg_.as_real_imag()\n", "        rv = atan2(y, x)\n", "        if rv.is_number:\n", "            return rv\n", "        if arg_ != arg:\n", "            return cls(arg_, evaluate=False)\n"]}]}, {"file_path": "sympy/polys/rootoftools.py", "span_ids": ["ComplexRootOf._refine_imaginary", "ComplexRootOf", "ComplexRootOf._refine_complexes"], "content": [{"span_id": "ComplexRootOf._refine_imaginary", "start_line": 498, "end_line": 525, "content": ["    @classmethod\n", "    def _refine_imaginary(cls, complexes):\n", "        sifted = sift(complexes, lambda c: c[1])\n", "        complexes = []\n", "        for f in ordered(sifted):\n", "            nimag = _imag_count_of_factor(f)\n", "            if nimag == 0:\n", "                # refine until xbounds are neg or pos\n", "                for u, f, k in sifted[f]:\n", "                    while u.ax*u.bx <= 0:\n", "                        u = u._inner_refine()\n", "                    complexes.append((u, f, k))\n", "            else:\n", "                # refine until all but nimag xbounds are neg or pos\n", "                potential_imag = list(range(len(sifted[f])))\n", "                while True:\n", "                    assert len(potential_imag) > 1\n", "                    for i in list(potential_imag):\n", "                        u, f, k = sifted[f][i]\n", "                        if u.ax*u.bx > 0:\n", "                            potential_imag.remove(i)\n", "                        elif u.ax != u.bx:\n", "                            u = u._inner_refine()\n", "                            sifted[f][i] = u, f, k\n", "                    if len(potential_imag) == nimag:\n", "                        break\n", "                complexes.extend(sifted[f])\n", "        return complexes\n"]}, {"span_id": "ComplexRootOf", "start_line": 165, "end_line": 295, "content": ["@public\n", "class ComplexRootOf(RootOf):\n", "    \"\"\"Represents an indexed complex root of a polynomial.\n", "\n", "    Roots of a univariate polynomial separated into disjoint\n", "    real or complex intervals and indexed in a fixed order.\n", "    Currently only rational coefficients are allowed.\n", "    Can be imported as ``CRootOf``. To avoid confusion, the\n", "    generator must be a Symbol.\n", "\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import CRootOf, rootof\n", "    >>> from sympy.abc import x\n", "\n", "    CRootOf is a way to reference a particular root of a\n", "    polynomial. If there is a rational root, it will be returned:\n", "\n", "    >>> CRootOf.clear_cache()  # for doctest reproducibility\n", "    >>> CRootOf(x**2 - 4, 0)\n", "    -2\n", "\n", "    Whether roots involving radicals are returned or not\n", "    depends on whether the ``radicals`` flag is true (which is\n", "    set to True with rootof):\n", "\n", "    >>> CRootOf(x**2 - 3, 0)\n", "    CRootOf(x**2 - 3, 0)\n", "    >>> CRootOf(x**2 - 3, 0, radicals=True)\n", "    -sqrt(3)\n", "    >>> rootof(x**2 - 3, 0)\n", "    -sqrt(3)\n", "\n", "    The following cannot be expressed in terms of radicals:\n", "\n", "    >>> r = rootof(4*x**5 + 16*x**3 + 12*x**2 + 7, 0); r\n", "    CRootOf(4*x**5 + 16*x**3 + 12*x**2 + 7, 0)\n", "\n", "    The root bounds can be seen, however, and they are used by the\n", "    evaluation methods to get numerical approximations for the root.\n", "\n", "    >>> interval = r._get_interval(); interval\n", "    (-1, 0)\n", "    >>> r.evalf(2)\n", "    -0.98\n", "\n", "    The evalf method refines the width of the root bounds until it\n", "    guarantees that any decimal approximation within those bounds\n", "    will satisfy the desired precision. It then stores the refined\n", "    interval so subsequent requests at or below the requested\n", "    precision will not have to recompute the root bounds and will\n", "    return very quickly.\n", "\n", "    Before evaluation above, the interval was\n", "\n", "    >>> interval\n", "    (-1, 0)\n", "\n", "    After evaluation it is now\n", "\n", "    >>> r._get_interval() # doctest: +SKIP\n", "    (-165/169, -206/211)\n", "\n", "    To reset all intervals for a given polynomial, the :meth:`_reset` method\n", "    can be called from any CRootOf instance of the polynomial:\n", "\n", "    >>> r._reset()\n", "    >>> r._get_interval()\n", "    (-1, 0)\n", "\n", "    The :meth:`eval_approx` method will also find the root to a given\n", "    precision but the interval is not modified unless the search\n", "    for the root fails to converge within the root bounds. And\n", "    the secant method is used to find the root. (The ``evalf``\n", "    method uses bisection and will always update the interval.)\n", "\n", "    >>> r.eval_approx(2)\n", "    -0.98\n", "\n", "    The interval needed to be slightly updated to find that root:\n", "\n", "    >>> r._get_interval()\n", "    (-1, -1/2)\n", "\n", "    The ``evalf_rational`` will compute a rational approximation\n", "    of the root to the desired accuracy or precision.\n", "\n", "    >>> r.eval_rational(n=2)\n", "    -69629/71318\n", "\n", "    >>> t = CRootOf(x**3 + 10*x + 1, 1)\n", "    >>> t.eval_rational(1e-1)\n", "    15/256 - 805*I/256\n", "    >>> t.eval_rational(1e-1, 1e-4)\n", "    3275/65536 - 414645*I/131072\n", "    >>> t.eval_rational(1e-4, 1e-4)\n", "    6545/131072 - 414645*I/131072\n", "    >>> t.eval_rational(n=2)\n", "    104755/2097152 - 6634255*I/2097152\n", "\n", "    Notes\n", "    =====\n", "\n", "    Although a PurePoly can be constructed from a non-symbol generator\n", "    RootOf instances of non-symbols are disallowed to avoid confusion\n", "    over what root is being represented.\n", "\n", "    >>> from sympy import exp, PurePoly\n", "    >>> PurePoly(x) == PurePoly(exp(x))\n", "    True\n", "    >>> CRootOf(x - 1, 0)\n", "    1\n", "    >>> CRootOf(exp(x) - 1, 0)  # would correspond to x == 0\n", "    Traceback (most recent call last):\n", "    ...\n", "    sympy.polys.polyerrors.PolynomialError: generator must be a Symbol\n", "\n", "    See Also\n", "    ========\n", "\n", "    eval_approx\n", "    eval_rational\n", "\n", "    \"\"\"\n", "\n", "    __slots__ = ('index',)\n", "    is_complex = True\n", "    is_number = True\n", "    is_finite = True\n"]}, {"span_id": "ComplexRootOf._refine_complexes", "start_line": 527, "end_line": 554, "content": ["    @classmethod\n", "    def _refine_complexes(cls, complexes):\n", "        \"\"\"return complexes such that no bounding rectangles of non-conjugate\n", "        roots would intersect. In addition, assure that neither ay nor by is\n", "        0 to guarantee that non-real roots are distinct from real roots in\n", "        terms of the y-bounds.\n", "        \"\"\"\n", "        # get the intervals pairwise-disjoint.\n", "        # If rectangles were drawn around the coordinates of the bounding\n", "        # rectangles, no rectangles would intersect after this procedure.\n", "        for i, (u, f, k) in enumerate(complexes):\n", "            for j, (v, g, m) in enumerate(complexes[i + 1:]):\n", "                u, v = u.refine_disjoint(v)\n", "                complexes[i + j + 1] = (v, g, m)\n", "\n", "            complexes[i] = (u, f, k)\n", "\n", "        # refine until the x-bounds are unambiguously positive or negative\n", "        # for non-imaginary roots\n", "        complexes = cls._refine_imaginary(complexes)\n", "\n", "        # make sure that all y bounds are off the real axis\n", "        # and on the same side of the axis\n", "        for i, (u, f, k) in enumerate(complexes):\n", "            while u.ay*u.by <= 0:\n", "                u = u.refine()\n", "            complexes[i] = u, f, k\n", "        return complexes\n"]}]}]}