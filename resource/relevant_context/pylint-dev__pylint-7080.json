{"instance_id": "pylint-dev__pylint-7080", "identified_spans": [{"file_path": "pylint/lint/expand_modules.py", "span_ids": ["expand_modules"], "content": [{"span_id": "expand_modules", "start_line": 63, "end_line": 161, "content": ["def expand_modules(\n", "    files_or_modules: Sequence[str],\n", "    ignore_list: list[str],\n", "    ignore_list_re: list[Pattern[str]],\n", "    ignore_list_paths_re: list[Pattern[str]],\n", ") -> tuple[list[ModuleDescriptionDict], list[ErrorDescriptionDict]]:\n", "    \"\"\"Take a list of files/modules/packages and return the list of tuple\n", "    (file, module name) which have to be actually checked.\n", "    \"\"\"\n", "    result: list[ModuleDescriptionDict] = []\n", "    errors: list[ErrorDescriptionDict] = []\n", "    path = sys.path.copy()\n", "\n", "    for something in files_or_modules:\n", "        basename = os.path.basename(something)\n", "        if _is_ignored_file(\n", "            something, ignore_list, ignore_list_re, ignore_list_paths_re\n", "        ):\n", "            continue\n", "        module_path = get_python_path(something)\n", "        additional_search_path = [\".\", module_path] + path\n", "        if os.path.exists(something):\n", "            # this is a file or a directory\n", "            try:\n", "                modname = \".\".join(\n", "                    modutils.modpath_from_file(something, path=additional_search_path)\n", "                )\n", "            except ImportError:\n", "                modname = os.path.splitext(basename)[0]\n", "            if os.path.isdir(something):\n", "                filepath = os.path.join(something, \"__init__.py\")\n", "            else:\n", "                filepath = something\n", "        else:\n", "            # suppose it's a module or package\n", "            modname = something\n", "            try:\n", "                filepath = modutils.file_from_modpath(\n", "                    modname.split(\".\"), path=additional_search_path\n", "                )\n", "                if filepath is None:\n", "                    continue\n", "            except (ImportError, SyntaxError) as ex:\n", "                # The SyntaxError is a Python bug and should be\n", "                # removed once we move away from imp.find_module: https://bugs.python.org/issue10588\n", "                errors.append({\"key\": \"fatal\", \"mod\": modname, \"ex\": ex})\n", "                continue\n", "        filepath = os.path.normpath(filepath)\n", "        modparts = (modname or something).split(\".\")\n", "        try:\n", "            spec = modutils.file_info_from_modpath(\n", "                modparts, path=additional_search_path\n", "            )\n", "        except ImportError:\n", "            # Might not be acceptable, don't crash.\n", "            is_namespace = False\n", "            is_directory = os.path.isdir(something)\n", "        else:\n", "            is_namespace = modutils.is_namespace(spec)\n", "            is_directory = modutils.is_directory(spec)\n", "        if not is_namespace:\n", "            result.append(\n", "                {\n", "                    \"path\": filepath,\n", "                    \"name\": modname,\n", "                    \"isarg\": True,\n", "                    \"basepath\": filepath,\n", "                    \"basename\": modname,\n", "                }\n", "            )\n", "        has_init = (\n", "            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n", "            and os.path.basename(filepath) == \"__init__.py\"\n", "        )\n", "        if has_init or is_namespace or is_directory:\n", "            for subfilepath in modutils.get_module_files(\n", "                os.path.dirname(filepath), ignore_list, list_all=is_namespace\n", "            ):\n", "                if filepath == subfilepath:\n", "                    continue\n", "                if _is_in_ignore_list_re(\n", "                    os.path.basename(subfilepath), ignore_list_re\n", "                ) or _is_in_ignore_list_re(subfilepath, ignore_list_paths_re):\n", "                    continue\n", "\n", "                modpath = _modpath_from_file(\n", "                    subfilepath, is_namespace, path=additional_search_path\n", "                )\n", "                submodname = \".\".join(modpath)\n", "                result.append(\n", "                    {\n", "                        \"path\": subfilepath,\n", "                        \"name\": submodname,\n", "                        \"isarg\": False,\n", "                        \"basepath\": filepath,\n", "                        \"basename\": modname,\n", "                    }\n", "                )\n", "    return result, errors\n"]}]}, {"file_path": "pylint/lint/pylinter.py", "span_ids": ["PyLinter._discover_files", "PyLinter.check"], "content": [{"span_id": "PyLinter._discover_files", "start_line": 585, "end_line": 619, "content": ["    def _discover_files(self, files_or_modules: Sequence[str]) -> Iterator[str]:\n", "        \"\"\"Discover python modules and packages in sub-directory.\n", "\n", "        Returns iterator of paths to discovered modules and packages.\n", "        \"\"\"\n", "        for something in files_or_modules:\n", "            if os.path.isdir(something) and not os.path.isfile(\n", "                os.path.join(something, \"__init__.py\")\n", "            ):\n", "                skip_subtrees: list[str] = []\n", "                for root, _, files in os.walk(something):\n", "                    if any(root.startswith(s) for s in skip_subtrees):\n", "                        # Skip subtree of already discovered package.\n", "                        continue\n", "\n", "                    if _is_ignored_file(\n", "                        root,\n", "                        self.config.ignore,\n", "                        self.config.ignore_patterns,\n", "                        self.config.ignore_paths,\n", "                    ):\n", "                        skip_subtrees.append(root)\n", "                        continue\n", "\n", "                    if \"__init__.py\" in files:\n", "                        skip_subtrees.append(root)\n", "                        yield root\n", "                    else:\n", "                        yield from (\n", "                            os.path.join(root, file)\n", "                            for file in files\n", "                            if file.endswith(\".py\")\n", "                        )\n", "            else:\n", "                yield something\n"]}, {"span_id": "PyLinter.check", "start_line": 621, "end_line": 659, "content": ["    def check(self, files_or_modules: Sequence[str] | str) -> None:\n", "        \"\"\"Main checking entry: check a list of files or modules from their name.\n", "\n", "        files_or_modules is either a string or list of strings presenting modules to check.\n", "        \"\"\"\n", "        self.initialize()\n", "        if not isinstance(files_or_modules, (list, tuple)):\n", "            # TODO: 3.0: Remove deprecated typing and update docstring\n", "            warnings.warn(\n", "                \"In pylint 3.0, the checkers check function will only accept sequence of string\",\n", "                DeprecationWarning,\n", "            )\n", "            files_or_modules = (files_or_modules,)  # type: ignore[assignment]\n", "        if self.config.recursive:\n", "            files_or_modules = tuple(self._discover_files(files_or_modules))\n", "        if self.config.from_stdin:\n", "            if len(files_or_modules) != 1:\n", "                raise exceptions.InvalidArgsError(\n", "                    \"Missing filename required for --from-stdin\"\n", "                )\n", "\n", "            filepath = files_or_modules[0]\n", "            with fix_import_path(files_or_modules):\n", "                self._check_files(\n", "                    functools.partial(self.get_ast, data=_read_stdin()),\n", "                    [self._get_file_descr_from_stdin(filepath)],\n", "                )\n", "        elif self.config.jobs == 1:\n", "            with fix_import_path(files_or_modules):\n", "                self._check_files(\n", "                    self.get_ast, self._iterate_file_descrs(files_or_modules)\n", "                )\n", "        else:\n", "            check_parallel(\n", "                self,\n", "                self.config.jobs,\n", "                self._iterate_file_descrs(files_or_modules),\n", "                files_or_modules,\n", "            )\n"]}]}]}