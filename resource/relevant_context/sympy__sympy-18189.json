{"instance_id": "sympy__sympy-18189", "identified_spans": [{"file_path": "sympy/solvers/diophantine.py", "span_ids": ["diophantine"], "content": [{"span_id": "diophantine", "start_line": 101, "end_line": 351, "content": ["def diophantine(eq, param=symbols(\"t\", integer=True), syms=None,\n", "                permute=False):\n", "    \"\"\"\n", "    Simplify the solution procedure of diophantine equation ``eq`` by\n", "    converting it into a product of terms which should equal zero.\n", "\n", "    For example, when solving, `x^2 - y^2 = 0` this is treated as\n", "    `(x + y)(x - y) = 0` and `x + y = 0` and `x - y = 0` are solved\n", "    independently and combined. Each term is solved by calling\n", "    ``diop_solve()``. (Although it is possible to call ``diop_solve()``\n", "    directly, one must be careful to pass an equation in the correct\n", "    form and to interpret the output correctly; ``diophantine()`` is\n", "    the public-facing function to use in general.)\n", "\n", "    Output of ``diophantine()`` is a set of tuples. The elements of the\n", "    tuple are the solutions for each variable in the equation and\n", "    are arranged according to the alphabetic ordering of the variables.\n", "    e.g. For an equation with two variables, `a` and `b`, the first\n", "    element of the tuple is the solution for `a` and the second for `b`.\n", "\n", "    Usage\n", "    =====\n", "\n", "    ``diophantine(eq, t, syms)``: Solve the diophantine\n", "    equation ``eq``.\n", "    ``t`` is the optional parameter to be used by ``diop_solve()``.\n", "    ``syms`` is an optional list of symbols which determines the\n", "    order of the elements in the returned tuple.\n", "\n", "    By default, only the base solution is returned. If ``permute`` is set to\n", "    True then permutations of the base solution and/or permutations of the\n", "    signs of the values will be returned when applicable.\n", "\n", "    >>> from sympy.solvers.diophantine import diophantine\n", "    >>> from sympy.abc import a, b\n", "    >>> eq = a**4 + b**4 - (2**4 + 3**4)\n", "    >>> diophantine(eq)\n", "    {(2, 3)}\n", "    >>> diophantine(eq, permute=True)\n", "    {(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}\n", "\n", "    Details\n", "    =======\n", "\n", "    ``eq`` should be an expression which is assumed to be zero.\n", "    ``t`` is the parameter to be used in the solution.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.abc import x, y, z\n", "    >>> diophantine(x**2 - y**2)\n", "    {(t_0, -t_0), (t_0, t_0)}\n", "\n", "    >>> diophantine(x*(2*x + 3*y - z))\n", "    {(0, n1, n2), (t_0, t_1, 2*t_0 + 3*t_1)}\n", "    >>> diophantine(x**2 + 3*x*y + 4*x)\n", "    {(0, n1), (3*t_0 - 4, -t_0)}\n", "\n", "    See Also\n", "    ========\n", "\n", "    diop_solve()\n", "    sympy.utilities.iterables.permute_signs\n", "    sympy.utilities.iterables.signed_permutations\n", "    \"\"\"\n", "\n", "    from sympy.utilities.iterables import (\n", "        subsets, permute_signs, signed_permutations)\n", "\n", "    if isinstance(eq, Eq):\n", "        eq = eq.lhs - eq.rhs\n", "\n", "    try:\n", "        var = list(eq.expand(force=True).free_symbols)\n", "        var.sort(key=default_sort_key)\n", "        if syms:\n", "            if not is_sequence(syms):\n", "                raise TypeError(\n", "                    'syms should be given as a sequence, e.g. a list')\n", "            syms = [i for i in syms if i in var]\n", "            if syms != var:\n", "                dict_sym_index = dict(zip(syms, range(len(syms))))\n", "                return {tuple([t[dict_sym_index[i]] for i in var])\n", "                            for t in diophantine(eq, param)}\n", "        n, d = eq.as_numer_denom()\n", "        if n.is_number:\n", "            return set()\n", "        if not d.is_number:\n", "            dsol = diophantine(d)\n", "            good = diophantine(n) - dsol\n", "            return {s for s in good if _mexpand(d.subs(zip(var, s)))}\n", "        else:\n", "            eq = n\n", "        eq = factor_terms(eq)\n", "        assert not eq.is_number\n", "        eq = eq.as_independent(*var, as_Add=False)[1]\n", "        p = Poly(eq)\n", "        assert not any(g.is_number for g in p.gens)\n", "        eq = p.as_expr()\n", "        assert eq.is_polynomial()\n", "    except (GeneratorsNeeded, AssertionError, AttributeError):\n", "        raise TypeError(filldedent('''\n", "    Equation should be a polynomial with Rational coefficients.'''))\n", "\n", "    # permute only sign\n", "    do_permute_signs = False\n", "    # permute sign and values\n", "    do_permute_signs_var = False\n", "    # permute few signs\n", "    permute_few_signs = False\n", "    try:\n", "        # if we know that factoring should not be attempted, skip\n", "        # the factoring step\n", "        v, c, t = classify_diop(eq)\n", "\n", "        # check for permute sign\n", "        if permute:\n", "            len_var = len(v)\n", "            permute_signs_for = [\n", "                'general_sum_of_squares',\n", "                'general_sum_of_even_powers']\n", "            permute_signs_check = [\n", "                'homogeneous_ternary_quadratic',\n", "                'homogeneous_ternary_quadratic_normal',\n", "                'binary_quadratic']\n", "            if t in permute_signs_for:\n", "                do_permute_signs_var = True\n", "            elif t in permute_signs_check:\n", "                # if all the variables in eq have even powers\n", "                # then do_permute_sign = True\n", "                if len_var == 3:\n", "                    var_mul = list(subsets(v, 2))\n", "                    # here var_mul is like [(x, y), (x, z), (y, z)]\n", "                    xy_coeff = True\n", "                    x_coeff = True\n", "                    var1_mul_var2 = map(lambda a: a[0]*a[1], var_mul)\n", "                    # if coeff(y*z), coeff(y*x), coeff(x*z) is not 0 then\n", "                    # `xy_coeff` => True and do_permute_sign => False.\n", "                    # Means no permuted solution.\n", "                    for v1_mul_v2 in var1_mul_var2:\n", "                        try:\n", "                            coeff = c[v1_mul_v2]\n", "                        except KeyError:\n", "                            coeff = 0\n", "                        xy_coeff = bool(xy_coeff) and bool(coeff)\n", "                    var_mul = list(subsets(v, 1))\n", "                    # here var_mul is like [(x,), (y, )]\n", "                    for v1 in var_mul:\n", "                        try:\n", "                            coeff = c[v1[0]]\n", "                        except KeyError:\n", "                            coeff = 0\n", "                        x_coeff = bool(x_coeff) and bool(coeff)\n", "                    if not any([xy_coeff, x_coeff]):\n", "                        # means only x**2, y**2, z**2, const is present\n", "                        do_permute_signs = True\n", "                    elif not x_coeff:\n", "                        permute_few_signs = True\n", "                elif len_var == 2:\n", "                    var_mul = list(subsets(v, 2))\n", "                    # here var_mul is like [(x, y)]\n", "                    xy_coeff = True\n", "                    x_coeff = True\n", "                    var1_mul_var2 = map(lambda x: x[0]*x[1], var_mul)\n", "                    for v1_mul_v2 in var1_mul_var2:\n", "                        try:\n", "                            coeff = c[v1_mul_v2]\n", "                        except KeyError:\n", "                            coeff = 0\n", "                        xy_coeff = bool(xy_coeff) and bool(coeff)\n", "                    var_mul = list(subsets(v, 1))\n", "                    # here var_mul is like [(x,), (y, )]\n", "                    for v1 in var_mul:\n", "                        try:\n", "                            coeff = c[v1[0]]\n", "                        except KeyError:\n", "                            coeff = 0\n", "                        x_coeff = bool(x_coeff) and bool(coeff)\n", "                    if not any([xy_coeff, x_coeff]):\n", "                        # means only x**2, y**2 and const is present\n", "                        # so we can get more soln by permuting this soln.\n", "                        do_permute_signs = True\n", "                    elif not x_coeff:\n", "                        # when coeff(x), coeff(y) is not present then signs of\n", "                        #  x, y can be permuted such that their sign are same\n", "                        # as sign of x*y.\n", "                        # e.g 1. (x_val,y_val)=> (x_val,y_val), (-x_val,-y_val)\n", "                        # 2. (-x_vall, y_val)=> (-x_val,y_val), (x_val,-y_val)\n", "                        permute_few_signs = True\n", "        if t == 'general_sum_of_squares':\n", "            # trying to factor such expressions will sometimes hang\n", "            terms = [(eq, 1)]\n", "        else:\n", "            raise TypeError\n", "    except (TypeError, NotImplementedError):\n", "        terms = factor_list(eq)[1]\n", "\n", "    sols = set([])\n", "\n", "    for term in terms:\n", "\n", "        base, _ = term\n", "        var_t, _, eq_type = classify_diop(base, _dict=False)\n", "        _, base = signsimp(base, evaluate=False).as_coeff_Mul()\n", "        solution = diop_solve(base, param)\n", "\n", "        if eq_type in [\n", "                \"linear\",\n", "                \"homogeneous_ternary_quadratic\",\n", "                \"homogeneous_ternary_quadratic_normal\",\n", "                \"general_pythagorean\"]:\n", "            sols.add(merge_solution(var, var_t, solution))\n", "\n", "        elif eq_type in [\n", "                \"binary_quadratic\",\n", "                \"general_sum_of_squares\",\n", "                \"general_sum_of_even_powers\",\n", "                \"univariate\"]:\n", "            for sol in solution:\n", "                sols.add(merge_solution(var, var_t, sol))\n", "\n", "        else:\n", "            raise NotImplementedError('unhandled type: %s' % eq_type)\n", "\n", "    # remove null merge results\n", "    if () in sols:\n", "        sols.remove(())\n", "    null = tuple([0]*len(var))\n", "    # if there is no solution, return trivial solution\n", "    if not sols and eq.subs(zip(var, null)).is_zero:\n", "        sols.add(null)\n", "    final_soln = set([])\n", "    for sol in sols:\n", "        if all(_is_int(s) for s in sol):\n", "            if do_permute_signs:\n", "                permuted_sign = set(permute_signs(sol))\n", "                final_soln.update(permuted_sign)\n", "            elif permute_few_signs:\n", "                lst = list(permute_signs(sol))\n", "                lst = list(filter(lambda x: x[0]*x[1] == sol[1]*sol[0], lst))\n", "                permuted_sign = set(lst)\n", "                final_soln.update(permuted_sign)\n", "            elif do_permute_signs_var:\n", "                permuted_sign_var = set(signed_permutations(sol))\n", "                final_soln.update(permuted_sign_var)\n", "            else:\n", "                final_soln.add(sol)\n", "        else:\n", "                final_soln.add(sol)\n", "    return final_soln\n"]}]}]}