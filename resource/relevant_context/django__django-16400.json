{"instance_id": "django__django-16400", "identified_spans": [{"file_path": "django/contrib/auth/management/__init__.py", "span_ids": ["create_permissions"], "content": [{"span_id": "create_permissions", "start_line": 37, "end_line": 106, "content": ["def create_permissions(\n", "    app_config,\n", "    verbosity=2,\n", "    interactive=True,\n", "    using=DEFAULT_DB_ALIAS,\n", "    apps=global_apps,\n", "    **kwargs,\n", "):\n", "    if not app_config.models_module:\n", "        return\n", "\n", "    # Ensure that contenttypes are created for this app. Needed if\n", "    # 'django.contrib.auth' is in INSTALLED_APPS before\n", "    # 'django.contrib.contenttypes'.\n", "    create_contenttypes(\n", "        app_config,\n", "        verbosity=verbosity,\n", "        interactive=interactive,\n", "        using=using,\n", "        apps=apps,\n", "        **kwargs,\n", "    )\n", "\n", "    app_label = app_config.label\n", "    try:\n", "        app_config = apps.get_app_config(app_label)\n", "        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n", "        Permission = apps.get_model(\"auth\", \"Permission\")\n", "    except LookupError:\n", "        return\n", "\n", "    if not router.allow_migrate_model(using, Permission):\n", "        return\n", "\n", "    # This will hold the permissions we're looking for as\n", "    # (content_type, (codename, name))\n", "    searched_perms = []\n", "    # The codenames and ctypes that should exist.\n", "    ctypes = set()\n", "    for klass in app_config.get_models():\n", "        # Force looking up the content types in the current database\n", "        # before creating foreign keys to them.\n", "        ctype = ContentType.objects.db_manager(using).get_for_model(\n", "            klass, for_concrete_model=False\n", "        )\n", "\n", "        ctypes.add(ctype)\n", "        for perm in _get_all_permissions(klass._meta):\n", "            searched_perms.append((ctype, perm))\n", "\n", "    # Find all the Permissions that have a content_type for a model we're\n", "    # looking for.  We don't need to check for codenames since we already have\n", "    # a list of the ones we're going to create.\n", "    all_perms = set(\n", "        Permission.objects.using(using)\n", "        .filter(\n", "            content_type__in=ctypes,\n", "        )\n", "        .values_list(\"content_type\", \"codename\")\n", "    )\n", "\n", "    perms = [\n", "        Permission(codename=codename, name=name, content_type=ct)\n", "        for ct, (codename, name) in searched_perms\n", "        if (ct.pk, codename) not in all_perms\n", "    ]\n", "    Permission.objects.using(using).bulk_create(perms)\n", "    if verbosity >= 2:\n", "        for perm in perms:\n", "            print(\"Adding permission '%s'\" % perm)\n"]}]}, {"file_path": "django/core/management/commands/migrate.py", "span_ids": ["Command.handle"], "content": [{"span_id": "Command.handle", "start_line": 96, "end_line": 390, "content": ["    @no_translations\n", "    def handle(self, *args, **options):\n", "        database = options[\"database\"]\n", "        if not options[\"skip_checks\"]:\n", "            self.check(databases=[database])\n", "\n", "        self.verbosity = options[\"verbosity\"]\n", "        self.interactive = options[\"interactive\"]\n", "\n", "        # Import the 'management' module within each installed app, to register\n", "        # dispatcher events.\n", "        for app_config in apps.get_app_configs():\n", "            if module_has_submodule(app_config.module, \"management\"):\n", "                import_module(\".management\", app_config.name)\n", "\n", "        # Get the database we're operating from\n", "        connection = connections[database]\n", "\n", "        # Hook for backends needing any database preparation\n", "        connection.prepare_database()\n", "        # Work out which apps have migrations and which do not\n", "        executor = MigrationExecutor(connection, self.migration_progress_callback)\n", "\n", "        # Raise an error if any migrations are applied before their dependencies.\n", "        executor.loader.check_consistent_history(connection)\n", "\n", "        # Before anything else, see if there's conflicting apps and drop out\n", "        # hard if there are any\n", "        conflicts = executor.loader.detect_conflicts()\n", "        if conflicts:\n", "            name_str = \"; \".join(\n", "                \"%s in %s\" % (\", \".join(names), app) for app, names in conflicts.items()\n", "            )\n", "            raise CommandError(\n", "                \"Conflicting migrations detected; multiple leaf nodes in the \"\n", "                \"migration graph: (%s).\\nTo fix them run \"\n", "                \"'python manage.py makemigrations --merge'\" % name_str\n", "            )\n", "\n", "        # If they supplied command line arguments, work out what they mean.\n", "        run_syncdb = options[\"run_syncdb\"]\n", "        target_app_labels_only = True\n", "        if options[\"app_label\"]:\n", "            # Validate app_label.\n", "            app_label = options[\"app_label\"]\n", "            try:\n", "                apps.get_app_config(app_label)\n", "            except LookupError as err:\n", "                raise CommandError(str(err))\n", "            if run_syncdb:\n", "                if app_label in executor.loader.migrated_apps:\n", "                    raise CommandError(\n", "                        \"Can't use run_syncdb with app '%s' as it has migrations.\"\n", "                        % app_label\n", "                    )\n", "            elif app_label not in executor.loader.migrated_apps:\n", "                raise CommandError(\"App '%s' does not have migrations.\" % app_label)\n", "\n", "        if options[\"app_label\"] and options[\"migration_name\"]:\n", "            migration_name = options[\"migration_name\"]\n", "            if migration_name == \"zero\":\n", "                targets = [(app_label, None)]\n", "            else:\n", "                try:\n", "                    migration = executor.loader.get_migration_by_prefix(\n", "                        app_label, migration_name\n", "                    )\n", "                except AmbiguityError:\n", "                    raise CommandError(\n", "                        \"More than one migration matches '%s' in app '%s'. \"\n", "                        \"Please be more specific.\" % (migration_name, app_label)\n", "                    )\n", "                except KeyError:\n", "                    raise CommandError(\n", "                        \"Cannot find a migration matching '%s' from app '%s'.\"\n", "                        % (migration_name, app_label)\n", "                    )\n", "                target = (app_label, migration.name)\n", "                # Partially applied squashed migrations are not included in the\n", "                # graph, use the last replacement instead.\n", "                if (\n", "                    target not in executor.loader.graph.nodes\n", "                    and target in executor.loader.replacements\n", "                ):\n", "                    incomplete_migration = executor.loader.replacements[target]\n", "                    target = incomplete_migration.replaces[-1]\n", "                targets = [target]\n", "            target_app_labels_only = False\n", "        elif options[\"app_label\"]:\n", "            targets = [\n", "                key for key in executor.loader.graph.leaf_nodes() if key[0] == app_label\n", "            ]\n", "        else:\n", "            targets = executor.loader.graph.leaf_nodes()\n", "\n", "        if options[\"prune\"]:\n", "            if not options[\"app_label\"]:\n", "                raise CommandError(\n", "                    \"Migrations can be pruned only when an app is specified.\"\n", "                )\n", "            if self.verbosity > 0:\n", "                self.stdout.write(\"Pruning migrations:\", self.style.MIGRATE_HEADING)\n", "            to_prune = set(executor.loader.applied_migrations) - set(\n", "                executor.loader.disk_migrations\n", "            )\n", "            squashed_migrations_with_deleted_replaced_migrations = [\n", "                migration_key\n", "                for migration_key, migration_obj in executor.loader.replacements.items()\n", "                if any(replaced in to_prune for replaced in migration_obj.replaces)\n", "            ]\n", "            if squashed_migrations_with_deleted_replaced_migrations:\n", "                self.stdout.write(\n", "                    self.style.NOTICE(\n", "                        \"  Cannot use --prune because the following squashed \"\n", "                        \"migrations have their 'replaces' attributes and may not \"\n", "                        \"be recorded as applied:\"\n", "                    )\n", "                )\n", "                for migration in squashed_migrations_with_deleted_replaced_migrations:\n", "                    app, name = migration\n", "                    self.stdout.write(f\"    {app}.{name}\")\n", "                self.stdout.write(\n", "                    self.style.NOTICE(\n", "                        \"  Re-run 'manage.py migrate' if they are not marked as \"\n", "                        \"applied, and remove 'replaces' attributes in their \"\n", "                        \"Migration classes.\"\n", "                    )\n", "                )\n", "            else:\n", "                to_prune = sorted(\n", "                    migration for migration in to_prune if migration[0] == app_label\n", "                )\n", "                if to_prune:\n", "                    for migration in to_prune:\n", "                        app, name = migration\n", "                        if self.verbosity > 0:\n", "                            self.stdout.write(\n", "                                self.style.MIGRATE_LABEL(f\"  Pruning {app}.{name}\"),\n", "                                ending=\"\",\n", "                            )\n", "                        executor.recorder.record_unapplied(app, name)\n", "                        if self.verbosity > 0:\n", "                            self.stdout.write(self.style.SUCCESS(\" OK\"))\n", "                elif self.verbosity > 0:\n", "                    self.stdout.write(\"  No migrations to prune.\")\n", "\n", "        plan = executor.migration_plan(targets)\n", "\n", "        if options[\"plan\"]:\n", "            self.stdout.write(\"Planned operations:\", self.style.MIGRATE_LABEL)\n", "            if not plan:\n", "                self.stdout.write(\"  No planned migration operations.\")\n", "            else:\n", "                for migration, backwards in plan:\n", "                    self.stdout.write(str(migration), self.style.MIGRATE_HEADING)\n", "                    for operation in migration.operations:\n", "                        message, is_error = self.describe_operation(\n", "                            operation, backwards\n", "                        )\n", "                        style = self.style.WARNING if is_error else None\n", "                        self.stdout.write(\"    \" + message, style)\n", "                if options[\"check_unapplied\"]:\n", "                    sys.exit(1)\n", "            return\n", "        if options[\"check_unapplied\"]:\n", "            if plan:\n", "                sys.exit(1)\n", "            return\n", "        if options[\"prune\"]:\n", "            return\n", "\n", "        # At this point, ignore run_syncdb if there aren't any apps to sync.\n", "        run_syncdb = options[\"run_syncdb\"] and executor.loader.unmigrated_apps\n", "        # Print some useful info\n", "        if self.verbosity >= 1:\n", "            self.stdout.write(self.style.MIGRATE_HEADING(\"Operations to perform:\"))\n", "            if run_syncdb:\n", "                if options[\"app_label\"]:\n", "                    self.stdout.write(\n", "                        self.style.MIGRATE_LABEL(\n", "                            \"  Synchronize unmigrated app: %s\" % app_label\n", "                        )\n", "                    )\n", "                else:\n", "                    self.stdout.write(\n", "                        self.style.MIGRATE_LABEL(\"  Synchronize unmigrated apps: \")\n", "                        + (\", \".join(sorted(executor.loader.unmigrated_apps)))\n", "                    )\n", "            if target_app_labels_only:\n", "                self.stdout.write(\n", "                    self.style.MIGRATE_LABEL(\"  Apply all migrations: \")\n", "                    + (\", \".join(sorted({a for a, n in targets})) or \"(none)\")\n", "                )\n", "            else:\n", "                if targets[0][1] is None:\n", "                    self.stdout.write(\n", "                        self.style.MIGRATE_LABEL(\"  Unapply all migrations: \")\n", "                        + str(targets[0][0])\n", "                    )\n", "                else:\n", "                    self.stdout.write(\n", "                        self.style.MIGRATE_LABEL(\"  Target specific migration: \")\n", "                        + \"%s, from %s\" % (targets[0][1], targets[0][0])\n", "                    )\n", "\n", "        pre_migrate_state = executor._create_project_state(with_applied_migrations=True)\n", "        pre_migrate_apps = pre_migrate_state.apps\n", "        emit_pre_migrate_signal(\n", "            self.verbosity,\n", "            self.interactive,\n", "            connection.alias,\n", "            stdout=self.stdout,\n", "            apps=pre_migrate_apps,\n", "            plan=plan,\n", "        )\n", "\n", "        # Run the syncdb phase.\n", "        if run_syncdb:\n", "            if self.verbosity >= 1:\n", "                self.stdout.write(\n", "                    self.style.MIGRATE_HEADING(\"Synchronizing apps without migrations:\")\n", "                )\n", "            if options[\"app_label\"]:\n", "                self.sync_apps(connection, [app_label])\n", "            else:\n", "                self.sync_apps(connection, executor.loader.unmigrated_apps)\n", "\n", "        # Migrate!\n", "        if self.verbosity >= 1:\n", "            self.stdout.write(self.style.MIGRATE_HEADING(\"Running migrations:\"))\n", "        if not plan:\n", "            if self.verbosity >= 1:\n", "                self.stdout.write(\"  No migrations to apply.\")\n", "                # If there's changes that aren't in migrations yet, tell them\n", "                # how to fix it.\n", "                autodetector = MigrationAutodetector(\n", "                    executor.loader.project_state(),\n", "                    ProjectState.from_apps(apps),\n", "                )\n", "                changes = autodetector.changes(graph=executor.loader.graph)\n", "                if changes:\n", "                    self.stdout.write(\n", "                        self.style.NOTICE(\n", "                            \"  Your models in app(s): %s have changes that are not \"\n", "                            \"yet reflected in a migration, and so won't be \"\n", "                            \"applied.\" % \", \".join(repr(app) for app in sorted(changes))\n", "                        )\n", "                    )\n", "                    self.stdout.write(\n", "                        self.style.NOTICE(\n", "                            \"  Run 'manage.py makemigrations' to make new \"\n", "                            \"migrations, and then re-run 'manage.py migrate' to \"\n", "                            \"apply them.\"\n", "                        )\n", "                    )\n", "            fake = False\n", "            fake_initial = False\n", "        else:\n", "            fake = options[\"fake\"]\n", "            fake_initial = options[\"fake_initial\"]\n", "        post_migrate_state = executor.migrate(\n", "            targets,\n", "            plan=plan,\n", "            state=pre_migrate_state.clone(),\n", "            fake=fake,\n", "            fake_initial=fake_initial,\n", "        )\n", "        # post_migrate signals have access to all models. Ensure that all models\n", "        # are reloaded in case any are delayed.\n", "        post_migrate_state.clear_delayed_apps_cache()\n", "        post_migrate_apps = post_migrate_state.apps\n", "\n", "        # Re-render models of real apps to include relationships now that\n", "        # we've got a final state. This wouldn't be necessary if real apps\n", "        # models were rendered with relationships in the first place.\n", "        with post_migrate_apps.bulk_update():\n", "            model_keys = []\n", "            for model_state in post_migrate_apps.real_models:\n", "                model_key = model_state.app_label, model_state.name_lower\n", "                model_keys.append(model_key)\n", "                post_migrate_apps.unregister_model(*model_key)\n", "        post_migrate_apps.render_multiple(\n", "            [ModelState.from_model(apps.get_model(*model)) for model in model_keys]\n", "        )\n", "\n", "        # Send the post_migrate signal, so individual apps can do whatever they need\n", "        # to do at this point.\n", "        emit_post_migrate_signal(\n", "            self.verbosity,\n", "            self.interactive,\n", "            connection.alias,\n", "            stdout=self.stdout,\n", "            apps=post_migrate_apps,\n", "            plan=plan,\n", "        )\n"]}]}, {"file_path": "django/db/migrations/executor.py", "span_ids": ["MigrationExecutor.apply_migration", "MigrationExecutor.migrate"], "content": [{"span_id": "MigrationExecutor.apply_migration", "start_line": 236, "end_line": 261, "content": ["    def apply_migration(self, state, migration, fake=False, fake_initial=False):\n", "        \"\"\"Run a migration forwards.\"\"\"\n", "        migration_recorded = False\n", "        if self.progress_callback:\n", "            self.progress_callback(\"apply_start\", migration, fake)\n", "        if not fake:\n", "            if fake_initial:\n", "                # Test to see if this is an already-applied initial migration\n", "                applied, state = self.detect_soft_applied(state, migration)\n", "                if applied:\n", "                    fake = True\n", "            if not fake:\n", "                # Alright, do it normally\n", "                with self.connection.schema_editor(\n", "                    atomic=migration.atomic\n", "                ) as schema_editor:\n", "                    state = migration.apply(state, schema_editor)\n", "                    if not schema_editor.deferred_sql:\n", "                        self.record_migration(migration)\n", "                        migration_recorded = True\n", "        if not migration_recorded:\n", "            self.record_migration(migration)\n", "        # Report progress\n", "        if self.progress_callback:\n", "            self.progress_callback(\"apply_success\", migration, fake)\n", "        return state\n"]}, {"span_id": "MigrationExecutor.migrate", "start_line": 94, "end_line": 145, "content": ["    def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):\n", "        \"\"\"\n", "        Migrate the database up to the given targets.\n", "\n", "        Django first needs to create all project states before a migration is\n", "        (un)applied and in a second step run all the database operations.\n", "        \"\"\"\n", "        # The django_migrations table must be present to record applied\n", "        # migrations, but don't create it if there are no migrations to apply.\n", "        if plan == []:\n", "            if not self.recorder.has_table():\n", "                return self._create_project_state(with_applied_migrations=False)\n", "        else:\n", "            self.recorder.ensure_schema()\n", "\n", "        if plan is None:\n", "            plan = self.migration_plan(targets)\n", "        # Create the forwards plan Django would follow on an empty database\n", "        full_plan = self.migration_plan(\n", "            self.loader.graph.leaf_nodes(), clean_start=True\n", "        )\n", "\n", "        all_forwards = all(not backwards for mig, backwards in plan)\n", "        all_backwards = all(backwards for mig, backwards in plan)\n", "\n", "        if not plan:\n", "            if state is None:\n", "                # The resulting state should include applied migrations.\n", "                state = self._create_project_state(with_applied_migrations=True)\n", "        elif all_forwards == all_backwards:\n", "            # This should only happen if there's a mixed plan\n", "            raise InvalidMigrationPlan(\n", "                \"Migration plans with both forwards and backwards migrations \"\n", "                \"are not supported. Please split your migration process into \"\n", "                \"separate plans of only forwards OR backwards migrations.\",\n", "                plan,\n", "            )\n", "        elif all_forwards:\n", "            if state is None:\n", "                # The resulting state should still include applied migrations.\n", "                state = self._create_project_state(with_applied_migrations=True)\n", "            state = self._migrate_all_forwards(\n", "                state, plan, full_plan, fake=fake, fake_initial=fake_initial\n", "            )\n", "        else:\n", "            # No need to check for `elif all_backwards` here, as that condition\n", "            # would always evaluate to true.\n", "            state = self._migrate_all_backwards(plan, full_plan, fake=fake)\n", "\n", "        self.check_replacements()\n", "\n", "        return state\n"]}]}, {"file_path": "django/db/utils.py", "span_ids": ["ConnectionRouter.allow_migrate", "ConnectionRouter.db_for_write", "ConnectionRouter", "ConnectionRouter.db_for_read"], "content": [{"span_id": "ConnectionRouter.allow_migrate", "start_line": 253, "end_line": 265, "content": ["    def allow_migrate(self, db, app_label, **hints):\n", "        for router in self.routers:\n", "            try:\n", "                method = router.allow_migrate\n", "            except AttributeError:\n", "                # If the router doesn't have a method, skip to the next one.\n", "                continue\n", "\n", "            allow = method(db, app_label, **hints)\n", "\n", "            if allow is not None:\n", "                return allow\n", "        return True\n"]}, {"span_id": "ConnectionRouter", "start_line": 197, "end_line": 197, "content": ["class ConnectionRouter:\n"]}]}]}