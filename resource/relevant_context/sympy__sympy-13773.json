{"instance_id": "sympy__sympy-13773", "identified_spans": [{"file_path": "sympy/matrices/common.py", "span_ids": ["MatrixArithmetic.__matmul__", "MatrixArithmetic.__rmatmul__", "MatrixArithmetic.__mul__"], "content": [{"span_id": "MatrixArithmetic.__matmul__", "start_line": 1974, "end_line": 1976, "content": ["    @call_highest_priority('__rmatmul__')\n", "    def __matmul__(self, other):\n", "        return self.__mul__(other)\n"]}, {"span_id": "MatrixArithmetic.__rmatmul__", "start_line": 2069, "end_line": 2071, "content": ["    @call_highest_priority('__matmul__')\n", "    def __rmatmul__(self, other):\n", "        return self.__rmul__(other)\n"]}, {"span_id": "MatrixArithmetic.__mul__", "start_line": 1978, "end_line": 2028, "content": ["    @call_highest_priority('__rmul__')\n", "    def __mul__(self, other):\n", "        \"\"\"Return self*other where other is either a scalar or a matrix\n", "        of compatible dimensions.\n", "\n", "        Examples\n", "        ========\n", "\n", "        >>> from sympy.matrices import Matrix\n", "        >>> A = Matrix([[1, 2, 3], [4, 5, 6]])\n", "        >>> 2*A == A*2 == Matrix([[2, 4, 6], [8, 10, 12]])\n", "        True\n", "        >>> B = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n", "        >>> A*B\n", "        Matrix([\n", "        [30, 36, 42],\n", "        [66, 81, 96]])\n", "        >>> B*A\n", "        Traceback (most recent call last):\n", "        ...\n", "        ShapeError: Matrices size mismatch.\n", "        >>>\n", "\n", "        See Also\n", "        ========\n", "\n", "        matrix_multiply_elementwise\n", "        \"\"\"\n", "        other = _matrixify(other)\n", "        # matrix-like objects can have shapes.  This is\n", "        # our first sanity check.\n", "        if hasattr(other, 'shape') and len(other.shape) == 2:\n", "            if self.shape[1] != other.shape[0]:\n", "                raise ShapeError(\"Matrix size mismatch: %s * %s.\" % (\n", "                    self.shape, other.shape))\n", "\n", "        # honest sympy matrices defer to their class's routine\n", "        if getattr(other, 'is_Matrix', False):\n", "            return self._eval_matrix_mul(other)\n", "        # Matrix-like objects can be passed to CommonMatrix routines directly.\n", "        if getattr(other, 'is_MatrixLike', False):\n", "            return MatrixArithmetic._eval_matrix_mul(self, other)\n", "\n", "        # if 'other' is not iterable then scalar multiplication.\n", "        if not isinstance(other, collections.Iterable):\n", "            try:\n", "                return self._eval_scalar_mul(other)\n", "            except TypeError:\n", "                pass\n", "\n", "        return NotImplemented\n"]}]}, {"file_path": "sympy/matrices/expressions/matexpr.py", "span_ids": ["MatrixExpr.__matmul__", "MatrixExpr.__rmatmul__"], "content": [{"span_id": "MatrixExpr.__matmul__", "start_line": 112, "end_line": 115, "content": ["    @_sympifyit('other', NotImplemented)\n", "    @call_highest_priority('__rmul__')\n", "    def __matmul__(self, other):\n", "        return MatMul(self, other).doit()\n"]}, {"span_id": "MatrixExpr.__rmatmul__", "start_line": 122, "end_line": 125, "content": ["    @_sympifyit('other', NotImplemented)\n", "    @call_highest_priority('__mul__')\n", "    def __rmatmul__(self, other):\n", "        return MatMul(other, self).doit()\n"]}]}]}