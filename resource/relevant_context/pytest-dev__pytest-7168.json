{"instance_id": "pytest-dev__pytest-7168", "identified_spans": [{"file_path": "src/_pytest/_code/code.py", "span_ids": ["ExceptionInfo.__repr__"], "content": [{"span_id": "ExceptionInfo.__repr__", "start_line": 543, "end_line": 548, "content": ["    def __repr__(self) -> str:\n", "        if self._excinfo is None:\n", "            return \"<ExceptionInfo for raises contextmanager>\"\n", "        return \"<{} {} tblen={}>\".format(\n", "            self.__class__.__name__, saferepr(self._excinfo[1]), len(self.traceback)\n", "        )\n"]}]}, {"file_path": "src/_pytest/debugging.py", "span_ids": ["pytest_exception_interact"], "content": []}, {"file_path": "src/_pytest/nodes.py", "span_ids": ["Node._repr_failure_py"], "content": [{"span_id": "Node._repr_failure_py", "start_line": 320, "end_line": 362, "content": ["    def _repr_failure_py(\n", "        self, excinfo: ExceptionInfo[Union[Failed, FixtureLookupError]], style=None\n", "    ) -> Union[str, ReprExceptionInfo, ExceptionChainRepr, FixtureLookupErrorRepr]:\n", "        if isinstance(excinfo.value, fail.Exception):\n", "            if not excinfo.value.pytrace:\n", "                return str(excinfo.value)\n", "        if isinstance(excinfo.value, FixtureLookupError):\n", "            return excinfo.value.formatrepr()\n", "        if self.config.getoption(\"fulltrace\", False):\n", "            style = \"long\"\n", "        else:\n", "            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n", "            self._prunetraceback(excinfo)\n", "            if len(excinfo.traceback) == 0:\n", "                excinfo.traceback = tb\n", "            if style == \"auto\":\n", "                style = \"long\"\n", "        # XXX should excinfo.getrepr record all data and toterminal() process it?\n", "        if style is None:\n", "            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n", "                style = \"short\"\n", "            else:\n", "                style = \"long\"\n", "\n", "        if self.config.getoption(\"verbose\", 0) > 1:\n", "            truncate_locals = False\n", "        else:\n", "            truncate_locals = True\n", "\n", "        try:\n", "            os.getcwd()\n", "            abspath = False\n", "        except OSError:\n", "            abspath = True\n", "\n", "        return excinfo.getrepr(\n", "            funcargs=True,\n", "            abspath=abspath,\n", "            showlocals=self.config.getoption(\"showlocals\", False),\n", "            style=style,\n", "            tbfilter=False,  # pruned already, or in --fulltrace mode.\n", "            truncate_locals=truncate_locals,\n", "        )\n"]}]}, {"file_path": "src/_pytest/python.py", "span_ids": ["Function.repr_failure"], "content": [{"span_id": "Function.repr_failure", "start_line": 1541, "end_line": 1546, "content": ["    def repr_failure(self, excinfo, outerr=None):\n", "        assert outerr is None, \"XXX outerr usage is deprecated\"\n", "        style = self.config.getoption(\"tbstyle\", \"auto\")\n", "        if style == \"auto\":\n", "            style = \"long\"\n", "        return self._repr_failure_py(excinfo, style=style)\n"]}]}, {"file_path": "src/_pytest/reports.py", "span_ids": ["TestReport.__repr__"], "content": [{"span_id": "TestReport.__repr__", "start_line": 265, "end_line": 268, "content": ["    def __repr__(self):\n", "        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n", "            self.__class__.__name__, self.nodeid, self.when, self.outcome\n", "        )\n"]}]}]}