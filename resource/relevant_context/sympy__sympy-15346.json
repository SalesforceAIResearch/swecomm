{"instance_id": "sympy__sympy-15346", "identified_spans": [{"file_path": "sympy/functions/elementary/trigonometric.py", "span_ids": ["cos.eval", "cos", "sin.eval", "sin"], "content": [{"span_id": "cos.eval", "start_line": 530, "end_line": 668, "content": ["    @classmethod\n", "    def eval(cls, arg):\n", "        from sympy.functions.special.polynomials import chebyshevt\n", "        from sympy.calculus.util import AccumBounds\n", "        from sympy.sets.setexpr import SetExpr\n", "        if arg.is_Number:\n", "            if arg is S.NaN:\n", "                return S.NaN\n", "            elif arg is S.Zero:\n", "                return S.One\n", "            elif arg is S.Infinity or arg is S.NegativeInfinity:\n", "                # In this case it is better to return AccumBounds(-1, 1)\n", "                # rather than returning S.NaN, since AccumBounds(-1, 1)\n", "                # preserves the information that sin(oo) is between\n", "                # -1 and 1, where S.NaN does not do that.\n", "                return AccumBounds(-1, 1)\n", "\n", "        if arg is S.ComplexInfinity:\n", "            return S.NaN\n", "\n", "        if isinstance(arg, AccumBounds):\n", "            return sin(arg + S.Pi/2)\n", "        elif isinstance(arg, SetExpr):\n", "            return arg._eval_func(cls)\n", "\n", "        if arg.could_extract_minus_sign():\n", "            return cls(-arg)\n", "\n", "        i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n", "        if i_coeff is not None:\n", "            return cosh(i_coeff)\n", "\n", "        pi_coeff = _pi_coeff(arg)\n", "        if pi_coeff is not None:\n", "            if pi_coeff.is_integer:\n", "                return (S.NegativeOne)**pi_coeff\n", "\n", "            if (2*pi_coeff).is_integer:\n", "                if pi_coeff.is_even:\n", "                    return (S.NegativeOne)**(pi_coeff/2)\n", "                elif pi_coeff.is_even is False:\n", "                    return S.Zero\n", "\n", "            if not pi_coeff.is_Rational:\n", "                narg = pi_coeff*S.Pi\n", "                if narg != arg:\n", "                    return cls(narg)\n", "                return None\n", "\n", "            # cosine formula #####################\n", "            # https://github.com/sympy/sympy/issues/6048\n", "            # explicit calculations are preformed for\n", "            # cos(k pi/n) for n = 8,10,12,15,20,24,30,40,60,120\n", "            # Some other exact values like cos(k pi/240) can be\n", "            # calculated using a partial-fraction decomposition\n", "            # by calling cos( X ).rewrite(sqrt)\n", "            cst_table_some = {\n", "                3: S.Half,\n", "                5: (sqrt(5) + 1)/4,\n", "            }\n", "            if pi_coeff.is_Rational:\n", "                q = pi_coeff.q\n", "                p = pi_coeff.p % (2*q)\n", "                if p > q:\n", "                    narg = (pi_coeff - 1)*S.Pi\n", "                    return -cls(narg)\n", "                if 2*p > q:\n", "                    narg = (1 - pi_coeff)*S.Pi\n", "                    return -cls(narg)\n", "\n", "                # If nested sqrt's are worse than un-evaluation\n", "                # you can require q to be in (1, 2, 3, 4, 6, 12)\n", "                # q <= 12, q=15, q=20, q=24, q=30, q=40, q=60, q=120 return\n", "                # expressions with 2 or fewer sqrt nestings.\n", "                table2 = {\n", "                    12: (3, 4),\n", "                    20: (4, 5),\n", "                    30: (5, 6),\n", "                    15: (6, 10),\n", "                    24: (6, 8),\n", "                    40: (8, 10),\n", "                    60: (20, 30),\n", "                    120: (40, 60)\n", "                    }\n", "                if q in table2:\n", "                    a, b = p*S.Pi/table2[q][0], p*S.Pi/table2[q][1]\n", "                    nvala, nvalb = cls(a), cls(b)\n", "                    if None == nvala or None == nvalb:\n", "                        return None\n", "                    return nvala*nvalb + cls(S.Pi/2 - a)*cls(S.Pi/2 - b)\n", "\n", "                if q > 12:\n", "                    return None\n", "\n", "                if q in cst_table_some:\n", "                    cts = cst_table_some[pi_coeff.q]\n", "                    return chebyshevt(pi_coeff.p, cts).expand()\n", "\n", "                if 0 == q % 2:\n", "                    narg = (pi_coeff*2)*S.Pi\n", "                    nval = cls(narg)\n", "                    if None == nval:\n", "                        return None\n", "                    x = (2*pi_coeff + 1)/2\n", "                    sign_cos = (-1)**((-1 if x < 0 else 1)*int(abs(x)))\n", "                    return sign_cos*sqrt( (1 + nval)/2 )\n", "            return None\n", "\n", "        if arg.is_Add:\n", "            x, m = _peeloff_pi(arg)\n", "            if m:\n", "                return cos(m)*cos(x) - sin(m)*sin(x)\n", "\n", "        if isinstance(arg, acos):\n", "            return arg.args[0]\n", "\n", "        if isinstance(arg, atan):\n", "            x = arg.args[0]\n", "            return 1 / sqrt(1 + x**2)\n", "\n", "        if isinstance(arg, atan2):\n", "            y, x = arg.args\n", "            return x / sqrt(x**2 + y**2)\n", "\n", "        if isinstance(arg, asin):\n", "            x = arg.args[0]\n", "            return sqrt(1 - x ** 2)\n", "\n", "        if isinstance(arg, acot):\n", "            x = arg.args[0]\n", "            return 1 / sqrt(1 + 1 / x**2)\n", "\n", "        if isinstance(arg, acsc):\n", "            x = arg.args[0]\n", "            return sqrt(1 - 1 / x**2)\n", "\n", "        if isinstance(arg, asec):\n", "            x = arg.args[0]\n", "            return 1 / x\n"]}, {"span_id": "cos", "start_line": 478, "end_line": 519, "content": ["class cos(TrigonometricFunction):\n", "    \"\"\"\n", "    The cosine function.\n", "\n", "    Returns the cosine of x (measured in radians).\n", "\n", "    Notes\n", "    =====\n", "\n", "    See :func:`sin` for notes about automatic evaluation.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import cos, pi\n", "    >>> from sympy.abc import x\n", "    >>> cos(x**2).diff(x)\n", "    -2*x*sin(x**2)\n", "    >>> cos(1).diff(x)\n", "    0\n", "    >>> cos(pi)\n", "    -1\n", "    >>> cos(pi/2)\n", "    0\n", "    >>> cos(2*pi/3)\n", "    -1/2\n", "    >>> cos(pi/12)\n", "    sqrt(2)/4 + sqrt(6)/4\n", "\n", "    See Also\n", "    ========\n", "\n", "    sin, csc, sec, tan, cot\n", "    asin, acsc, acos, asec, atan, acot, atan2\n", "\n", "    References\n", "    ==========\n", "\n", "    .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions\n", "    .. [2] http://dlmf.nist.gov/4.14\n", "    .. [3] http://functions.wolfram.com/ElementaryFunctions/Cos\n", "    \"\"\"\n"]}, {"span_id": "sin.eval", "start_line": 256, "end_line": 365, "content": ["    @classmethod\n", "    def eval(cls, arg):\n", "        from sympy.calculus import AccumBounds\n", "        from sympy.sets.setexpr import SetExpr\n", "        if arg.is_Number:\n", "            if arg is S.NaN:\n", "                return S.NaN\n", "            elif arg is S.Zero:\n", "                return S.Zero\n", "            elif arg is S.Infinity or arg is S.NegativeInfinity:\n", "                return AccumBounds(-1, 1)\n", "\n", "        if arg is S.ComplexInfinity:\n", "            return S.NaN\n", "\n", "        if isinstance(arg, AccumBounds):\n", "            min, max = arg.min, arg.max\n", "            d = floor(min/(2*S.Pi))\n", "            if min is not S.NegativeInfinity:\n", "                min = min - d*2*S.Pi\n", "            if max is not S.Infinity:\n", "                max = max - d*2*S.Pi\n", "            if AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 5*S.Pi/2)) \\\n", "                    is not S.EmptySet and \\\n", "                    AccumBounds(min, max).intersection(FiniteSet(3*S.Pi/2,\n", "                        7*S.Pi/2)) is not S.EmptySet:\n", "                return AccumBounds(-1, 1)\n", "            elif AccumBounds(min, max).intersection(FiniteSet(S.Pi/2, 5*S.Pi/2)) \\\n", "                    is not S.EmptySet:\n", "                return AccumBounds(Min(sin(min), sin(max)), 1)\n", "            elif AccumBounds(min, max).intersection(FiniteSet(3*S.Pi/2, 8*S.Pi/2)) \\\n", "                        is not S.EmptySet:\n", "                return AccumBounds(-1, Max(sin(min), sin(max)))\n", "            else:\n", "                return AccumBounds(Min(sin(min), sin(max)),\n", "                                Max(sin(min), sin(max)))\n", "        elif isinstance(arg, SetExpr):\n", "            return arg._eval_func(cls)\n", "\n", "        if arg.could_extract_minus_sign():\n", "            return -cls(-arg)\n", "\n", "        i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n", "        if i_coeff is not None:\n", "            return S.ImaginaryUnit * sinh(i_coeff)\n", "\n", "        pi_coeff = _pi_coeff(arg)\n", "        if pi_coeff is not None:\n", "            if pi_coeff.is_integer:\n", "                return S.Zero\n", "\n", "            if (2*pi_coeff).is_integer:\n", "                if pi_coeff.is_even:\n", "                    return S.Zero\n", "                elif pi_coeff.is_even is False:\n", "                    return S.NegativeOne**(pi_coeff - S.Half)\n", "\n", "            if not pi_coeff.is_Rational:\n", "                narg = pi_coeff*S.Pi\n", "                if narg != arg:\n", "                    return cls(narg)\n", "                return None\n", "\n", "            # https://github.com/sympy/sympy/issues/6048\n", "            # transform a sine to a cosine, to avoid redundant code\n", "            if pi_coeff.is_Rational:\n", "                x = pi_coeff % 2\n", "                if x > 1:\n", "                    return -cls((x % 1)*S.Pi)\n", "                if 2*x > 1:\n", "                    return cls((1 - x)*S.Pi)\n", "                narg = ((pi_coeff + Rational(3, 2)) % 2)*S.Pi\n", "                result = cos(narg)\n", "                if not isinstance(result, cos):\n", "                    return result\n", "                if pi_coeff*S.Pi != arg:\n", "                    return cls(pi_coeff*S.Pi)\n", "                return None\n", "\n", "        if arg.is_Add:\n", "            x, m = _peeloff_pi(arg)\n", "            if m:\n", "                return sin(m)*cos(x) + cos(m)*sin(x)\n", "\n", "        if isinstance(arg, asin):\n", "            return arg.args[0]\n", "\n", "        if isinstance(arg, atan):\n", "            x = arg.args[0]\n", "            return x / sqrt(1 + x**2)\n", "\n", "        if isinstance(arg, atan2):\n", "            y, x = arg.args\n", "            return y / sqrt(x**2 + y**2)\n", "\n", "        if isinstance(arg, acos):\n", "            x = arg.args[0]\n", "            return sqrt(1 - x**2)\n", "\n", "        if isinstance(arg, acot):\n", "            x = arg.args[0]\n", "            return 1 / (sqrt(1 + 1 / x**2) * x)\n", "\n", "        if isinstance(arg, acsc):\n", "            x = arg.args[0]\n", "            return 1 / x\n", "\n", "        if isinstance(arg, asec):\n", "            x = arg.args[0]\n", "            return sqrt(1 - 1 / x**2)\n"]}, {"span_id": "sin", "start_line": 200, "end_line": 245, "content": ["class sin(TrigonometricFunction):\n", "    \"\"\"\n", "    The sine function.\n", "\n", "    Returns the sine of x (measured in radians).\n", "\n", "    Notes\n", "    =====\n", "\n", "    This function will evaluate automatically in the\n", "    case x/pi is some rational number [4]_.  For example,\n", "    if x is a multiple of pi, pi/2, pi/3, pi/4 and pi/6.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import sin, pi\n", "    >>> from sympy.abc import x\n", "    >>> sin(x**2).diff(x)\n", "    2*x*cos(x**2)\n", "    >>> sin(1).diff(x)\n", "    0\n", "    >>> sin(pi)\n", "    0\n", "    >>> sin(pi/2)\n", "    1\n", "    >>> sin(pi/6)\n", "    1/2\n", "    >>> sin(pi/12)\n", "    -sqrt(2)/4 + sqrt(6)/4\n", "\n", "\n", "    See Also\n", "    ========\n", "\n", "    csc, cos, sec, tan, cot\n", "    asin, acsc, acos, asec, atan, acot, atan2\n", "\n", "    References\n", "    ==========\n", "\n", "    .. [1] http://en.wikipedia.org/wiki/Trigonometric_functions\n", "    .. [2] http://dlmf.nist.gov/4.14\n", "    .. [3] http://functions.wolfram.com/ElementaryFunctions/Sin\n", "    .. [4] http://mathworld.wolfram.com/TrigonometryAngles.html\n", "    \"\"\"\n"]}]}, {"file_path": "sympy/simplify/simplify.py", "span_ids": ["simplify"], "content": [{"span_id": "simplify", "start_line": 385, "end_line": 644, "content": ["def simplify(expr, ratio=1.7, measure=count_ops, rational=False, inverse=False):\n", "    \"\"\"Simplifies the given expression.\n", "\n", "    Simplification is not a well defined term and the exact strategies\n", "    this function tries can change in the future versions of SymPy. If\n", "    your algorithm relies on \"simplification\" (whatever it is), try to\n", "    determine what you need exactly  -  is it powsimp()?, radsimp()?,\n", "    together()?, logcombine()?, or something else? And use this particular\n", "    function directly, because those are well defined and thus your algorithm\n", "    will be robust.\n", "\n", "    Nonetheless, especially for interactive use, or when you don't know\n", "    anything about the structure of the expression, simplify() tries to apply\n", "    intelligent heuristics to make the input expression \"simpler\".  For\n", "    example:\n", "\n", "    >>> from sympy import simplify, cos, sin\n", "    >>> from sympy.abc import x, y\n", "    >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n", "    >>> a\n", "    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n", "    >>> simplify(a)\n", "    x + 1\n", "\n", "    Note that we could have obtained the same result by using specific\n", "    simplification functions:\n", "\n", "    >>> from sympy import trigsimp, cancel\n", "    >>> trigsimp(a)\n", "    (x**2 + x)/x\n", "    >>> cancel(_)\n", "    x + 1\n", "\n", "    In some cases, applying :func:`simplify` may actually result in some more\n", "    complicated expression. The default ``ratio=1.7`` prevents more extreme\n", "    cases: if (result length)/(input length) > ratio, then input is returned\n", "    unmodified.  The ``measure`` parameter lets you specify the function used\n", "    to determine how complex an expression is.  The function should take a\n", "    single argument as an expression and return a number such that if\n", "    expression ``a`` is more complex than expression ``b``, then\n", "    ``measure(a) > measure(b)``.  The default measure function is\n", "    :func:`count_ops`, which returns the total number of operations in the\n", "    expression.\n", "\n", "    For example, if ``ratio=1``, ``simplify`` output can't be longer\n", "    than input.\n", "\n", "    ::\n", "\n", "        >>> from sympy import sqrt, simplify, count_ops, oo\n", "        >>> root = 1/(sqrt(2)+3)\n", "\n", "    Since ``simplify(root)`` would result in a slightly longer expression,\n", "    root is returned unchanged instead::\n", "\n", "       >>> simplify(root, ratio=1) == root\n", "       True\n", "\n", "    If ``ratio=oo``, simplify will be applied anyway::\n", "\n", "        >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n", "        True\n", "\n", "    Note that the shortest expression is not necessary the simplest, so\n", "    setting ``ratio`` to 1 may not be a good idea.\n", "    Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n", "    choice.\n", "\n", "    You can easily define your own measure function based on what you feel\n", "    should represent the \"size\" or \"complexity\" of the input expression.  Note\n", "    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n", "    good metrics, but have other problems (in this case, the measure function\n", "    may slow down simplify too much for very large expressions).  If you don't\n", "    know what a good metric would be, the default, ``count_ops``, is a good\n", "    one.\n", "\n", "    For example:\n", "\n", "    >>> from sympy import symbols, log\n", "    >>> a, b = symbols('a b', positive=True)\n", "    >>> g = log(a) + log(b) + log(a)*log(1/b)\n", "    >>> h = simplify(g)\n", "    >>> h\n", "    log(a*b**(-log(a) + 1))\n", "    >>> count_ops(g)\n", "    8\n", "    >>> count_ops(h)\n", "    5\n", "\n", "    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n", "    However, we may not like how ``simplify`` (in this case, using\n", "    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n", "    to reduce this would be to give more weight to powers as operations in\n", "    ``count_ops``.  We can do this by using the ``visual=True`` option:\n", "\n", "    >>> print(count_ops(g, visual=True))\n", "    2*ADD + DIV + 4*LOG + MUL\n", "    >>> print(count_ops(h, visual=True))\n", "    2*LOG + MUL + POW + SUB\n", "\n", "    >>> from sympy import Symbol, S\n", "    >>> def my_measure(expr):\n", "    ...     POW = Symbol('POW')\n", "    ...     # Discourage powers by giving POW a weight of 10\n", "    ...     count = count_ops(expr, visual=True).subs(POW, 10)\n", "    ...     # Every other operation gets a weight of 1 (the default)\n", "    ...     count = count.replace(Symbol, type(S.One))\n", "    ...     return count\n", "    >>> my_measure(g)\n", "    8\n", "    >>> my_measure(h)\n", "    14\n", "    >>> 15./8 > 1.7 # 1.7 is the default ratio\n", "    True\n", "    >>> simplify(g, measure=my_measure)\n", "    -log(a)*log(b) + log(a) + log(b)\n", "\n", "    Note that because ``simplify()`` internally tries many different\n", "    simplification strategies and then compares them using the measure\n", "    function, we get a completely different result that is still different\n", "    from the input expression by doing this.\n", "\n", "    If rational=True, Floats will be recast as Rationals before simplification.\n", "    If rational=None, Floats will be recast as Rationals but the result will\n", "    be recast as Floats. If rational=False(default) then nothing will be done\n", "    to the Floats.\n", "\n", "    If inverse=True, it will be assumed that a composition of inverse\n", "    functions, such as sin and asin, can be cancelled in any order.\n", "    For example, ``asin(sin(x))`` will yield ``x`` without checking whether\n", "    x belongs to the set where this relation is true. The default is\n", "    False.\n", "    \"\"\"\n", "    expr = sympify(expr)\n", "\n", "    try:\n", "        return expr._eval_simplify(ratio=ratio, measure=measure, rational=rational, inverse=inverse)\n", "    except AttributeError:\n", "        pass\n", "\n", "    original_expr = expr = signsimp(expr)\n", "\n", "    from sympy.simplify.hyperexpand import hyperexpand\n", "    from sympy.functions.special.bessel import BesselBase\n", "    from sympy import Sum, Product\n", "\n", "    if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n", "        return expr\n", "\n", "    if inverse and expr.has(Function):\n", "        expr = inversecombine(expr)\n", "        if not expr.args:  # simplified to atomic\n", "            return expr\n", "\n", "    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n", "        return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational, inverse=inverse)\n", "                         for x in expr.args])\n", "\n", "    if not expr.is_commutative:\n", "        expr = nc_simplify(expr)\n", "\n", "    # TODO: Apply different strategies, considering expression pattern:\n", "    # is it a purely rational function? Is there any trigonometric function?...\n", "    # See also https://github.com/sympy/sympy/pull/185.\n", "\n", "    def shorter(*choices):\n", "        '''Return the choice that has the fewest ops. In case of a tie,\n", "        the expression listed first is selected.'''\n", "        if not has_variety(choices):\n", "            return choices[0]\n", "        return min(choices, key=measure)\n", "\n", "    # rationalize Floats\n", "    floats = False\n", "    if rational is not False and expr.has(Float):\n", "        floats = True\n", "        expr = nsimplify(expr, rational=True)\n", "\n", "    expr = bottom_up(expr, lambda w: w.normal())\n", "    expr = Mul(*powsimp(expr).as_content_primitive())\n", "    _e = cancel(expr)\n", "    expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n", "    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n", "\n", "    if ratio is S.Infinity:\n", "        expr = expr2\n", "    else:\n", "        expr = shorter(expr2, expr1, expr)\n", "    if not isinstance(expr, Basic):  # XXX: temporary hack\n", "        return expr\n", "\n", "    expr = factor_terms(expr, sign=False)\n", "\n", "    # hyperexpand automatically only works on hypergeometric terms\n", "    expr = hyperexpand(expr)\n", "\n", "    expr = piecewise_fold(expr)\n", "\n", "    if expr.has(BesselBase):\n", "        expr = besselsimp(expr)\n", "\n", "    if expr.has(TrigonometricFunction, HyperbolicFunction):\n", "        expr = trigsimp(expr, deep=True)\n", "\n", "    if expr.has(log):\n", "        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n", "\n", "    if expr.has(CombinatorialFunction, gamma):\n", "        # expression with gamma functions or non-integer arguments is\n", "        # automatically passed to gammasimp\n", "        expr = combsimp(expr)\n", "\n", "    if expr.has(Sum):\n", "        expr = sum_simplify(expr)\n", "\n", "    if expr.has(Product):\n", "        expr = product_simplify(expr)\n", "\n", "    from sympy.physics.units import Quantity\n", "    from sympy.physics.units.util import quantity_simplify\n", "\n", "    if expr.has(Quantity):\n", "        expr = quantity_simplify(expr)\n", "\n", "    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n", "    short = shorter(short, cancel(short))\n", "    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n", "    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n", "        short = exptrigsimp(short)\n", "\n", "    # get rid of hollow 2-arg Mul factorization\n", "    hollow_mul = Transform(\n", "        lambda x: Mul(*x.args),\n", "        lambda x:\n", "        x.is_Mul and\n", "        len(x.args) == 2 and\n", "        x.args[0].is_Number and\n", "        x.args[1].is_Add and\n", "        x.is_commutative)\n", "    expr = short.xreplace(hollow_mul)\n", "\n", "    numer, denom = expr.as_numer_denom()\n", "    if denom.is_Add:\n", "        n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n", "        if n is not S.One:\n", "            expr = (numer*n).expand()/d\n", "\n", "    if expr.could_extract_minus_sign():\n", "        n, d = fraction(expr)\n", "        if d != 0:\n", "            expr = signsimp(-n/(-d))\n", "\n", "    if measure(expr) > ratio*measure(original_expr):\n", "        expr = original_expr\n", "\n", "    # restore floats\n", "    if floats and rational is None:\n", "        expr = nfloat(expr, exponent=False)\n", "\n", "    return expr\n"]}]}, {"file_path": "sympy/simplify/trigsimp.py", "span_ids": ["trigsimp_old", "__trigsimp"], "content": [{"span_id": "trigsimp_old", "start_line": 606, "end_line": 738, "content": ["def trigsimp_old(expr, **opts):\n", "    \"\"\"\n", "    reduces expression by using known trig identities\n", "\n", "    Notes\n", "    =====\n", "\n", "    deep:\n", "    - Apply trigsimp inside all objects with arguments\n", "\n", "    recursive:\n", "    - Use common subexpression elimination (cse()) and apply\n", "    trigsimp recursively (this is quite expensive if the\n", "    expression is large)\n", "\n", "    method:\n", "    - Determine the method to use. Valid choices are 'matching' (default),\n", "    'groebner', 'combined', 'fu' and 'futrig'. If 'matching', simplify the\n", "    expression recursively by pattern matching. If 'groebner', apply an\n", "    experimental groebner basis algorithm. In this case further options\n", "    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n", "    If 'combined', first run the groebner basis algorithm with small\n", "    default parameters, then run the 'matching' algorithm. 'fu' runs the\n", "    collection of trigonometric transformations described by Fu, et al.\n", "    (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms\n", "    that mimic the behavior of `trigsimp`.\n", "\n", "    compare:\n", "    - show input and output from `trigsimp` and `futrig` when different,\n", "    but returns the `trigsimp` value.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot\n", "    >>> from sympy.abc import x, y\n", "    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n", "    >>> trigsimp(e, old=True)\n", "    2\n", "    >>> trigsimp(log(e), old=True)\n", "    log(2*sin(x)**2 + 2*cos(x)**2)\n", "    >>> trigsimp(log(e), deep=True, old=True)\n", "    log(2)\n", "\n", "    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n", "    more simplification:\n", "\n", "    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n", "    >>> trigsimp(e, old=True)\n", "    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n", "    >>> trigsimp(e, method=\"groebner\", old=True)\n", "    2/cos(x)\n", "\n", "    >>> trigsimp(1/cot(x)**2, compare=True, old=True)\n", "          futrig: tan(x)**2\n", "    cot(x)**(-2)\n", "\n", "    \"\"\"\n", "    old = expr\n", "    first = opts.pop('first', True)\n", "    if first:\n", "        if not expr.has(*_trigs):\n", "            return expr\n", "\n", "        trigsyms = set().union(*[t.free_symbols for t in expr.atoms(*_trigs)])\n", "        if len(trigsyms) > 1:\n", "            d = separatevars(expr)\n", "            if d.is_Mul:\n", "                d = separatevars(d, dict=True) or d\n", "            if isinstance(d, dict):\n", "                expr = 1\n", "                for k, v in d.items():\n", "                    # remove hollow factoring\n", "                    was = v\n", "                    v = expand_mul(v)\n", "                    opts['first'] = False\n", "                    vnew = trigsimp(v, **opts)\n", "                    if vnew == v:\n", "                        vnew = was\n", "                    expr *= vnew\n", "                old = expr\n", "            else:\n", "                if d.is_Add:\n", "                    for s in trigsyms:\n", "                        r, e = expr.as_independent(s)\n", "                        if r:\n", "                            opts['first'] = False\n", "                            expr = r + trigsimp(e, **opts)\n", "                            if not expr.is_Add:\n", "                                break\n", "                    old = expr\n", "\n", "    recursive = opts.pop('recursive', False)\n", "    deep = opts.pop('deep', False)\n", "    method = opts.pop('method', 'matching')\n", "\n", "    def groebnersimp(ex, deep, **opts):\n", "        def traverse(e):\n", "            if e.is_Atom:\n", "                return e\n", "            args = [traverse(x) for x in e.args]\n", "            if e.is_Function or e.is_Pow:\n", "                args = [trigsimp_groebner(x, **opts) for x in args]\n", "            return e.func(*args)\n", "        if deep:\n", "            ex = traverse(ex)\n", "        return trigsimp_groebner(ex, **opts)\n", "\n", "    trigsimpfunc = {\n", "        'matching': (lambda x, d: _trigsimp(x, d)),\n", "        'groebner': (lambda x, d: groebnersimp(x, d, **opts)),\n", "        'combined': (lambda x, d: _trigsimp(groebnersimp(x,\n", "                                       d, polynomial=True, hints=[2, tan]),\n", "                                   d))\n", "                   }[method]\n", "\n", "    if recursive:\n", "        w, g = cse(expr)\n", "        g = trigsimpfunc(g[0], deep)\n", "\n", "        for sub in reversed(w):\n", "            g = g.subs(sub[0], sub[1])\n", "            g = trigsimpfunc(g, deep)\n", "        result = g\n", "    else:\n", "        result = trigsimpfunc(expr, deep)\n", "\n", "    if opts.get('compare', False):\n", "        f = futrig(old)\n", "        if f != result:\n", "            print('\\tfutrig:', f)\n", "\n", "    return result\n"]}, {"span_id": "__trigsimp", "start_line": 935, "end_line": 1062, "content": ["@cacheit\n", "def __trigsimp(expr, deep=False):\n", "    \"\"\"recursive helper for trigsimp\"\"\"\n", "    from sympy.simplify.fu import TR10i\n", "\n", "    if _trigpat is None:\n", "        _trigpats()\n", "    a, b, c, d, matchers_division, matchers_add, \\\n", "    matchers_identity, artifacts = _trigpat\n", "\n", "    if expr.is_Mul:\n", "        # do some simplifications like sin/cos -> tan:\n", "        if not expr.is_commutative:\n", "            com, nc = expr.args_cnc()\n", "            expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)\n", "        else:\n", "            for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):\n", "                if not _dotrig(expr, pattern):\n", "                    continue\n", "\n", "                newexpr = _match_div_rewrite(expr, i)\n", "                if newexpr is not None:\n", "                    if newexpr != expr:\n", "                        expr = newexpr\n", "                        break\n", "                    else:\n", "                        continue\n", "\n", "                # use SymPy matching instead\n", "                res = expr.match(pattern)\n", "                if res and res.get(c, 0):\n", "                    if not res[c].is_integer:\n", "                        ok = ok1.subs(res)\n", "                        if not ok.is_positive:\n", "                            continue\n", "                        ok = ok2.subs(res)\n", "                        if not ok.is_positive:\n", "                            continue\n", "                    # if \"a\" contains any of trig or hyperbolic funcs with\n", "                    # argument \"b\" then skip the simplification\n", "                    if any(w.args[0] == res[b] for w in res[a].atoms(\n", "                            TrigonometricFunction, HyperbolicFunction)):\n", "                        continue\n", "                    # simplify and finish:\n", "                    expr = simp.subs(res)\n", "                    break  # process below\n", "\n", "    if expr.is_Add:\n", "        args = []\n", "        for term in expr.args:\n", "            if not term.is_commutative:\n", "                com, nc = term.args_cnc()\n", "                nc = Mul._from_args(nc)\n", "                term = Mul._from_args(com)\n", "            else:\n", "                nc = S.One\n", "            term = _trigsimp(term, deep)\n", "            for pattern, result in matchers_identity:\n", "                res = term.match(pattern)\n", "                if res is not None:\n", "                    term = result.subs(res)\n", "                    break\n", "            args.append(term*nc)\n", "        if args != expr.args:\n", "            expr = Add(*args)\n", "            expr = min(expr, expand(expr), key=count_ops)\n", "        if expr.is_Add:\n", "            for pattern, result in matchers_add:\n", "                if not _dotrig(expr, pattern):\n", "                    continue\n", "                expr = TR10i(expr)\n", "                if expr.has(HyperbolicFunction):\n", "                    res = expr.match(pattern)\n", "                    # if \"d\" contains any trig or hyperbolic funcs with\n", "                    # argument \"a\" or \"b\" then skip the simplification;\n", "                    # this isn't perfect -- see tests\n", "                    if res is None or not (a in res and b in res) or any(\n", "                        w.args[0] in (res[a], res[b]) for w in res[d].atoms(\n", "                            TrigonometricFunction, HyperbolicFunction)):\n", "                        continue\n", "                    expr = result.subs(res)\n", "                    break\n", "\n", "        # Reduce any lingering artifacts, such as sin(x)**2 changing\n", "        # to 1 - cos(x)**2 when sin(x)**2 was \"simpler\"\n", "        for pattern, result, ex in artifacts:\n", "            if not _dotrig(expr, pattern):\n", "                continue\n", "            # Substitute a new wild that excludes some function(s)\n", "            # to help influence a better match. This is because\n", "            # sometimes, for example, 'a' would match sec(x)**2\n", "            a_t = Wild('a', exclude=[ex])\n", "            pattern = pattern.subs(a, a_t)\n", "            result = result.subs(a, a_t)\n", "\n", "            m = expr.match(pattern)\n", "            was = None\n", "            while m and was != expr:\n", "                was = expr\n", "                if m[a_t] == 0 or \\\n", "                        -m[a_t] in m[c].args or m[a_t] + m[c] == 0:\n", "                    break\n", "                if d in m and m[a_t]*m[d] + m[c] == 0:\n", "                    break\n", "                expr = result.subs(m)\n", "                m = expr.match(pattern)\n", "                m.setdefault(c, S.Zero)\n", "\n", "    elif expr.is_Mul or expr.is_Pow or deep and expr.args:\n", "        expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])\n", "\n", "    try:\n", "        if not expr.has(*_trigs):\n", "            raise TypeError\n", "        e = expr.atoms(exp)\n", "        new = expr.rewrite(exp, deep=deep)\n", "        if new == e:\n", "            raise TypeError\n", "        fnew = factor(new)\n", "        if fnew != new:\n", "            new = sorted([new, factor(new)], key=count_ops)[0]\n", "        # if all exp that were introduced disappeared then accept it\n", "        if not (new.atoms(exp) - e):\n", "            expr = new\n", "    except TypeError:\n", "        pass\n", "\n", "    return expr\n"]}]}]}