{"instance_id": "django__django-11422", "identified_spans": [{"file_path": "django/core/management/commands/runserver.py", "span_ids": ["Command.run"], "content": [{"span_id": "Command.run", "start_line": 97, "end_line": 104, "content": ["    def run(self, **options):\n", "        \"\"\"Run the server, using the autoreloader if needed.\"\"\"\n", "        use_reloader = options['use_reloader']\n", "\n", "        if use_reloader:\n", "            autoreload.run_with_reloader(self.inner_run, **options)\n", "        else:\n", "            self.inner_run(None, **options)\n"]}]}, {"file_path": "django/utils/autoreload.py", "span_ids": ["StatReloader", "StatReloader.tick", "StatReloader.snapshot_files", "run_with_reloader", "get_reloader"], "content": [{"span_id": "StatReloader", "start_line": 323, "end_line": 324, "content": ["class StatReloader(BaseReloader):\n", "    SLEEP_TIME = 1  # Check for changes once per second.\n"]}, {"span_id": "StatReloader.tick", "start_line": 326, "end_line": 340, "content": ["    def tick(self):\n", "        mtimes = {}\n", "        while True:\n", "            for filepath, mtime in self.snapshot_files():\n", "                old_time = mtimes.get(filepath)\n", "                if old_time is None:\n", "                    logger.debug('File %s first seen with mtime %s', filepath, mtime)\n", "                    mtimes[filepath] = mtime\n", "                    continue\n", "                elif mtime > old_time:\n", "                    logger.debug('File %s previous mtime: %s, current mtime: %s', filepath, old_time, mtime)\n", "                    self.notify_file_changed(filepath)\n", "\n", "            time.sleep(self.SLEEP_TIME)\n", "            yield\n"]}, {"span_id": "StatReloader.snapshot_files", "start_line": 342, "end_line": 354, "content": ["    def snapshot_files(self):\n", "        # watched_files may produce duplicate paths if globs overlap.\n", "        seen_files = set()\n", "        for file in self.watched_files():\n", "            if file in seen_files:\n", "                continue\n", "            try:\n", "                mtime = file.stat().st_mtime\n", "            except OSError:\n", "                # This is thrown when the file does not exist.\n", "                continue\n", "            seen_files.add(file)\n", "            yield file, mtime\n"]}, {"span_id": "run_with_reloader", "start_line": 577, "end_line": 588, "content": ["def run_with_reloader(main_func, *args, **kwargs):\n", "    signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n", "    try:\n", "        if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n", "            reloader = get_reloader()\n", "            logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n", "            start_django(reloader, main_func, *args, **kwargs)\n", "        else:\n", "            exit_code = restart_with_reloader()\n", "            sys.exit(exit_code)\n", "    except KeyboardInterrupt:\n", "        pass\n"]}, {"span_id": "get_reloader", "start_line": 549, "end_line": 555, "content": ["def get_reloader():\n", "    \"\"\"Return the most suitable reloader for this environment.\"\"\"\n", "    try:\n", "        WatchmanReloader.check_availability()\n", "    except WatchmanUnavailable:\n", "        return StatReloader()\n", "    return WatchmanReloader()\n"]}]}]}