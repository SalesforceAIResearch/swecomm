{"instance_id": "django__django-16595", "identified_spans": [{"file_path": "django/db/migrations/autodetector.py", "span_ids": ["MigrationAutodetector", "MigrationAutodetector.generate_altered_fields", "MigrationAutodetector._detect_changes"], "content": [{"span_id": "MigrationAutodetector", "start_line": 21, "end_line": 32, "content": ["class MigrationAutodetector:\n", "    \"\"\"\n", "    Take a pair of ProjectStates and compare them to see what the first would\n", "    need doing to make it match the second (the second usually being the\n", "    project's current state).\n", "\n", "    Note that this naturally operates on entire projects at a time,\n", "    as it's likely that changes interact (for example, you can't\n", "    add a ForeignKey without having a migration to add the table it\n", "    depends on first). A user interface may offer single-app usage\n", "    if it wishes, with the caveat that it may not always be possible.\n", "    \"\"\"\n"]}, {"span_id": "MigrationAutodetector.generate_altered_fields", "start_line": 1097, "end_line": 1214, "content": ["    def generate_altered_fields(self):\n", "        \"\"\"\n", "        Make AlterField operations, or possibly RemovedField/AddField if alter\n", "        isn't possible.\n", "        \"\"\"\n", "        for app_label, model_name, field_name in sorted(\n", "            self.old_field_keys & self.new_field_keys\n", "        ):\n", "            # Did the field change?\n", "            old_model_name = self.renamed_models.get(\n", "                (app_label, model_name), model_name\n", "            )\n", "            old_field_name = self.renamed_fields.get(\n", "                (app_label, model_name, field_name), field_name\n", "            )\n", "            old_field = self.from_state.models[app_label, old_model_name].get_field(\n", "                old_field_name\n", "            )\n", "            new_field = self.to_state.models[app_label, model_name].get_field(\n", "                field_name\n", "            )\n", "            dependencies = []\n", "            # Implement any model renames on relations; these are handled by RenameModel\n", "            # so we need to exclude them from the comparison\n", "            if hasattr(new_field, \"remote_field\") and getattr(\n", "                new_field.remote_field, \"model\", None\n", "            ):\n", "                rename_key = resolve_relation(\n", "                    new_field.remote_field.model, app_label, model_name\n", "                )\n", "                if rename_key in self.renamed_models:\n", "                    new_field.remote_field.model = old_field.remote_field.model\n", "                # Handle ForeignKey which can only have a single to_field.\n", "                remote_field_name = getattr(new_field.remote_field, \"field_name\", None)\n", "                if remote_field_name:\n", "                    to_field_rename_key = rename_key + (remote_field_name,)\n", "                    if to_field_rename_key in self.renamed_fields:\n", "                        # Repoint both model and field name because to_field\n", "                        # inclusion in ForeignKey.deconstruct() is based on\n", "                        # both.\n", "                        new_field.remote_field.model = old_field.remote_field.model\n", "                        new_field.remote_field.field_name = (\n", "                            old_field.remote_field.field_name\n", "                        )\n", "                # Handle ForeignObjects which can have multiple from_fields/to_fields.\n", "                from_fields = getattr(new_field, \"from_fields\", None)\n", "                if from_fields:\n", "                    from_rename_key = (app_label, model_name)\n", "                    new_field.from_fields = tuple(\n", "                        [\n", "                            self.renamed_fields.get(\n", "                                from_rename_key + (from_field,), from_field\n", "                            )\n", "                            for from_field in from_fields\n", "                        ]\n", "                    )\n", "                    new_field.to_fields = tuple(\n", "                        [\n", "                            self.renamed_fields.get(rename_key + (to_field,), to_field)\n", "                            for to_field in new_field.to_fields\n", "                        ]\n", "                    )\n", "                dependencies.extend(\n", "                    self._get_dependencies_for_foreign_key(\n", "                        app_label,\n", "                        model_name,\n", "                        new_field,\n", "                        self.to_state,\n", "                    )\n", "                )\n", "            if hasattr(new_field, \"remote_field\") and getattr(\n", "                new_field.remote_field, \"through\", None\n", "            ):\n", "                rename_key = resolve_relation(\n", "                    new_field.remote_field.through, app_label, model_name\n", "                )\n", "                if rename_key in self.renamed_models:\n", "                    new_field.remote_field.through = old_field.remote_field.through\n", "            old_field_dec = self.deep_deconstruct(old_field)\n", "            new_field_dec = self.deep_deconstruct(new_field)\n", "            # If the field was confirmed to be renamed it means that only\n", "            # db_column was allowed to change which generate_renamed_fields()\n", "            # already accounts for by adding an AlterField operation.\n", "            if old_field_dec != new_field_dec and old_field_name == field_name:\n", "                both_m2m = old_field.many_to_many and new_field.many_to_many\n", "                neither_m2m = not old_field.many_to_many and not new_field.many_to_many\n", "                if both_m2m or neither_m2m:\n", "                    # Either both fields are m2m or neither is\n", "                    preserve_default = True\n", "                    if (\n", "                        old_field.null\n", "                        and not new_field.null\n", "                        and not new_field.has_default()\n", "                        and not new_field.many_to_many\n", "                    ):\n", "                        field = new_field.clone()\n", "                        new_default = self.questioner.ask_not_null_alteration(\n", "                            field_name, model_name\n", "                        )\n", "                        if new_default is not models.NOT_PROVIDED:\n", "                            field.default = new_default\n", "                            preserve_default = False\n", "                    else:\n", "                        field = new_field\n", "                    self.add_operation(\n", "                        app_label,\n", "                        operations.AlterField(\n", "                            model_name=model_name,\n", "                            name=field_name,\n", "                            field=field,\n", "                            preserve_default=preserve_default,\n", "                        ),\n", "                        dependencies=dependencies,\n", "                    )\n", "                else:\n", "                    # We cannot alter between m2m and concrete fields\n", "                    self._generate_removed_field(app_label, model_name, field_name)\n", "                    self._generate_added_field(app_label, model_name, field_name)\n"]}, {"span_id": "MigrationAutodetector._detect_changes", "start_line": 104, "end_line": 209, "content": ["    def _detect_changes(self, convert_apps=None, graph=None):\n", "        \"\"\"\n", "        Return a dict of migration plans which will achieve the\n", "        change from from_state to to_state. The dict has app labels\n", "        as keys and a list of migrations as values.\n", "\n", "        The resulting migrations aren't specially named, but the names\n", "        do matter for dependencies inside the set.\n", "\n", "        convert_apps is the list of apps to convert to use migrations\n", "        (i.e. to make initial migrations for, in the usual case)\n", "\n", "        graph is an optional argument that, if provided, can help improve\n", "        dependency generation and avoid potential circular dependencies.\n", "        \"\"\"\n", "        # The first phase is generating all the operations for each app\n", "        # and gathering them into a big per-app list.\n", "        # Then go through that list, order it, and split into migrations to\n", "        # resolve dependencies caused by M2Ms and FKs.\n", "        self.generated_operations = {}\n", "        self.altered_indexes = {}\n", "        self.altered_constraints = {}\n", "        self.renamed_fields = {}\n", "\n", "        # Prepare some old/new state and model lists, separating\n", "        # proxy models and ignoring unmigrated apps.\n", "        self.old_model_keys = set()\n", "        self.old_proxy_keys = set()\n", "        self.old_unmanaged_keys = set()\n", "        self.new_model_keys = set()\n", "        self.new_proxy_keys = set()\n", "        self.new_unmanaged_keys = set()\n", "        for (app_label, model_name), model_state in self.from_state.models.items():\n", "            if not model_state.options.get(\"managed\", True):\n", "                self.old_unmanaged_keys.add((app_label, model_name))\n", "            elif app_label not in self.from_state.real_apps:\n", "                if model_state.options.get(\"proxy\"):\n", "                    self.old_proxy_keys.add((app_label, model_name))\n", "                else:\n", "                    self.old_model_keys.add((app_label, model_name))\n", "\n", "        for (app_label, model_name), model_state in self.to_state.models.items():\n", "            if not model_state.options.get(\"managed\", True):\n", "                self.new_unmanaged_keys.add((app_label, model_name))\n", "            elif app_label not in self.from_state.real_apps or (\n", "                convert_apps and app_label in convert_apps\n", "            ):\n", "                if model_state.options.get(\"proxy\"):\n", "                    self.new_proxy_keys.add((app_label, model_name))\n", "                else:\n", "                    self.new_model_keys.add((app_label, model_name))\n", "\n", "        self.from_state.resolve_fields_and_relations()\n", "        self.to_state.resolve_fields_and_relations()\n", "\n", "        # Renames have to come first\n", "        self.generate_renamed_models()\n", "\n", "        # Prepare lists of fields and generate through model map\n", "        self._prepare_field_lists()\n", "        self._generate_through_model_map()\n", "\n", "        # Generate non-rename model operations\n", "        self.generate_deleted_models()\n", "        self.generate_created_models()\n", "        self.generate_deleted_proxies()\n", "        self.generate_created_proxies()\n", "        self.generate_altered_options()\n", "        self.generate_altered_managers()\n", "        self.generate_altered_db_table_comment()\n", "\n", "        # Create the renamed fields and store them in self.renamed_fields.\n", "        # They are used by create_altered_indexes(), generate_altered_fields(),\n", "        # generate_removed_altered_index/unique_together(), and\n", "        # generate_altered_index/unique_together().\n", "        self.create_renamed_fields()\n", "        # Create the altered indexes and store them in self.altered_indexes.\n", "        # This avoids the same computation in generate_removed_indexes()\n", "        # and generate_added_indexes().\n", "        self.create_altered_indexes()\n", "        self.create_altered_constraints()\n", "        # Generate index removal operations before field is removed\n", "        self.generate_removed_constraints()\n", "        self.generate_removed_indexes()\n", "        # Generate field renaming operations.\n", "        self.generate_renamed_fields()\n", "        self.generate_renamed_indexes()\n", "        # Generate removal of foo together.\n", "        self.generate_removed_altered_unique_together()\n", "        self.generate_removed_altered_index_together()  # RemovedInDjango51Warning.\n", "        # Generate field operations.\n", "        self.generate_removed_fields()\n", "        self.generate_added_fields()\n", "        self.generate_altered_fields()\n", "        self.generate_altered_order_with_respect_to()\n", "        self.generate_altered_unique_together()\n", "        self.generate_altered_index_together()  # RemovedInDjango51Warning.\n", "        self.generate_added_indexes()\n", "        self.generate_added_constraints()\n", "        self.generate_altered_db_table()\n", "\n", "        self._sort_migrations()\n", "        self._build_migration_list(graph)\n", "        self._optimize_migrations()\n", "\n", "        return self.migrations\n"]}]}, {"file_path": "django/db/migrations/operations/fields.py", "span_ids": ["AlterField", "AlterField.reduce"], "content": [{"span_id": "AlterField", "start_line": 198, "end_line": 202, "content": ["class AlterField(FieldOperation):\n", "    \"\"\"\n", "    Alter a field's database column (e.g. null, max_length) to the provided\n", "    new field.\n", "    \"\"\"\n"]}, {"span_id": "AlterField.reduce", "start_line": 249, "end_line": 267, "content": ["    def reduce(self, operation, app_label):\n", "        if isinstance(operation, RemoveField) and self.is_same_field_operation(\n", "            operation\n", "        ):\n", "            return [operation]\n", "        elif (\n", "            isinstance(operation, RenameField)\n", "            and self.is_same_field_operation(operation)\n", "            and self.field.db_column is None\n", "        ):\n", "            return [\n", "                operation,\n", "                AlterField(\n", "                    model_name=self.model_name,\n", "                    name=operation.new_name,\n", "                    field=self.field,\n", "                ),\n", "            ]\n", "        return super().reduce(operation, app_label)\n"]}]}, {"file_path": "django/db/migrations/optimizer.py", "span_ids": ["MigrationOptimizer", "MigrationOptimizer.optimize", "MigrationOptimizer.optimize_inner"], "content": [{"span_id": "MigrationOptimizer", "start_line": 1, "end_line": 10, "content": ["class MigrationOptimizer:\n", "    \"\"\"\n", "    Power the optimization process, where you provide a list of Operations\n", "    and you are returned a list of equal or shorter length - operations\n", "    are merged into one if possible.\n", "\n", "    For example, a CreateModel and an AddField can be optimized into a\n", "    new CreateModel, and CreateModel and DeleteModel can be optimized into\n", "    nothing.\n", "    \"\"\"\n"]}, {"span_id": "MigrationOptimizer.optimize", "start_line": 12, "end_line": 38, "content": ["    def optimize(self, operations, app_label):\n", "        \"\"\"\n", "        Main optimization entry point. Pass in a list of Operation instances,\n", "        get out a new list of Operation instances.\n", "\n", "        Unfortunately, due to the scope of the optimization (two combinable\n", "        operations might be separated by several hundred others), this can't be\n", "        done as a peephole optimization with checks/output implemented on\n", "        the Operations themselves; instead, the optimizer looks at each\n", "        individual operation and scans forwards in the list to see if there\n", "        are any matches, stopping at boundaries - operations which can't\n", "        be optimized over (RunSQL, operations on the same field/model, etc.)\n", "\n", "        The inner loop is run until the starting list is the same as the result\n", "        list, and then the result is returned. This means that operation\n", "        optimization must be stable and always return an equal or shorter list.\n", "        \"\"\"\n", "        # Internal tracking variable for test assertions about # of loops\n", "        if app_label is None:\n", "            raise TypeError(\"app_label must be a str.\")\n", "        self._iterations = 0\n", "        while True:\n", "            result = self.optimize_inner(operations, app_label)\n", "            self._iterations += 1\n", "            if result == operations:\n", "                return result\n", "            operations = result\n"]}, {"span_id": "MigrationOptimizer.optimize_inner", "start_line": 40, "end_line": 69, "content": ["    def optimize_inner(self, operations, app_label):\n", "        \"\"\"Inner optimization loop.\"\"\"\n", "        new_operations = []\n", "        for i, operation in enumerate(operations):\n", "            right = True  # Should we reduce on the right or on the left.\n", "            # Compare it to each operation after it\n", "            for j, other in enumerate(operations[i + 1 :]):\n", "                result = operation.reduce(other, app_label)\n", "                if isinstance(result, list):\n", "                    in_between = operations[i + 1 : i + j + 1]\n", "                    if right:\n", "                        new_operations.extend(in_between)\n", "                        new_operations.extend(result)\n", "                    elif all(op.reduce(other, app_label) is True for op in in_between):\n", "                        # Perform a left reduction if all of the in-between\n", "                        # operations can optimize through other.\n", "                        new_operations.extend(result)\n", "                        new_operations.extend(in_between)\n", "                    else:\n", "                        # Otherwise keep trying.\n", "                        new_operations.append(operation)\n", "                        break\n", "                    new_operations.extend(operations[i + j + 2 :])\n", "                    return new_operations\n", "                elif not result:\n", "                    # Can't perform a right reduction.\n", "                    right = False\n", "            else:\n", "                new_operations.append(operation)\n", "        return new_operations\n"]}]}]}