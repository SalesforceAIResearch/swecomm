{"instance_id": "django__django-15819", "identified_spans": [{"file_path": "django/core/management/commands/inspectdb.py", "span_ids": ["Command", "Command.handle_inspection"], "content": [{"span_id": "Command", "start_line": 9, "end_line": 16, "content": ["class Command(BaseCommand):\n", "    help = (\n", "        \"Introspects the database tables in the given database and outputs a Django \"\n", "        \"model module.\"\n", "    )\n", "    requires_system_checks = []\n", "    stealth_options = (\"table_name_filter\",)\n", "    db_module = \"django.db\"\n"]}, {"span_id": "Command.handle_inspection", "start_line": 54, "end_line": 245, "content": ["    def handle_inspection(self, options):\n", "        connection = connections[options[\"database\"]]\n", "        # 'table_name_filter' is a stealth option\n", "        table_name_filter = options.get(\"table_name_filter\")\n", "\n", "        def table2model(table_name):\n", "            return re.sub(r\"[^a-zA-Z0-9]\", \"\", table_name.title())\n", "\n", "        with connection.cursor() as cursor:\n", "            yield \"# This is an auto-generated Django model module.\"\n", "            yield \"# You'll have to do the following manually to clean this up:\"\n", "            yield \"#   * Rearrange models' order\"\n", "            yield \"#   * Make sure each model has one field with primary_key=True\"\n", "            yield (\n", "                \"#   * Make sure each ForeignKey and OneToOneField has `on_delete` set \"\n", "                \"to the desired behavior\"\n", "            )\n", "            yield (\n", "                \"#   * Remove `managed = False` lines if you wish to allow \"\n", "                \"Django to create, modify, and delete the table\"\n", "            )\n", "            yield (\n", "                \"# Feel free to rename the models, but don't rename db_table values or \"\n", "                \"field names.\"\n", "            )\n", "            yield \"from %s import models\" % self.db_module\n", "            known_models = []\n", "            table_info = connection.introspection.get_table_list(cursor)\n", "\n", "            # Determine types of tables and/or views to be introspected.\n", "            types = {\"t\"}\n", "            if options[\"include_partitions\"]:\n", "                types.add(\"p\")\n", "            if options[\"include_views\"]:\n", "                types.add(\"v\")\n", "\n", "            for table_name in options[\"table\"] or sorted(\n", "                info.name for info in table_info if info.type in types\n", "            ):\n", "                if table_name_filter is not None and callable(table_name_filter):\n", "                    if not table_name_filter(table_name):\n", "                        continue\n", "                try:\n", "                    try:\n", "                        relations = connection.introspection.get_relations(\n", "                            cursor, table_name\n", "                        )\n", "                    except NotImplementedError:\n", "                        relations = {}\n", "                    try:\n", "                        constraints = connection.introspection.get_constraints(\n", "                            cursor, table_name\n", "                        )\n", "                    except NotImplementedError:\n", "                        constraints = {}\n", "                    primary_key_columns = (\n", "                        connection.introspection.get_primary_key_columns(\n", "                            cursor, table_name\n", "                        )\n", "                    )\n", "                    primary_key_column = (\n", "                        primary_key_columns[0] if primary_key_columns else None\n", "                    )\n", "                    unique_columns = [\n", "                        c[\"columns\"][0]\n", "                        for c in constraints.values()\n", "                        if c[\"unique\"] and len(c[\"columns\"]) == 1\n", "                    ]\n", "                    table_description = connection.introspection.get_table_description(\n", "                        cursor, table_name\n", "                    )\n", "                except Exception as e:\n", "                    yield \"# Unable to inspect table '%s'\" % table_name\n", "                    yield \"# The error was: %s\" % e\n", "                    continue\n", "\n", "                yield \"\"\n", "                yield \"\"\n", "                yield \"class %s(models.Model):\" % table2model(table_name)\n", "                known_models.append(table2model(table_name))\n", "                used_column_names = []  # Holds column names used in the table so far\n", "                column_to_field_name = {}  # Maps column names to names of model fields\n", "                for row in table_description:\n", "                    comment_notes = (\n", "                        []\n", "                    )  # Holds Field notes, to be displayed in a Python comment.\n", "                    extra_params = {}  # Holds Field parameters such as 'db_column'.\n", "                    column_name = row.name\n", "                    is_relation = column_name in relations\n", "\n", "                    att_name, params, notes = self.normalize_col_name(\n", "                        column_name, used_column_names, is_relation\n", "                    )\n", "                    extra_params.update(params)\n", "                    comment_notes.extend(notes)\n", "\n", "                    used_column_names.append(att_name)\n", "                    column_to_field_name[column_name] = att_name\n", "\n", "                    # Add primary_key and unique, if necessary.\n", "                    if column_name == primary_key_column:\n", "                        extra_params[\"primary_key\"] = True\n", "                        if len(primary_key_columns) > 1:\n", "                            comment_notes.append(\n", "                                \"The composite primary key (%s) found, that is not \"\n", "                                \"supported. The first column is selected.\"\n", "                                % \", \".join(primary_key_columns)\n", "                            )\n", "                    elif column_name in unique_columns:\n", "                        extra_params[\"unique\"] = True\n", "\n", "                    if is_relation:\n", "                        ref_db_column, ref_db_table = relations[column_name]\n", "                        if extra_params.pop(\"unique\", False) or extra_params.get(\n", "                            \"primary_key\"\n", "                        ):\n", "                            rel_type = \"OneToOneField\"\n", "                        else:\n", "                            rel_type = \"ForeignKey\"\n", "                            ref_pk_column = (\n", "                                connection.introspection.get_primary_key_column(\n", "                                    cursor, ref_db_table\n", "                                )\n", "                            )\n", "                            if ref_pk_column and ref_pk_column != ref_db_column:\n", "                                extra_params[\"to_field\"] = ref_db_column\n", "                        rel_to = (\n", "                            \"self\"\n", "                            if ref_db_table == table_name\n", "                            else table2model(ref_db_table)\n", "                        )\n", "                        if rel_to in known_models:\n", "                            field_type = \"%s(%s\" % (rel_type, rel_to)\n", "                        else:\n", "                            field_type = \"%s('%s'\" % (rel_type, rel_to)\n", "                    else:\n", "                        # Calling `get_field_type` to get the field type string and any\n", "                        # additional parameters and notes.\n", "                        field_type, field_params, field_notes = self.get_field_type(\n", "                            connection, table_name, row\n", "                        )\n", "                        extra_params.update(field_params)\n", "                        comment_notes.extend(field_notes)\n", "\n", "                        field_type += \"(\"\n", "\n", "                    # Don't output 'id = meta.AutoField(primary_key=True)', because\n", "                    # that's assumed if it doesn't exist.\n", "                    if att_name == \"id\" and extra_params == {\"primary_key\": True}:\n", "                        if field_type == \"AutoField(\":\n", "                            continue\n", "                        elif (\n", "                            field_type\n", "                            == connection.features.introspected_field_types[\"AutoField\"]\n", "                            + \"(\"\n", "                        ):\n", "                            comment_notes.append(\"AutoField?\")\n", "\n", "                    # Add 'null' and 'blank', if the 'null_ok' flag was present in the\n", "                    # table description.\n", "                    if row.null_ok:  # If it's NULL...\n", "                        extra_params[\"blank\"] = True\n", "                        extra_params[\"null\"] = True\n", "\n", "                    field_desc = \"%s = %s%s\" % (\n", "                        att_name,\n", "                        # Custom fields will have a dotted path\n", "                        \"\" if \".\" in field_type else \"models.\",\n", "                        field_type,\n", "                    )\n", "                    if field_type.startswith((\"ForeignKey(\", \"OneToOneField(\")):\n", "                        field_desc += \", models.DO_NOTHING\"\n", "\n", "                    if extra_params:\n", "                        if not field_desc.endswith(\"(\"):\n", "                            field_desc += \", \"\n", "                        field_desc += \", \".join(\n", "                            \"%s=%r\" % (k, v) for k, v in extra_params.items()\n", "                        )\n", "                    field_desc += \")\"\n", "                    if comment_notes:\n", "                        field_desc += \"  # \" + \" \".join(comment_notes)\n", "                    yield \"    %s\" % field_desc\n", "                is_view = any(\n", "                    info.name == table_name and info.type == \"v\" for info in table_info\n", "                )\n", "                is_partition = any(\n", "                    info.name == table_name and info.type == \"p\" for info in table_info\n", "                )\n", "                yield from self.get_meta(\n", "                    table_name, constraints, column_to_field_name, is_view, is_partition\n", "                )\n"]}]}]}