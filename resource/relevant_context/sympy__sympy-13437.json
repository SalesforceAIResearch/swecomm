{"instance_id": "sympy__sympy-13437", "identified_spans": [{"file_path": "sympy/functions/combinatorial/numbers.py", "span_ids": ["bell.eval", "bell"], "content": [{"span_id": "bell.eval", "start_line": 435, "end_line": 444, "content": ["    @classmethod\n", "    def eval(cls, n, k_sym=None, symbols=None):\n", "        if n.is_Integer and n.is_nonnegative:\n", "            if k_sym is None:\n", "                return Integer(cls._bell(int(n)))\n", "            elif symbols is None:\n", "                return cls._bell_poly(int(n)).subs(_sym, k_sym)\n", "            else:\n", "                r = cls._bell_incomplete_poly(int(n), int(k_sym), symbols)\n", "                return r\n"]}, {"span_id": "bell", "start_line": 322, "end_line": 384, "content": ["class bell(Function):\n", "    r\"\"\"\n", "    Bell numbers / Bell polynomials\n", "\n", "    The Bell numbers satisfy `B_0 = 1` and\n", "\n", "    .. math:: B_n = \\sum_{k=0}^{n-1} \\binom{n-1}{k} B_k.\n", "\n", "    They are also given by:\n", "\n", "    .. math:: B_n = \\frac{1}{e} \\sum_{k=0}^{\\infty} \\frac{k^n}{k!}.\n", "\n", "    The Bell polynomials are given by `B_0(x) = 1` and\n", "\n", "    .. math:: B_n(x) = x \\sum_{k=1}^{n-1} \\binom{n-1}{k-1} B_{k-1}(x).\n", "\n", "    The second kind of Bell polynomials (are sometimes called \"partial\" Bell\n", "    polynomials or incomplete Bell polynomials) are defined as\n", "\n", "    .. math:: B_{n,k}(x_1, x_2,\\dotsc x_{n-k+1}) =\n", "            \\sum_{j_1+j_2+j_2+\\dotsb=k \\atop j_1+2j_2+3j_2+\\dotsb=n}\n", "                \\frac{n!}{j_1!j_2!\\dotsb j_{n-k+1}!}\n", "                \\left(\\frac{x_1}{1!} \\right)^{j_1}\n", "                \\left(\\frac{x_2}{2!} \\right)^{j_2} \\dotsb\n", "                \\left(\\frac{x_{n-k+1}}{(n-k+1)!} \\right) ^{j_{n-k+1}}.\n", "\n", "    * bell(n) gives the `n^{th}` Bell number, `B_n`.\n", "    * bell(n, x) gives the `n^{th}` Bell polynomial, `B_n(x)`.\n", "    * bell(n, k, (x1, x2, ...)) gives Bell polynomials of the second kind,\n", "      `B_{n,k}(x_1, x_2, \\dotsc, x_{n-k+1})`.\n", "\n", "    Notes\n", "    =====\n", "\n", "    Not to be confused with Bernoulli numbers and Bernoulli polynomials,\n", "    which use the same notation.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import bell, Symbol, symbols\n", "\n", "    >>> [bell(n) for n in range(11)]\n", "    [1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975]\n", "    >>> bell(30)\n", "    846749014511809332450147\n", "    >>> bell(4, Symbol('t'))\n", "    t**4 + 6*t**3 + 7*t**2 + t\n", "    >>> bell(6, 2, symbols('x:6')[1:])\n", "    6*x1*x5 + 15*x2*x4 + 10*x3**2\n", "\n", "    References\n", "    ==========\n", "\n", "    .. [1] http://en.wikipedia.org/wiki/Bell_number\n", "    .. [2] http://mathworld.wolfram.com/BellNumber.html\n", "    .. [3] http://mathworld.wolfram.com/BellPolynomial.html\n", "\n", "    See Also\n", "    ========\n", "\n", "    bernoulli, catalan, euler, fibonacci, harmonic, lucas\n", "    \"\"\"\n"]}]}, {"file_path": "sympy/series/limits.py", "span_ids": ["Limit", "limit", "Limit.doit"], "content": [{"span_id": "Limit", "start_line": 83, "end_line": 96, "content": ["class Limit(Expr):\n", "    \"\"\"Represents an unevaluated limit.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import Limit, sin, Symbol\n", "    >>> from sympy.abc import x\n", "    >>> Limit(sin(x)/x, x, 0)\n", "    Limit(sin(x)/x, x, 0)\n", "    >>> Limit(1/x, x, 0, dir=\"-\")\n", "    Limit(1/x, x, 0, dir='-')\n", "\n", "    \"\"\"\n"]}, {"span_id": "limit", "start_line": 16, "end_line": 49, "content": ["def limit(e, z, z0, dir=\"+\"):\n", "    \"\"\"\n", "    Compute the limit of e(z) at the point z0.\n", "\n", "    z0 can be any expression, including oo and -oo.\n", "\n", "    For dir=\"+\" (default) it calculates the limit from the right\n", "    (z->z0+) and for dir=\"-\" the limit from the left (z->z0-).  For infinite\n", "    z0 (oo or -oo), the dir argument is determined from the direction\n", "    of the infinity (i.e., dir=\"-\" for oo).\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import limit, sin, Symbol, oo\n", "    >>> from sympy.abc import x\n", "    >>> limit(sin(x)/x, x, 0)\n", "    1\n", "    >>> limit(1/x, x, 0, dir=\"+\")\n", "    oo\n", "    >>> limit(1/x, x, 0, dir=\"-\")\n", "    -oo\n", "    >>> limit(1/x, x, oo)\n", "    0\n", "\n", "    Notes\n", "    =====\n", "\n", "    First we try some heuristics for easy and frequent cases like \"x\", \"1/x\",\n", "    \"x**2\" and similar, so that it's fast. For all other cases, we use the\n", "    Gruntz algorithm (see the gruntz() function).\n", "    \"\"\"\n", "\n", "    return Limit(e, z, z0, dir).doit(deep=False)\n"]}, {"span_id": "Limit.doit", "start_line": 130, "end_line": 197, "content": ["    def doit(self, **hints):\n", "        \"\"\"Evaluates limit\"\"\"\n", "        from sympy.series.limitseq import limit_seq\n", "        from sympy.functions import RisingFactorial\n", "\n", "        e, z, z0, dir = self.args\n", "\n", "        if hints.get('deep', True):\n", "            e = e.doit(**hints)\n", "            z = z.doit(**hints)\n", "            z0 = z0.doit(**hints)\n", "\n", "        if e == z:\n", "            return z0\n", "\n", "        if not e.has(z):\n", "            return e\n", "\n", "        # gruntz fails on factorials but works with the gamma function\n", "        # If no factorial term is present, e should remain unchanged.\n", "        # factorial is defined to be zero for negative inputs (which\n", "        # differs from gamma) so only rewrite for positive z0.\n", "        if z0.is_positive:\n", "            e = e.rewrite([factorial, RisingFactorial], gamma)\n", "\n", "        if e.is_Mul:\n", "            if abs(z0) is S.Infinity:\n", "                e = factor_terms(e)\n", "                e = e.rewrite(fibonacci, GoldenRatio)\n", "                ok = lambda w: (z in w.free_symbols and\n", "                                any(a.is_polynomial(z) or\n", "                                    any(z in m.free_symbols and m.is_polynomial(z)\n", "                                        for m in Mul.make_args(a))\n", "                                    for a in Add.make_args(w)))\n", "                if all(ok(w) for w in e.as_numer_denom()):\n", "                    u = Dummy(positive=True)\n", "                    if z0 is S.NegativeInfinity:\n", "                        inve = e.subs(z, -1/u)\n", "                    else:\n", "                        inve = e.subs(z, 1/u)\n", "                    r = limit(inve.as_leading_term(u), u, S.Zero, \"+\")\n", "                    if isinstance(r, Limit):\n", "                        return self\n", "                    else:\n", "                        return r\n", "\n", "        if e.is_Order:\n", "            return Order(limit(e.expr, z, z0), *e.args[1:])\n", "\n", "        try:\n", "            r = gruntz(e, z, z0, dir)\n", "            if r is S.NaN:\n", "                raise PoleError()\n", "        except (PoleError, ValueError):\n", "            r = heuristics(e, z, z0, dir)\n", "            if r is None:\n", "                return self\n", "        except NotImplementedError:\n", "            # Trying finding limits of sequences\n", "            if hints.get('sequence', True) and z0 is S.Infinity:\n", "                trials = hints.get('trials', 5)\n", "                r = limit_seq(e, z, trials)\n", "                if r is None:\n", "                    raise NotImplementedError()\n", "            else:\n", "                raise NotImplementedError()\n", "\n", "        return r\n"]}]}]}