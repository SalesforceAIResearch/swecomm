{"instance_id": "astropy__astropy-14995", "identified_spans": [{"file_path": "astropy/nddata/mixins/ndarithmetic.py", "span_ids": ["NDArithmeticMixin.multiply", "NDArithmeticMixin", "NDArithmeticMixin._arithmetic"], "content": [{"span_id": "NDArithmeticMixin.multiply", "start_line": 615, "end_line": 620, "content": ["    @sharedmethod\n", "    @format_doc(_arit_doc, name=\"multiplication\", op=\"*\")\n", "    def multiply(self, operand, operand2=None, **kwargs):\n", "        return self._prepare_then_do_arithmetic(\n", "            np.multiply, operand, operand2, **kwargs\n", "        )\n"]}, {"span_id": "NDArithmeticMixin", "start_line": 103, "end_line": 164, "content": ["class NDArithmeticMixin:\n", "    \"\"\"\n", "    Mixin class to add arithmetic to an NDData object.\n", "\n", "    When subclassing, be sure to list the superclasses in the correct order\n", "    so that the subclass sees NDData as the main superclass. See\n", "    `~astropy.nddata.NDDataArray` for an example.\n", "\n", "    Notes\n", "    -----\n", "    This class only aims at covering the most common cases so there are certain\n", "    restrictions on the saved attributes::\n", "\n", "        - ``uncertainty`` : has to be something that has a `NDUncertainty`-like\n", "          interface for uncertainty propagation\n", "        - ``mask`` : has to be something that can be used by a bitwise ``or``\n", "          operation.\n", "        - ``wcs`` : has to implement a way of comparing with ``=`` to allow\n", "          the operation.\n", "\n", "    But there is a workaround that allows to disable handling a specific\n", "    attribute and to simply set the results attribute to ``None`` or to\n", "    copy the existing attribute (and neglecting the other).\n", "    For example for uncertainties not representing an `NDUncertainty`-like\n", "    interface you can alter the ``propagate_uncertainties`` parameter in\n", "    :meth:`NDArithmeticMixin.add`. ``None`` means that the result will have no\n", "    uncertainty, ``False`` means it takes the uncertainty of the first operand\n", "    (if this does not exist from the second operand) as the result's\n", "    uncertainty. This behavior is also explained in the docstring for the\n", "    different arithmetic operations.\n", "\n", "    Decomposing the units is not attempted, mainly due to the internal mechanics\n", "    of `~astropy.units.Quantity`, so the resulting data might have units like\n", "    ``km/m`` if you divided for example 100km by 5m. So this Mixin has adopted\n", "    this behavior.\n", "\n", "    Examples\n", "    --------\n", "    Using this Mixin with `~astropy.nddata.NDData`:\n", "\n", "        >>> from astropy.nddata import NDData, NDArithmeticMixin\n", "        >>> class NDDataWithMath(NDArithmeticMixin, NDData):\n", "        ...     pass\n", "\n", "    Using it with one operand on an instance::\n", "\n", "        >>> ndd = NDDataWithMath(100)\n", "        >>> ndd.add(20)\n", "        NDDataWithMath(120)\n", "\n", "    Using it with two operand on an instance::\n", "\n", "        >>> ndd = NDDataWithMath(-4)\n", "        >>> ndd.divide(1, ndd)\n", "        NDDataWithMath(-0.25)\n", "\n", "    Using it as classmethod requires two operands::\n", "\n", "        >>> NDDataWithMath.subtract(5, 4)\n", "        NDDataWithMath(1)\n", "\n", "    \"\"\"\n"]}, {"span_id": "NDArithmeticMixin._arithmetic", "start_line": 166, "end_line": 352, "content": ["    def _arithmetic(\n", "        self,\n", "        operation,\n", "        operand,\n", "        propagate_uncertainties=True,\n", "        handle_mask=np.logical_or,\n", "        handle_meta=None,\n", "        uncertainty_correlation=0,\n", "        compare_wcs=\"first_found\",\n", "        operation_ignores_mask=False,\n", "        axis=None,\n", "        **kwds,\n", "    ):\n", "        \"\"\"\n", "        Base method which calculates the result of the arithmetic operation.\n", "\n", "        This method determines the result of the arithmetic operation on the\n", "        ``data`` including their units and then forwards to other methods\n", "        to calculate the other properties for the result (like uncertainty).\n", "\n", "        Parameters\n", "        ----------\n", "        operation : callable\n", "            The operation that is performed on the `NDData`. Supported are\n", "            `numpy.add`, `numpy.subtract`, `numpy.multiply` and\n", "            `numpy.true_divide`.\n", "\n", "        operand : same type (class) as self\n", "            see :meth:`NDArithmeticMixin.add`\n", "\n", "        propagate_uncertainties : `bool` or ``None``, optional\n", "            see :meth:`NDArithmeticMixin.add`\n", "\n", "        handle_mask : callable, ``'first_found'`` or ``None``, optional\n", "            see :meth:`NDArithmeticMixin.add`\n", "\n", "        handle_meta : callable, ``'first_found'`` or ``None``, optional\n", "            see :meth:`NDArithmeticMixin.add`\n", "\n", "        compare_wcs : callable, ``'first_found'`` or ``None``, optional\n", "            see :meth:`NDArithmeticMixin.add`\n", "\n", "        uncertainty_correlation : ``Number`` or `~numpy.ndarray`, optional\n", "            see :meth:`NDArithmeticMixin.add`\n", "\n", "        operation_ignores_mask : bool, optional\n", "            When True, masked values will be excluded from operations;\n", "            otherwise the operation will be performed on all values,\n", "            including masked ones.\n", "\n", "        axis : int or tuple of ints, optional\n", "            axis or axes over which to perform collapse operations like min, max, sum or mean.\n", "\n", "        kwargs :\n", "            Any other parameter that should be passed to the\n", "            different :meth:`NDArithmeticMixin._arithmetic_mask` (or wcs, ...)\n", "            methods.\n", "\n", "        Returns\n", "        -------\n", "        result : ndarray or `~astropy.units.Quantity`\n", "            The resulting data as array (in case both operands were without\n", "            unit) or as quantity if at least one had a unit.\n", "\n", "        kwargs : `dict`\n", "            The kwargs should contain all the other attributes (besides data\n", "            and unit) needed to create a new instance for the result. Creating\n", "            the new instance is up to the calling method, for example\n", "            :meth:`NDArithmeticMixin.add`.\n", "\n", "        \"\"\"\n", "        # Find the appropriate keywords for the appropriate method (not sure\n", "        # if data and uncertainty are ever used ...)\n", "        kwds2 = {\"mask\": {}, \"meta\": {}, \"wcs\": {}, \"data\": {}, \"uncertainty\": {}}\n", "        for i in kwds:\n", "            splitted = i.split(\"_\", 1)\n", "            try:\n", "                kwds2[splitted[0]][splitted[1]] = kwds[i]\n", "            except KeyError:\n", "                raise KeyError(f\"Unknown prefix {splitted[0]} for parameter {i}\")\n", "\n", "        kwargs = {}\n", "\n", "        # First check that the WCS allows the arithmetic operation\n", "        if compare_wcs is None:\n", "            kwargs[\"wcs\"] = None\n", "        elif compare_wcs in [\"ff\", \"first_found\"]:\n", "            if self.wcs is None and hasattr(operand, \"wcs\"):\n", "                kwargs[\"wcs\"] = deepcopy(operand.wcs)\n", "            else:\n", "                kwargs[\"wcs\"] = deepcopy(self.wcs)\n", "        else:\n", "            kwargs[\"wcs\"] = self._arithmetic_wcs(\n", "                operation, operand, compare_wcs, **kwds2[\"wcs\"]\n", "            )\n", "\n", "        # collapse operations on masked quantities/arrays which are supported by\n", "        # the astropy.utils.masked or np.ma modules should use those modules to\n", "        # do the arithmetic on the data and propagate masks.\n", "        use_masked_arith = operand is None and self.mask is not None\n", "        if use_masked_arith:\n", "            # if we're *including* masked values in the operation,\n", "            # use the astropy Masked module:\n", "            if not operation_ignores_mask:\n", "                # call the numpy operation on a Masked NDDataArray\n", "                # representation of the nddata, with units when available:\n", "                if self.unit is not None and not hasattr(self.data, \"unit\"):\n", "                    masked_input = Masked(self.data << self.unit, mask=self.mask)\n", "                else:\n", "                    masked_input = Masked(self.data, mask=self.mask)\n", "            # if we're *excluding* masked values in the operation,\n", "            # we use the numpy.ma module:\n", "            else:\n", "                masked_input = np.ma.masked_array(self.data, self.mask)\n", "            result = operation(masked_input, axis=axis)\n", "            # since result may be e.g. a float if operation is a sum over all axes,\n", "            # let's ensure that result is a masked array, since we'll assume this later:\n", "            if not hasattr(result, \"mask\"):\n", "                result = np.ma.masked_array(\n", "                    result, mask=np.zeros_like(result, dtype=bool)\n", "                )\n", "        else:\n", "            # Then calculate the resulting data (which can but needs not be a\n", "            # quantity)\n", "            result = self._arithmetic_data(\n", "                operation, operand, axis=axis, **kwds2[\"data\"]\n", "            )\n", "\n", "        # preserve original units\n", "        if not hasattr(result, \"unit\") and hasattr(self, \"unit\"):\n", "            kwargs[\"unit\"] = self.unit\n", "\n", "        # Determine the other properties\n", "        if propagate_uncertainties is None:\n", "            kwargs[\"uncertainty\"] = None\n", "        elif not propagate_uncertainties:\n", "            if self.uncertainty is None:\n", "                kwargs[\"uncertainty\"] = deepcopy(operand.uncertainty)\n", "            else:\n", "                kwargs[\"uncertainty\"] = deepcopy(self.uncertainty)\n", "        else:\n", "            kwargs[\"uncertainty\"] = self._arithmetic_uncertainty(\n", "                operation,\n", "                operand,\n", "                result,\n", "                uncertainty_correlation,\n", "                axis=axis,\n", "                **kwds2[\"uncertainty\"],\n", "            )\n", "\n", "        # If both are None, there is nothing to do.\n", "        if self.psf is not None or (operand is not None and operand.psf is not None):\n", "            warnings.warn(\n", "                f\"Not setting psf attribute during {operation.__name__}.\",\n", "                AstropyUserWarning,\n", "            )\n", "\n", "        if handle_mask is None:\n", "            pass\n", "        elif hasattr(result, \"mask\"):\n", "            # if numpy.ma or astropy.utils.masked is being used, the constructor\n", "            # will pick up the mask from the masked object:\n", "            kwargs[\"mask\"] = None\n", "        elif handle_mask in [\"ff\", \"first_found\"]:\n", "            if self.mask is None:\n", "                kwargs[\"mask\"] = deepcopy(operand.mask)\n", "            else:\n", "                kwargs[\"mask\"] = deepcopy(self.mask)\n", "        else:\n", "            kwargs[\"mask\"] = self._arithmetic_mask(\n", "                operation, operand, handle_mask, axis=axis, **kwds2[\"mask\"]\n", "            )\n", "\n", "        if handle_meta is None:\n", "            kwargs[\"meta\"] = None\n", "        elif handle_meta in [\"ff\", \"first_found\"]:\n", "            if not self.meta:\n", "                kwargs[\"meta\"] = deepcopy(operand.meta)\n", "            else:\n", "                kwargs[\"meta\"] = deepcopy(self.meta)\n", "        else:\n", "            kwargs[\"meta\"] = self._arithmetic_meta(\n", "                operation, operand, handle_meta, **kwds2[\"meta\"]\n", "            )\n", "\n", "        # Wrap the individual results into a new instance of the same class.\n", "        return result, kwargs\n"]}]}]}