{"instance_id": "django__django-11964", "identified_spans": [{"file_path": "django/db/models/base.py", "span_ids": ["Model.__init__"], "content": [{"span_id": "Model.__init__", "start_line": 405, "end_line": 502, "content": ["    def __init__(self, *args, **kwargs):\n", "        # Alias some things as locals to avoid repeat global lookups\n", "        cls = self.__class__\n", "        opts = self._meta\n", "        _setattr = setattr\n", "        _DEFERRED = DEFERRED\n", "\n", "        pre_init.send(sender=cls, args=args, kwargs=kwargs)\n", "\n", "        # Set up the storage for instance state\n", "        self._state = ModelState()\n", "\n", "        # There is a rather weird disparity here; if kwargs, it's set, then args\n", "        # overrides it. It should be one or the other; don't duplicate the work\n", "        # The reason for the kwargs check is that standard iterator passes in by\n", "        # args, and instantiation for iteration is 33% faster.\n", "        if len(args) > len(opts.concrete_fields):\n", "            # Daft, but matches old exception sans the err msg.\n", "            raise IndexError(\"Number of args exceeds number of fields\")\n", "\n", "        if not kwargs:\n", "            fields_iter = iter(opts.concrete_fields)\n", "            # The ordering of the zip calls matter - zip throws StopIteration\n", "            # when an iter throws it. So if the first iter throws it, the second\n", "            # is *not* consumed. We rely on this, so don't change the order\n", "            # without changing the logic.\n", "            for val, field in zip(args, fields_iter):\n", "                if val is _DEFERRED:\n", "                    continue\n", "                _setattr(self, field.attname, val)\n", "        else:\n", "            # Slower, kwargs-ready version.\n", "            fields_iter = iter(opts.fields)\n", "            for val, field in zip(args, fields_iter):\n", "                if val is _DEFERRED:\n", "                    continue\n", "                _setattr(self, field.attname, val)\n", "                kwargs.pop(field.name, None)\n", "\n", "        # Now we're left with the unprocessed fields that *must* come from\n", "        # keywords, or default.\n", "\n", "        for field in fields_iter:\n", "            is_related_object = False\n", "            # Virtual field\n", "            if field.attname not in kwargs and field.column is None:\n", "                continue\n", "            if kwargs:\n", "                if isinstance(field.remote_field, ForeignObjectRel):\n", "                    try:\n", "                        # Assume object instance was passed in.\n", "                        rel_obj = kwargs.pop(field.name)\n", "                        is_related_object = True\n", "                    except KeyError:\n", "                        try:\n", "                            # Object instance wasn't passed in -- must be an ID.\n", "                            val = kwargs.pop(field.attname)\n", "                        except KeyError:\n", "                            val = field.get_default()\n", "                else:\n", "                    try:\n", "                        val = kwargs.pop(field.attname)\n", "                    except KeyError:\n", "                        # This is done with an exception rather than the\n", "                        # default argument on pop because we don't want\n", "                        # get_default() to be evaluated, and then not used.\n", "                        # Refs #12057.\n", "                        val = field.get_default()\n", "            else:\n", "                val = field.get_default()\n", "\n", "            if is_related_object:\n", "                # If we are passed a related instance, set it using the\n", "                # field.name instead of field.attname (e.g. \"user\" instead of\n", "                # \"user_id\") so that the object gets properly cached (and type\n", "                # checked) by the RelatedObjectDescriptor.\n", "                if rel_obj is not _DEFERRED:\n", "                    _setattr(self, field.name, rel_obj)\n", "            else:\n", "                if val is not _DEFERRED:\n", "                    _setattr(self, field.attname, val)\n", "\n", "        if kwargs:\n", "            property_names = opts._property_names\n", "            for prop in tuple(kwargs):\n", "                try:\n", "                    # Any remaining kwargs must correspond to properties or\n", "                    # virtual fields.\n", "                    if prop in property_names or opts.get_field(prop):\n", "                        if kwargs[prop] is not _DEFERRED:\n", "                            _setattr(self, prop, kwargs[prop])\n", "                        del kwargs[prop]\n", "                except (AttributeError, FieldDoesNotExist):\n", "                    pass\n", "            for kwarg in kwargs:\n", "                raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\n", "        super().__init__()\n", "        post_init.send(sender=cls, instance=self)\n"]}]}, {"file_path": "django/db/models/enums.py", "span_ids": ["TextChoices", "ChoicesMeta"], "content": [{"span_id": "TextChoices", "start_line": 71, "end_line": 72, "content": ["class TextChoices(str, Choices):\n", "    \"\"\"Class for creating enumerated string choices.\"\"\"\n"]}, {"span_id": "ChoicesMeta", "start_line": 8, "end_line": 9, "content": ["class ChoicesMeta(enum.EnumMeta):\n", "    \"\"\"A metaclass for creating a enum choices.\"\"\"\n"]}]}, {"file_path": "django/db/models/fields/__init__.py", "span_ids": ["CharField.get_prep_value", "CharField.__init__", "CharField", "CharField.to_python", "Field.get_prep_value", "Field.to_python", "Field"], "content": [{"span_id": "CharField.get_prep_value", "start_line": 1015, "end_line": 1017, "content": ["    def get_prep_value(self, value):\n", "        value = super().get_prep_value(value)\n", "        return self.to_python(value)\n"]}, {"span_id": "CharField.__init__", "start_line": 971, "end_line": 973, "content": ["    def __init__(self, *args, **kwargs):\n", "        super().__init__(*args, **kwargs)\n", "        self.validators.append(validators.MaxLengthValidator(self.max_length))\n"]}, {"span_id": "CharField", "start_line": 968, "end_line": 969, "content": ["class CharField(Field):\n", "    description = _(\"String (up to %(max_length)s)\")\n"]}, {"span_id": "CharField.to_python", "start_line": 1010, "end_line": 1013, "content": ["    def to_python(self, value):\n", "        if isinstance(value, str) or value is None:\n", "            return value\n", "        return str(value)\n"]}, {"span_id": "Field.get_prep_value", "start_line": 791, "end_line": 795, "content": ["    def get_prep_value(self, value):\n", "        \"\"\"Perform preliminary non-db specific value checks and conversions.\"\"\"\n", "        if isinstance(value, Promise):\n", "            value = value._proxy____cast()\n", "        return value\n"]}, {"span_id": "Field.to_python", "start_line": 575, "end_line": 581, "content": ["    def to_python(self, value):\n", "        \"\"\"\n", "        Convert the input value into the expected Python data type, raising\n", "        django.core.exceptions.ValidationError if the data can't be converted.\n", "        Return the converted value. Subclasses should override this.\n", "        \"\"\"\n", "        return value\n"]}, {"span_id": "Field", "start_line": 84, "end_line": 122, "content": ["@total_ordering\n", "class Field(RegisterLookupMixin):\n", "    \"\"\"Base class for all field types\"\"\"\n", "\n", "    # Designates whether empty strings fundamentally are allowed at the\n", "    # database level.\n", "    empty_strings_allowed = True\n", "    empty_values = list(validators.EMPTY_VALUES)\n", "\n", "    # These track each time a Field instance is created. Used to retain order.\n", "    # The auto_creation_counter is used for fields that Django implicitly\n", "    # creates, creation_counter is used for all user-specified fields.\n", "    creation_counter = 0\n", "    auto_creation_counter = -1\n", "    default_validators = []  # Default set of validators\n", "    default_error_messages = {\n", "        'invalid_choice': _('Value %(value)r is not a valid choice.'),\n", "        'null': _('This field cannot be null.'),\n", "        'blank': _('This field cannot be blank.'),\n", "        'unique': _('%(model_name)s with this %(field_label)s '\n", "                    'already exists.'),\n", "        # Translators: The 'lookup_type' is one of 'date', 'year' or 'month'.\n", "        # Eg: \"Title must be unique for pub_date year\"\n", "        'unique_for_date': _(\"%(field_label)s must be unique for \"\n", "                             \"%(date_field_label)s %(lookup_type)s.\"),\n", "    }\n", "    system_check_deprecated_details = None\n", "    system_check_removed_details = None\n", "\n", "    # Field flags\n", "    hidden = False\n", "\n", "    many_to_many = None\n", "    many_to_one = None\n", "    one_to_many = None\n", "    one_to_one = None\n", "    related_model = None\n", "\n", "    descriptor_class = DeferredAttribute\n"]}]}]}