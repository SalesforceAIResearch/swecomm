{"instance_id": "matplotlib__matplotlib-23299", "identified_spans": [{"file_path": "lib/matplotlib/__init__.py", "span_ids": ["get_backend"], "content": [{"span_id": "get_backend", "start_line": 1170, "end_line": 1178, "content": ["def get_backend():\n", "    \"\"\"\n", "    Return the name of the current backend.\n", "\n", "    See Also\n", "    --------\n", "    matplotlib.use\n", "    \"\"\"\n", "    return rcParams['backend']\n"]}]}, {"file_path": "lib/matplotlib/_pylab_helpers.py", "span_ids": ["Gcf.destroy_fig", "Gcf.destroy_all", "Gcf.destroy", "Gcf.get_fig_manager", "Gcf.get_active", "Gcf", "Gcf.set_active", "Gcf._set_new_active_manager"], "content": [{"span_id": "Gcf.destroy_fig", "start_line": 74, "end_line": 80, "content": ["    @classmethod\n", "    def destroy_fig(cls, fig):\n", "        \"\"\"Destroy figure *fig*.\"\"\"\n", "        num = next((manager.num for manager in cls.figs.values()\n", "                    if manager.canvas.figure == fig), None)\n", "        if num is not None:\n", "            cls.destroy(num)\n"]}, {"span_id": "Gcf.destroy_all", "start_line": 82, "end_line": 92, "content": ["    @classmethod\n", "    def destroy_all(cls):\n", "        \"\"\"Destroy all figures.\"\"\"\n", "        # Reimport gc in case the module globals have already been removed\n", "        # during interpreter shutdown.\n", "        import gc\n", "        for manager in list(cls.figs.values()):\n", "            manager.canvas.mpl_disconnect(manager._cidgcf)\n", "            manager.destroy()\n", "        cls.figs.clear()\n", "        gc.collect(1)\n"]}, {"span_id": "Gcf.destroy", "start_line": 45, "end_line": 72, "content": ["    @classmethod\n", "    def destroy(cls, num):\n", "        \"\"\"\n", "        Destroy manager *num* -- either a manager instance or a manager number.\n", "\n", "        In the interactive backends, this is bound to the window \"destroy\" and\n", "        \"delete\" events.\n", "\n", "        It is recommended to pass a manager instance, to avoid confusion when\n", "        two managers share the same number.\n", "        \"\"\"\n", "        if all(hasattr(num, attr) for attr in [\"num\", \"destroy\"]):\n", "            manager = num\n", "            if cls.figs.get(manager.num) is manager:\n", "                cls.figs.pop(manager.num)\n", "        else:\n", "            try:\n", "                manager = cls.figs.pop(num)\n", "            except KeyError:\n", "                return\n", "        if hasattr(manager, \"_cidgcf\"):\n", "            manager.canvas.mpl_disconnect(manager._cidgcf)\n", "        manager.destroy()\n", "        del manager, num\n", "        # Full cyclic garbage collection may be too expensive to do on every\n", "        # figure destruction, so we collect only the youngest two generations.\n", "        # see: https://github.com/matplotlib/matplotlib/pull/3045\n", "        gc.collect(1)\n"]}, {"span_id": "Gcf.get_fig_manager", "start_line": 34, "end_line": 43, "content": ["    @classmethod\n", "    def get_fig_manager(cls, num):\n", "        \"\"\"\n", "        If manager number *num* exists, make it the active one and return it;\n", "        otherwise return *None*.\n", "        \"\"\"\n", "        manager = cls.figs.get(num, None)\n", "        if manager is not None:\n", "            cls.set_active(manager)\n", "        return manager\n"]}, {"span_id": "Gcf.get_active", "start_line": 109, "end_line": 112, "content": ["    @classmethod\n", "    def get_active(cls):\n", "        \"\"\"Return the active manager, or *None* if there is no manager.\"\"\"\n", "        return next(reversed(cls.figs.values())) if cls.figs else None\n"]}, {"span_id": "Gcf", "start_line": 10, "end_line": 32, "content": ["class Gcf:\n", "    \"\"\"\n", "    Singleton to maintain the relation between figures and their managers, and\n", "    keep track of and \"active\" figure and manager.\n", "\n", "    The canvas of a figure created through pyplot is associated with a figure\n", "    manager, which handles the interaction between the figure and the backend.\n", "    pyplot keeps track of figure managers using an identifier, the \"figure\n", "    number\" or \"manager number\" (which can actually be any hashable value);\n", "    this number is available as the :attr:`number` attribute of the manager.\n", "\n", "    This class is never instantiated; it consists of an `OrderedDict` mapping\n", "    figure/manager numbers to managers, and a set of class methods that\n", "    manipulate this `OrderedDict`.\n", "\n", "    Attributes\n", "    ----------\n", "    figs : OrderedDict\n", "        `OrderedDict` mapping numbers to managers; the active manager is at the\n", "        end.\n", "    \"\"\"\n", "\n", "    figs = OrderedDict()\n"]}, {"span_id": "Gcf.set_active", "start_line": 127, "end_line": 131, "content": ["    @classmethod\n", "    def set_active(cls, manager):\n", "        \"\"\"Make *manager* the active manager.\"\"\"\n", "        cls.figs[manager.num] = manager\n", "        cls.figs.move_to_end(manager.num)\n"]}, {"span_id": "Gcf._set_new_active_manager", "start_line": 114, "end_line": 125, "content": ["    @classmethod\n", "    def _set_new_active_manager(cls, manager):\n", "        \"\"\"Adopt *manager* into pyplot and make it the active manager.\"\"\"\n", "        if not hasattr(manager, \"_cidgcf\"):\n", "            manager._cidgcf = manager.canvas.mpl_connect(\n", "                \"button_press_event\", lambda event: cls.set_active(manager))\n", "        fig = manager.canvas.figure\n", "        fig.number = manager.num\n", "        label = fig.get_label()\n", "        if label:\n", "            manager.set_window_title(label)\n", "        cls.set_active(manager)\n"]}]}, {"file_path": "lib/matplotlib/pyplot.py", "span_ids": ["close", "figure", "gcf"], "content": [{"span_id": "close", "start_line": 918, "end_line": 957, "content": ["def close(fig=None):\n", "    \"\"\"\n", "    Close a figure window.\n", "\n", "    Parameters\n", "    ----------\n", "    fig : None or int or str or `.Figure`\n", "        The figure to close. There are a number of ways to specify this:\n", "\n", "        - *None*: the current figure\n", "        - `.Figure`: the given `.Figure` instance\n", "        - ``int``: a figure number\n", "        - ``str``: a figure name\n", "        - 'all': all figures\n", "\n", "    \"\"\"\n", "    if fig is None:\n", "        manager = _pylab_helpers.Gcf.get_active()\n", "        if manager is None:\n", "            return\n", "        else:\n", "            _pylab_helpers.Gcf.destroy(manager)\n", "    elif fig == 'all':\n", "        _pylab_helpers.Gcf.destroy_all()\n", "    elif isinstance(fig, int):\n", "        _pylab_helpers.Gcf.destroy(fig)\n", "    elif hasattr(fig, 'int'):\n", "        # if we are dealing with a type UUID, we\n", "        # can use its integer representation\n", "        _pylab_helpers.Gcf.destroy(fig.int)\n", "    elif isinstance(fig, str):\n", "        all_labels = get_figlabels()\n", "        if fig in all_labels:\n", "            num = get_fignums()[all_labels.index(fig)]\n", "            _pylab_helpers.Gcf.destroy(num)\n", "    elif isinstance(fig, Figure):\n", "        _pylab_helpers.Gcf.destroy_fig(fig)\n", "    else:\n", "        raise TypeError(\"close() argument must be a Figure, an int, a string, \"\n", "                        \"or None, not %s\" % type(fig))\n"]}, {"span_id": "figure", "start_line": 696, "end_line": 834, "content": ["@_api.make_keyword_only(\"3.6\", \"facecolor\")\n", "def figure(num=None,  # autoincrement if None, else integer from 1-N\n", "           figsize=None,  # defaults to rc figure.figsize\n", "           dpi=None,  # defaults to rc figure.dpi\n", "           facecolor=None,  # defaults to rc figure.facecolor\n", "           edgecolor=None,  # defaults to rc figure.edgecolor\n", "           frameon=True,\n", "           FigureClass=Figure,\n", "           clear=False,\n", "           **kwargs\n", "           ):\n", "    \"\"\"\n", "    Create a new figure, or activate an existing figure.\n", "\n", "    Parameters\n", "    ----------\n", "    num : int or str or `.Figure` or `.SubFigure`, optional\n", "        A unique identifier for the figure.\n", "\n", "        If a figure with that identifier already exists, this figure is made\n", "        active and returned. An integer refers to the ``Figure.number``\n", "        attribute, a string refers to the figure label.\n", "\n", "        If there is no figure with the identifier or *num* is not given, a new\n", "        figure is created, made active and returned.  If *num* is an int, it\n", "        will be used for the ``Figure.number`` attribute, otherwise, an\n", "        auto-generated integer value is used (starting at 1 and incremented\n", "        for each new figure). If *num* is a string, the figure label and the\n", "        window title is set to this value.  If num is a ``SubFigure``, its\n", "        parent ``Figure`` is activated.\n", "\n", "    figsize : (float, float), default: :rc:`figure.figsize`\n", "        Width, height in inches.\n", "\n", "    dpi : float, default: :rc:`figure.dpi`\n", "        The resolution of the figure in dots-per-inch.\n", "\n", "    facecolor : color, default: :rc:`figure.facecolor`\n", "        The background color.\n", "\n", "    edgecolor : color, default: :rc:`figure.edgecolor`\n", "        The border color.\n", "\n", "    frameon : bool, default: True\n", "        If False, suppress drawing the figure frame.\n", "\n", "    FigureClass : subclass of `~matplotlib.figure.Figure`\n", "        If set, an instance of this subclass will be created, rather than a\n", "        plain `.Figure`.\n", "\n", "    clear : bool, default: False\n", "        If True and the figure already exists, then it is cleared.\n", "\n", "    layout : {'constrained', 'tight', `.LayoutEngine`, None}, default: None\n", "        The layout mechanism for positioning of plot elements to avoid\n", "        overlapping Axes decorations (labels, ticks, etc). Note that layout\n", "        managers can measurably slow down figure display. Defaults to *None*\n", "        (but see the documentation of the `.Figure` constructor regarding the\n", "        interaction with rcParams).\n", "\n", "    **kwargs\n", "        Additional keyword arguments are passed to the `.Figure` constructor.\n", "\n", "    Returns\n", "    -------\n", "    `~matplotlib.figure.Figure`\n", "\n", "    Notes\n", "    -----\n", "    Newly created figures will be passed to the\n", "    `~.backend_template.new_figure_manager` function provided by the current\n", "    backend, which will install a canvas and a manager on the figure.\n", "\n", "    If you are creating many figures, make sure you explicitly call\n", "    `.pyplot.close` on the figures you are not using, because this will\n", "    enable pyplot to properly clean up the memory.\n", "\n", "    `~matplotlib.rcParams` defines the default values, which can be modified\n", "    in the matplotlibrc file.\n", "    \"\"\"\n", "    if isinstance(num, FigureBase):\n", "        if num.canvas.manager is None:\n", "            raise ValueError(\"The passed figure is not managed by pyplot\")\n", "        _pylab_helpers.Gcf.set_active(num.canvas.manager)\n", "        return num.figure\n", "\n", "    allnums = get_fignums()\n", "    next_num = max(allnums) + 1 if allnums else 1\n", "    fig_label = ''\n", "    if num is None:\n", "        num = next_num\n", "    elif isinstance(num, str):\n", "        fig_label = num\n", "        all_labels = get_figlabels()\n", "        if fig_label not in all_labels:\n", "            if fig_label == 'all':\n", "                _api.warn_external(\"close('all') closes all existing figures.\")\n", "            num = next_num\n", "        else:\n", "            inum = all_labels.index(fig_label)\n", "            num = allnums[inum]\n", "    else:\n", "        num = int(num)  # crude validation of num argument\n", "\n", "    manager = _pylab_helpers.Gcf.get_fig_manager(num)\n", "    if manager is None:\n", "        max_open_warning = rcParams['figure.max_open_warning']\n", "        if len(allnums) == max_open_warning >= 1:\n", "            _api.warn_external(\n", "                f\"More than {max_open_warning} figures have been opened. \"\n", "                f\"Figures created through the pyplot interface \"\n", "                f\"(`matplotlib.pyplot.figure`) are retained until explicitly \"\n", "                f\"closed and may consume too much memory. (To control this \"\n", "                f\"warning, see the rcParam `figure.max_open_warning`).\",\n", "                RuntimeWarning)\n", "\n", "        manager = new_figure_manager(\n", "            num, figsize=figsize, dpi=dpi,\n", "            facecolor=facecolor, edgecolor=edgecolor, frameon=frameon,\n", "            FigureClass=FigureClass, **kwargs)\n", "        fig = manager.canvas.figure\n", "        if fig_label:\n", "            fig.set_label(fig_label)\n", "\n", "        _pylab_helpers.Gcf._set_new_active_manager(manager)\n", "\n", "        # make sure backends (inline) that we don't ship that expect this\n", "        # to be called in plotting commands to make the figure call show\n", "        # still work.  There is probably a better way to do this in the\n", "        # FigureManager base class.\n", "        draw_if_interactive()\n", "\n", "        if _REPL_DISPLAYHOOK is _ReplDisplayHook.PLAIN:\n", "            fig.stale_callback = _auto_draw_if_interactive\n", "\n", "    if clear:\n", "        manager.canvas.figure.clear()\n", "\n", "    return manager.canvas.figure\n"]}, {"span_id": "gcf", "start_line": 858, "end_line": 871, "content": ["def gcf():\n", "    \"\"\"\n", "    Get the current figure.\n", "\n", "    If there is currently no figure on the pyplot figure stack, a new one is\n", "    created using `~.pyplot.figure()`.  (To test whether there is currently a\n", "    figure on the pyplot figure stack, check whether `~.pyplot.get_fignums()`\n", "    is empty.)\n", "    \"\"\"\n", "    manager = _pylab_helpers.Gcf.get_active()\n", "    if manager is not None:\n", "        return manager.canvas.figure\n", "    else:\n", "        return figure()\n"]}]}]}