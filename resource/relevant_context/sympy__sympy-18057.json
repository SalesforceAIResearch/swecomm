{"instance_id": "sympy__sympy-18057", "identified_spans": [{"file_path": "sympy/core/expr.py", "span_ids": ["Expr.__eq__"], "content": [{"span_id": "Expr.__eq__", "start_line": 122, "end_line": 142, "content": ["    def __eq__(self, other):\n", "        try:\n", "            other = sympify(other)\n", "            if not isinstance(other, Expr):\n", "                return False\n", "        except (SympifyError, SyntaxError):\n", "            return False\n", "        # check for pure number expr\n", "        if  not (self.is_Number and other.is_Number) and (\n", "                type(self) != type(other)):\n", "            return False\n", "        a, b = self._hashable_content(), other._hashable_content()\n", "        if a != b:\n", "            return False\n", "        # check number *in* an expression\n", "        for a, b in zip(a, b):\n", "            if not isinstance(a, Expr):\n", "                continue\n", "            if a.is_Number and type(a) != type(b):\n", "                return False\n", "        return True\n"]}]}, {"file_path": "sympy/core/sympify.py", "span_ids": ["sympify"], "content": [{"span_id": "sympify", "start_line": 78, "end_line": 389, "content": ["def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,\n", "        evaluate=None):\n", "    \"\"\"Converts an arbitrary expression to a type that can be used inside SymPy.\n", "\n", "    For example, it will convert Python ints into instances of sympy.Integer,\n", "    floats into instances of sympy.Float, etc. It is also able to coerce symbolic\n", "    expressions which inherit from Basic. This can be useful in cooperation\n", "    with SAGE.\n", "\n", "    It currently accepts as arguments:\n", "       - any object defined in SymPy\n", "       - standard numeric python types: int, long, float, Decimal\n", "       - strings (like \"0.09\" or \"2e-19\")\n", "       - booleans, including ``None`` (will leave ``None`` unchanged)\n", "       - dict, lists, sets or tuples containing any of the above\n", "\n", "    .. warning::\n", "        Note that this function uses ``eval``, and thus shouldn't be used on\n", "        unsanitized input.\n", "\n", "    If the argument is already a type that SymPy understands, it will do\n", "    nothing but return that value. This can be used at the beginning of a\n", "    function to ensure you are working with the correct type.\n", "\n", "    >>> from sympy import sympify\n", "\n", "    >>> sympify(2).is_integer\n", "    True\n", "    >>> sympify(2).is_real\n", "    True\n", "\n", "    >>> sympify(2.0).is_real\n", "    True\n", "    >>> sympify(\"2.0\").is_real\n", "    True\n", "    >>> sympify(\"2e-45\").is_real\n", "    True\n", "\n", "    If the expression could not be converted, a SympifyError is raised.\n", "\n", "    >>> sympify(\"x***2\")\n", "    Traceback (most recent call last):\n", "    ...\n", "    SympifyError: SympifyError: \"could not parse u'x***2'\"\n", "\n", "    Locals\n", "    ------\n", "\n", "    The sympification happens with access to everything that is loaded\n", "    by ``from sympy import *``; anything used in a string that is not\n", "    defined by that import will be converted to a symbol. In the following,\n", "    the ``bitcount`` function is treated as a symbol and the ``O`` is\n", "    interpreted as the Order object (used with series) and it raises\n", "    an error when used improperly:\n", "\n", "    >>> s = 'bitcount(42)'\n", "    >>> sympify(s)\n", "    bitcount(42)\n", "    >>> sympify(\"O(x)\")\n", "    O(x)\n", "    >>> sympify(\"O + 1\")\n", "    Traceback (most recent call last):\n", "    ...\n", "    TypeError: unbound method...\n", "\n", "    In order to have ``bitcount`` be recognized it can be imported into a\n", "    namespace dictionary and passed as locals:\n", "\n", "    >>> from sympy.core.compatibility import exec_\n", "    >>> ns = {}\n", "    >>> exec_('from sympy.core.evalf import bitcount', ns)\n", "    >>> sympify(s, locals=ns)\n", "    6\n", "\n", "    In order to have the ``O`` interpreted as a Symbol, identify it as such\n", "    in the namespace dictionary. This can be done in a variety of ways; all\n", "    three of the following are possibilities:\n", "\n", "    >>> from sympy import Symbol\n", "    >>> ns[\"O\"] = Symbol(\"O\")  # method 1\n", "    >>> exec_('from sympy.abc import O', ns)  # method 2\n", "    >>> ns.update(dict(O=Symbol(\"O\")))  # method 3\n", "    >>> sympify(\"O + 1\", locals=ns)\n", "    O + 1\n", "\n", "    If you want *all* single-letter and Greek-letter variables to be symbols\n", "    then you can use the clashing-symbols dictionaries that have been defined\n", "    there as private variables: _clash1 (single-letter variables), _clash2\n", "    (the multi-letter Greek names) or _clash (both single and multi-letter\n", "    names that are defined in abc).\n", "\n", "    >>> from sympy.abc import _clash1\n", "    >>> _clash1\n", "    {'C': C, 'E': E, 'I': I, 'N': N, 'O': O, 'Q': Q, 'S': S}\n", "    >>> sympify('I & Q', _clash1)\n", "    I & Q\n", "\n", "    Strict\n", "    ------\n", "\n", "    If the option ``strict`` is set to ``True``, only the types for which an\n", "    explicit conversion has been defined are converted. In the other\n", "    cases, a SympifyError is raised.\n", "\n", "    >>> print(sympify(None))\n", "    None\n", "    >>> sympify(None, strict=True)\n", "    Traceback (most recent call last):\n", "    ...\n", "    SympifyError: SympifyError: None\n", "\n", "    Evaluation\n", "    ----------\n", "\n", "    If the option ``evaluate`` is set to ``False``, then arithmetic and\n", "    operators will be converted into their SymPy equivalents and the\n", "    ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will\n", "    be denested first. This is done via an AST transformation that replaces\n", "    operators with their SymPy equivalents, so if an operand redefines any\n", "    of those operations, the redefined operators will not be used.\n", "\n", "    >>> sympify('2**2 / 3 + 5')\n", "    19/3\n", "    >>> sympify('2**2 / 3 + 5', evaluate=False)\n", "    2**2/3 + 5\n", "\n", "    Extending\n", "    ---------\n", "\n", "    To extend ``sympify`` to convert custom objects (not derived from ``Basic``),\n", "    just define a ``_sympy_`` method to your class. You can do that even to\n", "    classes that you do not own by subclassing or adding the method at runtime.\n", "\n", "    >>> from sympy import Matrix\n", "    >>> class MyList1(object):\n", "    ...     def __iter__(self):\n", "    ...         yield 1\n", "    ...         yield 2\n", "    ...         return\n", "    ...     def __getitem__(self, i): return list(self)[i]\n", "    ...     def _sympy_(self): return Matrix(self)\n", "    >>> sympify(MyList1())\n", "    Matrix([\n", "    [1],\n", "    [2]])\n", "\n", "    If you do not have control over the class definition you could also use the\n", "    ``converter`` global dictionary. The key is the class and the value is a\n", "    function that takes a single argument and returns the desired SymPy\n", "    object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.\n", "\n", "    >>> class MyList2(object):   # XXX Do not do this if you control the class!\n", "    ...     def __iter__(self):  #     Use _sympy_!\n", "    ...         yield 1\n", "    ...         yield 2\n", "    ...         return\n", "    ...     def __getitem__(self, i): return list(self)[i]\n", "    >>> from sympy.core.sympify import converter\n", "    >>> converter[MyList2] = lambda x: Matrix(x)\n", "    >>> sympify(MyList2())\n", "    Matrix([\n", "    [1],\n", "    [2]])\n", "\n", "    Notes\n", "    =====\n", "\n", "    The keywords ``rational`` and ``convert_xor`` are only used\n", "    when the input is a string.\n", "\n", "    Sometimes autosimplification during sympification results in expressions\n", "    that are very different in structure than what was entered. Until such\n", "    autosimplification is no longer done, the ``kernS`` function might be of\n", "    some use. In the example below you can see how an expression reduces to\n", "    -1 by autosimplification, but does not do so when ``kernS`` is used.\n", "\n", "    >>> from sympy.core.sympify import kernS\n", "    >>> from sympy.abc import x\n", "    >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n", "    -1\n", "    >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'\n", "    >>> sympify(s)\n", "    -1\n", "    >>> kernS(s)\n", "    -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n", "\n", "    \"\"\"\n", "    is_sympy = getattr(a, '__sympy__', None)\n", "    if is_sympy is not None:\n", "        return a\n", "\n", "    if isinstance(a, CantSympify):\n", "        raise SympifyError(a)\n", "    cls = getattr(a, \"__class__\", None)\n", "    if cls is None:\n", "        cls = type(a)  # Probably an old-style class\n", "    conv = converter.get(cls, None)\n", "    if conv is not None:\n", "        return conv(a)\n", "\n", "    for superclass in getmro(cls):\n", "        try:\n", "            return converter[superclass](a)\n", "        except KeyError:\n", "            continue\n", "\n", "    if cls is type(None):\n", "        if strict:\n", "            raise SympifyError(a)\n", "        else:\n", "            return a\n", "\n", "    if evaluate is None:\n", "        if global_evaluate[0] is False:\n", "            evaluate = global_evaluate[0]\n", "        else:\n", "            evaluate = True\n", "\n", "    # Support for basic numpy datatypes\n", "    # Note that this check exists to avoid importing NumPy when not necessary\n", "    if type(a).__module__ == 'numpy':\n", "        import numpy as np\n", "        if np.isscalar(a):\n", "            return _convert_numpy_types(a, locals=locals,\n", "                convert_xor=convert_xor, strict=strict, rational=rational,\n", "                evaluate=evaluate)\n", "\n", "    _sympy_ = getattr(a, \"_sympy_\", None)\n", "    if _sympy_ is not None:\n", "        try:\n", "            return a._sympy_()\n", "        # XXX: Catches AttributeError: 'SympyConverter' object has no\n", "        # attribute 'tuple'\n", "        # This is probably a bug somewhere but for now we catch it here.\n", "        except AttributeError:\n", "            pass\n", "\n", "    if not strict:\n", "        # Put numpy array conversion _before_ float/int, see\n", "        # <https://github.com/sympy/sympy/issues/13924>.\n", "        flat = getattr(a, \"flat\", None)\n", "        if flat is not None:\n", "            shape = getattr(a, \"shape\", None)\n", "            if shape is not None:\n", "                from ..tensor.array import Array\n", "                return Array(a.flat, a.shape)  # works with e.g. NumPy arrays\n", "\n", "    if not isinstance(a, string_types):\n", "        for coerce in (float, int):\n", "            try:\n", "                coerced = coerce(a)\n", "            except (TypeError, ValueError):\n", "                continue\n", "            # XXX: AttributeError only needed here for Py2\n", "            except AttributeError:\n", "                continue\n", "            try:\n", "                return sympify(coerced)\n", "            except SympifyError:\n", "                continue\n", "\n", "    if strict:\n", "        raise SympifyError(a)\n", "\n", "    if iterable(a):\n", "        try:\n", "            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,\n", "                rational=rational) for x in a])\n", "        except TypeError:\n", "            # Not all iterables are rebuildable with their type.\n", "            pass\n", "    if isinstance(a, dict):\n", "        try:\n", "            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,\n", "                rational=rational) for x in a.items()])\n", "        except TypeError:\n", "            # Not all iterables are rebuildable with their type.\n", "            pass\n", "\n", "    # At this point we were given an arbitrary expression\n", "    # which does not inherit from Basic and doesn't implement\n", "    # _sympy_ (which is a canonical and robust way to convert\n", "    # anything to SymPy expression).\n", "    #\n", "    # As a last chance, we try to take \"a\"'s normal form via unicode()\n", "    # and try to parse it. If it fails, then we have no luck and\n", "    # return an exception\n", "    try:\n", "        from .compatibility import unicode\n", "        a = unicode(a)\n", "    except Exception as exc:\n", "        raise SympifyError(a, exc)\n", "\n", "    from sympy.parsing.sympy_parser import (parse_expr, TokenError,\n", "                                            standard_transformations)\n", "    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n", "    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n", "\n", "    transformations = standard_transformations\n", "\n", "    if rational:\n", "        transformations += (t_rationalize,)\n", "    if convert_xor:\n", "        transformations += (t_convert_xor,)\n", "\n", "    try:\n", "        a = a.replace('\\n', '')\n", "        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n", "    except (TokenError, SyntaxError) as exc:\n", "        raise SympifyError('could not parse %r' % a, exc)\n", "\n", "    return expr\n"]}]}, {"file_path": "sympy/parsing/sympy_parser.py", "span_ids": ["eval_expr", "parse_expr"], "content": [{"span_id": "eval_expr", "start_line": 896, "end_line": 905, "content": ["def eval_expr(code, local_dict, global_dict):\n", "    \"\"\"\n", "    Evaluate Python code generated by ``stringify_expr``.\n", "\n", "    Generally, ``parse_expr`` should be used.\n", "    \"\"\"\n", "    expr = eval(\n", "        code, global_dict, local_dict)  # take local objects in preference\n", "\n", "    return expr\n"]}, {"span_id": "parse_expr", "start_line": 908, "end_line": 1008, "content": ["def parse_expr(s, local_dict=None, transformations=standard_transformations,\n", "               global_dict=None, evaluate=True):\n", "    \"\"\"Converts the string ``s`` to a SymPy expression, in ``local_dict``\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    s : str\n", "        The string to parse.\n", "\n", "    local_dict : dict, optional\n", "        A dictionary of local variables to use when parsing.\n", "\n", "    global_dict : dict, optional\n", "        A dictionary of global variables. By default, this is initialized\n", "        with ``from sympy import *``; provide this parameter to override\n", "        this behavior (for instance, to parse ``\"Q & S\"``).\n", "\n", "    transformations : tuple, optional\n", "        A tuple of transformation functions used to modify the tokens of the\n", "        parsed expression before evaluation. The default transformations\n", "        convert numeric literals into their SymPy equivalents, convert\n", "        undefined variables into SymPy symbols, and allow the use of standard\n", "        mathematical factorial notation (e.g. ``x!``).\n", "\n", "    evaluate : bool, optional\n", "        When False, the order of the arguments will remain as they were in the\n", "        string and automatic simplification that would normally occur is\n", "        suppressed. (see examples)\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.parsing.sympy_parser import parse_expr\n", "    >>> parse_expr(\"1/2\")\n", "    1/2\n", "    >>> type(_)\n", "    <class 'sympy.core.numbers.Half'>\n", "    >>> from sympy.parsing.sympy_parser import standard_transformations,\\\\\n", "    ... implicit_multiplication_application\n", "    >>> transformations = (standard_transformations +\n", "    ...     (implicit_multiplication_application,))\n", "    >>> parse_expr(\"2x\", transformations=transformations)\n", "    2*x\n", "\n", "    When evaluate=False, some automatic simplifications will not occur:\n", "\n", "    >>> parse_expr(\"2**3\"), parse_expr(\"2**3\", evaluate=False)\n", "    (8, 2**3)\n", "\n", "    In addition the order of the arguments will not be made canonical.\n", "    This feature allows one to tell exactly how the expression was entered:\n", "\n", "    >>> a = parse_expr('1 + x', evaluate=False)\n", "    >>> b = parse_expr('x + 1', evaluate=0)\n", "    >>> a == b\n", "    False\n", "    >>> a.args\n", "    (1, x)\n", "    >>> b.args\n", "    (x, 1)\n", "\n", "    See Also\n", "    ========\n", "\n", "    stringify_expr, eval_expr, standard_transformations,\n", "    implicit_multiplication_application\n", "\n", "    \"\"\"\n", "\n", "    if local_dict is None:\n", "        local_dict = {}\n", "    elif not isinstance(local_dict, dict):\n", "        raise TypeError('expecting local_dict to be a dict')\n", "\n", "    if global_dict is None:\n", "        global_dict = {}\n", "        exec_('from sympy import *', global_dict)\n", "    elif not isinstance(global_dict, dict):\n", "        raise TypeError('expecting global_dict to be a dict')\n", "\n", "    transformations = transformations or ()\n", "    if transformations:\n", "        if not iterable(transformations):\n", "            raise TypeError(\n", "                '`transformations` should be a list of functions.')\n", "        for _ in transformations:\n", "            if not callable(_):\n", "                raise TypeError(filldedent('''\n", "                    expected a function in `transformations`,\n", "                    not %s''' % func_name(_)))\n", "            if arity(_) != 3:\n", "                raise TypeError(filldedent('''\n", "                    a transformation should be function that\n", "                    takes 3 arguments'''))\n", "    code = stringify_expr(s, local_dict, global_dict, transformations)\n", "\n", "    if not evaluate:\n", "        code = compile(evaluateFalse(code), '<string>', 'eval')\n", "\n", "    return eval_expr(code, local_dict, global_dict)\n"]}]}]}