{"instance_id": "mwaskom__seaborn-2848", "identified_spans": [{"file_path": "seaborn/axisgrid.py", "span_ids": ["PairGrid._plot_bivariate", "PairGrid._map_bivariate", "PairGrid.map"], "content": [{"span_id": "PairGrid._plot_bivariate", "start_line": 1537, "end_line": 1574, "content": ["    def _plot_bivariate(self, x_var, y_var, ax, func, **kwargs):\n", "        \"\"\"Draw a bivariate plot on the specified axes.\"\"\"\n", "        if \"hue\" not in signature(func).parameters:\n", "            self._plot_bivariate_iter_hue(x_var, y_var, ax, func, **kwargs)\n", "            return\n", "\n", "        kwargs = kwargs.copy()\n", "        if str(func.__module__).startswith(\"seaborn\"):\n", "            kwargs[\"ax\"] = ax\n", "        else:\n", "            plt.sca(ax)\n", "\n", "        if x_var == y_var:\n", "            axes_vars = [x_var]\n", "        else:\n", "            axes_vars = [x_var, y_var]\n", "\n", "        if self._hue_var is not None and self._hue_var not in axes_vars:\n", "            axes_vars.append(self._hue_var)\n", "\n", "        data = self.data[axes_vars]\n", "        if self._dropna:\n", "            data = data.dropna()\n", "\n", "        x = data[x_var]\n", "        y = data[y_var]\n", "        if self._hue_var is None:\n", "            hue = None\n", "        else:\n", "            hue = data.get(self._hue_var)\n", "\n", "        if \"hue\" not in kwargs:\n", "            kwargs.update({\n", "                \"hue\": hue, \"hue_order\": self._hue_order, \"palette\": self._orig_palette,\n", "            })\n", "        func(x=x, y=y, **kwargs)\n", "\n", "        self._update_legend_data(ax)\n"]}, {"span_id": "PairGrid._map_bivariate", "start_line": 1515, "end_line": 1535, "content": ["    def _map_bivariate(self, func, indices, **kwargs):\n", "        \"\"\"Draw a bivariate plot on the indicated axes.\"\"\"\n", "        # This is a hack to handle the fact that new distribution plots don't add\n", "        # their artists onto the axes. This is probably superior in general, but\n", "        # we'll need a better way to handle it in the axisgrid functions.\n", "        from .distributions import histplot, kdeplot\n", "        if func is histplot or func is kdeplot:\n", "            self._extract_legend_handles = True\n", "\n", "        kws = kwargs.copy()  # Use copy as we insert other kwargs\n", "        for i, j in indices:\n", "            x_var = self.x_vars[j]\n", "            y_var = self.y_vars[i]\n", "            ax = self.axes[i, j]\n", "            if ax is None:  # i.e. we are in corner mode\n", "                continue\n", "            self._plot_bivariate(x_var, y_var, ax, func, **kws)\n", "        self._add_axis_labels()\n", "\n", "        if \"hue\" in signature(func).parameters:\n", "            self.hue_names = list(self._legend_data)\n"]}, {"span_id": "PairGrid.map", "start_line": 1320, "end_line": 1335, "content": ["    def map(self, func, **kwargs):\n", "        \"\"\"Plot with the same function in every subplot.\n", "\n", "        Parameters\n", "        ----------\n", "        func : callable plotting function\n", "            Must take x, y arrays as positional arguments and draw onto the\n", "            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n", "            called ``color`` and  ``label``.\n", "\n", "        \"\"\"\n", "        row_indices, col_indices = np.indices(self.axes.shape)\n", "        indices = zip(row_indices.flat, col_indices.flat)\n", "        self._map_bivariate(func, indices, **kwargs)\n", "\n", "        return self\n"]}]}]}