{"instance_id": "sympy__sympy-22005", "identified_spans": [{"file_path": "sympy/solvers/polysys.py", "span_ids": ["solve_generic", "solve_poly_system"], "content": [{"span_id": "solve_generic", "start_line": 135, "end_line": 292, "content": ["def solve_generic(polys, opt):\n", "    \"\"\"\n", "    Solve a generic system of polynomial equations.\n", "\n", "    Returns all possible solutions over C[x_1, x_2, ..., x_m] of a\n", "    set F = { f_1, f_2, ..., f_n } of polynomial equations,  using\n", "    Groebner basis approach. For now only zero-dimensional systems\n", "    are supported, which means F can have at most a finite number\n", "    of solutions.\n", "\n", "    The algorithm works by the fact that, supposing G is the basis\n", "    of F with respect to an elimination order  (here lexicographic\n", "    order is used), G and F generate the same ideal, they have the\n", "    same set of solutions. By the elimination property,  if G is a\n", "    reduced, zero-dimensional Groebner basis, then there exists an\n", "    univariate polynomial in G (in its last variable). This can be\n", "    solved by computing its roots. Substituting all computed roots\n", "    for the last (eliminated) variable in other elements of G, new\n", "    polynomial system is generated. Applying the above procedure\n", "    recursively, a finite number of solutions can be found.\n", "\n", "    The ability of finding all solutions by this procedure depends\n", "    on the root finding algorithms. If no solutions were found, it\n", "    means only that roots() failed, but the system is solvable. To\n", "    overcome this difficulty use numerical algorithms instead.\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    polys: a list/tuple/set\n", "        Listing all the polynomial equations that are needed to be solved\n", "    opt: an Options object\n", "        For specifying keyword arguments and generators\n", "\n", "    Returns\n", "    =======\n", "\n", "    List[Tuple]\n", "        A List of tuples. Solutions for symbols that satisfy the\n", "        equations listed in seq\n", "\n", "    References\n", "    ==========\n", "\n", "    .. [Buchberger01] B. Buchberger, Groebner Bases: A Short\n", "    Introduction for Systems Theorists, In: R. Moreno-Diaz,\n", "    B. Buchberger, J.L. Freire, Proceedings of EUROCAST'01,\n", "    February, 2001\n", "\n", "    .. [Cox97] D. Cox, J. Little, D. O'Shea, Ideals, Varieties\n", "    and Algorithms, Springer, Second Edition, 1997, pp. 112\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.polys import Poly, Options\n", "    >>> from sympy.solvers.polysys import solve_generic\n", "    >>> from sympy.abc import x, y\n", "    >>> NewOption = Options((x, y), {'domain': 'ZZ'})\n", "\n", "    >>> a = Poly(x - y + 5, x, y, domain='ZZ')\n", "    >>> b = Poly(x + y - 3, x, y, domain='ZZ')\n", "    >>> solve_generic([a, b], NewOption)\n", "    [(-1, 4)]\n", "\n", "    >>> a = Poly(x - 2*y + 5, x, y, domain='ZZ')\n", "    >>> b = Poly(2*x - y - 3, x, y, domain='ZZ')\n", "    >>> solve_generic([a, b], NewOption)\n", "    [(11/3, 13/3)]\n", "\n", "    >>> a = Poly(x**2 + y, x, y, domain='ZZ')\n", "    >>> b = Poly(x + y*4, x, y, domain='ZZ')\n", "    >>> solve_generic([a, b], NewOption)\n", "    [(0, 0), (1/4, -1/16)]\n", "    \"\"\"\n", "    def _is_univariate(f):\n", "        \"\"\"Returns True if 'f' is univariate in its last variable. \"\"\"\n", "        for monom in f.monoms():\n", "            if any(monom[:-1]):\n", "                return False\n", "\n", "        return True\n", "\n", "    def _subs_root(f, gen, zero):\n", "        \"\"\"Replace generator with a root so that the result is nice. \"\"\"\n", "        p = f.as_expr({gen: zero})\n", "\n", "        if f.degree(gen) >= 2:\n", "            p = p.expand(deep=False)\n", "\n", "        return p\n", "\n", "    def _solve_reduced_system(system, gens, entry=False):\n", "        \"\"\"Recursively solves reduced polynomial systems. \"\"\"\n", "        if len(system) == len(gens) == 1:\n", "            zeros = list(roots(system[0], gens[-1]).keys())\n", "            return [(zero,) for zero in zeros]\n", "\n", "        basis = groebner(system, gens, polys=True)\n", "\n", "        if len(basis) == 1 and basis[0].is_ground:\n", "            if not entry:\n", "                return []\n", "            else:\n", "                return None\n", "\n", "        univariate = list(filter(_is_univariate, basis))\n", "\n", "        if len(univariate) == 1:\n", "            f = univariate.pop()\n", "        else:\n", "            raise NotImplementedError(filldedent('''\n", "                only zero-dimensional systems supported\n", "                (finite number of solutions)\n", "                '''))\n", "\n", "        gens = f.gens\n", "        gen = gens[-1]\n", "\n", "        zeros = list(roots(f.ltrim(gen)).keys())\n", "\n", "        if not zeros:\n", "            return []\n", "\n", "        if len(basis) == 1:\n", "            return [(zero,) for zero in zeros]\n", "\n", "        solutions = []\n", "\n", "        for zero in zeros:\n", "            new_system = []\n", "            new_gens = gens[:-1]\n", "\n", "            for b in basis[:-1]:\n", "                eq = _subs_root(b, gen, zero)\n", "\n", "                if eq is not S.Zero:\n", "                    new_system.append(eq)\n", "\n", "            for solution in _solve_reduced_system(new_system, new_gens):\n", "                solutions.append(solution + (zero,))\n", "\n", "        if solutions and len(solutions[0]) != len(gens):\n", "            raise NotImplementedError(filldedent('''\n", "                only zero-dimensional systems supported\n", "                (finite number of solutions)\n", "                '''))\n", "        return solutions\n", "\n", "    try:\n", "        result = _solve_reduced_system(polys, opt.gens, entry=True)\n", "    except CoercionFailed:\n", "        raise NotImplementedError\n", "\n", "    if result is not None:\n", "        return sorted(result, key=default_sort_key)\n", "    else:\n", "        return None\n"]}, {"span_id": "solve_poly_system", "start_line": 17, "end_line": 63, "content": ["def solve_poly_system(seq, *gens, **args):\n", "    \"\"\"\n", "    Solve a system of polynomial equations.\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    seq: a list/tuple/set\n", "        Listing all the equations that are needed to be solved\n", "    gens: generators\n", "        generators of the equations in seq for which we want the\n", "        solutions\n", "    args: Keyword arguments\n", "        Special options for solving the equations\n", "\n", "    Returns\n", "    =======\n", "\n", "    List[Tuple]\n", "        A List of tuples. Solutions for symbols that satisfy the\n", "        equations listed in seq\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import solve_poly_system\n", "    >>> from sympy.abc import x, y\n", "\n", "    >>> solve_poly_system([x*y - 2*y, 2*y**2 - x**2], x, y)\n", "    [(0, 0), (2, -sqrt(2)), (2, sqrt(2))]\n", "\n", "    \"\"\"\n", "    try:\n", "        polys, opt = parallel_poly_from_expr(seq, *gens, **args)\n", "    except PolificationFailed as exc:\n", "        raise ComputationFailed('solve_poly_system', len(seq), exc)\n", "\n", "    if len(polys) == len(opt.gens) == 2:\n", "        f, g = polys\n", "\n", "        if all(i <= 2 for i in f.degree_list() + g.degree_list()):\n", "            try:\n", "                return solve_biquadratic(f, g, opt)\n", "            except SolveFailed:\n", "                pass\n", "\n", "    return solve_generic(polys, opt)\n"]}]}]}