{"instance_id": "sympy__sympy-21614", "identified_spans": [{"file_path": "sympy/core/function.py", "span_ids": ["Derivative.__new__", "Derivative"], "content": [{"span_id": "Derivative.__new__", "start_line": 1268, "end_line": 1512, "content": ["    def __new__(cls, expr, *variables, **kwargs):\n", "\n", "        from sympy.matrices.common import MatrixCommon\n", "        from sympy import Integer, MatrixExpr\n", "        from sympy.tensor.array import Array, NDimArray\n", "        from sympy.utilities.misc import filldedent\n", "\n", "        expr = sympify(expr)\n", "        symbols_or_none = getattr(expr, \"free_symbols\", None)\n", "        has_symbol_set = isinstance(symbols_or_none, set)\n", "\n", "        if not has_symbol_set:\n", "            raise ValueError(filldedent('''\n", "                Since there are no variables in the expression %s,\n", "                it cannot be differentiated.''' % expr))\n", "\n", "        # determine value for variables if it wasn't given\n", "        if not variables:\n", "            variables = expr.free_symbols\n", "            if len(variables) != 1:\n", "                if expr.is_number:\n", "                    return S.Zero\n", "                if len(variables) == 0:\n", "                    raise ValueError(filldedent('''\n", "                        Since there are no variables in the expression,\n", "                        the variable(s) of differentiation must be supplied\n", "                        to differentiate %s''' % expr))\n", "                else:\n", "                    raise ValueError(filldedent('''\n", "                        Since there is more than one variable in the\n", "                        expression, the variable(s) of differentiation\n", "                        must be supplied to differentiate %s''' % expr))\n", "\n", "        # Standardize the variables by sympifying them:\n", "        variables = list(sympify(variables))\n", "\n", "        # Split the list of variables into a list of the variables we are diff\n", "        # wrt, where each element of the list has the form (s, count) where\n", "        # s is the entity to diff wrt and count is the order of the\n", "        # derivative.\n", "        variable_count = []\n", "        array_likes = (tuple, list, Tuple)\n", "\n", "        for i, v in enumerate(variables):\n", "            if isinstance(v, Integer):\n", "                if i == 0:\n", "                    raise ValueError(\"First variable cannot be a number: %i\" % v)\n", "                count = v\n", "                prev, prevcount = variable_count[-1]\n", "                if prevcount != 1:\n", "                    raise TypeError(\"tuple {} followed by number {}\".format((prev, prevcount), v))\n", "                if count == 0:\n", "                    variable_count.pop()\n", "                else:\n", "                    variable_count[-1] = Tuple(prev, count)\n", "            else:\n", "                if isinstance(v, array_likes):\n", "                    if len(v) == 0:\n", "                        # Ignore empty tuples: Derivative(expr, ... , (), ... )\n", "                        continue\n", "                    if isinstance(v[0], array_likes):\n", "                        # Derive by array: Derivative(expr, ... , [[x, y, z]], ... )\n", "                        if len(v) == 1:\n", "                            v = Array(v[0])\n", "                            count = 1\n", "                        else:\n", "                            v, count = v\n", "                            v = Array(v)\n", "                    else:\n", "                        v, count = v\n", "                    if count == 0:\n", "                        continue\n", "                elif isinstance(v, UndefinedFunction):\n", "                    raise TypeError(\n", "                        \"cannot differentiate wrt \"\n", "                        \"UndefinedFunction: %s\" % v)\n", "                else:\n", "                    count = 1\n", "                variable_count.append(Tuple(v, count))\n", "\n", "        # light evaluation of contiguous, identical\n", "        # items: (x, 1), (x, 1) -> (x, 2)\n", "        merged = []\n", "        for t in variable_count:\n", "            v, c = t\n", "            if c.is_negative:\n", "                raise ValueError(\n", "                    'order of differentiation must be nonnegative')\n", "            if merged and merged[-1][0] == v:\n", "                c += merged[-1][1]\n", "                if not c:\n", "                    merged.pop()\n", "                else:\n", "                    merged[-1] = Tuple(v, c)\n", "            else:\n", "                merged.append(t)\n", "        variable_count = merged\n", "\n", "        # sanity check of variables of differentation; we waited\n", "        # until the counts were computed since some variables may\n", "        # have been removed because the count was 0\n", "        for v, c in variable_count:\n", "            # v must have _diff_wrt True\n", "            if not v._diff_wrt:\n", "                __ = ''  # filler to make error message neater\n", "                raise ValueError(filldedent('''\n", "                    Can't calculate derivative wrt %s.%s''' % (v,\n", "                    __)))\n", "\n", "        # We make a special case for 0th derivative, because there is no\n", "        # good way to unambiguously print this.\n", "        if len(variable_count) == 0:\n", "            return expr\n", "\n", "        evaluate = kwargs.get('evaluate', False)\n", "\n", "        if evaluate:\n", "            if isinstance(expr, Derivative):\n", "                expr = expr.canonical\n", "            variable_count = [\n", "                (v.canonical if isinstance(v, Derivative) else v, c)\n", "                for v, c in variable_count]\n", "\n", "            # Look for a quick exit if there are symbols that don't appear in\n", "            # expression at all. Note, this cannot check non-symbols like\n", "            # Derivatives as those can be created by intermediate\n", "            # derivatives.\n", "            zero = False\n", "            free = expr.free_symbols\n", "            for v, c in variable_count:\n", "                vfree = v.free_symbols\n", "                if c.is_positive and vfree:\n", "                    if isinstance(v, AppliedUndef):\n", "                        # these match exactly since\n", "                        # x.diff(f(x)) == g(x).diff(f(x)) == 0\n", "                        # and are not created by differentiation\n", "                        D = Dummy()\n", "                        if not expr.xreplace({v: D}).has(D):\n", "                            zero = True\n", "                            break\n", "                    elif isinstance(v, MatrixExpr):\n", "                        zero = False\n", "                        break\n", "                    elif isinstance(v, Symbol) and v not in free:\n", "                        zero = True\n", "                        break\n", "                    else:\n", "                        if not free & vfree:\n", "                            # e.g. v is IndexedBase or Matrix\n", "                            zero = True\n", "                            break\n", "            if zero:\n", "                return cls._get_zero_with_shape_like(expr)\n", "\n", "            # make the order of symbols canonical\n", "            #TODO: check if assumption of discontinuous derivatives exist\n", "            variable_count = cls._sort_variable_count(variable_count)\n", "\n", "        # denest\n", "        if isinstance(expr, Derivative):\n", "            variable_count = list(expr.variable_count) + variable_count\n", "            expr = expr.expr\n", "            return _derivative_dispatch(expr, *variable_count, **kwargs)\n", "\n", "        # we return here if evaluate is False or if there is no\n", "        # _eval_derivative method\n", "        if not evaluate or not hasattr(expr, '_eval_derivative'):\n", "            # return an unevaluated Derivative\n", "            if evaluate and variable_count == [(expr, 1)] and expr.is_scalar:\n", "                # special hack providing evaluation for classes\n", "                # that have defined is_scalar=True but have no\n", "                # _eval_derivative defined\n", "                return S.One\n", "            return Expr.__new__(cls, expr, *variable_count)\n", "\n", "        # evaluate the derivative by calling _eval_derivative method\n", "        # of expr for each variable\n", "        # -------------------------------------------------------------\n", "        nderivs = 0  # how many derivatives were performed\n", "        unhandled = []\n", "        for i, (v, count) in enumerate(variable_count):\n", "\n", "            old_expr = expr\n", "            old_v = None\n", "\n", "            is_symbol = v.is_symbol or isinstance(v,\n", "                (Iterable, Tuple, MatrixCommon, NDimArray))\n", "\n", "            if not is_symbol:\n", "                old_v = v\n", "                v = Dummy('xi')\n", "                expr = expr.xreplace({old_v: v})\n", "                # Derivatives and UndefinedFunctions are independent\n", "                # of all others\n", "                clashing = not (isinstance(old_v, Derivative) or \\\n", "                    isinstance(old_v, AppliedUndef))\n", "                if not v in expr.free_symbols and not clashing:\n", "                    return expr.diff(v)  # expr's version of 0\n", "                if not old_v.is_scalar and not hasattr(\n", "                        old_v, '_eval_derivative'):\n", "                    # special hack providing evaluation for classes\n", "                    # that have defined is_scalar=True but have no\n", "                    # _eval_derivative defined\n", "                    expr *= old_v.diff(old_v)\n", "\n", "            obj = cls._dispatch_eval_derivative_n_times(expr, v, count)\n", "            if obj is not None and obj.is_zero:\n", "                return obj\n", "\n", "            nderivs += count\n", "\n", "            if old_v is not None:\n", "                if obj is not None:\n", "                    # remove the dummy that was used\n", "                    obj = obj.subs(v, old_v)\n", "                # restore expr\n", "                expr = old_expr\n", "\n", "            if obj is None:\n", "                # we've already checked for quick-exit conditions\n", "                # that give 0 so the remaining variables\n", "                # are contained in the expression but the expression\n", "                # did not compute a derivative so we stop taking\n", "                # derivatives\n", "                unhandled = variable_count[i:]\n", "                break\n", "\n", "            expr = obj\n", "\n", "        # what we have so far can be made canonical\n", "        expr = expr.replace(\n", "            lambda x: isinstance(x, Derivative),\n", "            lambda x: x.canonical)\n", "\n", "        if unhandled:\n", "            if isinstance(expr, Derivative):\n", "                unhandled = list(expr.variable_count) + unhandled\n", "                expr = expr.expr\n", "            expr = Expr.__new__(cls, expr, *unhandled)\n", "\n", "        if (nderivs > 1) == True and kwargs.get('simplify', True):\n", "            from sympy.core.exprtools import factor_terms\n", "            from sympy.simplify.simplify import signsimp\n", "            expr = factor_terms(signsimp(expr))\n", "        return expr\n"]}, {"span_id": "Derivative", "start_line": 1053, "end_line": 1232, "content": ["class Derivative(Expr):\n", "    \"\"\"\n", "    Carries out differentiation of the given expression with respect to symbols.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import Derivative, Function, symbols, Subs\n", "    >>> from sympy.abc import x, y\n", "    >>> f, g = symbols('f g', cls=Function)\n", "\n", "    >>> Derivative(x**2, x, evaluate=True)\n", "    2*x\n", "\n", "    Denesting of derivatives retains the ordering of variables:\n", "\n", "        >>> Derivative(Derivative(f(x, y), y), x)\n", "        Derivative(f(x, y), y, x)\n", "\n", "    Contiguously identical symbols are merged into a tuple giving\n", "    the symbol and the count:\n", "\n", "        >>> Derivative(f(x), x, x, y, x)\n", "        Derivative(f(x), (x, 2), y, x)\n", "\n", "    If the derivative cannot be performed, and evaluate is True, the\n", "    order of the variables of differentiation will be made canonical:\n", "\n", "        >>> Derivative(f(x, y), y, x, evaluate=True)\n", "        Derivative(f(x, y), x, y)\n", "\n", "    Derivatives with respect to undefined functions can be calculated:\n", "\n", "        >>> Derivative(f(x)**2, f(x), evaluate=True)\n", "        2*f(x)\n", "\n", "    Such derivatives will show up when the chain rule is used to\n", "    evalulate a derivative:\n", "\n", "        >>> f(g(x)).diff(x)\n", "        Derivative(f(g(x)), g(x))*Derivative(g(x), x)\n", "\n", "    Substitution is used to represent derivatives of functions with\n", "    arguments that are not symbols or functions:\n", "\n", "        >>> f(2*x + 3).diff(x) == 2*Subs(f(y).diff(y), y, 2*x + 3)\n", "        True\n", "\n", "    Notes\n", "    =====\n", "\n", "    Simplification of high-order derivatives:\n", "\n", "    Because there can be a significant amount of simplification that can be\n", "    done when multiple differentiations are performed, results will be\n", "    automatically simplified in a fairly conservative fashion unless the\n", "    keyword ``simplify`` is set to False.\n", "\n", "        >>> from sympy import sqrt, diff, Function, symbols\n", "        >>> from sympy.abc import x, y, z\n", "        >>> f, g = symbols('f,g', cls=Function)\n", "\n", "        >>> e = sqrt((x + 1)**2 + x)\n", "        >>> diff(e, (x, 5), simplify=False).count_ops()\n", "        136\n", "        >>> diff(e, (x, 5)).count_ops()\n", "        30\n", "\n", "    Ordering of variables:\n", "\n", "    If evaluate is set to True and the expression cannot be evaluated, the\n", "    list of differentiation symbols will be sorted, that is, the expression is\n", "    assumed to have continuous derivatives up to the order asked.\n", "\n", "    Derivative wrt non-Symbols:\n", "\n", "    For the most part, one may not differentiate wrt non-symbols.\n", "    For example, we do not allow differentiation wrt `x*y` because\n", "    there are multiple ways of structurally defining where x*y appears\n", "    in an expression: a very strict definition would make\n", "    (x*y*z).diff(x*y) == 0. Derivatives wrt defined functions (like\n", "    cos(x)) are not allowed, either:\n", "\n", "        >>> (x*y*z).diff(x*y)\n", "        Traceback (most recent call last):\n", "        ...\n", "        ValueError: Can't calculate derivative wrt x*y.\n", "\n", "    To make it easier to work with variational calculus, however,\n", "    derivatives wrt AppliedUndef and Derivatives are allowed.\n", "    For example, in the Euler-Lagrange method one may write\n", "    F(t, u, v) where u = f(t) and v = f'(t). These variables can be\n", "    written explicitly as functions of time::\n", "\n", "        >>> from sympy.abc import t\n", "        >>> F = Function('F')\n", "        >>> U = f(t)\n", "        >>> V = U.diff(t)\n", "\n", "    The derivative wrt f(t) can be obtained directly:\n", "\n", "        >>> direct = F(t, U, V).diff(U)\n", "\n", "    When differentiation wrt a non-Symbol is attempted, the non-Symbol\n", "    is temporarily converted to a Symbol while the differentiation\n", "    is performed and the same answer is obtained:\n", "\n", "        >>> indirect = F(t, U, V).subs(U, x).diff(x).subs(x, U)\n", "        >>> assert direct == indirect\n", "\n", "    The implication of this non-symbol replacement is that all\n", "    functions are treated as independent of other functions and the\n", "    symbols are independent of the functions that contain them::\n", "\n", "        >>> x.diff(f(x))\n", "        0\n", "        >>> g(x).diff(f(x))\n", "        0\n", "\n", "    It also means that derivatives are assumed to depend only\n", "    on the variables of differentiation, not on anything contained\n", "    within the expression being differentiated::\n", "\n", "        >>> F = f(x)\n", "        >>> Fx = F.diff(x)\n", "        >>> Fx.diff(F)  # derivative depends on x, not F\n", "        0\n", "        >>> Fxx = Fx.diff(x)\n", "        >>> Fxx.diff(Fx)  # derivative depends on x, not Fx\n", "        0\n", "\n", "    The last example can be made explicit by showing the replacement\n", "    of Fx in Fxx with y:\n", "\n", "        >>> Fxx.subs(Fx, y)\n", "        Derivative(y, x)\n", "\n", "        Since that in itself will evaluate to zero, differentiating\n", "        wrt Fx will also be zero:\n", "\n", "        >>> _.doit()\n", "        0\n", "\n", "    Replacing undefined functions with concrete expressions\n", "\n", "    One must be careful to replace undefined functions with expressions\n", "    that contain variables consistent with the function definition and\n", "    the variables of differentiation or else insconsistent result will\n", "    be obtained. Consider the following example:\n", "\n", "    >>> eq = f(x)*g(y)\n", "    >>> eq.subs(f(x), x*y).diff(x, y).doit()\n", "    y*Derivative(g(y), y) + g(y)\n", "    >>> eq.diff(x, y).subs(f(x), x*y).doit()\n", "    y*Derivative(g(y), y)\n", "\n", "    The results differ because `f(x)` was replaced with an expression\n", "    that involved both variables of differentiation. In the abstract\n", "    case, differentiation of `f(x)` by `y` is 0; in the concrete case,\n", "    the presence of `y` made that derivative nonvanishing and produced\n", "    the extra `g(y)` term.\n", "\n", "    Defining differentiation for an object\n", "\n", "    An object must define ._eval_derivative(symbol) method that returns\n", "    the differentiation result. This function only needs to consider the\n", "    non-trivial case where expr contains symbol and it should call the diff()\n", "    method internally (not _eval_derivative); Derivative should be the only\n", "    one to call _eval_derivative.\n", "\n", "    Any class can allow derivatives to be taken with respect to\n", "    itself (while indicating its scalar nature). See the\n", "    docstring of Expr._diff_wrt.\n", "\n", "    See Also\n", "    ========\n", "    _sort_variable_count\n", "    \"\"\"\n", "\n", "    is_Derivative = True\n"]}]}, {"file_path": "sympy/core/kind.py", "span_ids": ["KindDispatcher", "Kind"], "content": [{"span_id": "KindDispatcher", "start_line": 190, "end_line": 257, "content": ["class KindDispatcher:\n", "    \"\"\"\n", "    Dispatcher to select a kind from multiple kinds by binary dispatching.\n", "\n", "    .. notes::\n", "       This approach is experimental, and can be replaced or deleted in\n", "       the future.\n", "\n", "    Explanation\n", "    ===========\n", "\n", "    SymPy object's :obj:`sympy.core.kind.Kind()` vaguely represents the\n", "    algebraic structure where the object belongs to. Therefore, with\n", "    given operation, we can always find a dominating kind among the\n", "    different kinds. This class selects the kind by recursive binary\n", "    dispatching. If the result cannot be determined, ``UndefinedKind``\n", "    is returned.\n", "\n", "    Examples\n", "    ========\n", "\n", "    Multiplication between numbers return number.\n", "\n", "    >>> from sympy import Mul\n", "    >>> from sympy.core import NumberKind\n", "    >>> Mul._kind_dispatcher(NumberKind, NumberKind)\n", "    NumberKind\n", "\n", "    Multiplication between number and unknown-kind object returns unknown kind.\n", "\n", "    >>> from sympy.core import UndefinedKind\n", "    >>> Mul._kind_dispatcher(NumberKind, UndefinedKind)\n", "    UndefinedKind\n", "\n", "    Any number and order of kinds is allowed.\n", "\n", "    >>> Mul._kind_dispatcher(UndefinedKind, NumberKind)\n", "    UndefinedKind\n", "    >>> Mul._kind_dispatcher(NumberKind, UndefinedKind, NumberKind)\n", "    UndefinedKind\n", "\n", "    Since matrix forms a vector space over scalar field, multiplication\n", "    between matrix with numeric element and number returns matrix with\n", "    numeric element.\n", "\n", "    >>> from sympy.matrices import MatrixKind\n", "    >>> Mul._kind_dispatcher(MatrixKind(NumberKind), NumberKind)\n", "    MatrixKind(NumberKind)\n", "\n", "    If a matrix with number element and another matrix with unknown-kind\n", "    element are multiplied, we know that the result is matrix but the\n", "    kind of its elements is unknown.\n", "\n", "    >>> Mul._kind_dispatcher(MatrixKind(NumberKind), MatrixKind(UndefinedKind))\n", "    MatrixKind(UndefinedKind)\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    name : str\n", "\n", "    commutative : bool, optional\n", "        If True, binary dispatch will be automatically registered in\n", "        reversed order as well.\n", "\n", "    doc : str, optional\n", "\n", "    \"\"\"\n"]}, {"span_id": "Kind", "start_line": 48, "end_line": 74, "content": ["class Kind(object, metaclass=KindMeta):\n", "    \"\"\"\n", "    Base class for kinds.\n", "\n", "    Kind of the object represents the mathematical classification that\n", "    the entity falls into. It is expected that functions and classes\n", "    recognize and filter the argument by its kind.\n", "\n", "    Kind of every object must be carefully selected so that it shows the\n", "    intention of design. Expressions may have different kind according\n", "    to the kind of its arguements. For example, arguements of ``Add``\n", "    must have common kind since addition is group operator, and the\n", "    resulting ``Add()`` has the same kind.\n", "\n", "    For the performance, each kind is as broad as possible and is not\n", "    based on set theory. For example, ``NumberKind`` includes not only\n", "    complex number but expression containing ``S.Infinity`` or ``S.NaN``\n", "    which are not strictly number.\n", "\n", "    Kind may have arguments as parameter. For example, ``MatrixKind()``\n", "    may be constructed with one element which represents the kind of its\n", "    elements.\n", "\n", "    ``Kind`` behaves in singleton-like fashion. Same signature will\n", "    return the same object.\n", "\n", "    \"\"\"\n"]}]}, {"file_path": "sympy/matrices/common.py", "span_ids": ["MatrixKind"], "content": [{"span_id": "MatrixKind", "start_line": 3151, "end_line": 3204, "content": ["class MatrixKind(Kind):\n", "    \"\"\"\n", "    Kind for all matrices in SymPy.\n", "\n", "    Basic class for this kind is ``MatrixBase`` and ``MatrixExpr``,\n", "    but any expression representing the matrix can have this.\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    element_kind : Kind\n", "        Kind of the element. Default is :obj:NumberKind `<sympy.core.kind.NumberKind>`,\n", "        which means that the matrix contains only numbers.\n", "\n", "    Examples\n", "    ========\n", "\n", "    Any instance of matrix class has ``MatrixKind``.\n", "\n", "    >>> from sympy import MatrixSymbol\n", "    >>> A = MatrixSymbol('A', 2,2)\n", "    >>> A.kind\n", "    MatrixKind(NumberKind)\n", "\n", "    Although expression representing a matrix may be not instance of\n", "    matrix class, it will have ``MatrixKind`` as well.\n", "\n", "    >>> from sympy import Integral\n", "    >>> from sympy.matrices.expressions import MatrixExpr\n", "    >>> from sympy.abc import x\n", "    >>> intM = Integral(A, x)\n", "    >>> isinstance(intM, MatrixExpr)\n", "    False\n", "    >>> intM.kind\n", "    MatrixKind(NumberKind)\n", "\n", "    Use ``isinstance()`` to check for ``MatrixKind` without specifying\n", "    the element kind. Use ``is`` with specifying the element kind.\n", "\n", "    >>> from sympy import Matrix\n", "    >>> from sympy.matrices import MatrixKind\n", "    >>> from sympy.core.kind import NumberKind\n", "    >>> M = Matrix([1, 2])\n", "    >>> isinstance(M.kind, MatrixKind)\n", "    True\n", "    >>> M.kind is MatrixKind(NumberKind)\n", "    True\n", "\n", "    See Also\n", "    ========\n", "\n", "    shape : Function to return the shape of objects with ``MatrixKind``.\n", "\n", "    \"\"\"\n"]}]}]}