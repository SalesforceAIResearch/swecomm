{"instance_id": "django__django-11001", "identified_spans": [{"file_path": "django/db/models/sql/compiler.py", "span_ids": ["SQLCompiler.get_extra_select", "SQLCompiler.get_order_by", "SQLCompiler"], "content": [{"span_id": "SQLCompiler.get_extra_select", "start_line": 364, "end_line": 372, "content": ["    def get_extra_select(self, order_by, select):\n", "        extra_select = []\n", "        if self.query.distinct and not self.query.distinct_fields:\n", "            select_sql = [t[1] for t in select]\n", "            for expr, (sql, params, is_ref) in order_by:\n", "                without_ordering = self.ordering_parts.search(sql).group(1)\n", "                if not is_ref and (without_ordering, params) not in select_sql:\n", "                    extra_select.append((expr, (without_ordering, params), None))\n", "        return extra_select\n"]}, {"span_id": "SQLCompiler.get_order_by", "start_line": 252, "end_line": 362, "content": ["    def get_order_by(self):\n", "        \"\"\"\n", "        Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n", "        ORDER BY clause.\n", "\n", "        The order_by clause can alter the select clause (for example it\n", "        can add aliases to clauses that do not yet have one, or it can\n", "        add totally new select clauses).\n", "        \"\"\"\n", "        if self.query.extra_order_by:\n", "            ordering = self.query.extra_order_by\n", "        elif not self.query.default_ordering:\n", "            ordering = self.query.order_by\n", "        elif self.query.order_by:\n", "            ordering = self.query.order_by\n", "        elif self.query.get_meta().ordering:\n", "            ordering = self.query.get_meta().ordering\n", "            self._meta_ordering = ordering\n", "        else:\n", "            ordering = []\n", "        if self.query.standard_ordering:\n", "            asc, desc = ORDER_DIR['ASC']\n", "        else:\n", "            asc, desc = ORDER_DIR['DESC']\n", "\n", "        order_by = []\n", "        for field in ordering:\n", "            if hasattr(field, 'resolve_expression'):\n", "                if not isinstance(field, OrderBy):\n", "                    field = field.asc()\n", "                if not self.query.standard_ordering:\n", "                    field.reverse_ordering()\n", "                order_by.append((field, False))\n", "                continue\n", "            if field == '?':  # random\n", "                order_by.append((OrderBy(Random()), False))\n", "                continue\n", "\n", "            col, order = get_order_dir(field, asc)\n", "            descending = order == 'DESC'\n", "\n", "            if col in self.query.annotation_select:\n", "                # Reference to expression in SELECT clause\n", "                order_by.append((\n", "                    OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),\n", "                    True))\n", "                continue\n", "            if col in self.query.annotations:\n", "                # References to an expression which is masked out of the SELECT clause\n", "                order_by.append((\n", "                    OrderBy(self.query.annotations[col], descending=descending),\n", "                    False))\n", "                continue\n", "\n", "            if '.' in field:\n", "                # This came in through an extra(order_by=...) addition. Pass it\n", "                # on verbatim.\n", "                table, col = col.split('.', 1)\n", "                order_by.append((\n", "                    OrderBy(\n", "                        RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),\n", "                        descending=descending\n", "                    ), False))\n", "                continue\n", "\n", "            if not self.query.extra or col not in self.query.extra:\n", "                # 'col' is of the form 'field' or 'field1__field2' or\n", "                # '-field1__field2__field', etc.\n", "                order_by.extend(self.find_ordering_name(\n", "                    field, self.query.get_meta(), default_order=asc))\n", "            else:\n", "                if col not in self.query.extra_select:\n", "                    order_by.append((\n", "                        OrderBy(RawSQL(*self.query.extra[col]), descending=descending),\n", "                        False))\n", "                else:\n", "                    order_by.append((\n", "                        OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),\n", "                        True))\n", "        result = []\n", "        seen = set()\n", "\n", "        for expr, is_ref in order_by:\n", "            resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n", "            if self.query.combinator:\n", "                src = resolved.get_source_expressions()[0]\n", "                # Relabel order by columns to raw numbers if this is a combined\n", "                # query; necessary since the columns can't be referenced by the\n", "                # fully qualified name and the simple column names may collide.\n", "                for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n", "                    if is_ref and col_alias == src.refs:\n", "                        src = src.source\n", "                    elif col_alias:\n", "                        continue\n", "                    if src == sel_expr:\n", "                        resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n", "                        break\n", "                else:\n", "                    raise DatabaseError('ORDER BY term does not match any column in the result set.')\n", "            sql, params = self.compile(resolved)\n", "            # Don't add the same column twice, but the order direction is\n", "            # not taken into account so we strip it. When this entire method\n", "            # is refactored into expressions, then we can check each part as we\n", "            # generate it.\n", "            without_ordering = self.ordering_parts.search(sql).group(1)\n", "            params_hash = make_hashable(params)\n", "            if (without_ordering, params_hash) in seen:\n", "                continue\n", "            seen.add((without_ordering, params_hash))\n", "            result.append((resolved, (sql, params, is_ref)))\n", "        return result\n"]}, {"span_id": "SQLCompiler", "start_line": 22, "end_line": 22, "content": ["class SQLCompiler:\n"]}]}]}