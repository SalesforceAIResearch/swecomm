{"instance_id": "django__django-12856", "identified_spans": [{"file_path": "django/db/migrations/autodetector.py", "span_ids": ["MigrationAutodetector.generate_added_constraints"], "content": [{"span_id": "MigrationAutodetector.generate_added_constraints", "start_line": 1047, "end_line": 1056, "content": ["    def generate_added_constraints(self):\n", "        for (app_label, model_name), alt_constraints in self.altered_constraints.items():\n", "            for constraint in alt_constraints['added_constraints']:\n", "                self.add_operation(\n", "                    app_label,\n", "                    operations.AddConstraint(\n", "                        model_name=model_name,\n", "                        constraint=constraint,\n", "                    )\n", "                )\n"]}]}, {"file_path": "django/db/models/base.py", "span_ids": ["Model._check_constraints", "Model.check", "Model._check_unique_together"], "content": [{"span_id": "Model._check_constraints", "start_line": 1866, "end_line": 1929, "content": ["    @classmethod\n", "    def _check_constraints(cls, databases):\n", "        errors = []\n", "        for db in databases:\n", "            if not router.allow_migrate_model(db, cls):\n", "                continue\n", "            connection = connections[db]\n", "            if not (\n", "                connection.features.supports_table_check_constraints or\n", "                'supports_table_check_constraints' in cls._meta.required_db_features\n", "            ) and any(\n", "                isinstance(constraint, CheckConstraint)\n", "                for constraint in cls._meta.constraints\n", "            ):\n", "                errors.append(\n", "                    checks.Warning(\n", "                        '%s does not support check constraints.' % connection.display_name,\n", "                        hint=(\n", "                            \"A constraint won't be created. Silence this \"\n", "                            \"warning if you don't care about it.\"\n", "                        ),\n", "                        obj=cls,\n", "                        id='models.W027',\n", "                    )\n", "                )\n", "            if not (\n", "                connection.features.supports_partial_indexes or\n", "                'supports_partial_indexes' in cls._meta.required_db_features\n", "            ) and any(\n", "                isinstance(constraint, UniqueConstraint) and constraint.condition is not None\n", "                for constraint in cls._meta.constraints\n", "            ):\n", "                errors.append(\n", "                    checks.Warning(\n", "                        '%s does not support unique constraints with '\n", "                        'conditions.' % connection.display_name,\n", "                        hint=(\n", "                            \"A constraint won't be created. Silence this \"\n", "                            \"warning if you don't care about it.\"\n", "                        ),\n", "                        obj=cls,\n", "                        id='models.W036',\n", "                    )\n", "                )\n", "            if not (\n", "                connection.features.supports_deferrable_unique_constraints or\n", "                'supports_deferrable_unique_constraints' in cls._meta.required_db_features\n", "            ) and any(\n", "                isinstance(constraint, UniqueConstraint) and constraint.deferrable is not None\n", "                for constraint in cls._meta.constraints\n", "            ):\n", "                errors.append(\n", "                    checks.Warning(\n", "                        '%s does not support deferrable unique constraints.'\n", "                        % connection.display_name,\n", "                        hint=(\n", "                            \"A constraint won't be created. Silence this \"\n", "                            \"warning if you don't care about it.\"\n", "                        ),\n", "                        obj=cls,\n", "                        id='models.W038',\n", "                    )\n", "                )\n", "        return errors\n"]}, {"span_id": "Model.check", "start_line": 1255, "end_line": 1285, "content": ["    @classmethod\n", "    def check(cls, **kwargs):\n", "        errors = [*cls._check_swappable(), *cls._check_model(), *cls._check_managers(**kwargs)]\n", "        if not cls._meta.swapped:\n", "            databases = kwargs.get('databases') or []\n", "            errors += [\n", "                *cls._check_fields(**kwargs),\n", "                *cls._check_m2m_through_same_relationship(),\n", "                *cls._check_long_column_names(databases),\n", "            ]\n", "            clash_errors = (\n", "                *cls._check_id_field(),\n", "                *cls._check_field_name_clashes(),\n", "                *cls._check_model_name_db_lookup_clashes(),\n", "                *cls._check_property_name_related_field_accessor_clashes(),\n", "                *cls._check_single_primary_key(),\n", "            )\n", "            errors.extend(clash_errors)\n", "            # If there are field name clashes, hide consequent column name\n", "            # clashes.\n", "            if not clash_errors:\n", "                errors.extend(cls._check_column_name_clashes())\n", "            errors += [\n", "                *cls._check_index_together(),\n", "                *cls._check_unique_together(),\n", "                *cls._check_indexes(databases),\n", "                *cls._check_ordering(),\n", "                *cls._check_constraints(databases),\n", "            ]\n", "\n", "        return errors\n"]}, {"span_id": "Model._check_unique_together", "start_line": 1561, "end_line": 1586, "content": ["    @classmethod\n", "    def _check_unique_together(cls):\n", "        \"\"\"Check the value of \"unique_together\" option.\"\"\"\n", "        if not isinstance(cls._meta.unique_together, (tuple, list)):\n", "            return [\n", "                checks.Error(\n", "                    \"'unique_together' must be a list or tuple.\",\n", "                    obj=cls,\n", "                    id='models.E010',\n", "                )\n", "            ]\n", "\n", "        elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):\n", "            return [\n", "                checks.Error(\n", "                    \"All 'unique_together' elements must be lists or tuples.\",\n", "                    obj=cls,\n", "                    id='models.E011',\n", "                )\n", "            ]\n", "\n", "        else:\n", "            errors = []\n", "            for fields in cls._meta.unique_together:\n", "                errors.extend(cls._check_local_fields(fields, \"unique_together\"))\n", "            return errors\n"]}]}, {"file_path": "django/db/models/constraints.py", "span_ids": ["UniqueConstraint", "UniqueConstraint.__init__"], "content": [{"span_id": "UniqueConstraint", "start_line": 79, "end_line": 79, "content": ["class UniqueConstraint(BaseConstraint):\n"]}, {"span_id": "UniqueConstraint.__init__", "start_line": 80, "end_line": 96, "content": ["    def __init__(self, *, fields, name, condition=None, deferrable=None):\n", "        if not fields:\n", "            raise ValueError('At least one field is required to define a unique constraint.')\n", "        if not isinstance(condition, (type(None), Q)):\n", "            raise ValueError('UniqueConstraint.condition must be a Q instance.')\n", "        if condition and deferrable:\n", "            raise ValueError(\n", "                'UniqueConstraint with conditions cannot be deferred.'\n", "            )\n", "        if not isinstance(deferrable, (type(None), Deferrable)):\n", "            raise ValueError(\n", "                'UniqueConstraint.deferrable must be a Deferrable instance.'\n", "            )\n", "        self.fields = tuple(fields)\n", "        self.condition = condition\n", "        self.deferrable = deferrable\n", "        super().__init__(name)\n"]}]}]}