{"instance_id": "django__django-11019", "identified_spans": [{"file_path": "django/forms/widgets.py", "span_ids": ["Media", "MediaOrderConflictWarning", "Media.__init__", "media_property", "Media._css", "Media._js", "Media.merge", "MediaDefiningClass", "Media.__add__"], "content": [{"span_id": "Media", "start_line": 40, "end_line": 40, "content": ["@html_safe\n"]}, {"span_id": "MediaOrderConflictWarning", "start_line": 36, "end_line": 37, "content": ["class MediaOrderConflictWarning(RuntimeWarning):\n", "    pass\n"]}, {"span_id": "Media.__init__", "start_line": 42, "end_line": 52, "content": ["    def __init__(self, media=None, css=None, js=None):\n", "        if media is not None:\n", "            css = getattr(media, 'css', {})\n", "            js = getattr(media, 'js', [])\n", "        else:\n", "            if css is None:\n", "                css = {}\n", "            if js is None:\n", "                js = []\n", "        self._css_lists = [css]\n", "        self._js_lists = [js]\n"]}, {"span_id": "media_property", "start_line": 159, "end_line": 182, "content": ["def media_property(cls):\n", "    def _media(self):\n", "        # Get the media property of the superclass, if it exists\n", "        sup_cls = super(cls, self)\n", "        try:\n", "            base = sup_cls.media\n", "        except AttributeError:\n", "            base = Media()\n", "\n", "        # Get the media definition for this class\n", "        definition = getattr(cls, 'Media', None)\n", "        if definition:\n", "            extend = getattr(definition, 'extend', True)\n", "            if extend:\n", "                if extend is True:\n", "                    m = base\n", "                else:\n", "                    m = Media()\n", "                    for medium in extend:\n", "                        m = m + base[medium]\n", "                return m + Media(definition)\n", "            return Media(definition)\n", "        return base\n", "    return property(_media)\n"]}, {"span_id": "Media._css", "start_line": 60, "end_line": 69, "content": ["    @property\n", "    def _css(self):\n", "        css = self._css_lists[0]\n", "        # filter(None, ...) avoids calling merge with empty dicts.\n", "        for obj in filter(None, self._css_lists[1:]):\n", "            css = {\n", "                medium: self.merge(css.get(medium, []), obj.get(medium, []))\n", "                for medium in css.keys() | obj.keys()\n", "            }\n", "        return css\n"]}, {"span_id": "Media._js", "start_line": 71, "end_line": 77, "content": ["    @property\n", "    def _js(self):\n", "        js = self._js_lists[0]\n", "        # filter(None, ...) avoids calling merge() with empty lists.\n", "        for obj in filter(None, self._js_lists[1:]):\n", "            js = self.merge(js, obj)\n", "        return js\n"]}, {"span_id": "Media.merge", "start_line": 117, "end_line": 150, "content": ["    @staticmethod\n", "    def merge(list_1, list_2):\n", "        \"\"\"\n", "        Merge two lists while trying to keep the relative order of the elements.\n", "        Warn if the lists have the same two elements in a different relative\n", "        order.\n", "\n", "        For static assets it can be important to have them included in the DOM\n", "        in a certain order. In JavaScript you may not be able to reference a\n", "        global or in CSS you might want to override a style.\n", "        \"\"\"\n", "        # Start with a copy of list_1.\n", "        combined_list = list(list_1)\n", "        last_insert_index = len(list_1)\n", "        # Walk list_2 in reverse, inserting each element into combined_list if\n", "        # it doesn't already exist.\n", "        for path in reversed(list_2):\n", "            try:\n", "                # Does path already exist in the list?\n", "                index = combined_list.index(path)\n", "            except ValueError:\n", "                # Add path to combined_list since it doesn't exist.\n", "                combined_list.insert(last_insert_index, path)\n", "            else:\n", "                if index > last_insert_index:\n", "                    warnings.warn(\n", "                        'Detected duplicate Media files in an opposite order:\\n'\n", "                        '%s\\n%s' % (combined_list[last_insert_index], combined_list[index]),\n", "                        MediaOrderConflictWarning,\n", "                    )\n", "                # path already exists in the list. Update last_insert_index so\n", "                # that the following elements are inserted in front of this one.\n", "                last_insert_index = index\n", "        return combined_list\n"]}, {"span_id": "MediaDefiningClass", "start_line": 185, "end_line": 188, "content": ["class MediaDefiningClass(type):\n", "    \"\"\"\n", "    Metaclass for classes that can have media definitions.\n", "    \"\"\"\n"]}, {"span_id": "Media.__add__", "start_line": 152, "end_line": 156, "content": ["    def __add__(self, other):\n", "        combined = Media()\n", "        combined._css_lists = self._css_lists + other._css_lists\n", "        combined._js_lists = self._js_lists + other._js_lists\n", "        return combined\n"]}]}]}