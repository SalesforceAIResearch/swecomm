{"instance_id": "sphinx-doc__sphinx-8282", "identified_spans": [{"file_path": "sphinx/ext/autodoc/__init__.py", "span_ids": ["FunctionDocumenter", "ClassDocumenter.format_signature", "FunctionDocumenter.format_args", "FunctionDocumenter.format_signature", "ClassDocumenter.format_args", "ClassDocumenter"], "content": [{"span_id": "FunctionDocumenter", "start_line": 1196, "end_line": 1201, "content": ["class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n", "    \"\"\"\n", "    Specialized Documenter subclass for functions.\n", "    \"\"\"\n", "    objtype = 'function'\n", "    member_order = 30\n"]}, {"span_id": "ClassDocumenter.format_signature", "start_line": 1469, "end_line": 1493, "content": ["    def format_signature(self, **kwargs: Any) -> str:\n", "        if self.doc_as_attr:\n", "            return ''\n", "\n", "        sig = super().format_signature()\n", "        sigs = []\n", "\n", "        overloads = self.get_overloaded_signatures()\n", "        if overloads:\n", "            # Use signatures for overloaded methods instead of the implementation method.\n", "            method = safe_getattr(self._signature_class, self._signature_method_name, None)\n", "            __globals__ = safe_getattr(method, '__globals__', {})\n", "            for overload in overloads:\n", "                overload = evaluate_signature(overload, __globals__,\n", "                                              self.env.config.autodoc_type_aliases)\n", "\n", "                parameters = list(overload.parameters.values())\n", "                overload = overload.replace(parameters=parameters[1:],\n", "                                            return_annotation=Parameter.empty)\n", "                sig = stringify_signature(overload, **kwargs)\n", "                sigs.append(sig)\n", "        else:\n", "            sigs.append(sig)\n", "\n", "        return \"\\n\".join(sigs)\n"]}, {"span_id": "FunctionDocumenter.format_args", "start_line": 1210, "end_line": 1229, "content": ["    def format_args(self, **kwargs: Any) -> str:\n", "        if self.env.config.autodoc_typehints in ('none', 'description'):\n", "            kwargs.setdefault('show_annotation', False)\n", "\n", "        try:\n", "            self.env.app.emit('autodoc-before-process-signature', self.object, False)\n", "            sig = inspect.signature(self.object, follow_wrapped=True,\n", "                                    type_aliases=self.env.config.autodoc_type_aliases)\n", "            args = stringify_signature(sig, **kwargs)\n", "        except TypeError as exc:\n", "            logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n", "                           self.fullname, exc)\n", "            return None\n", "        except ValueError:\n", "            args = ''\n", "\n", "        if self.env.config.strip_signature_backslash:\n", "            # escape backslashes for reST\n", "            args = args.replace('\\\\', '\\\\\\\\')\n", "        return args\n"]}, {"span_id": "FunctionDocumenter.format_signature", "start_line": 1241, "end_line": 1272, "content": ["    def format_signature(self, **kwargs: Any) -> str:\n", "        sigs = []\n", "        if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n", "            # Use signatures for overloaded functions instead of the implementation function.\n", "            overloaded = True\n", "        else:\n", "            overloaded = False\n", "            sig = super().format_signature(**kwargs)\n", "            sigs.append(sig)\n", "\n", "        if inspect.is_singledispatch_function(self.object):\n", "            # append signature of singledispatch'ed functions\n", "            for typ, func in self.object.registry.items():\n", "                if typ is object:\n", "                    pass  # default implementation. skipped.\n", "                else:\n", "                    self.annotate_to_first_argument(func, typ)\n", "\n", "                    documenter = FunctionDocumenter(self.directive, '')\n", "                    documenter.object = func\n", "                    documenter.objpath = [None]\n", "                    sigs.append(documenter.format_signature())\n", "        if overloaded:\n", "            __globals__ = safe_getattr(self.object, '__globals__', {})\n", "            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n", "                overload = evaluate_signature(overload, __globals__,\n", "                                              self.env.config.autodoc_type_aliases)\n", "\n", "                sig = stringify_signature(overload, **kwargs)\n", "                sigs.append(sig)\n", "\n", "        return \"\\n\".join(sigs)\n"]}, {"span_id": "ClassDocumenter.format_args", "start_line": 1452, "end_line": 1467, "content": ["    def format_args(self, **kwargs: Any) -> str:\n", "        if self.env.config.autodoc_typehints in ('none', 'description'):\n", "            kwargs.setdefault('show_annotation', False)\n", "\n", "        try:\n", "            self._signature_class, self._signature_method_name, sig = self._get_signature()\n", "        except TypeError as exc:\n", "            # __signature__ attribute contained junk\n", "            logger.warning(__(\"Failed to get a constructor signature for %s: %s\"),\n", "                           self.fullname, exc)\n", "            return None\n", "\n", "        if sig is None:\n", "            return None\n", "\n", "        return stringify_signature(sig, show_return_annotation=False, **kwargs)\n"]}, {"span_id": "ClassDocumenter", "start_line": 1342, "end_line": 1357, "content": ["class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n", "    \"\"\"\n", "    Specialized Documenter subclass for classes.\n", "    \"\"\"\n", "    objtype = 'class'\n", "    member_order = 20\n", "    option_spec = {\n", "        'members': members_option, 'undoc-members': bool_option,\n", "        'noindex': bool_option, 'inherited-members': inherited_members_option,\n", "        'show-inheritance': bool_option, 'member-order': member_order_option,\n", "        'exclude-members': exclude_members_option,\n", "        'private-members': members_option, 'special-members': members_option,\n", "    }  # type: Dict[str, Callable]\n", "\n", "    _signature_class = None  # type: Any\n", "    _signature_method_name = None  # type: str\n"]}]}, {"file_path": "sphinx/ext/autodoc/typehints.py", "span_ids": ["merge_typehints"], "content": [{"span_id": "merge_typehints", "start_line": 41, "end_line": 67, "content": ["def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n", "    if domain != 'py':\n", "        return\n", "    if app.config.autodoc_typehints != 'description':\n", "        return\n", "    if objtype == 'class' and app.config.autoclass_content not in ('init', 'both'):\n", "        return\n", "\n", "    try:\n", "        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n", "        if signature['module']:\n", "            fullname = '.'.join([signature['module'], signature['fullname']])\n", "        else:\n", "            fullname = signature['fullname']\n", "    except KeyError:\n", "        # signature node does not have valid context info for the target object\n", "        return\n", "\n", "    annotations = app.env.temp_data.get('annotations', {})\n", "    if annotations.get(fullname, {}):\n", "        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n", "        if field_lists == []:\n", "            field_list = insert_field_list(contentnode)\n", "            field_lists.append(field_list)\n", "\n", "        for field_list in field_lists:\n", "            modify_field_list(field_list, annotations[fullname])\n"]}]}]}