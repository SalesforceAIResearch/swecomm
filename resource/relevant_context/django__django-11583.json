{"instance_id": "django__django-11583", "identified_spans": [{"file_path": "django/utils/autoreload.py", "span_ids": ["BaseReloader.watched_files", "StatReloader.snapshot_files", "iter_modules_and_files", "iter_all_python_module_files"], "content": [{"span_id": "BaseReloader.watched_files", "start_line": 251, "end_line": 261, "content": ["    def watched_files(self, include_globs=True):\n", "        \"\"\"\n", "        Yield all files that need to be watched, including module files and\n", "        files within globs.\n", "        \"\"\"\n", "        yield from iter_all_python_module_files()\n", "        yield from self.extra_files\n", "        if include_globs:\n", "            for directory, patterns in self.directory_globs.items():\n", "                for pattern in patterns:\n", "                    yield from directory.glob(pattern)\n"]}, {"span_id": "StatReloader.snapshot_files", "start_line": 354, "end_line": 366, "content": ["    def snapshot_files(self):\n", "        # watched_files may produce duplicate paths if globs overlap.\n", "        seen_files = set()\n", "        for file in self.watched_files():\n", "            if file in seen_files:\n", "                continue\n", "            try:\n", "                mtime = file.stat().st_mtime\n", "            except OSError:\n", "                # This is thrown when the file does not exist.\n", "                continue\n", "            seen_files.add(file)\n", "            yield file, mtime\n"]}, {"span_id": "iter_modules_and_files", "start_line": 108, "end_line": 147, "content": ["@functools.lru_cache(maxsize=1)\n", "def iter_modules_and_files(modules, extra_files):\n", "    \"\"\"Iterate through all modules needed to be watched.\"\"\"\n", "    sys_file_paths = []\n", "    for module in modules:\n", "        # During debugging (with PyDev) the 'typing.io' and 'typing.re' objects\n", "        # are added to sys.modules, however they are types not modules and so\n", "        # cause issues here.\n", "        if not isinstance(module, ModuleType):\n", "            continue\n", "        if module.__name__ == '__main__':\n", "            # __main__ (usually manage.py) doesn't always have a __spec__ set.\n", "            # Handle this by falling back to using __file__, resolved below.\n", "            # See https://docs.python.org/reference/import.html#main-spec\n", "            # __file__ may not exists, e.g. when running ipdb debugger.\n", "            if hasattr(module, '__file__'):\n", "                sys_file_paths.append(module.__file__)\n", "            continue\n", "        if getattr(module, '__spec__', None) is None:\n", "            continue\n", "        spec = module.__spec__\n", "        # Modules could be loaded from places without a concrete location. If\n", "        # this is the case, skip them.\n", "        if spec.has_location:\n", "            origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\n", "            sys_file_paths.append(origin)\n", "\n", "    results = set()\n", "    for filename in itertools.chain(sys_file_paths, extra_files):\n", "        if not filename:\n", "            continue\n", "        path = Path(filename)\n", "        try:\n", "            resolved_path = path.resolve(strict=True).absolute()\n", "        except FileNotFoundError:\n", "            # The module could have been removed, don't fail loudly if this\n", "            # is the case.\n", "            continue\n", "        results.add(resolved_path)\n", "    return frozenset(results)\n"]}, {"span_id": "iter_all_python_module_files", "start_line": 98, "end_line": 105, "content": ["def iter_all_python_module_files():\n", "    # This is a hot path during reloading. Create a stable sorted list of\n", "    # modules based on the module name and pass it to iter_modules_and_files().\n", "    # This ensures cached results are returned in the usual case that modules\n", "    # aren't loaded on the fly.\n", "    keys = sorted(sys.modules)\n", "    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n", "    return iter_modules_and_files(modules, frozenset(_error_files))\n"]}]}]}