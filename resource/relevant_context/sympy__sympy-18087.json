{"instance_id": "sympy__sympy-18087", "identified_spans": [{"file_path": "sympy/functions/elementary/trigonometric.py", "span_ids": ["sin", "cos"], "content": [{"span_id": "sin", "start_line": 203, "end_line": 249, "content": ["class sin(TrigonometricFunction):\n", "    \"\"\"\n", "    The sine function.\n", "\n", "    Returns the sine of x (measured in radians).\n", "\n", "    Notes\n", "    =====\n", "\n", "    This function will evaluate automatically in the\n", "    case x/pi is some rational number [4]_.  For example,\n", "    if x is a multiple of pi, pi/2, pi/3, pi/4 and pi/6.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import sin, pi\n", "    >>> from sympy.abc import x\n", "    >>> sin(x**2).diff(x)\n", "    2*x*cos(x**2)\n", "    >>> sin(1).diff(x)\n", "    0\n", "    >>> sin(pi)\n", "    0\n", "    >>> sin(pi/2)\n", "    1\n", "    >>> sin(pi/6)\n", "    1/2\n", "    >>> sin(pi/12)\n", "    -sqrt(2)/4 + sqrt(6)/4\n", "\n", "\n", "    See Also\n", "    ========\n", "\n", "    csc, cos, sec, tan, cot\n", "    asin, acsc, acos, asec, atan, acot, atan2\n", "\n", "    References\n", "    ==========\n", "\n", "    .. [1] https://en.wikipedia.org/wiki/Trigonometric_functions\n", "    .. [2] http://dlmf.nist.gov/4.14\n", "    .. [3] http://functions.wolfram.com/ElementaryFunctions/Sin\n", "    .. [4] http://mathworld.wolfram.com/TrigonometryAngles.html\n", "\n", "    \"\"\"\n"]}, {"span_id": "cos", "start_line": 495, "end_line": 537, "content": ["class cos(TrigonometricFunction):\n", "    \"\"\"\n", "    The cosine function.\n", "\n", "    Returns the cosine of x (measured in radians).\n", "\n", "    Notes\n", "    =====\n", "\n", "    See :func:`sin` for notes about automatic evaluation.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import cos, pi\n", "    >>> from sympy.abc import x\n", "    >>> cos(x**2).diff(x)\n", "    -2*x*sin(x**2)\n", "    >>> cos(1).diff(x)\n", "    0\n", "    >>> cos(pi)\n", "    -1\n", "    >>> cos(pi/2)\n", "    0\n", "    >>> cos(2*pi/3)\n", "    -1/2\n", "    >>> cos(pi/12)\n", "    sqrt(2)/4 + sqrt(6)/4\n", "\n", "    See Also\n", "    ========\n", "\n", "    sin, csc, sec, tan, cot\n", "    asin, acsc, acos, asec, atan, acot, atan2\n", "\n", "    References\n", "    ==========\n", "\n", "    .. [1] https://en.wikipedia.org/wiki/Trigonometric_functions\n", "    .. [2] http://dlmf.nist.gov/4.14\n", "    .. [3] http://functions.wolfram.com/ElementaryFunctions/Cos\n", "\n", "    \"\"\"\n"]}]}, {"file_path": "sympy/simplify/trigsimp.py", "span_ids": ["__trigsimp", "trigsimp"], "content": [{"span_id": "__trigsimp", "start_line": 938, "end_line": 1065, "content": ["@cacheit\n", "def __trigsimp(expr, deep=False):\n", "    \"\"\"recursive helper for trigsimp\"\"\"\n", "    from sympy.simplify.fu import TR10i\n", "\n", "    if _trigpat is None:\n", "        _trigpats()\n", "    a, b, c, d, matchers_division, matchers_add, \\\n", "    matchers_identity, artifacts = _trigpat\n", "\n", "    if expr.is_Mul:\n", "        # do some simplifications like sin/cos -> tan:\n", "        if not expr.is_commutative:\n", "            com, nc = expr.args_cnc()\n", "            expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)\n", "        else:\n", "            for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):\n", "                if not _dotrig(expr, pattern):\n", "                    continue\n", "\n", "                newexpr = _match_div_rewrite(expr, i)\n", "                if newexpr is not None:\n", "                    if newexpr != expr:\n", "                        expr = newexpr\n", "                        break\n", "                    else:\n", "                        continue\n", "\n", "                # use SymPy matching instead\n", "                res = expr.match(pattern)\n", "                if res and res.get(c, 0):\n", "                    if not res[c].is_integer:\n", "                        ok = ok1.subs(res)\n", "                        if not ok.is_positive:\n", "                            continue\n", "                        ok = ok2.subs(res)\n", "                        if not ok.is_positive:\n", "                            continue\n", "                    # if \"a\" contains any of trig or hyperbolic funcs with\n", "                    # argument \"b\" then skip the simplification\n", "                    if any(w.args[0] == res[b] for w in res[a].atoms(\n", "                            TrigonometricFunction, HyperbolicFunction)):\n", "                        continue\n", "                    # simplify and finish:\n", "                    expr = simp.subs(res)\n", "                    break  # process below\n", "\n", "    if expr.is_Add:\n", "        args = []\n", "        for term in expr.args:\n", "            if not term.is_commutative:\n", "                com, nc = term.args_cnc()\n", "                nc = Mul._from_args(nc)\n", "                term = Mul._from_args(com)\n", "            else:\n", "                nc = S.One\n", "            term = _trigsimp(term, deep)\n", "            for pattern, result in matchers_identity:\n", "                res = term.match(pattern)\n", "                if res is not None:\n", "                    term = result.subs(res)\n", "                    break\n", "            args.append(term*nc)\n", "        if args != expr.args:\n", "            expr = Add(*args)\n", "            expr = min(expr, expand(expr), key=count_ops)\n", "        if expr.is_Add:\n", "            for pattern, result in matchers_add:\n", "                if not _dotrig(expr, pattern):\n", "                    continue\n", "                expr = TR10i(expr)\n", "                if expr.has(HyperbolicFunction):\n", "                    res = expr.match(pattern)\n", "                    # if \"d\" contains any trig or hyperbolic funcs with\n", "                    # argument \"a\" or \"b\" then skip the simplification;\n", "                    # this isn't perfect -- see tests\n", "                    if res is None or not (a in res and b in res) or any(\n", "                        w.args[0] in (res[a], res[b]) for w in res[d].atoms(\n", "                            TrigonometricFunction, HyperbolicFunction)):\n", "                        continue\n", "                    expr = result.subs(res)\n", "                    break\n", "\n", "        # Reduce any lingering artifacts, such as sin(x)**2 changing\n", "        # to 1 - cos(x)**2 when sin(x)**2 was \"simpler\"\n", "        for pattern, result, ex in artifacts:\n", "            if not _dotrig(expr, pattern):\n", "                continue\n", "            # Substitute a new wild that excludes some function(s)\n", "            # to help influence a better match. This is because\n", "            # sometimes, for example, 'a' would match sec(x)**2\n", "            a_t = Wild('a', exclude=[ex])\n", "            pattern = pattern.subs(a, a_t)\n", "            result = result.subs(a, a_t)\n", "\n", "            m = expr.match(pattern)\n", "            was = None\n", "            while m and was != expr:\n", "                was = expr\n", "                if m[a_t] == 0 or \\\n", "                        -m[a_t] in m[c].args or m[a_t] + m[c] == 0:\n", "                    break\n", "                if d in m and m[a_t]*m[d] + m[c] == 0:\n", "                    break\n", "                expr = result.subs(m)\n", "                m = expr.match(pattern)\n", "                m.setdefault(c, S.Zero)\n", "\n", "    elif expr.is_Mul or expr.is_Pow or deep and expr.args:\n", "        expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])\n", "\n", "    try:\n", "        if not expr.has(*_trigs):\n", "            raise TypeError\n", "        e = expr.atoms(exp)\n", "        new = expr.rewrite(exp, deep=deep)\n", "        if new == e:\n", "            raise TypeError\n", "        fnew = factor(new)\n", "        if fnew != new:\n", "            new = sorted([new, factor(new)], key=count_ops)[0]\n", "        # if all exp that were introduced disappeared then accept it\n", "        if not (new.atoms(exp) - e):\n", "            expr = new\n", "    except TypeError:\n", "        pass\n", "\n", "    return expr\n"]}, {"span_id": "trigsimp", "start_line": 424, "end_line": 508, "content": ["def trigsimp(expr, **opts):\n", "    \"\"\"\n", "    reduces expression by using known trig identities\n", "\n", "    Notes\n", "    =====\n", "\n", "    method:\n", "    - Determine the method to use. Valid choices are 'matching' (default),\n", "    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n", "    expression recursively by targeting common patterns. If 'groebner', apply\n", "    an experimental groebner basis algorithm. In this case further options\n", "    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n", "    If 'combined', first run the groebner basis algorithm with small\n", "    default parameters, then run the 'matching' algorithm. 'fu' runs the\n", "    collection of trigonometric transformations described by Fu, et al.\n", "    (see the `fu` docstring).\n", "\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import trigsimp, sin, cos, log\n", "    >>> from sympy.abc import x, y\n", "    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n", "    >>> trigsimp(e)\n", "    2\n", "\n", "    Simplification occurs wherever trigonometric functions are located.\n", "\n", "    >>> trigsimp(log(e))\n", "    log(2)\n", "\n", "    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n", "    simplification.\n", "\n", "    The old trigsimp routine can be accessed as with method 'old'.\n", "\n", "    >>> from sympy import coth, tanh\n", "    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n", "    >>> trigsimp(t, method='old') == t\n", "    True\n", "    >>> trigsimp(t)\n", "    tanh(x)**7\n", "\n", "    \"\"\"\n", "    from sympy.simplify.fu import fu\n", "\n", "    expr = sympify(expr)\n", "\n", "    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n", "    if _eval_trigsimp is not None:\n", "        return _eval_trigsimp(**opts)\n", "\n", "    old = opts.pop('old', False)\n", "    if not old:\n", "        opts.pop('deep', None)\n", "        opts.pop('recursive', None)\n", "        method = opts.pop('method', 'matching')\n", "    else:\n", "        method = 'old'\n", "\n", "    def groebnersimp(ex, **opts):\n", "        def traverse(e):\n", "            if e.is_Atom:\n", "                return e\n", "            args = [traverse(x) for x in e.args]\n", "            if e.is_Function or e.is_Pow:\n", "                args = [trigsimp_groebner(x, **opts) for x in args]\n", "            return e.func(*args)\n", "        new = traverse(ex)\n", "        if not isinstance(new, Expr):\n", "            return new\n", "        return trigsimp_groebner(new, **opts)\n", "\n", "    trigsimpfunc = {\n", "        'fu': (lambda x: fu(x, **opts)),\n", "        'matching': (lambda x: futrig(x)),\n", "        'groebner': (lambda x: groebnersimp(x, **opts)),\n", "        'combined': (lambda x: futrig(groebnersimp(x,\n", "                               polynomial=True, hints=[2, tan]))),\n", "        'old': lambda x: trigsimp_old(x, **opts),\n", "                   }[method]\n", "\n", "    return trigsimpfunc(expr)\n"]}]}]}