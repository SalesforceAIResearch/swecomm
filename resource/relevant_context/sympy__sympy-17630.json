{"instance_id": "sympy__sympy-17630", "identified_spans": [{"file_path": "sympy/matrices/expressions/blockmatrix.py", "span_ids": ["bc_matmul", "BlockMatrix._blockmul", "BlockMatrix", "block_collapse"], "content": [{"span_id": "bc_matmul", "start_line": 454, "end_line": 477, "content": ["def bc_matmul(expr):\n", "    if isinstance(expr, MatPow):\n", "        if expr.args[1].is_Integer:\n", "            factor, matrices = (1, [expr.args[0]]*expr.args[1])\n", "        else:\n", "            return expr\n", "    else:\n", "        factor, matrices = expr.as_coeff_matrices()\n", "\n", "    i = 0\n", "    while (i+1 < len(matrices)):\n", "        A, B = matrices[i:i+2]\n", "        if isinstance(A, BlockMatrix) and isinstance(B, BlockMatrix):\n", "            matrices[i] = A._blockmul(B)\n", "            matrices.pop(i+1)\n", "        elif isinstance(A, BlockMatrix):\n", "            matrices[i] = A._blockmul(BlockMatrix([[B]]))\n", "            matrices.pop(i+1)\n", "        elif isinstance(B, BlockMatrix):\n", "            matrices[i] = BlockMatrix([[A]])._blockmul(B)\n", "            matrices.pop(i+1)\n", "        else:\n", "            i+=1\n", "    return MatMul(factor, *matrices).doit()\n"]}, {"span_id": "BlockMatrix._blockmul", "start_line": 164, "end_line": 169, "content": ["    def _blockmul(self, other):\n", "        if (isinstance(other, BlockMatrix) and\n", "                self.colblocksizes == other.rowblocksizes):\n", "            return BlockMatrix(self.blocks*other.blocks)\n", "\n", "        return self * other\n"]}, {"span_id": "BlockMatrix", "start_line": 23, "end_line": 78, "content": ["class BlockMatrix(MatrixExpr):\n", "    \"\"\"A BlockMatrix is a Matrix comprised of other matrices.\n", "\n", "    The submatrices are stored in a SymPy Matrix object but accessed as part of\n", "    a Matrix Expression\n", "\n", "    >>> from sympy import (MatrixSymbol, BlockMatrix, symbols,\n", "    ...     Identity, ZeroMatrix, block_collapse)\n", "    >>> n,m,l = symbols('n m l')\n", "    >>> X = MatrixSymbol('X', n, n)\n", "    >>> Y = MatrixSymbol('Y', m ,m)\n", "    >>> Z = MatrixSymbol('Z', n, m)\n", "    >>> B = BlockMatrix([[X, Z], [ZeroMatrix(m,n), Y]])\n", "    >>> print(B)\n", "    Matrix([\n", "    [X, Z],\n", "    [0, Y]])\n", "\n", "    >>> C = BlockMatrix([[Identity(n), Z]])\n", "    >>> print(C)\n", "    Matrix([[I, Z]])\n", "\n", "    >>> print(block_collapse(C*B))\n", "    Matrix([[X, Z + Z*Y]])\n", "\n", "    Some matrices might be comprised of rows of blocks with\n", "    the matrices in each row having the same height and the\n", "    rows all having the same total number of columns but\n", "    not having the same number of columns for each matrix\n", "    in each row. In this case, the matrix is not a block\n", "    matrix and should be instantiated by Matrix.\n", "\n", "    >>> from sympy import ones, Matrix\n", "    >>> dat = [\n", "    ... [ones(3,2), ones(3,3)*2],\n", "    ... [ones(2,3)*3, ones(2,2)*4]]\n", "    ...\n", "    >>> BlockMatrix(dat)\n", "    Traceback (most recent call last):\n", "    ...\n", "    ValueError:\n", "    Although this matrix is comprised of blocks, the blocks do not fill\n", "    the matrix in a size-symmetric fashion. To create a full matrix from\n", "    these arguments, pass them directly to Matrix.\n", "    >>> Matrix(dat)\n", "    Matrix([\n", "    [1, 1, 2, 2, 2],\n", "    [1, 1, 2, 2, 2],\n", "    [1, 1, 2, 2, 2],\n", "    [3, 3, 3, 4, 4],\n", "    [3, 3, 3, 4, 4]])\n", "\n", "    See Also\n", "    ========\n", "    sympy.matrices.matrices.MatrixBase.irregular\n", "    \"\"\"\n"]}, {"span_id": "block_collapse", "start_line": 348, "end_line": 398, "content": ["def block_collapse(expr):\n", "    \"\"\"Evaluates a block matrix expression\n", "\n", "    >>> from sympy import MatrixSymbol, BlockMatrix, symbols, \\\n", "                          Identity, Matrix, ZeroMatrix, block_collapse\n", "    >>> n,m,l = symbols('n m l')\n", "    >>> X = MatrixSymbol('X', n, n)\n", "    >>> Y = MatrixSymbol('Y', m ,m)\n", "    >>> Z = MatrixSymbol('Z', n, m)\n", "    >>> B = BlockMatrix([[X, Z], [ZeroMatrix(m, n), Y]])\n", "    >>> print(B)\n", "    Matrix([\n", "    [X, Z],\n", "    [0, Y]])\n", "\n", "    >>> C = BlockMatrix([[Identity(n), Z]])\n", "    >>> print(C)\n", "    Matrix([[I, Z]])\n", "\n", "    >>> print(block_collapse(C*B))\n", "    Matrix([[X, Z + Z*Y]])\n", "    \"\"\"\n", "    from sympy.strategies.util import expr_fns\n", "\n", "    hasbm = lambda expr: isinstance(expr, MatrixExpr) and expr.has(BlockMatrix)\n", "\n", "    conditioned_rl = condition(\n", "        hasbm,\n", "        typed(\n", "            {MatAdd: do_one(bc_matadd, bc_block_plus_ident),\n", "             MatMul: do_one(bc_matmul, bc_dist),\n", "             MatPow: bc_matmul,\n", "             Transpose: bc_transpose,\n", "             Inverse: bc_inverse,\n", "             BlockMatrix: do_one(bc_unpack, deblock)}\n", "        )\n", "    )\n", "\n", "    rule = exhaust(\n", "        bottom_up(\n", "            exhaust(conditioned_rl),\n", "            fns=expr_fns\n", "        )\n", "    )\n", "\n", "    result = rule(expr)\n", "    doit = getattr(result, 'doit', None)\n", "    if doit is not None:\n", "        return doit()\n", "    else:\n", "        return result\n"]}]}, {"file_path": "sympy/matrices/expressions/matexpr.py", "span_ids": ["ZeroMatrix"], "content": [{"span_id": "ZeroMatrix", "start_line": 932, "end_line": 946, "content": ["class ZeroMatrix(MatrixExpr):\n", "    \"\"\"The Matrix Zero 0 - additive identity\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import MatrixSymbol, ZeroMatrix\n", "    >>> A = MatrixSymbol('A', 3, 5)\n", "    >>> Z = ZeroMatrix(3, 5)\n", "    >>> A + Z\n", "    A\n", "    >>> Z*A.T\n", "    0\n", "    \"\"\"\n", "    is_ZeroMatrix = True\n"]}]}]}