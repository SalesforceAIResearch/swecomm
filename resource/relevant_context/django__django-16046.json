{"instance_id": "django__django-16046", "identified_spans": [{"file_path": "django/utils/numberformat.py", "span_ids": ["format"], "content": [{"span_id": "format", "start_line": 7, "end_line": 104, "content": ["def format(\n", "    number,\n", "    decimal_sep,\n", "    decimal_pos=None,\n", "    grouping=0,\n", "    thousand_sep=\"\",\n", "    force_grouping=False,\n", "    use_l10n=None,\n", "):\n", "    \"\"\"\n", "    Get a number (as a number or string), and return it as a string,\n", "    using formats defined as arguments:\n", "\n", "    * decimal_sep: Decimal separator symbol (for example \".\")\n", "    * decimal_pos: Number of decimal positions\n", "    * grouping: Number of digits in every group limited by thousand separator.\n", "        For non-uniform digit grouping, it can be a sequence with the number\n", "        of digit group sizes following the format used by the Python locale\n", "        module in locale.localeconv() LC_NUMERIC grouping (e.g. (3, 2, 0)).\n", "    * thousand_sep: Thousand separator symbol (for example \",\")\n", "    \"\"\"\n", "    use_grouping = (\n", "        use_l10n or (use_l10n is None and settings.USE_L10N)\n", "    ) and settings.USE_THOUSAND_SEPARATOR\n", "    use_grouping = use_grouping or force_grouping\n", "    use_grouping = use_grouping and grouping != 0\n", "    # Make the common case fast\n", "    if isinstance(number, int) and not use_grouping and not decimal_pos:\n", "        return mark_safe(number)\n", "    # sign\n", "    sign = \"\"\n", "    # Treat potentially very large/small floats as Decimals.\n", "    if isinstance(number, float) and \"e\" in str(number).lower():\n", "        number = Decimal(str(number))\n", "    if isinstance(number, Decimal):\n", "\n", "        if decimal_pos is not None:\n", "            # If the provided number is too small to affect any of the visible\n", "            # decimal places, consider it equal to '0'.\n", "            cutoff = Decimal(\"0.\" + \"1\".rjust(decimal_pos, \"0\"))\n", "            if abs(number) < cutoff:\n", "                number = Decimal(\"0\")\n", "\n", "        # Format values with more than 200 digits (an arbitrary cutoff) using\n", "        # scientific notation to avoid high memory usage in {:f}'.format().\n", "        _, digits, exponent = number.as_tuple()\n", "        if abs(exponent) + len(digits) > 200:\n", "            number = \"{:e}\".format(number)\n", "            coefficient, exponent = number.split(\"e\")\n", "            # Format the coefficient.\n", "            coefficient = format(\n", "                coefficient,\n", "                decimal_sep,\n", "                decimal_pos,\n", "                grouping,\n", "                thousand_sep,\n", "                force_grouping,\n", "                use_l10n,\n", "            )\n", "            return \"{}e{}\".format(coefficient, exponent)\n", "        else:\n", "            str_number = \"{:f}\".format(number)\n", "    else:\n", "        str_number = str(number)\n", "    if str_number[0] == \"-\":\n", "        sign = \"-\"\n", "        str_number = str_number[1:]\n", "    # decimal part\n", "    if \".\" in str_number:\n", "        int_part, dec_part = str_number.split(\".\")\n", "        if decimal_pos is not None:\n", "            dec_part = dec_part[:decimal_pos]\n", "    else:\n", "        int_part, dec_part = str_number, \"\"\n", "    if decimal_pos is not None:\n", "        dec_part = dec_part + (\"0\" * (decimal_pos - len(dec_part)))\n", "    dec_part = dec_part and decimal_sep + dec_part\n", "    # grouping\n", "    if use_grouping:\n", "        try:\n", "            # if grouping is a sequence\n", "            intervals = list(grouping)\n", "        except TypeError:\n", "            # grouping is a single value\n", "            intervals = [grouping, 0]\n", "        active_interval = intervals.pop(0)\n", "        int_part_gd = \"\"\n", "        cnt = 0\n", "        for digit in int_part[::-1]:\n", "            if cnt and cnt == active_interval:\n", "                if intervals:\n", "                    active_interval = intervals.pop(0) or active_interval\n", "                int_part_gd += thousand_sep[::-1]\n", "                cnt = 0\n", "            int_part_gd += digit\n", "            cnt += 1\n", "        int_part = int_part_gd[::-1]\n", "    return sign + int_part + dec_part\n"]}]}]}