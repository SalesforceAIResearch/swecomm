{"instance_id": "matplotlib__matplotlib-25442", "identified_spans": [{"file_path": "galleries/examples/event_handling/cursor_demo.py", "span_ids": ["Cursor", "BlittedCursor", "BlittedCursor.__init__", "BlittedCursor.on_draw", "Cursor.__init__", "BlittedCursor.create_new_background"], "content": [{"span_id": "Cursor", "start_line": 34, "end_line": 37, "content": ["class Cursor:\n", "    \"\"\"\n", "    A cross hair cursor.\n", "    \"\"\"\n"]}, {"span_id": "BlittedCursor", "start_line": 96, "end_line": 99, "content": ["class BlittedCursor:\n", "    \"\"\"\n", "    A cross-hair cursor using blitting for faster redraw.\n", "    \"\"\"\n"]}, {"span_id": "BlittedCursor.__init__", "start_line": 100, "end_line": 108, "content": ["    def __init__(self, ax):\n", "        self.ax = ax\n", "        self.background = None\n", "        self.horizontal_line = ax.axhline(color='k', lw=0.8, ls='--')\n", "        self.vertical_line = ax.axvline(color='k', lw=0.8, ls='--')\n", "        # text location in axes coordinates\n", "        self.text = ax.text(0.72, 0.9, '', transform=ax.transAxes)\n", "        self._creating_background = False\n", "        ax.figure.canvas.mpl_connect('draw_event', self.on_draw)\n"]}, {"span_id": "BlittedCursor.on_draw", "start_line": 110, "end_line": 111, "content": ["    def on_draw(self, event):\n", "        self.create_new_background()\n"]}, {"span_id": "Cursor.__init__", "start_line": 38, "end_line": 43, "content": ["    def __init__(self, ax):\n", "        self.ax = ax\n", "        self.horizontal_line = ax.axhline(color='k', lw=0.8, ls='--')\n", "        self.vertical_line = ax.axvline(color='k', lw=0.8, ls='--')\n", "        # text location in axes coordinates\n", "        self.text = ax.text(0.72, 0.9, '', transform=ax.transAxes)\n"]}, {"span_id": "BlittedCursor.create_new_background", "start_line": 120, "end_line": 129, "content": ["    def create_new_background(self):\n", "        if self._creating_background:\n", "            # discard calls triggered from within this function\n", "            return\n", "        self._creating_background = True\n", "        self.set_cross_hair_visible(False)\n", "        self.ax.figure.canvas.draw()\n", "        self.background = self.ax.figure.canvas.copy_from_bbox(self.ax.bbox)\n", "        self.set_cross_hair_visible(True)\n", "        self._creating_background = False\n"]}]}, {"file_path": "lib/matplotlib/backends/backend_qt.py", "span_ids": ["FigureCanvasQT.__init__", "FigureCanvasQT.mouseMoveEvent", "FigureCanvasQT", "FigureCanvasQT.mousePressEvent"], "content": [{"span_id": "FigureCanvasQT.__init__", "start_line": 203, "end_line": 218, "content": ["    def __init__(self, figure=None):\n", "        _create_qApp()\n", "        super().__init__(figure=figure)\n", "\n", "        self._draw_pending = False\n", "        self._is_drawing = False\n", "        self._draw_rect_callback = lambda painter: None\n", "        self._in_resize_event = False\n", "\n", "        self.setAttribute(\n", "            _enum(\"QtCore.Qt.WidgetAttribute\").WA_OpaquePaintEvent)\n", "        self.setMouseTracking(True)\n", "        self.resize(*self.get_width_height())\n", "\n", "        palette = QtGui.QPalette(QtGui.QColor(\"white\"))\n", "        self.setPalette(palette)\n"]}, {"span_id": "FigureCanvasQT.mouseMoveEvent", "start_line": 301, "end_line": 305, "content": ["    def mouseMoveEvent(self, event):\n", "        MouseEvent(\"motion_notify_event\", self,\n", "                   *self.mouseEventCoords(event),\n", "                   modifiers=self._mpl_modifiers(),\n", "                   guiEvent=event)._process()\n"]}, {"span_id": "FigureCanvasQT", "start_line": 188, "end_line": 201, "content": ["class FigureCanvasQT(FigureCanvasBase, QtWidgets.QWidget):\n", "    required_interactive_framework = \"qt\"\n", "    _timer_cls = TimerQT\n", "    manager_class = _api.classproperty(lambda cls: FigureManagerQT)\n", "\n", "    buttond = {\n", "        getattr(_enum(\"QtCore.Qt.MouseButton\"), k): v for k, v in [\n", "            (\"LeftButton\", MouseButton.LEFT),\n", "            (\"RightButton\", MouseButton.RIGHT),\n", "            (\"MiddleButton\", MouseButton.MIDDLE),\n", "            (\"XButton1\", MouseButton.BACK),\n", "            (\"XButton2\", MouseButton.FORWARD),\n", "        ]\n", "    }\n"]}, {"span_id": "FigureCanvasQT.mousePressEvent", "start_line": 285, "end_line": 291, "content": ["    def mousePressEvent(self, event):\n", "        button = self.buttond.get(event.button())\n", "        if button is not None:\n", "            MouseEvent(\"button_press_event\", self,\n", "                       *self.mouseEventCoords(event), button,\n", "                       modifiers=self._mpl_modifiers(),\n", "                       guiEvent=event)._process()\n"]}]}, {"file_path": "lib/matplotlib/widgets.py", "span_ids": ["MultiCursor", "Cursor.clear", "Cursor.__init__", "MultiCursor.onmove", "Cursor._update", "Cursor", "MultiCursor.clear", "MultiCursor._update", "MultiCursor.__init__", "Cursor.onmove"], "content": [{"span_id": "MultiCursor", "start_line": 2038, "end_line": 2073, "content": ["class MultiCursor(Widget):\n", "    \"\"\"\n", "    Provide a vertical (default) and/or horizontal line cursor shared between\n", "    multiple Axes.\n", "\n", "    For the cursor to remain responsive you must keep a reference to it.\n", "\n", "    Parameters\n", "    ----------\n", "    canvas : object\n", "        This parameter is entirely unused and only kept for back-compatibility.\n", "\n", "    axes : list of `matplotlib.axes.Axes`\n", "        The `~.axes.Axes` to attach the cursor to.\n", "\n", "    useblit : bool, default: True\n", "        Use blitting for faster drawing if supported by the backend.\n", "        See the tutorial :doc:`/tutorials/advanced/blitting`\n", "        for details.\n", "\n", "    horizOn : bool, default: False\n", "        Whether to draw the horizontal line.\n", "\n", "    vertOn : bool, default: True\n", "        Whether to draw the vertical line.\n", "\n", "    Other Parameters\n", "    ----------------\n", "    **lineprops\n", "        `.Line2D` properties that control the appearance of the lines.\n", "        See also `~.Axes.axhline`.\n", "\n", "    Examples\n", "    --------\n", "    See :doc:`/gallery/widgets/multicursor`.\n", "    \"\"\"\n"]}, {"span_id": "Cursor.clear", "start_line": 1994, "end_line": 1999, "content": ["    def clear(self, event):\n", "        \"\"\"Internal event handler to clear the cursor.\"\"\"\n", "        if self.ignore(event) or self._changed_canvas():\n", "            return\n", "        if self.useblit:\n", "            self.background = self.canvas.copy_from_bbox(self.ax.bbox)\n"]}, {"span_id": "Cursor.__init__", "start_line": 1973, "end_line": 1992, "content": ["    @_api.make_keyword_only(\"3.7\", \"horizOn\")\n", "    def __init__(self, ax, horizOn=True, vertOn=True, useblit=False,\n", "                 **lineprops):\n", "        super().__init__(ax)\n", "\n", "        self.connect_event('motion_notify_event', self.onmove)\n", "        self.connect_event('draw_event', self.clear)\n", "\n", "        self.visible = True\n", "        self.horizOn = horizOn\n", "        self.vertOn = vertOn\n", "        self.useblit = useblit and self.canvas.supports_blit\n", "\n", "        if self.useblit:\n", "            lineprops['animated'] = True\n", "        self.lineh = ax.axhline(ax.get_ybound()[0], visible=False, **lineprops)\n", "        self.linev = ax.axvline(ax.get_xbound()[0], visible=False, **lineprops)\n", "\n", "        self.background = None\n", "        self.needclear = False\n"]}, {"span_id": "MultiCursor.onmove", "start_line": 2143, "end_line": 2155, "content": ["    def onmove(self, event):\n", "        if (self.ignore(event)\n", "                or event.inaxes not in self.axes\n", "                or not event.canvas.widgetlock.available(self)):\n", "            return\n", "        for line in self.vlines:\n", "            line.set_xdata((event.xdata, event.xdata))\n", "            line.set_visible(self.visible and self.vertOn)\n", "        for line in self.hlines:\n", "            line.set_ydata((event.ydata, event.ydata))\n", "            line.set_visible(self.visible and self.horizOn)\n", "        if self.visible and (self.vertOn or self.horizOn):\n", "            self._update()\n"]}, {"span_id": "Cursor._update", "start_line": 2026, "end_line": 2035, "content": ["    def _update(self):\n", "        if self.useblit:\n", "            if self.background is not None:\n", "                self.canvas.restore_region(self.background)\n", "            self.ax.draw_artist(self.linev)\n", "            self.ax.draw_artist(self.lineh)\n", "            self.canvas.blit(self.ax.bbox)\n", "        else:\n", "            self.canvas.draw_idle()\n", "        return False\n"]}, {"span_id": "Cursor", "start_line": 1945, "end_line": 1972, "content": ["class Cursor(AxesWidget):\n", "    \"\"\"\n", "    A crosshair cursor that spans the Axes and moves with mouse cursor.\n", "\n", "    For the cursor to remain responsive you must keep a reference to it.\n", "\n", "    Parameters\n", "    ----------\n", "    ax : `matplotlib.axes.Axes`\n", "        The `~.axes.Axes` to attach the cursor to.\n", "    horizOn : bool, default: True\n", "        Whether to draw the horizontal line.\n", "    vertOn : bool, default: True\n", "        Whether to draw the vertical line.\n", "    useblit : bool, default: False\n", "        Use blitting for faster drawing if supported by the backend.\n", "        See the tutorial :doc:`/tutorials/advanced/blitting` for details.\n", "\n", "    Other Parameters\n", "    ----------------\n", "    **lineprops\n", "        `.Line2D` properties that control the appearance of the lines.\n", "        See also `~.Axes.axhline`.\n", "\n", "    Examples\n", "    --------\n", "    See :doc:`/gallery/widgets/cursor`.\n", "    \"\"\"\n"]}, {"span_id": "MultiCursor.clear", "start_line": 2129, "end_line": 2141, "content": ["    def clear(self, event):\n", "        \"\"\"Clear the cursor.\"\"\"\n", "        if self.ignore(event):\n", "            return\n", "        if self.useblit:\n", "            for canvas, info in self._canvas_infos.items():\n", "                # someone has switched the canvas on us!  This happens if\n", "                # `savefig` needs to save to a format the previous backend did\n", "                # not support (e.g. saving a figure using an Agg based backend\n", "                # saved to a vector format).\n", "                if canvas is not canvas.figure.canvas:\n", "                    continue\n", "                info[\"background\"] = canvas.copy_from_bbox(canvas.figure.bbox)\n"]}, {"span_id": "MultiCursor._update", "start_line": 2157, "end_line": 2172, "content": ["    def _update(self):\n", "        if self.useblit:\n", "            for canvas, info in self._canvas_infos.items():\n", "                if info[\"background\"]:\n", "                    canvas.restore_region(info[\"background\"])\n", "            if self.vertOn:\n", "                for ax, line in zip(self.axes, self.vlines):\n", "                    ax.draw_artist(line)\n", "            if self.horizOn:\n", "                for ax, line in zip(self.axes, self.hlines):\n", "                    ax.draw_artist(line)\n", "            for canvas in self._canvas_infos:\n", "                canvas.blit()\n", "        else:\n", "            for canvas in self._canvas_infos:\n", "                canvas.draw_idle()\n"]}, {"span_id": "MultiCursor.__init__", "start_line": 2075, "end_line": 2107, "content": ["    @_api.make_keyword_only(\"3.6\", \"useblit\")\n", "    def __init__(self, canvas, axes, useblit=True, horizOn=False, vertOn=True,\n", "                 **lineprops):\n", "        # canvas is stored only to provide the deprecated .canvas attribute;\n", "        # once it goes away the unused argument won't need to be stored at all.\n", "        self._canvas = canvas\n", "\n", "        self.axes = axes\n", "        self.horizOn = horizOn\n", "        self.vertOn = vertOn\n", "\n", "        self._canvas_infos = {\n", "            ax.figure.canvas: {\"cids\": [], \"background\": None} for ax in axes}\n", "\n", "        xmin, xmax = axes[-1].get_xlim()\n", "        ymin, ymax = axes[-1].get_ylim()\n", "        xmid = 0.5 * (xmin + xmax)\n", "        ymid = 0.5 * (ymin + ymax)\n", "\n", "        self.visible = True\n", "        self.useblit = (\n", "            useblit\n", "            and all(canvas.supports_blit for canvas in self._canvas_infos))\n", "\n", "        if self.useblit:\n", "            lineprops['animated'] = True\n", "\n", "        self.vlines = [ax.axvline(xmid, visible=False, **lineprops)\n", "                       for ax in axes]\n", "        self.hlines = [ax.axhline(ymid, visible=False, **lineprops)\n", "                       for ax in axes]\n", "\n", "        self.connect()\n"]}, {"span_id": "Cursor.onmove", "start_line": 2001, "end_line": 2024, "content": ["    def onmove(self, event):\n", "        \"\"\"Internal event handler to draw the cursor when the mouse moves.\"\"\"\n", "        if self.ignore(event):\n", "            return\n", "        if not self.canvas.widgetlock.available(self):\n", "            return\n", "        if event.inaxes != self.ax:\n", "            self.linev.set_visible(False)\n", "            self.lineh.set_visible(False)\n", "\n", "            if self.needclear:\n", "                self.canvas.draw()\n", "                self.needclear = False\n", "            return\n", "        self.needclear = True\n", "\n", "        self.linev.set_xdata((event.xdata, event.xdata))\n", "        self.linev.set_visible(self.visible and self.vertOn)\n", "\n", "        self.lineh.set_ydata((event.ydata, event.ydata))\n", "        self.lineh.set_visible(self.visible and self.horizOn)\n", "\n", "        if self.visible and (self.vertOn or self.horizOn):\n", "            self._update()\n"]}]}]}