{"instance_id": "sympy__sympy-22714", "identified_spans": [{"file_path": "sympy/core/parameters.py", "span_ids": ["evaluate"], "content": [{"span_id": "evaluate", "start_line": 70, "end_line": 102, "content": ["@contextmanager\n", "def evaluate(x):\n", "    \"\"\" Control automatic evaluation\n", "\n", "    Explanation\n", "    ===========\n", "\n", "    This context manager controls whether or not all SymPy functions evaluate\n", "    by default.\n", "\n", "    Note that much of SymPy expects evaluated expressions.  This functionality\n", "    is experimental and is unlikely to function as intended on large\n", "    expressions.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import evaluate\n", "    >>> from sympy.abc import x\n", "    >>> print(x + x)\n", "    2*x\n", "    >>> with evaluate(False):\n", "    ...     print(x + x)\n", "    x + x\n", "    \"\"\"\n", "\n", "    old = global_parameters.evaluate\n", "\n", "    try:\n", "        global_parameters.evaluate = x\n", "        yield\n", "    finally:\n", "        global_parameters.evaluate = old\n"]}]}, {"file_path": "sympy/core/sympify.py", "span_ids": ["sympify"], "content": [{"span_id": "sympify", "start_line": 97, "end_line": 480, "content": ["def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,\n", "        evaluate=None):\n", "    \"\"\"\n", "    Converts an arbitrary expression to a type that can be used inside SymPy.\n", "\n", "    Explanation\n", "    ===========\n", "\n", "    It will convert Python ints into instances of :class:`~.Integer`, floats\n", "    into instances of :class:`~.Float`, etc. It is also able to coerce\n", "    symbolic expressions which inherit from :class:`~.Basic`. This can be\n", "    useful in cooperation with SAGE.\n", "\n", "    .. warning::\n", "        Note that this function uses ``eval``, and thus shouldn't be used on\n", "        unsanitized input.\n", "\n", "    If the argument is already a type that SymPy understands, it will do\n", "    nothing but return that value. This can be used at the beginning of a\n", "    function to ensure you are working with the correct type.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import sympify\n", "\n", "    >>> sympify(2).is_integer\n", "    True\n", "    >>> sympify(2).is_real\n", "    True\n", "\n", "    >>> sympify(2.0).is_real\n", "    True\n", "    >>> sympify(\"2.0\").is_real\n", "    True\n", "    >>> sympify(\"2e-45\").is_real\n", "    True\n", "\n", "    If the expression could not be converted, a SympifyError is raised.\n", "\n", "    >>> sympify(\"x***2\")\n", "    Traceback (most recent call last):\n", "    ...\n", "    SympifyError: SympifyError: \"could not parse 'x***2'\"\n", "\n", "    Locals\n", "    ------\n", "\n", "    The sympification happens with access to everything that is loaded\n", "    by ``from sympy import *``; anything used in a string that is not\n", "    defined by that import will be converted to a symbol. In the following,\n", "    the ``bitcount`` function is treated as a symbol and the ``O`` is\n", "    interpreted as the :class:`~.Order` object (used with series) and it raises\n", "    an error when used improperly:\n", "\n", "    >>> s = 'bitcount(42)'\n", "    >>> sympify(s)\n", "    bitcount(42)\n", "    >>> sympify(\"O(x)\")\n", "    O(x)\n", "    >>> sympify(\"O + 1\")\n", "    Traceback (most recent call last):\n", "    ...\n", "    TypeError: unbound method...\n", "\n", "    In order to have ``bitcount`` be recognized it can be imported into a\n", "    namespace dictionary and passed as locals:\n", "\n", "    >>> ns = {}\n", "    >>> exec('from sympy.core.evalf import bitcount', ns)\n", "    >>> sympify(s, locals=ns)\n", "    6\n", "\n", "    In order to have the ``O`` interpreted as a Symbol, identify it as such\n", "    in the namespace dictionary. This can be done in a variety of ways; all\n", "    three of the following are possibilities:\n", "\n", "    >>> from sympy import Symbol\n", "    >>> ns[\"O\"] = Symbol(\"O\")  # method 1\n", "    >>> exec('from sympy.abc import O', ns)  # method 2\n", "    >>> ns.update(dict(O=Symbol(\"O\")))  # method 3\n", "    >>> sympify(\"O + 1\", locals=ns)\n", "    O + 1\n", "\n", "    If you want *all* single-letter and Greek-letter variables to be symbols\n", "    then you can use the clashing-symbols dictionaries that have been defined\n", "    there as private variables: ``_clash1`` (single-letter variables),\n", "    ``_clash2`` (the multi-letter Greek names) or ``_clash`` (both single and\n", "    multi-letter names that are defined in ``abc``).\n", "\n", "    >>> from sympy.abc import _clash1\n", "    >>> set(_clash1)\n", "    {'E', 'I', 'N', 'O', 'Q', 'S'}\n", "    >>> sympify('I & Q', _clash1)\n", "    I & Q\n", "\n", "    Strict\n", "    ------\n", "\n", "    If the option ``strict`` is set to ``True``, only the types for which an\n", "    explicit conversion has been defined are converted. In the other\n", "    cases, a SympifyError is raised.\n", "\n", "    >>> print(sympify(None))\n", "    None\n", "    >>> sympify(None, strict=True)\n", "    Traceback (most recent call last):\n", "    ...\n", "    SympifyError: SympifyError: None\n", "\n", "    Evaluation\n", "    ----------\n", "\n", "    If the option ``evaluate`` is set to ``False``, then arithmetic and\n", "    operators will be converted into their SymPy equivalents and the\n", "    ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will\n", "    be denested first. This is done via an AST transformation that replaces\n", "    operators with their SymPy equivalents, so if an operand redefines any\n", "    of those operations, the redefined operators will not be used. If\n", "    argument a is not a string, the mathematical expression is evaluated\n", "    before being passed to sympify, so adding ``evaluate=False`` will still\n", "    return the evaluated result of expression.\n", "\n", "    >>> sympify('2**2 / 3 + 5')\n", "    19/3\n", "    >>> sympify('2**2 / 3 + 5', evaluate=False)\n", "    2**2/3 + 5\n", "    >>> sympify('4/2+7', evaluate=True)\n", "    9\n", "    >>> sympify('4/2+7', evaluate=False)\n", "    4/2 + 7\n", "    >>> sympify(4/2+7, evaluate=False)\n", "    9.00000000000000\n", "\n", "    Extending\n", "    ---------\n", "\n", "    To extend ``sympify`` to convert custom objects (not derived from ``Basic``),\n", "    just define a ``_sympy_`` method to your class. You can do that even to\n", "    classes that you do not own by subclassing or adding the method at runtime.\n", "\n", "    >>> from sympy import Matrix\n", "    >>> class MyList1(object):\n", "    ...     def __iter__(self):\n", "    ...         yield 1\n", "    ...         yield 2\n", "    ...         return\n", "    ...     def __getitem__(self, i): return list(self)[i]\n", "    ...     def _sympy_(self): return Matrix(self)\n", "    >>> sympify(MyList1())\n", "    Matrix([\n", "    [1],\n", "    [2]])\n", "\n", "    If you do not have control over the class definition you could also use the\n", "    ``converter`` global dictionary. The key is the class and the value is a\n", "    function that takes a single argument and returns the desired SymPy\n", "    object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.\n", "\n", "    >>> class MyList2(object):   # XXX Do not do this if you control the class!\n", "    ...     def __iter__(self):  #     Use _sympy_!\n", "    ...         yield 1\n", "    ...         yield 2\n", "    ...         return\n", "    ...     def __getitem__(self, i): return list(self)[i]\n", "    >>> from sympy.core.sympify import converter\n", "    >>> converter[MyList2] = lambda x: Matrix(x)\n", "    >>> sympify(MyList2())\n", "    Matrix([\n", "    [1],\n", "    [2]])\n", "\n", "    Notes\n", "    =====\n", "\n", "    The keywords ``rational`` and ``convert_xor`` are only used\n", "    when the input is a string.\n", "\n", "    convert_xor\n", "    -----------\n", "\n", "    >>> sympify('x^y',convert_xor=True)\n", "    x**y\n", "    >>> sympify('x^y',convert_xor=False)\n", "    x ^ y\n", "\n", "    rational\n", "    --------\n", "\n", "    >>> sympify('0.1',rational=False)\n", "    0.1\n", "    >>> sympify('0.1',rational=True)\n", "    1/10\n", "\n", "    Sometimes autosimplification during sympification results in expressions\n", "    that are very different in structure than what was entered. Until such\n", "    autosimplification is no longer done, the ``kernS`` function might be of\n", "    some use. In the example below you can see how an expression reduces to\n", "    $-1$ by autosimplification, but does not do so when ``kernS`` is used.\n", "\n", "    >>> from sympy.core.sympify import kernS\n", "    >>> from sympy.abc import x\n", "    >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n", "    -1\n", "    >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'\n", "    >>> sympify(s)\n", "    -1\n", "    >>> kernS(s)\n", "    -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    a :\n", "        - any object defined in SymPy\n", "        - standard numeric Python types: ``int``, ``long``, ``float``, ``Decimal``\n", "        - strings (like ``\"0.09\"``, ``\"2e-19\"`` or ``'sin(x)'``)\n", "        - booleans, including ``None`` (will leave ``None`` unchanged)\n", "        - dicts, lists, sets or tuples containing any of the above\n", "\n", "    convert_xor : bool, optional\n", "        If true, treats ``^`` as exponentiation.\n", "        If False, treats ``^`` as XOR itself.\n", "        Used only when input is a string.\n", "\n", "    locals : any object defined in SymPy, optional\n", "        In order to have strings be recognized it can be imported\n", "        into a namespace dictionary and passed as locals.\n", "\n", "    strict : bool, optional\n", "        If the option strict is set to ``True``, only the types for which\n", "        an explicit conversion has been defined are converted. In the\n", "        other cases, a SympifyError is raised.\n", "\n", "    rational : bool, optional\n", "        If ``True``, converts floats into :class:`~.Rational`.\n", "        If ``False``, it lets floats remain as it is.\n", "        Used only when input is a string.\n", "\n", "    evaluate : bool, optional\n", "        If False, then arithmetic and operators will be converted into\n", "        their SymPy equivalents. If True the expression will be evaluated\n", "        and the result will be returned.\n", "\n", "    \"\"\"\n", "    # XXX: If a is a Basic subclass rather than instance (e.g. sin rather than\n", "    # sin(x)) then a.__sympy__ will be the property. Only on the instance will\n", "    # a.__sympy__ give the *value* of the property (True). Since sympify(sin)\n", "    # was used for a long time we allow it to pass. However if strict=True as\n", "    # is the case in internal calls to _sympify then we only allow\n", "    # is_sympy=True.\n", "    #\n", "    # https://github.com/sympy/sympy/issues/20124\n", "    is_sympy = getattr(a, '__sympy__', None)\n", "    if is_sympy is True:\n", "        return a\n", "    elif is_sympy is not None:\n", "        if not strict:\n", "            return a\n", "        else:\n", "            raise SympifyError(a)\n", "\n", "    if isinstance(a, CantSympify):\n", "        raise SympifyError(a)\n", "    cls = getattr(a, \"__class__\", None)\n", "    if cls is None:\n", "        cls = type(a)  # Probably an old-style class\n", "    conv = converter.get(cls, None)\n", "    if conv is not None:\n", "        return conv(a)\n", "\n", "    for superclass in getmro(cls):\n", "        try:\n", "            return converter[superclass](a)\n", "        except KeyError:\n", "            continue\n", "\n", "    if cls is type(None):\n", "        if strict:\n", "            raise SympifyError(a)\n", "        else:\n", "            return a\n", "\n", "    if evaluate is None:\n", "        evaluate = global_parameters.evaluate\n", "\n", "    # Support for basic numpy datatypes\n", "    if _is_numpy_instance(a):\n", "        import numpy as np\n", "        if np.isscalar(a):\n", "            return _convert_numpy_types(a, locals=locals,\n", "                convert_xor=convert_xor, strict=strict, rational=rational,\n", "                evaluate=evaluate)\n", "\n", "    _sympy_ = getattr(a, \"_sympy_\", None)\n", "    if _sympy_ is not None:\n", "        try:\n", "            return a._sympy_()\n", "        # XXX: Catches AttributeError: 'SymPyConverter' object has no\n", "        # attribute 'tuple'\n", "        # This is probably a bug somewhere but for now we catch it here.\n", "        except AttributeError:\n", "            pass\n", "\n", "    if not strict:\n", "        # Put numpy array conversion _before_ float/int, see\n", "        # <https://github.com/sympy/sympy/issues/13924>.\n", "        flat = getattr(a, \"flat\", None)\n", "        if flat is not None:\n", "            shape = getattr(a, \"shape\", None)\n", "            if shape is not None:\n", "                from sympy.tensor.array import Array\n", "                return Array(a.flat, a.shape)  # works with e.g. NumPy arrays\n", "\n", "    if not isinstance(a, str):\n", "        if _is_numpy_instance(a):\n", "            import numpy as np\n", "            assert not isinstance(a, np.number)\n", "            if isinstance(a, np.ndarray):\n", "                # Scalar arrays (those with zero dimensions) have sympify\n", "                # called on the scalar element.\n", "                if a.ndim == 0:\n", "                    try:\n", "                        return sympify(a.item(),\n", "                                       locals=locals,\n", "                                       convert_xor=convert_xor,\n", "                                       strict=strict,\n", "                                       rational=rational,\n", "                                       evaluate=evaluate)\n", "                    except SympifyError:\n", "                        pass\n", "        else:\n", "            # float and int can coerce size-one numpy arrays to their lone\n", "            # element.  See issue https://github.com/numpy/numpy/issues/10404.\n", "            for coerce in (float, int):\n", "                try:\n", "                    return sympify(coerce(a))\n", "                except (TypeError, ValueError, AttributeError, SympifyError):\n", "                    continue\n", "\n", "    if strict:\n", "        raise SympifyError(a)\n", "\n", "    if iterable(a):\n", "        try:\n", "            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,\n", "                rational=rational, evaluate=evaluate) for x in a])\n", "        except TypeError:\n", "            # Not all iterables are rebuildable with their type.\n", "            pass\n", "\n", "    if not isinstance(a, str):\n", "        try:\n", "            a = str(a)\n", "        except Exception as exc:\n", "            raise SympifyError(a, exc)\n", "        SymPyDeprecationWarning(\n", "            feature=\"String fallback in sympify\",\n", "            useinstead= \\\n", "                'sympify(str(obj)) or ' + \\\n", "                'sympy.core.sympify.converter or obj._sympy_',\n", "            issue=18066,\n", "            deprecated_since_version='1.6'\n", "        ).warn()\n", "\n", "    from sympy.parsing.sympy_parser import (parse_expr, TokenError,\n", "                                            standard_transformations)\n", "    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n", "    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n", "\n", "    transformations = standard_transformations\n", "\n", "    if rational:\n", "        transformations += (t_rationalize,)\n", "    if convert_xor:\n", "        transformations += (t_convert_xor,)\n", "\n", "    try:\n", "        a = a.replace('\\n', '')\n", "        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n", "    except (TokenError, SyntaxError) as exc:\n", "        raise SympifyError('could not parse %r' % a, exc)\n", "\n", "    return expr\n"]}]}, {"file_path": "sympy/geometry/point.py", "span_ids": ["Point2D.__new__", "Point.__new__"], "content": [{"span_id": "Point2D.__new__", "start_line": 912, "end_line": 916, "content": ["    def __new__(cls, *args, _nocheck=False, **kwargs):\n", "        if not _nocheck:\n", "            kwargs['dim'] = 2\n", "            args = Point(*args, **kwargs)\n", "        return GeometryEntity.__new__(cls, *args)\n"]}, {"span_id": "Point.__new__", "start_line": 109, "end_line": 179, "content": ["    def __new__(cls, *args, **kwargs):\n", "        evaluate = kwargs.get('evaluate', global_parameters.evaluate)\n", "        on_morph = kwargs.get('on_morph', 'ignore')\n", "\n", "        # unpack into coords\n", "        coords = args[0] if len(args) == 1 else args\n", "\n", "        # check args and handle quickly handle Point instances\n", "        if isinstance(coords, Point):\n", "            # even if we're mutating the dimension of a point, we\n", "            # don't reevaluate its coordinates\n", "            evaluate = False\n", "            if len(coords) == kwargs.get('dim', len(coords)):\n", "                return coords\n", "\n", "        if not is_sequence(coords):\n", "            raise TypeError(filldedent('''\n", "                Expecting sequence of coordinates, not `{}`'''\n", "                                       .format(func_name(coords))))\n", "        # A point where only `dim` is specified is initialized\n", "        # to zeros.\n", "        if len(coords) == 0 and kwargs.get('dim', None):\n", "            coords = (S.Zero,)*kwargs.get('dim')\n", "\n", "        coords = Tuple(*coords)\n", "        dim = kwargs.get('dim', len(coords))\n", "\n", "        if len(coords) < 2:\n", "            raise ValueError(filldedent('''\n", "                Point requires 2 or more coordinates or\n", "                keyword `dim` > 1.'''))\n", "        if len(coords) != dim:\n", "            message = (\"Dimension of {} needs to be changed \"\n", "                       \"from {} to {}.\").format(coords, len(coords), dim)\n", "            if on_morph == 'ignore':\n", "                pass\n", "            elif on_morph == \"error\":\n", "                raise ValueError(message)\n", "            elif on_morph == 'warn':\n", "                warnings.warn(message)\n", "            else:\n", "                raise ValueError(filldedent('''\n", "                        on_morph value should be 'error',\n", "                        'warn' or 'ignore'.'''))\n", "        if any(coords[dim:]):\n", "            raise ValueError('Nonzero coordinates cannot be removed.')\n", "        if any(a.is_number and im(a) for a in coords):\n", "            raise ValueError('Imaginary coordinates are not permitted.')\n", "        if not all(isinstance(a, Expr) for a in coords):\n", "            raise TypeError('Coordinates must be valid SymPy expressions.')\n", "\n", "        # pad with zeros appropriately\n", "        coords = coords[:dim] + (S.Zero,)*(dim - len(coords))\n", "\n", "        # Turn any Floats into rationals and simplify\n", "        # any expressions before we instantiate\n", "        if evaluate:\n", "            coords = coords.xreplace({\n", "                f: simplify(nsimplify(f, rational=True))\n", "                 for f in coords.atoms(Float)})\n", "\n", "        # return 2D or 3D instances\n", "        if len(coords) == 2:\n", "            kwargs['_nocheck'] = True\n", "            return Point2D(*coords, **kwargs)\n", "        elif len(coords) == 3:\n", "            kwargs['_nocheck'] = True\n", "            return Point3D(*coords, **kwargs)\n", "\n", "        # the general Point\n", "        return GeometryEntity.__new__(cls, *coords)\n"]}]}, {"file_path": "sympy/parsing/sympy_parser.py", "span_ids": ["parse_expr", "evaluateFalse"], "content": [{"span_id": "parse_expr", "start_line": 918, "end_line": 1100, "content": ["def parse_expr(s, local_dict=None, transformations=standard_transformations,\n", "               global_dict=None, evaluate=True):\n", "    \"\"\"Converts the string ``s`` to a SymPy expression, in ``local_dict``\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    s : str\n", "        The string to parse.\n", "\n", "    local_dict : dict, optional\n", "        A dictionary of local variables to use when parsing.\n", "\n", "    global_dict : dict, optional\n", "        A dictionary of global variables. By default, this is initialized\n", "        with ``from sympy import *``; provide this parameter to override\n", "        this behavior (for instance, to parse ``\"Q & S\"``).\n", "\n", "    transformations : tuple or str, optional\n", "        A tuple of transformation functions used to modify the tokens of the\n", "        parsed expression before evaluation. The default transformations\n", "        convert numeric literals into their SymPy equivalents, convert\n", "        undefined variables into SymPy symbols, and allow the use of standard\n", "        mathematical factorial notation (e.g. ``x!``). Selection via\n", "        string is available (see below).\n", "\n", "    evaluate : bool, optional\n", "        When False, the order of the arguments will remain as they were in the\n", "        string and automatic simplification that would normally occur is\n", "        suppressed. (see examples)\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.parsing.sympy_parser import parse_expr\n", "    >>> parse_expr(\"1/2\")\n", "    1/2\n", "    >>> type(_)\n", "    <class 'sympy.core.numbers.Half'>\n", "    >>> from sympy.parsing.sympy_parser import standard_transformations,\\\\\n", "    ... implicit_multiplication_application\n", "    >>> transformations = (standard_transformations +\n", "    ...     (implicit_multiplication_application,))\n", "    >>> parse_expr(\"2x\", transformations=transformations)\n", "    2*x\n", "\n", "    When evaluate=False, some automatic simplifications will not occur:\n", "\n", "    >>> parse_expr(\"2**3\"), parse_expr(\"2**3\", evaluate=False)\n", "    (8, 2**3)\n", "\n", "    In addition the order of the arguments will not be made canonical.\n", "    This feature allows one to tell exactly how the expression was entered:\n", "\n", "    >>> a = parse_expr('1 + x', evaluate=False)\n", "    >>> b = parse_expr('x + 1', evaluate=0)\n", "    >>> a == b\n", "    False\n", "    >>> a.args\n", "    (1, x)\n", "    >>> b.args\n", "    (x, 1)\n", "\n", "    Note, however, that when these expressions are printed they will\n", "    appear the same:\n", "\n", "    >>> assert str(a) == str(b)\n", "\n", "    As a convenience, transformations can be seen by printing ``transformations``:\n", "\n", "    >>> from sympy.parsing.sympy_parser import transformations\n", "\n", "    >>> print(transformations)\n", "    0: lambda_notation\n", "    1: auto_symbol\n", "    2: repeated_decimals\n", "    3: auto_number\n", "    4: factorial_notation\n", "    5: implicit_multiplication_application\n", "    6: convert_xor\n", "    7: implicit_application\n", "    8: implicit_multiplication\n", "    9: convert_equals_signs\n", "    10: function_exponentiation\n", "    11: rationalize\n", "\n", "    The ``T`` object provides a way to select these transformations:\n", "\n", "    >>> from sympy.parsing.sympy_parser import T\n", "\n", "    If you print it, you will see the same list as shown above.\n", "\n", "    >>> str(T) == str(transformations)\n", "    True\n", "\n", "    Standard slicing will return a tuple of transformations:\n", "\n", "    >>> T[:5] == standard_transformations\n", "    True\n", "\n", "    So ``T`` can be used to specify the parsing transformations:\n", "\n", "    >>> parse_expr(\"2x\", transformations=T[:5])\n", "    Traceback (most recent call last):\n", "    ...\n", "    SyntaxError: invalid syntax\n", "    >>> parse_expr(\"2x\", transformations=T[:6])\n", "    2*x\n", "    >>> parse_expr('.3', transformations=T[3, 11])\n", "    3/10\n", "    >>> parse_expr('.3x', transformations=T[:])\n", "    3*x/10\n", "\n", "    As a further convenience, strings 'implicit' and 'all' can be used\n", "    to select 0-5 and all the transformations, respectively.\n", "\n", "    >>> parse_expr('.3x', transformations='all')\n", "    3*x/10\n", "\n", "    See Also\n", "    ========\n", "\n", "    stringify_expr, eval_expr, standard_transformations,\n", "    implicit_multiplication_application\n", "\n", "    \"\"\"\n", "\n", "    if local_dict is None:\n", "        local_dict = {}\n", "    elif not isinstance(local_dict, dict):\n", "        raise TypeError('expecting local_dict to be a dict')\n", "\n", "    if global_dict is None:\n", "        global_dict = {}\n", "        exec('from sympy import *', global_dict)\n", "    elif not isinstance(global_dict, dict):\n", "        raise TypeError('expecting global_dict to be a dict')\n", "\n", "    transformations = transformations or ()\n", "    if type(transformations) is str:\n", "        if transformations == 'all':\n", "            transformations = T[:]\n", "        elif transformations == 'implicit':\n", "            transformations = T[:6]\n", "        else:\n", "            raise ValueError('unknown transformation group name')\n", "    if transformations:\n", "        if not iterable(transformations):\n", "            raise TypeError(\n", "                '`transformations` should be a list of functions.')\n", "        for _ in transformations:\n", "            if not callable(_):\n", "                raise TypeError(filldedent('''\n", "                    expected a function in `transformations`,\n", "                    not %s''' % func_name(_)))\n", "            if arity(_) != 3:\n", "                raise TypeError(filldedent('''\n", "                    a transformation should be function that\n", "                    takes 3 arguments'''))\n", "\n", "    builtins_dict = vars(builtins)\n", "    for name, obj in builtins_dict.items():\n", "        if isinstance(obj, types.BuiltinFunctionType):\n", "            global_dict[name] = obj\n", "    global_dict['max'] = Max\n", "    global_dict['min'] = Min\n", "\n", "    code = stringify_expr(s, local_dict, global_dict, transformations)\n", "\n", "    if not evaluate:\n", "        code = compile(evaluateFalse(code), '<string>', 'eval')\n", "\n", "    try:\n", "        rv = eval_expr(code, local_dict, global_dict)\n", "        # restore neutral definitions for names\n", "        for i in local_dict.pop(None, ()):\n", "            local_dict[i] = None\n", "        return rv\n", "    except Exception as e:\n", "        # restore neutral definitions for names\n", "        for i in local_dict.pop(None, ()):\n", "            local_dict[i] = None\n", "        raise e from ValueError(f\"Error from parse_expr with transformed code: {code!r}\")\n"]}, {"span_id": "evaluateFalse", "start_line": 1103, "end_line": 1112, "content": ["def evaluateFalse(s):\n", "    \"\"\"\n", "    Replaces operators with the SymPy equivalent and sets evaluate=False.\n", "    \"\"\"\n", "    node = ast.parse(s)\n", "    node = EvaluateFalseTransformer().visit(node)\n", "    # node is a Module, we want an Expression\n", "    node = ast.Expression(node.body[0].value)\n", "\n", "    return ast.fix_missing_locations(node)\n"]}]}]}