{"instance_id": "pytest-dev__pytest-7373", "identified_spans": [{"file_path": "src/_pytest/mark/evaluate.py", "span_ids": ["MarkEvaluator._istrue", "MarkEvaluator", "MarkEvaluator._getglobals", "cached_eval", "imports", "impl"], "content": [{"span_id": "MarkEvaluator._istrue", "start_line": 82, "end_line": 121, "content": ["    def _istrue(self) -> bool:\n", "        if hasattr(self, \"result\"):\n", "            result = getattr(self, \"result\")  # type: bool\n", "            return result\n", "        self._marks = self._get_marks()\n", "\n", "        if self._marks:\n", "            self.result = False\n", "            for mark in self._marks:\n", "                self._mark = mark\n", "                if \"condition\" not in mark.kwargs:\n", "                    args = mark.args\n", "                else:\n", "                    args = (mark.kwargs[\"condition\"],)\n", "\n", "                for expr in args:\n", "                    self.expr = expr\n", "                    if isinstance(expr, str):\n", "                        d = self._getglobals()\n", "                        result = cached_eval(self.item.config, expr, d)\n", "                    else:\n", "                        if \"reason\" not in mark.kwargs:\n", "                            # XXX better be checked at collection time\n", "                            msg = (\n", "                                \"you need to specify reason=STRING \"\n", "                                \"when using booleans as conditions.\"\n", "                            )\n", "                            fail(msg)\n", "                        result = bool(expr)\n", "                    if result:\n", "                        self.result = True\n", "                        self.reason = mark.kwargs.get(\"reason\", None)\n", "                        self.expr = expr\n", "                        return self.result\n", "\n", "                if not args:\n", "                    self.result = True\n", "                    self.reason = mark.kwargs.get(\"reason\", None)\n", "                    return self.result\n", "        return False\n"]}, {"span_id": "MarkEvaluator", "start_line": 34, "end_line": 34, "content": ["class MarkEvaluator:\n"]}, {"span_id": "MarkEvaluator._getglobals", "start_line": 76, "end_line": 80, "content": ["    def _getglobals(self) -> Dict[str, object]:\n", "        d = {\"os\": os, \"sys\": sys, \"platform\": platform, \"config\": self.item.config}\n", "        if hasattr(self.item, \"obj\"):\n", "            d.update(self.item.obj.__globals__)  # type: ignore[attr-defined] # noqa: F821\n", "        return d\n"]}, {"span_id": "cached_eval", "start_line": 21, "end_line": 31, "content": ["def cached_eval(config: Config, expr: str, d: Dict[str, object]) -> Any:\n", "    default = {}  # type: Dict[str, object]\n", "    evalcache = config._store.setdefault(evalcache_key, default)\n", "    try:\n", "        return evalcache[expr]\n", "    except KeyError:\n", "        import _pytest._code\n", "\n", "        exprcode = _pytest._code.compile(expr, mode=\"eval\")\n", "        evalcache[expr] = x = eval(exprcode, d)\n", "        return x\n"]}, {"span_id": "imports", "start_line": 1, "end_line": 18, "content": ["import os\n", "import platform\n", "import sys\n", "import traceback\n", "from typing import Any\n", "from typing import Dict\n", "from typing import List\n", "from typing import Optional\n", "\n", "from ..outcomes import fail\n", "from ..outcomes import TEST_OUTCOME\n", "from .structures import Mark\n", "from _pytest.config import Config\n", "from _pytest.nodes import Item\n", "from _pytest.store import StoreKey\n", "\n", "\n", "evalcache_key = StoreKey[Dict[str, Any]]()\n"]}]}]}