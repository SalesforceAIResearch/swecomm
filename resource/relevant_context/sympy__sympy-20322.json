{"instance_id": "sympy__sympy-20322", "identified_spans": [{"file_path": "sympy/core/numbers.py", "span_ids": ["Infinity.ceiling", "NaN.ceiling", "Rational.ceiling", "Float.ceiling", "ComplexInfinity.ceiling", "NegativeInfinity.ceiling", "Integer.ceiling"], "content": [{"span_id": "Infinity.ceiling", "start_line": 2988, "end_line": 2989, "content": ["    def ceiling(self):\n", "        return self\n"]}, {"span_id": "NaN.ceiling", "start_line": 3251, "end_line": 3252, "content": ["    def ceiling(self):\n", "        return self\n"]}, {"span_id": "Rational.ceiling", "start_line": 1864, "end_line": 1865, "content": ["    def ceiling(self):\n", "        return -Integer(-self.p // self.q)\n"]}, {"span_id": "Float.ceiling", "start_line": 1233, "end_line": 1235, "content": ["    def ceiling(self):\n", "        return Integer(int(mlib.to_int(\n", "            mlib.mpf_ceil(self._mpf_, self._prec))))\n"]}, {"span_id": "ComplexInfinity.ceiling", "start_line": 3337, "end_line": 3338, "content": ["    def ceiling(self):\n", "        return self\n"]}, {"span_id": "NegativeInfinity.ceiling", "start_line": 3151, "end_line": 3152, "content": ["    def ceiling(self):\n", "        return self\n"]}, {"span_id": "Integer.ceiling", "start_line": 2128, "end_line": 2129, "content": ["    def ceiling(self):\n", "        return Integer(self.p)\n"]}]}, {"file_path": "sympy/core/sympify.py", "span_ids": ["sympify"], "content": [{"span_id": "sympify", "start_line": 92, "end_line": 484, "content": ["def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,\n", "        evaluate=None):\n", "    \"\"\"\n", "    Converts an arbitrary expression to a type that can be used inside SymPy.\n", "\n", "    Explanation\n", "    ===========\n", "\n", "    It will convert Python ints into instances of sympy.Integer,\n", "    floats into instances of sympy.Float, etc. It is also able to coerce symbolic\n", "    expressions which inherit from Basic. This can be useful in cooperation\n", "    with SAGE.\n", "\n", "    .. warning::\n", "        Note that this function uses ``eval``, and thus shouldn't be used on\n", "        unsanitized input.\n", "\n", "    If the argument is already a type that SymPy understands, it will do\n", "    nothing but return that value. This can be used at the beginning of a\n", "    function to ensure you are working with the correct type.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import sympify\n", "\n", "    >>> sympify(2).is_integer\n", "    True\n", "    >>> sympify(2).is_real\n", "    True\n", "\n", "    >>> sympify(2.0).is_real\n", "    True\n", "    >>> sympify(\"2.0\").is_real\n", "    True\n", "    >>> sympify(\"2e-45\").is_real\n", "    True\n", "\n", "    If the expression could not be converted, a SympifyError is raised.\n", "\n", "    >>> sympify(\"x***2\")\n", "    Traceback (most recent call last):\n", "    ...\n", "    SympifyError: SympifyError: \"could not parse 'x***2'\"\n", "\n", "    Locals\n", "    ------\n", "\n", "    The sympification happens with access to everything that is loaded\n", "    by ``from sympy import *``; anything used in a string that is not\n", "    defined by that import will be converted to a symbol. In the following,\n", "    the ``bitcount`` function is treated as a symbol and the ``O`` is\n", "    interpreted as the Order object (used with series) and it raises\n", "    an error when used improperly:\n", "\n", "    >>> s = 'bitcount(42)'\n", "    >>> sympify(s)\n", "    bitcount(42)\n", "    >>> sympify(\"O(x)\")\n", "    O(x)\n", "    >>> sympify(\"O + 1\")\n", "    Traceback (most recent call last):\n", "    ...\n", "    TypeError: unbound method...\n", "\n", "    In order to have ``bitcount`` be recognized it can be imported into a\n", "    namespace dictionary and passed as locals:\n", "\n", "    >>> from sympy.core.compatibility import exec_\n", "    >>> ns = {}\n", "    >>> exec_('from sympy.core.evalf import bitcount', ns)\n", "    >>> sympify(s, locals=ns)\n", "    6\n", "\n", "    In order to have the ``O`` interpreted as a Symbol, identify it as such\n", "    in the namespace dictionary. This can be done in a variety of ways; all\n", "    three of the following are possibilities:\n", "\n", "    >>> from sympy import Symbol\n", "    >>> ns[\"O\"] = Symbol(\"O\")  # method 1\n", "    >>> exec_('from sympy.abc import O', ns)  # method 2\n", "    >>> ns.update(dict(O=Symbol(\"O\")))  # method 3\n", "    >>> sympify(\"O + 1\", locals=ns)\n", "    O + 1\n", "\n", "    If you want *all* single-letter and Greek-letter variables to be symbols\n", "    then you can use the clashing-symbols dictionaries that have been defined\n", "    there as private variables: _clash1 (single-letter variables), _clash2\n", "    (the multi-letter Greek names) or _clash (both single and multi-letter\n", "    names that are defined in abc).\n", "\n", "    >>> from sympy.abc import _clash1\n", "    >>> _clash1\n", "    {'C': C, 'E': E, 'I': I, 'N': N, 'O': O, 'Q': Q, 'S': S}\n", "    >>> sympify('I & Q', _clash1)\n", "    I & Q\n", "\n", "    Strict\n", "    ------\n", "\n", "    If the option ``strict`` is set to ``True``, only the types for which an\n", "    explicit conversion has been defined are converted. In the other\n", "    cases, a SympifyError is raised.\n", "\n", "    >>> print(sympify(None))\n", "    None\n", "    >>> sympify(None, strict=True)\n", "    Traceback (most recent call last):\n", "    ...\n", "    SympifyError: SympifyError: None\n", "\n", "    Evaluation\n", "    ----------\n", "\n", "    If the option ``evaluate`` is set to ``False``, then arithmetic and\n", "    operators will be converted into their SymPy equivalents and the\n", "    ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will\n", "    be denested first. This is done via an AST transformation that replaces\n", "    operators with their SymPy equivalents, so if an operand redefines any\n", "    of those operations, the redefined operators will not be used. If\n", "    argument a is not a string, the mathematical expression is evaluated\n", "    before being passed to sympify, so adding evaluate=False will still\n", "    return the evaluated result of expression.\n", "\n", "    >>> sympify('2**2 / 3 + 5')\n", "    19/3\n", "    >>> sympify('2**2 / 3 + 5', evaluate=False)\n", "    2**2/3 + 5\n", "    >>> sympify('4/2+7', evaluate=True)\n", "    9\n", "    >>> sympify('4/2+7', evaluate=False)\n", "    4/2 + 7\n", "    >>> sympify(4/2+7, evaluate=False)\n", "    9.00000000000000\n", "\n", "    Extending\n", "    ---------\n", "\n", "    To extend ``sympify`` to convert custom objects (not derived from ``Basic``),\n", "    just define a ``_sympy_`` method to your class. You can do that even to\n", "    classes that you do not own by subclassing or adding the method at runtime.\n", "\n", "    >>> from sympy import Matrix\n", "    >>> class MyList1(object):\n", "    ...     def __iter__(self):\n", "    ...         yield 1\n", "    ...         yield 2\n", "    ...         return\n", "    ...     def __getitem__(self, i): return list(self)[i]\n", "    ...     def _sympy_(self): return Matrix(self)\n", "    >>> sympify(MyList1())\n", "    Matrix([\n", "    [1],\n", "    [2]])\n", "\n", "    If you do not have control over the class definition you could also use the\n", "    ``converter`` global dictionary. The key is the class and the value is a\n", "    function that takes a single argument and returns the desired SymPy\n", "    object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.\n", "\n", "    >>> class MyList2(object):   # XXX Do not do this if you control the class!\n", "    ...     def __iter__(self):  #     Use _sympy_!\n", "    ...         yield 1\n", "    ...         yield 2\n", "    ...         return\n", "    ...     def __getitem__(self, i): return list(self)[i]\n", "    >>> from sympy.core.sympify import converter\n", "    >>> converter[MyList2] = lambda x: Matrix(x)\n", "    >>> sympify(MyList2())\n", "    Matrix([\n", "    [1],\n", "    [2]])\n", "\n", "    Notes\n", "    =====\n", "\n", "    The keywords ``rational`` and ``convert_xor`` are only used\n", "    when the input is a string.\n", "\n", "    convert_xor\n", "    -----------\n", "\n", "    >>> sympify('x^y',convert_xor=True)\n", "    x**y\n", "    >>> sympify('x^y',convert_xor=False)\n", "    x ^ y\n", "\n", "    rational\n", "    --------\n", "\n", "    >>> sympify('0.1',rational=False)\n", "    0.1\n", "    >>> sympify('0.1',rational=True)\n", "    1/10\n", "\n", "    Sometimes autosimplification during sympification results in expressions\n", "    that are very different in structure than what was entered. Until such\n", "    autosimplification is no longer done, the ``kernS`` function might be of\n", "    some use. In the example below you can see how an expression reduces to\n", "    -1 by autosimplification, but does not do so when ``kernS`` is used.\n", "\n", "    >>> from sympy.core.sympify import kernS\n", "    >>> from sympy.abc import x\n", "    >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n", "    -1\n", "    >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'\n", "    >>> sympify(s)\n", "    -1\n", "    >>> kernS(s)\n", "    -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    a :\n", "        - any object defined in SymPy\n", "        - standard numeric python types: int, long, float, Decimal\n", "        - strings (like \"0.09\", \"2e-19\" or 'sin(x)')\n", "        - booleans, including ``None`` (will leave ``None`` unchanged)\n", "        - dict, lists, sets or tuples containing any of the above\n", "\n", "    convert_xor : boolean, optional\n", "        If true, treats XOR as exponentiation.\n", "        If False, treats XOR as XOR itself.\n", "        Used only when input is a string.\n", "\n", "    locals : any object defined in SymPy, optional\n", "        In order to have strings be recognized it can be imported\n", "        into a namespace dictionary and passed as locals.\n", "\n", "    strict : boolean, optional\n", "        If the option strict is set to True, only the types for which\n", "        an explicit conversion has been defined are converted. In the\n", "        other cases, a SympifyError is raised.\n", "\n", "    rational : boolean, optional\n", "        If true, converts floats into Rational.\n", "        If false, it lets floats remain as it is.\n", "        Used only when input is a string.\n", "\n", "    evaluate : boolean, optional\n", "        If False, then arithmetic and operators will be converted into\n", "        their SymPy equivalents. If True the expression will be evaluated\n", "        and the result will be returned.\n", "\n", "    \"\"\"\n", "    # XXX: If a is a Basic subclass rather than instance (e.g. sin rather than\n", "    # sin(x)) then a.__sympy__ will be the property. Only on the instance will\n", "    # a.__sympy__ give the *value* of the property (True). Since sympify(sin)\n", "    # was used for a long time we allow it to pass. However if strict=True as\n", "    # is the case in internal calls to _sympify then we only allow\n", "    # is_sympy=True.\n", "    #\n", "    # https://github.com/sympy/sympy/issues/20124\n", "    is_sympy = getattr(a, '__sympy__', None)\n", "    if is_sympy is True:\n", "        return a\n", "    elif is_sympy is not None:\n", "        if not strict:\n", "            return a\n", "        else:\n", "            raise SympifyError(a)\n", "\n", "    if isinstance(a, CantSympify):\n", "        raise SympifyError(a)\n", "    cls = getattr(a, \"__class__\", None)\n", "    if cls is None:\n", "        cls = type(a)  # Probably an old-style class\n", "    conv = converter.get(cls, None)\n", "    if conv is not None:\n", "        return conv(a)\n", "\n", "    for superclass in getmro(cls):\n", "        try:\n", "            return converter[superclass](a)\n", "        except KeyError:\n", "            continue\n", "\n", "    if cls is type(None):\n", "        if strict:\n", "            raise SympifyError(a)\n", "        else:\n", "            return a\n", "\n", "    if evaluate is None:\n", "        evaluate = global_parameters.evaluate\n", "\n", "    # Support for basic numpy datatypes\n", "    if _is_numpy_instance(a):\n", "        import numpy as np\n", "        if np.isscalar(a):\n", "            return _convert_numpy_types(a, locals=locals,\n", "                convert_xor=convert_xor, strict=strict, rational=rational,\n", "                evaluate=evaluate)\n", "\n", "    _sympy_ = getattr(a, \"_sympy_\", None)\n", "    if _sympy_ is not None:\n", "        try:\n", "            return a._sympy_()\n", "        # XXX: Catches AttributeError: 'SympyConverter' object has no\n", "        # attribute 'tuple'\n", "        # This is probably a bug somewhere but for now we catch it here.\n", "        except AttributeError:\n", "            pass\n", "\n", "    if not strict:\n", "        # Put numpy array conversion _before_ float/int, see\n", "        # <https://github.com/sympy/sympy/issues/13924>.\n", "        flat = getattr(a, \"flat\", None)\n", "        if flat is not None:\n", "            shape = getattr(a, \"shape\", None)\n", "            if shape is not None:\n", "                from ..tensor.array import Array\n", "                return Array(a.flat, a.shape)  # works with e.g. NumPy arrays\n", "\n", "    if not isinstance(a, str):\n", "        if _is_numpy_instance(a):\n", "            import numpy as np\n", "            assert not isinstance(a, np.number)\n", "            if isinstance(a, np.ndarray):\n", "                # Scalar arrays (those with zero dimensions) have sympify\n", "                # called on the scalar element.\n", "                if a.ndim == 0:\n", "                    try:\n", "                        return sympify(a.item(),\n", "                                       locals=locals,\n", "                                       convert_xor=convert_xor,\n", "                                       strict=strict,\n", "                                       rational=rational,\n", "                                       evaluate=evaluate)\n", "                    except SympifyError:\n", "                        pass\n", "        else:\n", "            # float and int can coerce size-one numpy arrays to their lone\n", "            # element.  See issue https://github.com/numpy/numpy/issues/10404.\n", "            for coerce in (float, int):\n", "                try:\n", "                    return sympify(coerce(a))\n", "                except (TypeError, ValueError, AttributeError, SympifyError):\n", "                    continue\n", "\n", "    if strict:\n", "        raise SympifyError(a)\n", "\n", "    if iterable(a):\n", "        try:\n", "            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,\n", "                rational=rational) for x in a])\n", "        except TypeError:\n", "            # Not all iterables are rebuildable with their type.\n", "            pass\n", "    if isinstance(a, dict):\n", "        try:\n", "            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,\n", "                rational=rational) for x in a.items()])\n", "        except TypeError:\n", "            # Not all iterables are rebuildable with their type.\n", "            pass\n", "\n", "    if not isinstance(a, str):\n", "        try:\n", "            a = str(a)\n", "        except Exception as exc:\n", "            raise SympifyError(a, exc)\n", "        from sympy.utilities.exceptions import SymPyDeprecationWarning\n", "        SymPyDeprecationWarning(\n", "            feature=\"String fallback in sympify\",\n", "            useinstead= \\\n", "                'sympify(str(obj)) or ' + \\\n", "                'sympy.core.sympify.converter or obj._sympy_',\n", "            issue=18066,\n", "            deprecated_since_version='1.6'\n", "        ).warn()\n", "\n", "    from sympy.parsing.sympy_parser import (parse_expr, TokenError,\n", "                                            standard_transformations)\n", "    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n", "    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n", "\n", "    transformations = standard_transformations\n", "\n", "    if rational:\n", "        transformations += (t_rationalize,)\n", "    if convert_xor:\n", "        transformations += (t_convert_xor,)\n", "\n", "    try:\n", "        a = a.replace('\\n', '')\n", "        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n", "    except (TokenError, SyntaxError) as exc:\n", "        raise SympifyError('could not parse %r' % a, exc)\n", "\n", "    return expr\n"]}]}, {"file_path": "sympy/functions/elementary/integers.py", "span_ids": ["ceiling"], "content": [{"span_id": "ceiling", "start_line": 225, "end_line": 261, "content": ["class ceiling(RoundFunction):\n", "    \"\"\"\n", "    Ceiling is a univariate function which returns the smallest integer\n", "    value not less than its argument. This implementation\n", "    generalizes ceiling to complex numbers by taking the ceiling of the\n", "    real and imaginary parts separately.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import ceiling, E, I, S, Float, Rational\n", "    >>> ceiling(17)\n", "    17\n", "    >>> ceiling(Rational(23, 10))\n", "    3\n", "    >>> ceiling(2*E)\n", "    6\n", "    >>> ceiling(-Float(0.567))\n", "    0\n", "    >>> ceiling(I/2)\n", "    I\n", "    >>> ceiling(S(5)/2 + 5*I/2)\n", "    3 + 3*I\n", "\n", "    See Also\n", "    ========\n", "\n", "    sympy.functions.elementary.integers.floor\n", "\n", "    References\n", "    ==========\n", "\n", "    .. [1] \"Concrete mathematics\" by Graham, pp. 87\n", "    .. [2] http://mathworld.wolfram.com/CeilingFunction.html\n", "\n", "    \"\"\"\n", "    _dir = 1\n"]}]}]}