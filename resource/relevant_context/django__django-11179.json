{"instance_id": "django__django-11179", "identified_spans": [{"file_path": "django/db/models/deletion.py", "span_ids": ["Collector.delete"], "content": [{"span_id": "Collector.delete", "start_line": 262, "end_line": 327, "content": ["    def delete(self):\n", "        # sort instance collections\n", "        for model, instances in self.data.items():\n", "            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n", "\n", "        # if possible, bring the models in an order suitable for databases that\n", "        # don't support transactions or cannot defer constraint checks until the\n", "        # end of a transaction.\n", "        self.sort()\n", "        # number of objects deleted for each model label\n", "        deleted_counter = Counter()\n", "\n", "        # Optimize for the case with a single obj and no dependencies\n", "        if len(self.data) == 1 and len(instances) == 1:\n", "            instance = list(instances)[0]\n", "            if self.can_fast_delete(instance):\n", "                with transaction.mark_for_rollback_on_error():\n", "                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n", "                return count, {model._meta.label: count}\n", "\n", "        with transaction.atomic(using=self.using, savepoint=False):\n", "            # send pre_delete signals\n", "            for model, obj in self.instances_with_model():\n", "                if not model._meta.auto_created:\n", "                    signals.pre_delete.send(\n", "                        sender=model, instance=obj, using=self.using\n", "                    )\n", "\n", "            # fast deletes\n", "            for qs in self.fast_deletes:\n", "                count = qs._raw_delete(using=self.using)\n", "                deleted_counter[qs.model._meta.label] += count\n", "\n", "            # update fields\n", "            for model, instances_for_fieldvalues in self.field_updates.items():\n", "                for (field, value), instances in instances_for_fieldvalues.items():\n", "                    query = sql.UpdateQuery(model)\n", "                    query.update_batch([obj.pk for obj in instances],\n", "                                       {field.name: value}, self.using)\n", "\n", "            # reverse instance collections\n", "            for instances in self.data.values():\n", "                instances.reverse()\n", "\n", "            # delete instances\n", "            for model, instances in self.data.items():\n", "                query = sql.DeleteQuery(model)\n", "                pk_list = [obj.pk for obj in instances]\n", "                count = query.delete_batch(pk_list, self.using)\n", "                deleted_counter[model._meta.label] += count\n", "\n", "                if not model._meta.auto_created:\n", "                    for obj in instances:\n", "                        signals.post_delete.send(\n", "                            sender=model, instance=obj, using=self.using\n", "                        )\n", "\n", "        # update collected instances\n", "        for instances_for_fieldvalues in self.field_updates.values():\n", "            for (field, value), instances in instances_for_fieldvalues.items():\n", "                for obj in instances:\n", "                    setattr(obj, field.attname, value)\n", "        for model, instances in self.data.items():\n", "            for instance in instances:\n", "                setattr(instance, model._meta.pk.attname, None)\n", "        return sum(deleted_counter.values()), dict(deleted_counter)\n"]}]}]}