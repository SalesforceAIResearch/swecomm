{"instance_id": "matplotlib__matplotlib-23476", "identified_spans": [{"file_path": "lib/matplotlib/backends/backend_macosx.py", "span_ids": ["FigureCanvasMac.resize", "FigureCanvasMac"], "content": [{"span_id": "FigureCanvasMac.resize", "start_line": 95, "end_line": 102, "content": ["    def resize(self, width, height):\n", "        # Size from macOS is logical pixels, dpi is physical.\n", "        scale = self.figure.dpi / self.device_pixel_ratio\n", "        width /= scale\n", "        height /= scale\n", "        self.figure.set_size_inches(width, height, forward=False)\n", "        ResizeEvent(\"resize_event\", self)._process()\n", "        self.draw_idle()\n"]}, {"span_id": "FigureCanvasMac", "start_line": 20, "end_line": 36, "content": ["class FigureCanvasMac(FigureCanvasAgg, _macosx.FigureCanvas, FigureCanvasBase):\n", "    # docstring inherited\n", "\n", "    # Ideally this class would be `class FCMacAgg(FCAgg, FCMac)`\n", "    # (FC=FigureCanvas) where FCMac would be an ObjC-implemented mac-specific\n", "    # class also inheriting from FCBase (this is the approach with other GUI\n", "    # toolkits).  However, writing an extension type inheriting from a Python\n", "    # base class is slightly tricky (the extension type must be a heap type),\n", "    # and we can just as well lift the FCBase base up one level, keeping it *at\n", "    # the end* to have the right method resolution order.\n", "\n", "    # Events such as button presses, mouse movements, and key presses are\n", "    # handled in C and events (MouseEvent, etc.) are triggered from there.\n", "\n", "    required_interactive_framework = \"macosx\"\n", "    _timer_cls = TimerMac\n", "    manager_class = _api.classproperty(lambda cls: FigureManagerMac)\n"]}]}, {"file_path": "lib/matplotlib/figure.py", "span_ids": ["Figure:7", "Figure.__setstate__", "Figure.__getstate__"], "content": [{"span_id": "Figure:7", "start_line": 2597, "end_line": 2597, "content": ["    dpi = property(_get_dpi, _set_dpi, doc=\"The resolution in dots per inch.\")\n"]}, {"span_id": "Figure.__setstate__", "start_line": 3035, "end_line": 3059, "content": ["    def __setstate__(self, state):\n", "        version = state.pop('__mpl_version__')\n", "        restore_to_pylab = state.pop('_restore_to_pylab', False)\n", "\n", "        if version != mpl.__version__:\n", "            _api.warn_external(\n", "                f\"This figure was saved with matplotlib version {version} and \"\n", "                f\"is unlikely to function correctly.\")\n", "\n", "        self.__dict__ = state\n", "\n", "        # re-initialise some of the unstored state information\n", "        FigureCanvasBase(self)  # Set self.canvas.\n", "\n", "        if restore_to_pylab:\n", "            # lazy import to avoid circularity\n", "            import matplotlib.pyplot as plt\n", "            import matplotlib._pylab_helpers as pylab_helpers\n", "            allnums = plt.get_fignums()\n", "            num = max(allnums) + 1 if allnums else 1\n", "            mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n", "            pylab_helpers.Gcf._set_new_active_manager(mgr)\n", "            plt.draw_if_interactive()\n", "\n", "        self.stale = True\n"]}, {"span_id": "Figure.__getstate__", "start_line": 3015, "end_line": 3033, "content": ["    def __getstate__(self):\n", "        state = super().__getstate__()\n", "\n", "        # The canvas cannot currently be pickled, but this has the benefit\n", "        # of meaning that a figure can be detached from one canvas, and\n", "        # re-attached to another.\n", "        state.pop(\"canvas\")\n", "\n", "        # Set cached renderer to None -- it can't be pickled.\n", "        state[\"_cachedRenderer\"] = None\n", "\n", "        # add version information to the state\n", "        state['__mpl_version__'] = mpl.__version__\n", "\n", "        # check whether the figure manager (if any) is registered with pyplot\n", "        from matplotlib import _pylab_helpers\n", "        if self.canvas.manager in _pylab_helpers.Gcf.figs.values():\n", "            state['_restore_to_pylab'] = True\n", "        return state\n"]}]}]}