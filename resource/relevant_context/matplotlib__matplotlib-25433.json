{"instance_id": "matplotlib__matplotlib-25433", "identified_spans": [{"file_path": "lib/matplotlib/backends/_backend_tk.py", "span_ids": ["FigureCanvasTk.draw_idle"], "content": [{"span_id": "FigureCanvasTk.draw_idle", "start_line": 266, "end_line": 277, "content": ["    def draw_idle(self):\n", "        # docstring inherited\n", "        if self._idle_draw_id:\n", "            return\n", "\n", "        def idle_draw(*args):\n", "            try:\n", "                self.draw()\n", "            finally:\n", "                self._idle_draw_id = None\n", "\n", "        self._idle_draw_id = self._tkcanvas.after_idle(idle_draw)\n"]}]}, {"file_path": "lib/matplotlib/backends/backend_gtk3.py", "span_ids": ["FigureCanvasGTK3", "FigureCanvasGTK3.key_press_event", "FigureCanvasGTK3.leave_notify_event", "FigureCanvasGTK3.scroll_event", "FigureCanvasGTK3.enter_notify_event", "FigureCanvasGTK3.button_release_event", "FigureCanvasGTK3.size_allocate"], "content": [{"span_id": "FigureCanvasGTK3", "start_line": 55, "end_line": 68, "content": ["class FigureCanvasGTK3(_FigureCanvasGTK, Gtk.DrawingArea):\n", "    required_interactive_framework = \"gtk3\"\n", "    manager_class = _api.classproperty(lambda cls: FigureManagerGTK3)\n", "    # Setting this as a static constant prevents\n", "    # this resulting expression from leaking\n", "    event_mask = (Gdk.EventMask.BUTTON_PRESS_MASK\n", "                  | Gdk.EventMask.BUTTON_RELEASE_MASK\n", "                  | Gdk.EventMask.EXPOSURE_MASK\n", "                  | Gdk.EventMask.KEY_PRESS_MASK\n", "                  | Gdk.EventMask.KEY_RELEASE_MASK\n", "                  | Gdk.EventMask.ENTER_NOTIFY_MASK\n", "                  | Gdk.EventMask.LEAVE_NOTIFY_MASK\n", "                  | Gdk.EventMask.POINTER_MOTION_MASK\n", "                  | Gdk.EventMask.SCROLL_MASK)\n"]}, {"span_id": "FigureCanvasGTK3.key_press_event", "start_line": 156, "end_line": 160, "content": ["    def key_press_event(self, widget, event):\n", "        KeyEvent(\"key_press_event\", self,\n", "                 self._get_key(event), *self._mpl_coords(),\n", "                 guiEvent=event)._process()\n", "        return True  # stop event propagation\n"]}, {"span_id": "FigureCanvasGTK3.leave_notify_event", "start_line": 181, "end_line": 186, "content": ["    def leave_notify_event(self, widget, event):\n", "        gtk_mods = Gdk.Keymap.get_for_display(\n", "            self.get_display()).get_modifier_state()\n", "        LocationEvent(\"figure_leave_event\", self, *self._mpl_coords(event),\n", "                      modifiers=self._mpl_modifiers(gtk_mods),\n", "                      guiEvent=event)._process()\n"]}, {"span_id": "FigureCanvasGTK3.scroll_event", "start_line": 134, "end_line": 140, "content": ["    def scroll_event(self, widget, event):\n", "        step = 1 if event.direction == Gdk.ScrollDirection.UP else -1\n", "        MouseEvent(\"scroll_event\", self,\n", "                   *self._mpl_coords(event), step=step,\n", "                   modifiers=self._mpl_modifiers(event.state),\n", "                   guiEvent=event)._process()\n", "        return False  # finish event propagation?\n"]}, {"span_id": "FigureCanvasGTK3.enter_notify_event", "start_line": 174, "end_line": 179, "content": ["    def enter_notify_event(self, widget, event):\n", "        gtk_mods = Gdk.Keymap.get_for_display(\n", "            self.get_display()).get_modifier_state()\n", "        LocationEvent(\"figure_enter_event\", self, *self._mpl_coords(event),\n", "                      modifiers=self._mpl_modifiers(gtk_mods),\n", "                      guiEvent=event)._process()\n"]}, {"span_id": "FigureCanvasGTK3.button_release_event", "start_line": 149, "end_line": 154, "content": ["    def button_release_event(self, widget, event):\n", "        MouseEvent(\"button_release_event\", self,\n", "                   *self._mpl_coords(event), event.button,\n", "                   modifiers=self._mpl_modifiers(event.state),\n", "                   guiEvent=event)._process()\n", "        return False  # finish event propagation?\n"]}, {"span_id": "FigureCanvasGTK3.size_allocate", "start_line": 188, "end_line": 194, "content": ["    def size_allocate(self, widget, allocation):\n", "        dpival = self.figure.dpi\n", "        winch = allocation.width * self.device_pixel_ratio / dpival\n", "        hinch = allocation.height * self.device_pixel_ratio / dpival\n", "        self.figure.set_size_inches(winch, hinch, forward=False)\n", "        ResizeEvent(\"resize_event\", self)._process()\n", "        self.draw_idle()\n"]}]}, {"file_path": "lib/matplotlib/widgets.py", "span_ids": ["RangeSlider", "Slider.__init__", "RangeSlider._update", "Slider.set_val", "Slider.on_changed", "Slider", "RangeSlider.__init__", "RangeSlider.on_changed", "Slider._update", "RangeSlider.set_val"], "content": [{"span_id": "RangeSlider", "start_line": 606, "end_line": 619, "content": ["class RangeSlider(SliderBase):\n", "    \"\"\"\n", "    A slider representing a range of floating point values. Defines the min and\n", "    max of the range via the *val* attribute as a tuple of (min, max).\n", "\n", "    Create a slider that defines a range contained within [*valmin*, *valmax*]\n", "    in Axes *ax*. For the slider to remain responsive you must maintain a\n", "    reference to it. Call :meth:`on_changed` to connect to the slider event.\n", "\n", "    Attributes\n", "    ----------\n", "    val : tuple of float\n", "        Slider value.\n", "    \"\"\"\n"]}, {"span_id": "Slider.__init__", "start_line": 348, "end_line": 503, "content": ["    @_api.make_keyword_only(\"3.7\", name=\"valinit\")\n", "    def __init__(self, ax, label, valmin, valmax, valinit=0.5, valfmt=None,\n", "                 closedmin=True, closedmax=True, slidermin=None,\n", "                 slidermax=None, dragging=True, valstep=None,\n", "                 orientation='horizontal', *, initcolor='r',\n", "                 track_color='lightgrey', handle_style=None, **kwargs):\n", "        \"\"\"\n", "        Parameters\n", "        ----------\n", "        ax : Axes\n", "            The Axes to put the slider in.\n", "\n", "        label : str\n", "            Slider label.\n", "\n", "        valmin : float\n", "            The minimum value of the slider.\n", "\n", "        valmax : float\n", "            The maximum value of the slider.\n", "\n", "        valinit : float, default: 0.5\n", "            The slider initial position.\n", "\n", "        valfmt : str, default: None\n", "            %-format string used to format the slider value.  If None, a\n", "            `.ScalarFormatter` is used instead.\n", "\n", "        closedmin : bool, default: True\n", "            Whether the slider interval is closed on the bottom.\n", "\n", "        closedmax : bool, default: True\n", "            Whether the slider interval is closed on the top.\n", "\n", "        slidermin : Slider, default: None\n", "            Do not allow the current slider to have a value less than\n", "            the value of the Slider *slidermin*.\n", "\n", "        slidermax : Slider, default: None\n", "            Do not allow the current slider to have a value greater than\n", "            the value of the Slider *slidermax*.\n", "\n", "        dragging : bool, default: True\n", "            If True the slider can be dragged by the mouse.\n", "\n", "        valstep : float or array-like, default: None\n", "            If a float, the slider will snap to multiples of *valstep*.\n", "            If an array the slider will snap to the values in the array.\n", "\n", "        orientation : {'horizontal', 'vertical'}, default: 'horizontal'\n", "            The orientation of the slider.\n", "\n", "        initcolor : color, default: 'r'\n", "            The color of the line at the *valinit* position. Set to ``'none'``\n", "            for no line.\n", "\n", "        track_color : color, default: 'lightgrey'\n", "            The color of the background track. The track is accessible for\n", "            further styling via the *track* attribute.\n", "\n", "        handle_style : dict\n", "            Properties of the slider handle. Default values are\n", "\n", "            ========= ===== ======= ========================================\n", "            Key       Value Default Description\n", "            ========= ===== ======= ========================================\n", "            facecolor color 'white' The facecolor of the slider handle.\n", "            edgecolor color '.75'   The edgecolor of the slider handle.\n", "            size      int   10      The size of the slider handle in points.\n", "            ========= ===== ======= ========================================\n", "\n", "            Other values will be transformed as marker{foo} and passed to the\n", "            `~.Line2D` constructor. e.g. ``handle_style = {'style'='x'}`` will\n", "            result in ``markerstyle = 'x'``.\n", "\n", "        Notes\n", "        -----\n", "        Additional kwargs are passed on to ``self.poly`` which is the\n", "        `~matplotlib.patches.Polygon` that draws the slider knob.  See the\n", "        `.Polygon` documentation for valid property names (``facecolor``,\n", "        ``edgecolor``, ``alpha``, etc.).\n", "        \"\"\"\n", "        super().__init__(ax, orientation, closedmin, closedmax,\n", "                         valmin, valmax, valfmt, dragging, valstep)\n", "\n", "        if slidermin is not None and not hasattr(slidermin, 'val'):\n", "            raise ValueError(\n", "                f\"Argument slidermin ({type(slidermin)}) has no 'val'\")\n", "        if slidermax is not None and not hasattr(slidermax, 'val'):\n", "            raise ValueError(\n", "                f\"Argument slidermax ({type(slidermax)}) has no 'val'\")\n", "        self.slidermin = slidermin\n", "        self.slidermax = slidermax\n", "        valinit = self._value_in_bounds(valinit)\n", "        if valinit is None:\n", "            valinit = valmin\n", "        self.val = valinit\n", "        self.valinit = valinit\n", "\n", "        defaults = {'facecolor': 'white', 'edgecolor': '.75', 'size': 10}\n", "        handle_style = {} if handle_style is None else handle_style\n", "        marker_props = {\n", "            f'marker{k}': v for k, v in {**defaults, **handle_style}.items()\n", "        }\n", "\n", "        if orientation == 'vertical':\n", "            self.track = Rectangle(\n", "                (.25, 0), .5, 1,\n", "                transform=ax.transAxes,\n", "                facecolor=track_color\n", "            )\n", "            ax.add_patch(self.track)\n", "            self.poly = ax.axhspan(valmin, valinit, .25, .75, **kwargs)\n", "            # Drawing a longer line and clipping it to the track avoids\n", "            # pixelation-related asymmetries.\n", "            self.hline = ax.axhline(valinit, 0, 1, color=initcolor, lw=1,\n", "                                    clip_path=TransformedPatchPath(self.track))\n", "            handleXY = [[0.5], [valinit]]\n", "        else:\n", "            self.track = Rectangle(\n", "                (0, .25), 1, .5,\n", "                transform=ax.transAxes,\n", "                facecolor=track_color\n", "            )\n", "            ax.add_patch(self.track)\n", "            self.poly = ax.axvspan(valmin, valinit, .25, .75, **kwargs)\n", "            self.vline = ax.axvline(valinit, 0, 1, color=initcolor, lw=1,\n", "                                    clip_path=TransformedPatchPath(self.track))\n", "            handleXY = [[valinit], [0.5]]\n", "        self._handle, = ax.plot(\n", "            *handleXY,\n", "            \"o\",\n", "            **marker_props,\n", "            clip_on=False\n", "        )\n", "\n", "        if orientation == 'vertical':\n", "            self.label = ax.text(0.5, 1.02, label, transform=ax.transAxes,\n", "                                 verticalalignment='bottom',\n", "                                 horizontalalignment='center')\n", "\n", "            self.valtext = ax.text(0.5, -0.02, self._format(valinit),\n", "                                   transform=ax.transAxes,\n", "                                   verticalalignment='top',\n", "                                   horizontalalignment='center')\n", "        else:\n", "            self.label = ax.text(-0.02, 0.5, label, transform=ax.transAxes,\n", "                                 verticalalignment='center',\n", "                                 horizontalalignment='right')\n", "\n", "            self.valtext = ax.text(1.02, 0.5, self._format(valinit),\n", "                                   transform=ax.transAxes,\n", "                                   verticalalignment='center',\n", "                                   horizontalalignment='left')\n", "\n", "        self.set_val(valinit)\n"]}, {"span_id": "RangeSlider._update", "start_line": 867, "end_line": 906, "content": ["    def _update(self, event):\n", "        \"\"\"Update the slider position.\"\"\"\n", "        if self.ignore(event) or event.button != 1:\n", "            return\n", "\n", "        if event.name == \"button_press_event\" and event.inaxes == self.ax:\n", "            self.drag_active = True\n", "            event.canvas.grab_mouse(self.ax)\n", "\n", "        if not self.drag_active:\n", "            return\n", "\n", "        elif (event.name == \"button_release_event\") or (\n", "            event.name == \"button_press_event\" and event.inaxes != self.ax\n", "        ):\n", "            self.drag_active = False\n", "            event.canvas.release_mouse(self.ax)\n", "            self._active_handle = None\n", "            return\n", "\n", "        # determine which handle was grabbed\n", "        if self.orientation == \"vertical\":\n", "            handle_index = np.argmin(\n", "                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n", "            )\n", "        else:\n", "            handle_index = np.argmin(\n", "                np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n", "            )\n", "        handle = self._handles[handle_index]\n", "\n", "        # these checks ensure smooth behavior if the handles swap which one\n", "        # has a higher value. i.e. if one is dragged over and past the other.\n", "        if handle is not self._active_handle:\n", "            self._active_handle = handle\n", "\n", "        if self.orientation == \"vertical\":\n", "            self._update_val_from_pos(event.ydata)\n", "        else:\n", "            self._update_val_from_pos(event.xdata)\n"]}, {"span_id": "Slider.set_val", "start_line": 563, "end_line": 586, "content": ["    def set_val(self, val):\n", "        \"\"\"\n", "        Set slider value to *val*.\n", "\n", "        Parameters\n", "        ----------\n", "        val : float\n", "        \"\"\"\n", "        xy = self.poly.xy\n", "        if self.orientation == 'vertical':\n", "            xy[1] = .25, val\n", "            xy[2] = .75, val\n", "            self._handle.set_ydata([val])\n", "        else:\n", "            xy[2] = val, .75\n", "            xy[3] = val, .25\n", "            self._handle.set_xdata([val])\n", "        self.poly.xy = xy\n", "        self.valtext.set_text(self._format(val))\n", "        if self.drawon:\n", "            self.ax.figure.canvas.draw_idle()\n", "        self.val = val\n", "        if self.eventson:\n", "            self._observers.process('changed', val)\n"]}, {"span_id": "Slider.on_changed", "start_line": 588, "end_line": 603, "content": ["    def on_changed(self, func):\n", "        \"\"\"\n", "        Connect *func* as callback function to changes of the slider value.\n", "\n", "        Parameters\n", "        ----------\n", "        func : callable\n", "            Function to call when slider is changed.\n", "            The function must accept a single float as its arguments.\n", "\n", "        Returns\n", "        -------\n", "        int\n", "            Connection id (which can be used to disconnect *func*).\n", "        \"\"\"\n", "        return self._observers.connect('changed', lambda val: func(val))\n"]}, {"span_id": "Slider", "start_line": 334, "end_line": 346, "content": ["class Slider(SliderBase):\n", "    \"\"\"\n", "    A slider representing a floating point range.\n", "\n", "    Create a slider from *valmin* to *valmax* in Axes *ax*. For the slider to\n", "    remain responsive you must maintain a reference to it. Call\n", "    :meth:`on_changed` to connect to the slider event.\n", "\n", "    Attributes\n", "    ----------\n", "    val : float\n", "        Slider value.\n", "    \"\"\"\n"]}, {"span_id": "RangeSlider.__init__", "start_line": 621, "end_line": 803, "content": ["    @_api.make_keyword_only(\"3.7\", name=\"valinit\")\n", "    def __init__(\n", "        self,\n", "        ax,\n", "        label,\n", "        valmin,\n", "        valmax,\n", "        valinit=None,\n", "        valfmt=None,\n", "        closedmin=True,\n", "        closedmax=True,\n", "        dragging=True,\n", "        valstep=None,\n", "        orientation=\"horizontal\",\n", "        track_color='lightgrey',\n", "        handle_style=None,\n", "        **kwargs,\n", "    ):\n", "        \"\"\"\n", "        Parameters\n", "        ----------\n", "        ax : Axes\n", "            The Axes to put the slider in.\n", "\n", "        label : str\n", "            Slider label.\n", "\n", "        valmin : float\n", "            The minimum value of the slider.\n", "\n", "        valmax : float\n", "            The maximum value of the slider.\n", "\n", "        valinit : tuple of float or None, default: None\n", "            The initial positions of the slider. If None the initial positions\n", "            will be at the 25th and 75th percentiles of the range.\n", "\n", "        valfmt : str, default: None\n", "            %-format string used to format the slider values.  If None, a\n", "            `.ScalarFormatter` is used instead.\n", "\n", "        closedmin : bool, default: True\n", "            Whether the slider interval is closed on the bottom.\n", "\n", "        closedmax : bool, default: True\n", "            Whether the slider interval is closed on the top.\n", "\n", "        dragging : bool, default: True\n", "            If True the slider can be dragged by the mouse.\n", "\n", "        valstep : float, default: None\n", "            If given, the slider will snap to multiples of *valstep*.\n", "\n", "        orientation : {'horizontal', 'vertical'}, default: 'horizontal'\n", "            The orientation of the slider.\n", "\n", "        track_color : color, default: 'lightgrey'\n", "            The color of the background track. The track is accessible for\n", "            further styling via the *track* attribute.\n", "\n", "        handle_style : dict\n", "            Properties of the slider handles. Default values are\n", "\n", "            ========= ===== ======= =========================================\n", "            Key       Value Default Description\n", "            ========= ===== ======= =========================================\n", "            facecolor color 'white' The facecolor of the slider handles.\n", "            edgecolor color '.75'   The edgecolor of the slider handles.\n", "            size      int   10      The size of the slider handles in points.\n", "            ========= ===== ======= =========================================\n", "\n", "            Other values will be transformed as marker{foo} and passed to the\n", "            `~.Line2D` constructor. e.g. ``handle_style = {'style'='x'}`` will\n", "            result in ``markerstyle = 'x'``.\n", "\n", "        Notes\n", "        -----\n", "        Additional kwargs are passed on to ``self.poly`` which is the\n", "        `~matplotlib.patches.Polygon` that draws the slider knob.  See the\n", "        `.Polygon` documentation for valid property names (``facecolor``,\n", "        ``edgecolor``, ``alpha``, etc.).\n", "        \"\"\"\n", "        super().__init__(ax, orientation, closedmin, closedmax,\n", "                         valmin, valmax, valfmt, dragging, valstep)\n", "\n", "        # Set a value to allow _value_in_bounds() to work.\n", "        self.val = (valmin, valmax)\n", "        if valinit is None:\n", "            # Place at the 25th and 75th percentiles\n", "            extent = valmax - valmin\n", "            valinit = np.array([valmin + extent * 0.25,\n", "                                valmin + extent * 0.75])\n", "        else:\n", "            valinit = self._value_in_bounds(valinit)\n", "        self.val = valinit\n", "        self.valinit = valinit\n", "\n", "        defaults = {'facecolor': 'white', 'edgecolor': '.75', 'size': 10}\n", "        handle_style = {} if handle_style is None else handle_style\n", "        marker_props = {\n", "            f'marker{k}': v for k, v in {**defaults, **handle_style}.items()\n", "        }\n", "\n", "        if orientation == \"vertical\":\n", "            self.track = Rectangle(\n", "                (.25, 0), .5, 2,\n", "                transform=ax.transAxes,\n", "                facecolor=track_color\n", "            )\n", "            ax.add_patch(self.track)\n", "            poly_transform = self.ax.get_yaxis_transform(which=\"grid\")\n", "            handleXY_1 = [.5, valinit[0]]\n", "            handleXY_2 = [.5, valinit[1]]\n", "        else:\n", "            self.track = Rectangle(\n", "                (0, .25), 1, .5,\n", "                transform=ax.transAxes,\n", "                facecolor=track_color\n", "            )\n", "            ax.add_patch(self.track)\n", "            poly_transform = self.ax.get_xaxis_transform(which=\"grid\")\n", "            handleXY_1 = [valinit[0], .5]\n", "            handleXY_2 = [valinit[1], .5]\n", "        self.poly = Polygon(np.zeros([5, 2]), **kwargs)\n", "        self._update_selection_poly(*valinit)\n", "        self.poly.set_transform(poly_transform)\n", "        self.poly.get_path()._interpolation_steps = 100\n", "        self.ax.add_patch(self.poly)\n", "        self.ax._request_autoscale_view()\n", "        self._handles = [\n", "            ax.plot(\n", "                *handleXY_1,\n", "                \"o\",\n", "                **marker_props,\n", "                clip_on=False\n", "            )[0],\n", "            ax.plot(\n", "                *handleXY_2,\n", "                \"o\",\n", "                **marker_props,\n", "                clip_on=False\n", "            )[0]\n", "        ]\n", "\n", "        if orientation == \"vertical\":\n", "            self.label = ax.text(\n", "                0.5,\n", "                1.02,\n", "                label,\n", "                transform=ax.transAxes,\n", "                verticalalignment=\"bottom\",\n", "                horizontalalignment=\"center\",\n", "            )\n", "\n", "            self.valtext = ax.text(\n", "                0.5,\n", "                -0.02,\n", "                self._format(valinit),\n", "                transform=ax.transAxes,\n", "                verticalalignment=\"top\",\n", "                horizontalalignment=\"center\",\n", "            )\n", "        else:\n", "            self.label = ax.text(\n", "                -0.02,\n", "                0.5,\n", "                label,\n", "                transform=ax.transAxes,\n", "                verticalalignment=\"center\",\n", "                horizontalalignment=\"right\",\n", "            )\n", "\n", "            self.valtext = ax.text(\n", "                1.02,\n", "                0.5,\n", "                self._format(valinit),\n", "                transform=ax.transAxes,\n", "                verticalalignment=\"center\",\n", "                horizontalalignment=\"left\",\n", "            )\n", "\n", "        self._active_handle = None\n", "        self.set_val(valinit)\n"]}, {"span_id": "RangeSlider.on_changed", "start_line": 971, "end_line": 986, "content": ["    def on_changed(self, func):\n", "        \"\"\"\n", "        Connect *func* as callback function to changes of the slider value.\n", "\n", "        Parameters\n", "        ----------\n", "        func : callable\n", "            Function to call when slider is changed. The function\n", "            must accept a 2-tuple of floats as its argument.\n", "\n", "        Returns\n", "        -------\n", "        int\n", "            Connection id (which can be used to disconnect *func*).\n", "        \"\"\"\n", "        return self._observers.connect('changed', lambda val: func(val))\n"]}, {"span_id": "Slider._update", "start_line": 529, "end_line": 552, "content": ["    def _update(self, event):\n", "        \"\"\"Update the slider position.\"\"\"\n", "        if self.ignore(event) or event.button != 1:\n", "            return\n", "\n", "        if event.name == 'button_press_event' and event.inaxes == self.ax:\n", "            self.drag_active = True\n", "            event.canvas.grab_mouse(self.ax)\n", "\n", "        if not self.drag_active:\n", "            return\n", "\n", "        elif ((event.name == 'button_release_event') or\n", "              (event.name == 'button_press_event' and\n", "               event.inaxes != self.ax)):\n", "            self.drag_active = False\n", "            event.canvas.release_mouse(self.ax)\n", "            return\n", "        if self.orientation == 'vertical':\n", "            val = self._value_in_bounds(event.ydata)\n", "        else:\n", "            val = self._value_in_bounds(event.xdata)\n", "        if val not in [None, self.val]:\n", "            self.set_val(val)\n"]}, {"span_id": "RangeSlider.set_val", "start_line": 942, "end_line": 969, "content": ["    def set_val(self, val):\n", "        \"\"\"\n", "        Set slider value to *val*.\n", "\n", "        Parameters\n", "        ----------\n", "        val : tuple or array-like of float\n", "        \"\"\"\n", "        val = np.sort(val)\n", "        _api.check_shape((2,), val=val)\n", "        # Reset value to allow _value_in_bounds() to work.\n", "        self.val = (self.valmin, self.valmax)\n", "        vmin, vmax = self._value_in_bounds(val)\n", "        self._update_selection_poly(vmin, vmax)\n", "        if self.orientation == \"vertical\":\n", "            self._handles[0].set_ydata([vmin])\n", "            self._handles[1].set_ydata([vmax])\n", "        else:\n", "            self._handles[0].set_xdata([vmin])\n", "            self._handles[1].set_xdata([vmax])\n", "\n", "        self.valtext.set_text(self._format((vmin, vmax)))\n", "\n", "        if self.drawon:\n", "            self.ax.figure.canvas.draw_idle()\n", "        self.val = (vmin, vmax)\n", "        if self.eventson:\n", "            self._observers.process(\"changed\", (vmin, vmax))\n"]}]}]}