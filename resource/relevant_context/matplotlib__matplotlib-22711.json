{"instance_id": "matplotlib__matplotlib-22711", "identified_spans": [{"file_path": "lib/matplotlib/widgets.py", "span_ids": ["RangeSlider.__init__", "RangeSlider.set_val"], "content": [{"span_id": "RangeSlider.__init__", "start_line": 603, "end_line": 778, "content": ["    def __init__(\n", "        self,\n", "        ax,\n", "        label,\n", "        valmin,\n", "        valmax,\n", "        valinit=None,\n", "        valfmt=None,\n", "        closedmin=True,\n", "        closedmax=True,\n", "        dragging=True,\n", "        valstep=None,\n", "        orientation=\"horizontal\",\n", "        track_color='lightgrey',\n", "        handle_style=None,\n", "        **kwargs,\n", "    ):\n", "        \"\"\"\n", "        Parameters\n", "        ----------\n", "        ax : Axes\n", "            The Axes to put the slider in.\n", "\n", "        label : str\n", "            Slider label.\n", "\n", "        valmin : float\n", "            The minimum value of the slider.\n", "\n", "        valmax : float\n", "            The maximum value of the slider.\n", "\n", "        valinit : tuple of float or None, default: None\n", "            The initial positions of the slider. If None the initial positions\n", "            will be at the 25th and 75th percentiles of the range.\n", "\n", "        valfmt : str, default: None\n", "            %-format string used to format the slider values.  If None, a\n", "            `.ScalarFormatter` is used instead.\n", "\n", "        closedmin : bool, default: True\n", "            Whether the slider interval is closed on the bottom.\n", "\n", "        closedmax : bool, default: True\n", "            Whether the slider interval is closed on the top.\n", "\n", "        dragging : bool, default: True\n", "            If True the slider can be dragged by the mouse.\n", "\n", "        valstep : float, default: None\n", "            If given, the slider will snap to multiples of *valstep*.\n", "\n", "        orientation : {'horizontal', 'vertical'}, default: 'horizontal'\n", "            The orientation of the slider.\n", "\n", "        track_color : color, default: 'lightgrey'\n", "            The color of the background track. The track is accessible for\n", "            further styling via the *track* attribute.\n", "\n", "        handle_style : dict\n", "            Properties of the slider handles. Default values are\n", "\n", "            ========= ===== ======= =========================================\n", "            Key       Value Default Description\n", "            ========= ===== ======= =========================================\n", "            facecolor color 'white' The facecolor of the slider handles.\n", "            edgecolor color '.75'   The edgecolor of the slider handles.\n", "            size      int   10      The size of the slider handles in points.\n", "            ========= ===== ======= =========================================\n", "\n", "            Other values will be transformed as marker{foo} and passed to the\n", "            `~.Line2D` constructor. e.g. ``handle_style = {'style'='x'}`` will\n", "            result in ``markerstyle = 'x'``.\n", "\n", "        Notes\n", "        -----\n", "        Additional kwargs are passed on to ``self.poly`` which is the\n", "        `~matplotlib.patches.Polygon` that draws the slider knob.  See the\n", "        `.Polygon` documentation for valid property names (``facecolor``,\n", "        ``edgecolor``, ``alpha``, etc.).\n", "        \"\"\"\n", "        super().__init__(ax, orientation, closedmin, closedmax,\n", "                         valmin, valmax, valfmt, dragging, valstep)\n", "\n", "        # Set a value to allow _value_in_bounds() to work.\n", "        self.val = [valmin, valmax]\n", "        if valinit is None:\n", "            # Place at the 25th and 75th percentiles\n", "            extent = valmax - valmin\n", "            valinit = np.array([valmin + extent * 0.25,\n", "                                valmin + extent * 0.75])\n", "        else:\n", "            valinit = self._value_in_bounds(valinit)\n", "        self.val = valinit\n", "        self.valinit = valinit\n", "\n", "        defaults = {'facecolor': 'white', 'edgecolor': '.75', 'size': 10}\n", "        handle_style = {} if handle_style is None else handle_style\n", "        marker_props = {\n", "            f'marker{k}': v for k, v in {**defaults, **handle_style}.items()\n", "        }\n", "\n", "        if orientation == \"vertical\":\n", "            self.track = Rectangle(\n", "                (.25, 0), .5, 2,\n", "                transform=ax.transAxes,\n", "                facecolor=track_color\n", "            )\n", "            ax.add_patch(self.track)\n", "            self.poly = ax.axhspan(valinit[0], valinit[1], 0, 1, **kwargs)\n", "            handleXY_1 = [.5, valinit[0]]\n", "            handleXY_2 = [.5, valinit[1]]\n", "        else:\n", "            self.track = Rectangle(\n", "                (0, .25), 1, .5,\n", "                transform=ax.transAxes,\n", "                facecolor=track_color\n", "            )\n", "            ax.add_patch(self.track)\n", "            self.poly = ax.axvspan(valinit[0], valinit[1], 0, 1, **kwargs)\n", "            handleXY_1 = [valinit[0], .5]\n", "            handleXY_2 = [valinit[1], .5]\n", "        self._handles = [\n", "            ax.plot(\n", "                *handleXY_1,\n", "                \"o\",\n", "                **marker_props,\n", "                clip_on=False\n", "            )[0],\n", "            ax.plot(\n", "                *handleXY_2,\n", "                \"o\",\n", "                **marker_props,\n", "                clip_on=False\n", "            )[0]\n", "        ]\n", "\n", "        if orientation == \"vertical\":\n", "            self.label = ax.text(\n", "                0.5,\n", "                1.02,\n", "                label,\n", "                transform=ax.transAxes,\n", "                verticalalignment=\"bottom\",\n", "                horizontalalignment=\"center\",\n", "            )\n", "\n", "            self.valtext = ax.text(\n", "                0.5,\n", "                -0.02,\n", "                self._format(valinit),\n", "                transform=ax.transAxes,\n", "                verticalalignment=\"top\",\n", "                horizontalalignment=\"center\",\n", "            )\n", "        else:\n", "            self.label = ax.text(\n", "                -0.02,\n", "                0.5,\n", "                label,\n", "                transform=ax.transAxes,\n", "                verticalalignment=\"center\",\n", "                horizontalalignment=\"right\",\n", "            )\n", "\n", "            self.valtext = ax.text(\n", "                1.02,\n", "                0.5,\n", "                self._format(valinit),\n", "                transform=ax.transAxes,\n", "                verticalalignment=\"center\",\n", "                horizontalalignment=\"left\",\n", "            )\n", "\n", "        self._active_handle = None\n", "        self.set_val(valinit)\n"]}, {"span_id": "RangeSlider.set_val", "start_line": 888, "end_line": 919, "content": ["    def set_val(self, val):\n", "        \"\"\"\n", "        Set slider value to *val*.\n", "\n", "        Parameters\n", "        ----------\n", "        val : tuple or array-like of float\n", "        \"\"\"\n", "        val = np.sort(val)\n", "        _api.check_shape((2,), val=val)\n", "        val[0] = self._min_in_bounds(val[0])\n", "        val[1] = self._max_in_bounds(val[1])\n", "        xy = self.poly.xy\n", "        if self.orientation == \"vertical\":\n", "            xy[0] = .25, val[0]\n", "            xy[1] = .25, val[1]\n", "            xy[2] = .75, val[1]\n", "            xy[3] = .75, val[0]\n", "            xy[4] = .25, val[0]\n", "        else:\n", "            xy[0] = val[0], .25\n", "            xy[1] = val[0], .75\n", "            xy[2] = val[1], .75\n", "            xy[3] = val[1], .25\n", "            xy[4] = val[0], .25\n", "        self.poly.xy = xy\n", "        self.valtext.set_text(self._format(val))\n", "        if self.drawon:\n", "            self.ax.figure.canvas.draw_idle()\n", "        self.val = val\n", "        if self.eventson:\n", "            self._observers.process(\"changed\", val)\n"]}]}]}