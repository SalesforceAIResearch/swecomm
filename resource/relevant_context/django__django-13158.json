{"instance_id": "django__django-13158", "identified_spans": [{"file_path": "django/db/models/query.py", "span_ids": ["QuerySet._chain", "QuerySet._clone", "QuerySet", "QuerySet._combinator_query", "QuerySet.none", "QuerySet.union"], "content": [{"span_id": "QuerySet._chain", "start_line": 1277, "end_line": 1287, "content": ["    def _chain(self, **kwargs):\n", "        \"\"\"\n", "        Return a copy of the current QuerySet that's ready for another\n", "        operation.\n", "        \"\"\"\n", "        obj = self._clone()\n", "        if obj._sticky_filter:\n", "            obj.query.filter_is_sticky = True\n", "            obj._sticky_filter = False\n", "        obj.__dict__.update(kwargs)\n", "        return obj\n"]}, {"span_id": "QuerySet._clone", "start_line": 1289, "end_line": 1301, "content": ["    def _clone(self):\n", "        \"\"\"\n", "        Return a copy of the current QuerySet. A lightweight alternative\n", "        to deepcopy().\n", "        \"\"\"\n", "        c = self.__class__(model=self.model, query=self.query.chain(), using=self._db, hints=self._hints)\n", "        c._sticky_filter = self._sticky_filter\n", "        c._for_write = self._for_write\n", "        c._prefetch_related_lookups = self._prefetch_related_lookups[:]\n", "        c._known_related_objects = self._known_related_objects\n", "        c._iterable_class = self._iterable_class\n", "        c._fields = self._fields\n", "        return c\n"]}, {"span_id": "QuerySet", "start_line": 184, "end_line": 185, "content": ["class QuerySet:\n", "    \"\"\"Represent a lazy database lookup for a set of objects.\"\"\"\n"]}, {"span_id": "QuerySet._combinator_query", "start_line": 988, "end_line": 997, "content": ["    def _combinator_query(self, combinator, *other_qs, all=False):\n", "        # Clone the query to inherit the select list and everything\n", "        clone = self._chain()\n", "        # Clear limits and ordering so they can be reapplied\n", "        clone.query.clear_ordering(True)\n", "        clone.query.clear_limits()\n", "        clone.query.combined_queries = (self.query,) + tuple(qs.query for qs in other_qs)\n", "        clone.query.combinator = combinator\n", "        clone.query.combinator_all = all\n", "        return clone\n"]}, {"span_id": "QuerySet.none", "start_line": 919, "end_line": 923, "content": ["    def none(self):\n", "        \"\"\"Return an empty QuerySet.\"\"\"\n", "        clone = self._chain()\n", "        clone.query.set_empty()\n", "        return clone\n"]}, {"span_id": "QuerySet.union", "start_line": 999, "end_line": 1004, "content": ["    def union(self, *other_qs, all=False):\n", "        # If the query is an EmptyQuerySet, combine all nonempty querysets.\n", "        if isinstance(self, EmptyQuerySet):\n", "            qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n", "            return qs[0]._combinator_query('union', *qs[1:], all=all) if qs else self\n", "        return self._combinator_query('union', *other_qs, all=all)\n"]}]}]}