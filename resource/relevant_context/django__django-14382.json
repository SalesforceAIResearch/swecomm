{"instance_id": "django__django-14382", "identified_spans": [{"file_path": "django/core/management/templates.py", "span_ids": ["TemplateCommand.validate_name", "TemplateCommand.handle", "TemplateCommand"], "content": [{"span_id": "TemplateCommand.validate_name", "start_line": 211, "end_line": 242, "content": ["    def validate_name(self, name, name_or_dir='name'):\n", "        if name is None:\n", "            raise CommandError('you must provide {an} {app} name'.format(\n", "                an=self.a_or_an,\n", "                app=self.app_or_project,\n", "            ))\n", "        # Check it's a valid directory name.\n", "        if not name.isidentifier():\n", "            raise CommandError(\n", "                \"'{name}' is not a valid {app} {type}. Please make sure the \"\n", "                \"{type} is a valid identifier.\".format(\n", "                    name=name,\n", "                    app=self.app_or_project,\n", "                    type=name_or_dir,\n", "                )\n", "            )\n", "        # Check it cannot be imported.\n", "        try:\n", "            import_module(name)\n", "        except ImportError:\n", "            pass\n", "        else:\n", "            raise CommandError(\n", "                \"'{name}' conflicts with the name of an existing Python \"\n", "                \"module and cannot be used as {an} {app} {type}. Please try \"\n", "                \"another {type}.\".format(\n", "                    name=name,\n", "                    an=self.a_or_an,\n", "                    app=self.app_or_project,\n", "                    type=name_or_dir,\n", "                )\n", "            )\n"]}, {"span_id": "TemplateCommand.handle", "start_line": 58, "end_line": 183, "content": ["    def handle(self, app_or_project, name, target=None, **options):\n", "        self.app_or_project = app_or_project\n", "        self.a_or_an = 'an' if app_or_project == 'app' else 'a'\n", "        self.paths_to_remove = []\n", "        self.verbosity = options['verbosity']\n", "\n", "        self.validate_name(name)\n", "\n", "        # if some directory is given, make sure it's nicely expanded\n", "        if target is None:\n", "            top_dir = os.path.join(os.getcwd(), name)\n", "            try:\n", "                os.makedirs(top_dir)\n", "            except FileExistsError:\n", "                raise CommandError(\"'%s' already exists\" % top_dir)\n", "            except OSError as e:\n", "                raise CommandError(e)\n", "        else:\n", "            if app_or_project == 'app':\n", "                self.validate_name(os.path.basename(target), 'directory')\n", "            top_dir = os.path.abspath(os.path.expanduser(target))\n", "            if not os.path.exists(top_dir):\n", "                raise CommandError(\"Destination directory '%s' does not \"\n", "                                   \"exist, please create it first.\" % top_dir)\n", "\n", "        extensions = tuple(handle_extensions(options['extensions']))\n", "        extra_files = []\n", "        for file in options['files']:\n", "            extra_files.extend(map(lambda x: x.strip(), file.split(',')))\n", "        if self.verbosity >= 2:\n", "            self.stdout.write(\n", "                'Rendering %s template files with extensions: %s'\n", "                % (app_or_project, ', '.join(extensions))\n", "            )\n", "            self.stdout.write(\n", "                'Rendering %s template files with filenames: %s'\n", "                % (app_or_project, ', '.join(extra_files))\n", "            )\n", "        base_name = '%s_name' % app_or_project\n", "        base_subdir = '%s_template' % app_or_project\n", "        base_directory = '%s_directory' % app_or_project\n", "        camel_case_name = 'camel_case_%s_name' % app_or_project\n", "        camel_case_value = ''.join(x for x in name.title() if x != '_')\n", "\n", "        context = Context({\n", "            **options,\n", "            base_name: name,\n", "            base_directory: top_dir,\n", "            camel_case_name: camel_case_value,\n", "            'docs_version': get_docs_version(),\n", "            'django_version': django.__version__,\n", "        }, autoescape=False)\n", "\n", "        # Setup a stub settings environment for template rendering\n", "        if not settings.configured:\n", "            settings.configure()\n", "            django.setup()\n", "\n", "        template_dir = self.handle_template(options['template'],\n", "                                            base_subdir)\n", "        prefix_length = len(template_dir) + 1\n", "\n", "        for root, dirs, files in os.walk(template_dir):\n", "\n", "            path_rest = root[prefix_length:]\n", "            relative_dir = path_rest.replace(base_name, name)\n", "            if relative_dir:\n", "                target_dir = os.path.join(top_dir, relative_dir)\n", "                os.makedirs(target_dir, exist_ok=True)\n", "\n", "            for dirname in dirs[:]:\n", "                if dirname.startswith('.') or dirname == '__pycache__':\n", "                    dirs.remove(dirname)\n", "\n", "            for filename in files:\n", "                if filename.endswith(('.pyo', '.pyc', '.py.class')):\n", "                    # Ignore some files as they cause various breakages.\n", "                    continue\n", "                old_path = os.path.join(root, filename)\n", "                new_path = os.path.join(\n", "                    top_dir, relative_dir, filename.replace(base_name, name)\n", "                )\n", "                for old_suffix, new_suffix in self.rewrite_template_suffixes:\n", "                    if new_path.endswith(old_suffix):\n", "                        new_path = new_path[:-len(old_suffix)] + new_suffix\n", "                        break  # Only rewrite once\n", "\n", "                if os.path.exists(new_path):\n", "                    raise CommandError(\n", "                        \"%s already exists. Overlaying %s %s into an existing \"\n", "                        \"directory won't replace conflicting files.\" % (\n", "                            new_path, self.a_or_an, app_or_project,\n", "                        )\n", "                    )\n", "\n", "                # Only render the Python files, as we don't want to\n", "                # accidentally render Django templates files\n", "                if new_path.endswith(extensions) or filename in extra_files:\n", "                    with open(old_path, encoding='utf-8') as template_file:\n", "                        content = template_file.read()\n", "                    template = Engine().from_string(content)\n", "                    content = template.render(context)\n", "                    with open(new_path, 'w', encoding='utf-8') as new_file:\n", "                        new_file.write(content)\n", "                else:\n", "                    shutil.copyfile(old_path, new_path)\n", "\n", "                if self.verbosity >= 2:\n", "                    self.stdout.write('Creating %s' % new_path)\n", "                try:\n", "                    shutil.copymode(old_path, new_path)\n", "                    self.make_writeable(new_path)\n", "                except OSError:\n", "                    self.stderr.write(\n", "                        \"Notice: Couldn't set permission bits on %s. You're \"\n", "                        \"probably using an uncommon filesystem setup. No \"\n", "                        \"problem.\" % new_path, self.style.NOTICE)\n", "\n", "        if self.paths_to_remove:\n", "            if self.verbosity >= 2:\n", "                self.stdout.write('Cleaning up temporary files.')\n", "            for path_to_remove in self.paths_to_remove:\n", "                if os.path.isfile(path_to_remove):\n", "                    os.remove(path_to_remove)\n", "                else:\n", "                    shutil.rmtree(path_to_remove)\n"]}, {"span_id": "TemplateCommand", "start_line": 20, "end_line": 38, "content": ["class TemplateCommand(BaseCommand):\n", "    \"\"\"\n", "    Copy either a Django application layout template or a Django project\n", "    layout template into the specified directory.\n", "\n", "    :param style: A color style object (see django.core.management.color).\n", "    :param app_or_project: The string 'app' or 'project'.\n", "    :param name: The name of the application or project.\n", "    :param directory: The directory to which the template should be copied.\n", "    :param options: The additional variables passed to project or app templates\n", "    \"\"\"\n", "    requires_system_checks = []\n", "    # The supported URL schemes\n", "    url_schemes = ['http', 'https', 'ftp']\n", "    # Rewrite the following suffixes when determining the target filename.\n", "    rewrite_template_suffixes = (\n", "        # Allow shipping invalid .py files without byte-compilation.\n", "        ('.py-tpl', '.py'),\n", "    )\n"]}]}]}