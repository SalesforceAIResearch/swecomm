{"instance_id": "django__django-13321", "identified_spans": [{"file_path": "django/contrib/sessions/backends/base.py", "span_ids": ["SessionBase._legacy_decode", "SessionBase.decode"], "content": [{"span_id": "SessionBase._legacy_decode", "start_line": 133, "end_line": 150, "content": ["    def _legacy_decode(self, session_data):\n", "        # RemovedInDjango40Warning: pre-Django 3.1 format will be invalid.\n", "        encoded_data = base64.b64decode(session_data.encode('ascii'))\n", "        try:\n", "            # could produce ValueError if there is no ':'\n", "            hash, serialized = encoded_data.split(b':', 1)\n", "            expected_hash = self._hash(serialized)\n", "            if not constant_time_compare(hash.decode(), expected_hash):\n", "                raise SuspiciousSession(\"Session data corrupted\")\n", "            else:\n", "                return self.serializer().loads(serialized)\n", "        except Exception as e:\n", "            # ValueError, SuspiciousOperation, unpickling exceptions. If any of\n", "            # these happen, just return an empty dictionary (an empty session).\n", "            if isinstance(e, SuspiciousOperation):\n", "                logger = logging.getLogger('django.security.%s' % e.__class__.__name__)\n", "                logger.warning(str(e))\n", "            return {}\n"]}, {"span_id": "SessionBase.decode", "start_line": 119, "end_line": 125, "content": ["    def decode(self, session_data):\n", "        try:\n", "            return signing.loads(session_data, salt=self.key_salt, serializer=self.serializer)\n", "        # RemovedInDjango40Warning: when the deprecation ends, handle here\n", "        # exceptions similar to what _legacy_decode() does now.\n", "        except Exception:\n", "            return self._legacy_decode(session_data)\n"]}]}]}