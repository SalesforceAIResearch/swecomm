{"instance_id": "django__django-12470", "identified_spans": [{"file_path": "django/db/models/base.py", "span_ids": ["ModelBase.__new__"], "content": [{"span_id": "ModelBase.__new__", "start_line": 74, "end_line": 322, "content": ["    def __new__(cls, name, bases, attrs, **kwargs):\n", "        super_new = super().__new__\n", "\n", "        # Also ensure initialization is only performed for subclasses of Model\n", "        # (excluding Model class itself).\n", "        parents = [b for b in bases if isinstance(b, ModelBase)]\n", "        if not parents:\n", "            return super_new(cls, name, bases, attrs)\n", "\n", "        # Create the class.\n", "        module = attrs.pop('__module__')\n", "        new_attrs = {'__module__': module}\n", "        classcell = attrs.pop('__classcell__', None)\n", "        if classcell is not None:\n", "            new_attrs['__classcell__'] = classcell\n", "        attr_meta = attrs.pop('Meta', None)\n", "        # Pass all attrs without a (Django-specific) contribute_to_class()\n", "        # method to type.__new__() so that they're properly initialized\n", "        # (i.e. __set_name__()).\n", "        contributable_attrs = {}\n", "        for obj_name, obj in list(attrs.items()):\n", "            if _has_contribute_to_class(obj):\n", "                contributable_attrs[obj_name] = obj\n", "            else:\n", "                new_attrs[obj_name] = obj\n", "        new_class = super_new(cls, name, bases, new_attrs, **kwargs)\n", "\n", "        abstract = getattr(attr_meta, 'abstract', False)\n", "        meta = attr_meta or getattr(new_class, 'Meta', None)\n", "        base_meta = getattr(new_class, '_meta', None)\n", "\n", "        app_label = None\n", "\n", "        # Look for an application configuration to attach the model to.\n", "        app_config = apps.get_containing_app_config(module)\n", "\n", "        if getattr(meta, 'app_label', None) is None:\n", "            if app_config is None:\n", "                if not abstract:\n", "                    raise RuntimeError(\n", "                        \"Model class %s.%s doesn't declare an explicit \"\n", "                        \"app_label and isn't in an application in \"\n", "                        \"INSTALLED_APPS.\" % (module, name)\n", "                    )\n", "\n", "            else:\n", "                app_label = app_config.label\n", "\n", "        new_class.add_to_class('_meta', Options(meta, app_label))\n", "        if not abstract:\n", "            new_class.add_to_class(\n", "                'DoesNotExist',\n", "                subclass_exception(\n", "                    'DoesNotExist',\n", "                    tuple(\n", "                        x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract\n", "                    ) or (ObjectDoesNotExist,),\n", "                    module,\n", "                    attached_to=new_class))\n", "            new_class.add_to_class(\n", "                'MultipleObjectsReturned',\n", "                subclass_exception(\n", "                    'MultipleObjectsReturned',\n", "                    tuple(\n", "                        x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract\n", "                    ) or (MultipleObjectsReturned,),\n", "                    module,\n", "                    attached_to=new_class))\n", "            if base_meta and not base_meta.abstract:\n", "                # Non-abstract child classes inherit some attributes from their\n", "                # non-abstract parent (unless an ABC comes before it in the\n", "                # method resolution order).\n", "                if not hasattr(meta, 'ordering'):\n", "                    new_class._meta.ordering = base_meta.ordering\n", "                if not hasattr(meta, 'get_latest_by'):\n", "                    new_class._meta.get_latest_by = base_meta.get_latest_by\n", "\n", "        is_proxy = new_class._meta.proxy\n", "\n", "        # If the model is a proxy, ensure that the base class\n", "        # hasn't been swapped out.\n", "        if is_proxy and base_meta and base_meta.swapped:\n", "            raise TypeError(\"%s cannot proxy the swapped model '%s'.\" % (name, base_meta.swapped))\n", "\n", "        # Add remaining attributes (those with a contribute_to_class() method)\n", "        # to the class.\n", "        for obj_name, obj in contributable_attrs.items():\n", "            new_class.add_to_class(obj_name, obj)\n", "\n", "        # All the fields of any type declared on this model\n", "        new_fields = chain(\n", "            new_class._meta.local_fields,\n", "            new_class._meta.local_many_to_many,\n", "            new_class._meta.private_fields\n", "        )\n", "        field_names = {f.name for f in new_fields}\n", "\n", "        # Basic setup for proxy models.\n", "        if is_proxy:\n", "            base = None\n", "            for parent in [kls for kls in parents if hasattr(kls, '_meta')]:\n", "                if parent._meta.abstract:\n", "                    if parent._meta.fields:\n", "                        raise TypeError(\n", "                            \"Abstract base class containing model fields not \"\n", "                            \"permitted for proxy model '%s'.\" % name\n", "                        )\n", "                    else:\n", "                        continue\n", "                if base is None:\n", "                    base = parent\n", "                elif parent._meta.concrete_model is not base._meta.concrete_model:\n", "                    raise TypeError(\"Proxy model '%s' has more than one non-abstract model base class.\" % name)\n", "            if base is None:\n", "                raise TypeError(\"Proxy model '%s' has no non-abstract model base class.\" % name)\n", "            new_class._meta.setup_proxy(base)\n", "            new_class._meta.concrete_model = base._meta.concrete_model\n", "        else:\n", "            new_class._meta.concrete_model = new_class\n", "\n", "        # Collect the parent links for multi-table inheritance.\n", "        parent_links = {}\n", "        for base in reversed([new_class] + parents):\n", "            # Conceptually equivalent to `if base is Model`.\n", "            if not hasattr(base, '_meta'):\n", "                continue\n", "            # Skip concrete parent classes.\n", "            if base != new_class and not base._meta.abstract:\n", "                continue\n", "            # Locate OneToOneField instances.\n", "            for field in base._meta.local_fields:\n", "                if isinstance(field, OneToOneField) and field.remote_field.parent_link:\n", "                    related = resolve_relation(new_class, field.remote_field.model)\n", "                    parent_links[make_model_tuple(related)] = field\n", "\n", "        # Track fields inherited from base models.\n", "        inherited_attributes = set()\n", "        # Do the appropriate setup for any model parents.\n", "        for base in new_class.mro():\n", "            if base not in parents or not hasattr(base, '_meta'):\n", "                # Things without _meta aren't functional models, so they're\n", "                # uninteresting parents.\n", "                inherited_attributes.update(base.__dict__)\n", "                continue\n", "\n", "            parent_fields = base._meta.local_fields + base._meta.local_many_to_many\n", "            if not base._meta.abstract:\n", "                # Check for clashes between locally declared fields and those\n", "                # on the base classes.\n", "                for field in parent_fields:\n", "                    if field.name in field_names:\n", "                        raise FieldError(\n", "                            'Local field %r in class %r clashes with field of '\n", "                            'the same name from base class %r.' % (\n", "                                field.name,\n", "                                name,\n", "                                base.__name__,\n", "                            )\n", "                        )\n", "                    else:\n", "                        inherited_attributes.add(field.name)\n", "\n", "                # Concrete classes...\n", "                base = base._meta.concrete_model\n", "                base_key = make_model_tuple(base)\n", "                if base_key in parent_links:\n", "                    field = parent_links[base_key]\n", "                elif not is_proxy:\n", "                    attr_name = '%s_ptr' % base._meta.model_name\n", "                    field = OneToOneField(\n", "                        base,\n", "                        on_delete=CASCADE,\n", "                        name=attr_name,\n", "                        auto_created=True,\n", "                        parent_link=True,\n", "                    )\n", "\n", "                    if attr_name in field_names:\n", "                        raise FieldError(\n", "                            \"Auto-generated field '%s' in class %r for \"\n", "                            \"parent_link to base class %r clashes with \"\n", "                            \"declared field of the same name.\" % (\n", "                                attr_name,\n", "                                name,\n", "                                base.__name__,\n", "                            )\n", "                        )\n", "\n", "                    # Only add the ptr field if it's not already present;\n", "                    # e.g. migrations will already have it specified\n", "                    if not hasattr(new_class, attr_name):\n", "                        new_class.add_to_class(attr_name, field)\n", "                else:\n", "                    field = None\n", "                new_class._meta.parents[base] = field\n", "            else:\n", "                base_parents = base._meta.parents.copy()\n", "\n", "                # Add fields from abstract base class if it wasn't overridden.\n", "                for field in parent_fields:\n", "                    if (field.name not in field_names and\n", "                            field.name not in new_class.__dict__ and\n", "                            field.name not in inherited_attributes):\n", "                        new_field = copy.deepcopy(field)\n", "                        new_class.add_to_class(field.name, new_field)\n", "                        # Replace parent links defined on this base by the new\n", "                        # field. It will be appropriately resolved if required.\n", "                        if field.one_to_one:\n", "                            for parent, parent_link in base_parents.items():\n", "                                if field == parent_link:\n", "                                    base_parents[parent] = new_field\n", "\n", "                # Pass any non-abstract parent classes onto child.\n", "                new_class._meta.parents.update(base_parents)\n", "\n", "            # Inherit private fields (like GenericForeignKey) from the parent\n", "            # class\n", "            for field in base._meta.private_fields:\n", "                if field.name in field_names:\n", "                    if not base._meta.abstract:\n", "                        raise FieldError(\n", "                            'Local field %r in class %r clashes with field of '\n", "                            'the same name from base class %r.' % (\n", "                                field.name,\n", "                                name,\n", "                                base.__name__,\n", "                            )\n", "                        )\n", "                else:\n", "                    field = copy.deepcopy(field)\n", "                    if not base._meta.abstract:\n", "                        field.mti_inherited = True\n", "                    new_class.add_to_class(field.name, field)\n", "\n", "        # Copy indexes so that index names are unique when models extend an\n", "        # abstract model.\n", "        new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]\n", "\n", "        if abstract:\n", "            # Abstract base models can't be instantiated and don't appear in\n", "            # the list of models for an app. We do the final setup for them a\n", "            # little differently from normal models.\n", "            attr_meta.abstract = False\n", "            new_class.Meta = attr_meta\n", "            return new_class\n", "\n", "        new_class._prepare()\n", "        new_class._meta.apps.register_model(new_class._meta.app_label, new_class)\n", "        return new_class\n"]}]}, {"file_path": "django/db/models/options.py", "span_ids": ["Options.contribute_to_class", "Options.__init__"], "content": [{"span_id": "Options.contribute_to_class", "start_line": 147, "end_line": 206, "content": ["    def contribute_to_class(self, cls, name):\n", "        from django.db import connection\n", "        from django.db.backends.utils import truncate_name\n", "\n", "        cls._meta = self\n", "        self.model = cls\n", "        # First, construct the default values for these options.\n", "        self.object_name = cls.__name__\n", "        self.model_name = self.object_name.lower()\n", "        self.verbose_name = camel_case_to_spaces(self.object_name)\n", "\n", "        # Store the original user-defined values for each option,\n", "        # for use when serializing the model definition\n", "        self.original_attrs = {}\n", "\n", "        # Next, apply any overridden values from 'class Meta'.\n", "        if self.meta:\n", "            meta_attrs = self.meta.__dict__.copy()\n", "            for name in self.meta.__dict__:\n", "                # Ignore any private attributes that Django doesn't care about.\n", "                # NOTE: We can't modify a dictionary's contents while looping\n", "                # over it, so we loop over the *original* dictionary instead.\n", "                if name.startswith('_'):\n", "                    del meta_attrs[name]\n", "            for attr_name in DEFAULT_NAMES:\n", "                if attr_name in meta_attrs:\n", "                    setattr(self, attr_name, meta_attrs.pop(attr_name))\n", "                    self.original_attrs[attr_name] = getattr(self, attr_name)\n", "                elif hasattr(self.meta, attr_name):\n", "                    setattr(self, attr_name, getattr(self.meta, attr_name))\n", "                    self.original_attrs[attr_name] = getattr(self, attr_name)\n", "\n", "            self.unique_together = normalize_together(self.unique_together)\n", "            self.index_together = normalize_together(self.index_together)\n", "            # App label/class name interpolation for names of constraints and\n", "            # indexes.\n", "            if not getattr(cls._meta, 'abstract', False):\n", "                for attr_name in {'constraints', 'indexes'}:\n", "                    objs = getattr(self, attr_name, [])\n", "                    setattr(self, attr_name, self._format_names_with_class(cls, objs))\n", "\n", "            # verbose_name_plural is a special case because it uses a 's'\n", "            # by default.\n", "            if self.verbose_name_plural is None:\n", "                self.verbose_name_plural = format_lazy('{}s', self.verbose_name)\n", "\n", "            # order_with_respect_and ordering are mutually exclusive.\n", "            self._ordering_clash = bool(self.ordering and self.order_with_respect_to)\n", "\n", "            # Any leftover attributes must be invalid.\n", "            if meta_attrs != {}:\n", "                raise TypeError(\"'class Meta' got invalid attribute(s): %s\" % ','.join(meta_attrs))\n", "        else:\n", "            self.verbose_name_plural = format_lazy('{}s', self.verbose_name)\n", "        del self.meta\n", "\n", "        # If the db_table wasn't provided, use the app_label + model_name.\n", "        if not self.db_table:\n", "            self.db_table = \"%s_%s\" % (self.app_label, self.model_name)\n", "            self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())\n"]}, {"span_id": "Options.__init__", "start_line": 73, "end_line": 128, "content": ["    def __init__(self, meta, app_label=None):\n", "        self._get_fields_cache = {}\n", "        self.local_fields = []\n", "        self.local_many_to_many = []\n", "        self.private_fields = []\n", "        self.local_managers = []\n", "        self.base_manager_name = None\n", "        self.default_manager_name = None\n", "        self.model_name = None\n", "        self.verbose_name = None\n", "        self.verbose_name_plural = None\n", "        self.db_table = ''\n", "        self.ordering = []\n", "        self._ordering_clash = False\n", "        self.indexes = []\n", "        self.constraints = []\n", "        self.unique_together = []\n", "        self.index_together = []\n", "        self.select_on_save = False\n", "        self.default_permissions = ('add', 'change', 'delete', 'view')\n", "        self.permissions = []\n", "        self.object_name = None\n", "        self.app_label = app_label\n", "        self.get_latest_by = None\n", "        self.order_with_respect_to = None\n", "        self.db_tablespace = settings.DEFAULT_TABLESPACE\n", "        self.required_db_features = []\n", "        self.required_db_vendor = None\n", "        self.meta = meta\n", "        self.pk = None\n", "        self.auto_field = None\n", "        self.abstract = False\n", "        self.managed = True\n", "        self.proxy = False\n", "        # For any class that is a proxy (including automatically created\n", "        # classes for deferred object loading), proxy_for_model tells us\n", "        # which class this model is proxying. Note that proxy_for_model\n", "        # can create a chain of proxy models. For non-proxy models, the\n", "        # variable is always None.\n", "        self.proxy_for_model = None\n", "        # For any non-abstract class, the concrete class is the model\n", "        # in the end of the proxy_for_model chain. In particular, for\n", "        # concrete models, the concrete_model is always the class itself.\n", "        self.concrete_model = None\n", "        self.swappable = None\n", "        self.parents = {}\n", "        self.auto_created = False\n", "\n", "        # List of all lookups defined in ForeignKey 'limit_choices_to' options\n", "        # from *other* models. Needed for some admin checks. Internal use only.\n", "        self.related_fkey_lookups = []\n", "\n", "        # A custom app registry to use, if you're making a separate model set.\n", "        self.apps = self.default_apps\n", "\n", "        self.default_related_name = None\n"]}]}, {"file_path": "django/db/models/sql/compiler.py", "span_ids": ["SQLCompiler.get_order_by"], "content": [{"span_id": "SQLCompiler.get_order_by", "start_line": 265, "end_line": 387, "content": ["    def get_order_by(self):\n", "        \"\"\"\n", "        Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n", "        ORDER BY clause.\n", "\n", "        The order_by clause can alter the select clause (for example it\n", "        can add aliases to clauses that do not yet have one, or it can\n", "        add totally new select clauses).\n", "        \"\"\"\n", "        if self.query.extra_order_by:\n", "            ordering = self.query.extra_order_by\n", "        elif not self.query.default_ordering:\n", "            ordering = self.query.order_by\n", "        elif self.query.order_by:\n", "            ordering = self.query.order_by\n", "        elif self.query.get_meta().ordering:\n", "            ordering = self.query.get_meta().ordering\n", "            self._meta_ordering = ordering\n", "        else:\n", "            ordering = []\n", "        if self.query.standard_ordering:\n", "            asc, desc = ORDER_DIR['ASC']\n", "        else:\n", "            asc, desc = ORDER_DIR['DESC']\n", "\n", "        order_by = []\n", "        for field in ordering:\n", "            if hasattr(field, 'resolve_expression'):\n", "                if isinstance(field, Value):\n", "                    # output_field must be resolved for constants.\n", "                    field = Cast(field, field.output_field)\n", "                if not isinstance(field, OrderBy):\n", "                    field = field.asc()\n", "                if not self.query.standard_ordering:\n", "                    field = field.copy()\n", "                    field.reverse_ordering()\n", "                order_by.append((field, False))\n", "                continue\n", "            if field == '?':  # random\n", "                order_by.append((OrderBy(Random()), False))\n", "                continue\n", "\n", "            col, order = get_order_dir(field, asc)\n", "            descending = order == 'DESC'\n", "\n", "            if col in self.query.annotation_select:\n", "                # Reference to expression in SELECT clause\n", "                order_by.append((\n", "                    OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),\n", "                    True))\n", "                continue\n", "            if col in self.query.annotations:\n", "                # References to an expression which is masked out of the SELECT\n", "                # clause.\n", "                expr = self.query.annotations[col]\n", "                if isinstance(expr, Value):\n", "                    # output_field must be resolved for constants.\n", "                    expr = Cast(expr, expr.output_field)\n", "                order_by.append((OrderBy(expr, descending=descending), False))\n", "                continue\n", "\n", "            if '.' in field:\n", "                # This came in through an extra(order_by=...) addition. Pass it\n", "                # on verbatim.\n", "                table, col = col.split('.', 1)\n", "                order_by.append((\n", "                    OrderBy(\n", "                        RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),\n", "                        descending=descending\n", "                    ), False))\n", "                continue\n", "\n", "            if not self.query.extra or col not in self.query.extra:\n", "                # 'col' is of the form 'field' or 'field1__field2' or\n", "                # '-field1__field2__field', etc.\n", "                order_by.extend(self.find_ordering_name(\n", "                    field, self.query.get_meta(), default_order=asc))\n", "            else:\n", "                if col not in self.query.extra_select:\n", "                    order_by.append((\n", "                        OrderBy(RawSQL(*self.query.extra[col]), descending=descending),\n", "                        False))\n", "                else:\n", "                    order_by.append((\n", "                        OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),\n", "                        True))\n", "        result = []\n", "        seen = set()\n", "\n", "        for expr, is_ref in order_by:\n", "            resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n", "            if self.query.combinator:\n", "                src = resolved.get_source_expressions()[0]\n", "                # Relabel order by columns to raw numbers if this is a combined\n", "                # query; necessary since the columns can't be referenced by the\n", "                # fully qualified name and the simple column names may collide.\n", "                for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n", "                    if is_ref and col_alias == src.refs:\n", "                        src = src.source\n", "                    elif col_alias:\n", "                        continue\n", "                    if src == sel_expr:\n", "                        resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n", "                        break\n", "                else:\n", "                    if col_alias:\n", "                        raise DatabaseError('ORDER BY term does not match any column in the result set.')\n", "                    # Add column used in ORDER BY clause without an alias to\n", "                    # the selected columns.\n", "                    self.query.add_select_col(src)\n", "                    resolved.set_source_expressions([RawSQL('%d' % len(self.query.select), ())])\n", "            sql, params = self.compile(resolved)\n", "            # Don't add the same column twice, but the order direction is\n", "            # not taken into account so we strip it. When this entire method\n", "            # is refactored into expressions, then we can check each part as we\n", "            # generate it.\n", "            without_ordering = self.ordering_parts.search(sql).group(1)\n", "            params_hash = make_hashable(params)\n", "            if (without_ordering, params_hash) in seen:\n", "                continue\n", "            seen.add((without_ordering, params_hash))\n", "            result.append((resolved, (sql, params, is_ref)))\n", "        return result\n"]}]}, {"file_path": "django/db/models/sql/query.py", "span_ids": ["Query.add_ordering"], "content": [{"span_id": "Query.add_ordering", "start_line": 1886, "end_line": 1909, "content": ["    def add_ordering(self, *ordering):\n", "        \"\"\"\n", "        Add items from the 'ordering' sequence to the query's \"order by\"\n", "        clause. These items are either field names (not column names) --\n", "        possibly with a direction prefix ('-' or '?') -- or OrderBy\n", "        expressions.\n", "\n", "        If 'ordering' is empty, clear all ordering from the query.\n", "        \"\"\"\n", "        errors = []\n", "        for item in ordering:\n", "            if not hasattr(item, 'resolve_expression') and not ORDER_PATTERN.match(item):\n", "                errors.append(item)\n", "            if getattr(item, 'contains_aggregate', False):\n", "                raise FieldError(\n", "                    'Using an aggregate in order_by() without also including '\n", "                    'it in annotate() is not allowed: %s' % item\n", "                )\n", "        if errors:\n", "            raise FieldError('Invalid order_by arguments: %s' % errors)\n", "        if ordering:\n", "            self.order_by += ordering\n", "        else:\n", "            self.default_ordering = False\n"]}]}]}