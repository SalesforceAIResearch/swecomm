{"instance_id": "matplotlib__matplotlib-22835", "identified_spans": [{"file_path": "lib/matplotlib/artist.py", "span_ids": ["Artist.format_cursor_data"], "content": [{"span_id": "Artist.format_cursor_data", "start_line": 1277, "end_line": 1321, "content": ["    def format_cursor_data(self, data):\n", "        \"\"\"\n", "        Return a string representation of *data*.\n", "\n", "        .. note::\n", "            This method is intended to be overridden by artist subclasses.\n", "            As an end-user of Matplotlib you will most likely not call this\n", "            method yourself.\n", "\n", "        The default implementation converts ints and floats and arrays of ints\n", "        and floats into a comma-separated string enclosed in square brackets,\n", "        unless the artist has an associated colorbar, in which case scalar\n", "        values are formatted using the colorbar's formatter.\n", "\n", "        See Also\n", "        --------\n", "        get_cursor_data\n", "        \"\"\"\n", "        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n", "            # This block logically belongs to ScalarMappable, but can't be\n", "            # implemented in it because most ScalarMappable subclasses inherit\n", "            # from Artist first and from ScalarMappable second, so\n", "            # Artist.format_cursor_data would always have precedence over\n", "            # ScalarMappable.format_cursor_data.\n", "            n = self.cmap.N\n", "            if np.ma.getmask(data):\n", "                return \"[]\"\n", "            normed = self.norm(data)\n", "            if np.isfinite(normed):\n", "                # Midpoints of neighboring color intervals.\n", "                neighbors = self.norm.inverse(\n", "                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n", "                delta = abs(neighbors - data).max()\n", "                g_sig_digits = cbook._g_sig_digits(data, delta)\n", "            else:\n", "                g_sig_digits = 3  # Consistent with default below.\n", "            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n", "        else:\n", "            try:\n", "                data[0]\n", "            except (TypeError, IndexError):\n", "                data = [data]\n", "            data_str = ', '.join('{:0.3g}'.format(item) for item in data\n", "                                 if isinstance(item, Number))\n", "            return \"[\" + data_str + \"]\"\n"]}]}, {"file_path": "lib/matplotlib/colors.py", "span_ids": ["BoundaryNorm.inverse", "BoundaryNorm.__call__", "BoundaryNorm", "BoundaryNorm.__init__"], "content": [{"span_id": "BoundaryNorm.inverse", "start_line": 1904, "end_line": 1912, "content": ["    def inverse(self, value):\n", "        \"\"\"\n", "        Raises\n", "        ------\n", "        ValueError\n", "            BoundaryNorm is not invertible, so calling this method will always\n", "            raise an error\n", "        \"\"\"\n", "        raise ValueError(\"BoundaryNorm is not invertible\")\n"]}, {"span_id": "BoundaryNorm.__call__", "start_line": 1862, "end_line": 1902, "content": ["    def __call__(self, value, clip=None):\n", "        \"\"\"\n", "        This method behaves similarly to `.Normalize.__call__`, except that it\n", "        returns integers or arrays of int16.\n", "        \"\"\"\n", "        if clip is None:\n", "            clip = self.clip\n", "\n", "        xx, is_scalar = self.process_value(value)\n", "        mask = np.ma.getmaskarray(xx)\n", "        # Fill masked values a value above the upper boundary\n", "        xx = np.atleast_1d(xx.filled(self.vmax + 1))\n", "        if clip:\n", "            np.clip(xx, self.vmin, self.vmax, out=xx)\n", "            max_col = self.Ncmap - 1\n", "        else:\n", "            max_col = self.Ncmap\n", "        # this gives us the bins in the lookup table in the range\n", "        # [0, _n_regions - 1]  (the offset is set in the init)\n", "        iret = np.digitize(xx, self.boundaries) - 1 + self._offset\n", "        # if we have more colors than regions, stretch the region\n", "        # index computed above to full range of the color bins.  This\n", "        # will make use of the full range (but skip some of the colors\n", "        # in the middle) such that the first region is mapped to the\n", "        # first color and the last region is mapped to the last color.\n", "        if self.Ncmap > self._n_regions:\n", "            if self._n_regions == 1:\n", "                # special case the 1 region case, pick the middle color\n", "                iret[iret == 0] = (self.Ncmap - 1) // 2\n", "            else:\n", "                # otherwise linearly remap the values from the region index\n", "                # to the color index spaces\n", "                iret = (self.Ncmap - 1) / (self._n_regions - 1) * iret\n", "        # cast to 16bit integers in all cases\n", "        iret = iret.astype(np.int16)\n", "        iret[xx < self.vmin] = -1\n", "        iret[xx >= self.vmax] = max_col\n", "        ret = np.ma.array(iret, mask=mask)\n", "        if is_scalar:\n", "            ret = int(ret[0])  # assume python scalar\n", "        return ret\n"]}, {"span_id": "BoundaryNorm", "start_line": 1787, "end_line": 1793, "content": ["class BoundaryNorm(Normalize):\n", "    \"\"\"\n", "    Generate a colormap index based on discrete intervals.\n", "\n", "    Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers\n", "    instead of to the interval 0-1.\n", "    \"\"\"\n"]}, {"span_id": "BoundaryNorm.__init__", "start_line": 1799, "end_line": 1860, "content": ["    def __init__(self, boundaries, ncolors, clip=False, *, extend='neither'):\n", "        \"\"\"\n", "        Parameters\n", "        ----------\n", "        boundaries : array-like\n", "            Monotonically increasing sequence of at least 2 bin edges:  data\n", "            falling in the n-th bin will be mapped to the n-th color.\n", "\n", "        ncolors : int\n", "            Number of colors in the colormap to be used.\n", "\n", "        clip : bool, optional\n", "            If clip is ``True``, out of range values are mapped to 0 if they\n", "            are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they\n", "            are above ``boundaries[-1]``.\n", "\n", "            If clip is ``False``, out of range values are mapped to -1 if\n", "            they are below ``boundaries[0]`` or mapped to *ncolors* if they are\n", "            above ``boundaries[-1]``. These are then converted to valid indices\n", "            by `Colormap.__call__`.\n", "\n", "        extend : {'neither', 'both', 'min', 'max'}, default: 'neither'\n", "            Extend the number of bins to include one or both of the\n", "            regions beyond the boundaries.  For example, if ``extend``\n", "            is 'min', then the color to which the region between the first\n", "            pair of boundaries is mapped will be distinct from the first\n", "            color in the colormap, and by default a\n", "            `~matplotlib.colorbar.Colorbar` will be drawn with\n", "            the triangle extension on the left or lower end.\n", "\n", "        Notes\n", "        -----\n", "        If there are fewer bins (including extensions) than colors, then the\n", "        color index is chosen by linearly interpolating the ``[0, nbins - 1]``\n", "        range onto the ``[0, ncolors - 1]`` range, effectively skipping some\n", "        colors in the middle of the colormap.\n", "        \"\"\"\n", "        if clip and extend != 'neither':\n", "            raise ValueError(\"'clip=True' is not compatible with 'extend'\")\n", "        super().__init__(vmin=boundaries[0], vmax=boundaries[-1], clip=clip)\n", "        self.boundaries = np.asarray(boundaries)\n", "        self.N = len(self.boundaries)\n", "        if self.N < 2:\n", "            raise ValueError(\"You must provide at least 2 boundaries \"\n", "                             f\"(1 region) but you passed in {boundaries!r}\")\n", "        self.Ncmap = ncolors\n", "        self.extend = extend\n", "\n", "        self._scale = None  # don't use the default scale.\n", "\n", "        self._n_regions = self.N - 1  # number of colors needed\n", "        self._offset = 0\n", "        if extend in ('min', 'both'):\n", "            self._n_regions += 1\n", "            self._offset = 1\n", "        if extend in ('max', 'both'):\n", "            self._n_regions += 1\n", "        if self._n_regions > self.Ncmap:\n", "            raise ValueError(f\"There are {self._n_regions} color bins \"\n", "                             \"including extensions, but ncolors = \"\n", "                             f\"{ncolors}; ncolors must equal or exceed the \"\n", "                             \"number of bins\")\n"]}]}]}