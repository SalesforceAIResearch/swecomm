{"instance_id": "psf__requests-2148", "identified_spans": [{"file_path": "requests/adapters.py", "span_ids": ["HTTPAdapter.send"], "content": [{"span_id": "HTTPAdapter.send", "start_line": 312, "end_line": 406, "content": ["    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n", "        \"\"\"Sends PreparedRequest object. Returns Response object.\n", "\n", "        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n", "        :param stream: (optional) Whether to stream the request content.\n", "        :param timeout: (optional) The timeout on the request.\n", "        :param verify: (optional) Whether to verify SSL certificates.\n", "        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n", "        :param proxies: (optional) The proxies dictionary to apply to the request.\n", "        \"\"\"\n", "\n", "        conn = self.get_connection(request.url, proxies)\n", "\n", "        self.cert_verify(conn, request.url, verify, cert)\n", "        url = self.request_url(request, proxies)\n", "        self.add_headers(request)\n", "\n", "        chunked = not (request.body is None or 'Content-Length' in request.headers)\n", "\n", "        timeout = TimeoutSauce(connect=timeout, read=timeout)\n", "\n", "        try:\n", "            if not chunked:\n", "                resp = conn.urlopen(\n", "                    method=request.method,\n", "                    url=url,\n", "                    body=request.body,\n", "                    headers=request.headers,\n", "                    redirect=False,\n", "                    assert_same_host=False,\n", "                    preload_content=False,\n", "                    decode_content=False,\n", "                    retries=Retry(self.max_retries, read=False),\n", "                    timeout=timeout\n", "                )\n", "\n", "            # Send the request.\n", "            else:\n", "                if hasattr(conn, 'proxy_pool'):\n", "                    conn = conn.proxy_pool\n", "\n", "                low_conn = conn._get_conn(timeout=timeout)\n", "\n", "                try:\n", "                    low_conn.putrequest(request.method,\n", "                                        url,\n", "                                        skip_accept_encoding=True)\n", "\n", "                    for header, value in request.headers.items():\n", "                        low_conn.putheader(header, value)\n", "\n", "                    low_conn.endheaders()\n", "\n", "                    for i in request.body:\n", "                        low_conn.send(hex(len(i))[2:].encode('utf-8'))\n", "                        low_conn.send(b'\\r\\n')\n", "                        low_conn.send(i)\n", "                        low_conn.send(b'\\r\\n')\n", "                    low_conn.send(b'0\\r\\n\\r\\n')\n", "\n", "                    r = low_conn.getresponse()\n", "                    resp = HTTPResponse.from_httplib(\n", "                        r,\n", "                        pool=conn,\n", "                        connection=low_conn,\n", "                        preload_content=False,\n", "                        decode_content=False\n", "                    )\n", "                except:\n", "                    # If we hit any problems here, clean up the connection.\n", "                    # Then, reraise so that we can handle the actual exception.\n", "                    low_conn.close()\n", "                    raise\n", "                else:\n", "                    # All is well, return the connection to the pool.\n", "                    conn._put_conn(low_conn)\n", "\n", "        except socket.error as sockerr:\n", "            raise ConnectionError(sockerr, request=request)\n", "\n", "        except MaxRetryError as e:\n", "            raise ConnectionError(e, request=request)\n", "\n", "        except _ProxyError as e:\n", "            raise ProxyError(e)\n", "\n", "        except (_SSLError, _HTTPError) as e:\n", "            if isinstance(e, _SSLError):\n", "                raise SSLError(e, request=request)\n", "            elif isinstance(e, TimeoutError):\n", "                raise Timeout(e, request=request)\n", "            else:\n", "                raise\n", "\n", "        return self.build_response(request, resp)\n"]}]}, {"file_path": "requests/exceptions.py", "span_ids": ["ConnectionError"], "content": [{"span_id": "ConnectionError", "start_line": 34, "end_line": 35, "content": ["class ConnectionError(RequestException):\n", "    \"\"\"A Connection error occurred.\"\"\"\n"]}]}, {"file_path": "requests/packages/urllib3/connection.py", "span_ids": ["VerifiedHTTPSConnection.connect"], "content": [{"span_id": "VerifiedHTTPSConnection.connect", "start_line": 187, "end_line": 225, "content": ["    def connect(self):\n", "        # Add certificate verification\n", "        conn = self._new_conn()\n", "\n", "        resolved_cert_reqs = resolve_cert_reqs(self.cert_reqs)\n", "        resolved_ssl_version = resolve_ssl_version(self.ssl_version)\n", "\n", "        hostname = self.host\n", "        if getattr(self, '_tunnel_host', None):\n", "            # _tunnel_host was added in Python 2.6.3\n", "            # (See: http://hg.python.org/cpython/rev/0f57b30a152f)\n", "\n", "            self.sock = conn\n", "            # Calls self._set_hostport(), so self.host is\n", "            # self._tunnel_host below.\n", "            self._tunnel()\n", "            # Mark this connection as not reusable\n", "            self.auto_open = 0\n", "\n", "            # Override the host with the one we're requesting data from.\n", "            hostname = self._tunnel_host\n", "\n", "        # Wrap socket using verification with the root certs in\n", "        # trusted_root_certs\n", "        self.sock = ssl_wrap_socket(conn, self.key_file, self.cert_file,\n", "                                    cert_reqs=resolved_cert_reqs,\n", "                                    ca_certs=self.ca_certs,\n", "                                    server_hostname=hostname,\n", "                                    ssl_version=resolved_ssl_version)\n", "\n", "        if resolved_cert_reqs != ssl.CERT_NONE:\n", "            if self.assert_fingerprint:\n", "                assert_fingerprint(self.sock.getpeercert(binary_form=True),\n", "                                   self.assert_fingerprint)\n", "            elif self.assert_hostname is not False:\n", "                match_hostname(self.sock.getpeercert(),\n", "                               self.assert_hostname or hostname)\n", "\n", "        self.is_verified = resolved_cert_reqs == ssl.CERT_REQUIRED\n"]}]}, {"file_path": "requests/packages/urllib3/connectionpool.py", "span_ids": ["HTTPConnectionPool.urlopen"], "content": [{"span_id": "HTTPConnectionPool.urlopen", "start_line": 400, "end_line": 612, "content": ["    def urlopen(self, method, url, body=None, headers=None, retries=None,\n", "                redirect=True, assert_same_host=True, timeout=_Default,\n", "                pool_timeout=None, release_conn=None, **response_kw):\n", "        \"\"\"\n", "        Get a connection from the pool and perform an HTTP request. This is the\n", "        lowest level call for making a request, so you'll need to specify all\n", "        the raw details.\n", "\n", "        .. note::\n", "\n", "           More commonly, it's appropriate to use a convenience method provided\n", "           by :class:`.RequestMethods`, such as :meth:`request`.\n", "\n", "        .. note::\n", "\n", "           `release_conn` will only behave as expected if\n", "           `preload_content=False` because we want to make\n", "           `preload_content=False` the default behaviour someday soon without\n", "           breaking backwards compatibility.\n", "\n", "        :param method:\n", "            HTTP request method (such as GET, POST, PUT, etc.)\n", "\n", "        :param body:\n", "            Data to send in the request body (useful for creating\n", "            POST requests, see HTTPConnectionPool.post_url for\n", "            more convenience).\n", "\n", "        :param headers:\n", "            Dictionary of custom headers to send, such as User-Agent,\n", "            If-None-Match, etc. If None, pool headers are used. If provided,\n", "            these headers completely replace any pool-specific headers.\n", "\n", "        :param retries:\n", "            Configure the number of retries to allow before raising a\n", "            :class:`~urllib3.exceptions.MaxRetryError` exception.\n", "\n", "            Pass ``None`` to retry until you receive a response. Pass a\n", "            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n", "            over different types of retries.\n", "            Pass an integer number to retry connection errors that many times,\n", "            but no other types of errors. Pass zero to never retry.\n", "\n", "            If ``False``, then retries are disabled and any exception is raised\n", "            immediately. Also, instead of raising a MaxRetryError on redirects,\n", "            the redirect response will be returned.\n", "\n", "        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n", "\n", "        :param redirect:\n", "            If True, automatically handle redirects (status codes 301, 302,\n", "            303, 307, 308). Each redirect counts as a retry. Disabling retries\n", "            will disable redirect, too.\n", "\n", "        :param assert_same_host:\n", "            If ``True``, will make sure that the host of the pool requests is\n", "            consistent else will raise HostChangedError. When False, you can\n", "            use the pool on an HTTP proxy and request foreign hosts.\n", "\n", "        :param timeout:\n", "            If specified, overrides the default timeout for this one\n", "            request. It may be a float (in seconds) or an instance of\n", "            :class:`urllib3.util.Timeout`.\n", "\n", "        :param pool_timeout:\n", "            If set and the pool is set to block=True, then this method will\n", "            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n", "            connection is available within the time period.\n", "\n", "        :param release_conn:\n", "            If False, then the urlopen call will not release the connection\n", "            back into the pool once a response is received (but will release if\n", "            you read the entire contents of the response such as when\n", "            `preload_content=True`). This is useful if you're not preloading\n", "            the response's content immediately. You will need to call\n", "            ``r.release_conn()`` on the response ``r`` to return the connection\n", "            back into the pool. If None, it takes the value of\n", "            ``response_kw.get('preload_content', True)``.\n", "\n", "        :param \\**response_kw:\n", "            Additional parameters are passed to\n", "            :meth:`urllib3.response.HTTPResponse.from_httplib`\n", "        \"\"\"\n", "        if headers is None:\n", "            headers = self.headers\n", "\n", "        if not isinstance(retries, Retry):\n", "            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n", "\n", "        if release_conn is None:\n", "            release_conn = response_kw.get('preload_content', True)\n", "\n", "        # Check host\n", "        if assert_same_host and not self.is_same_host(url):\n", "            raise HostChangedError(self, url, retries)\n", "\n", "        conn = None\n", "\n", "        # Merge the proxy headers. Only do this in HTTP. We have to copy the\n", "        # headers dict so we can safely change it without those changes being\n", "        # reflected in anyone else's copy.\n", "        if self.scheme == 'http':\n", "            headers = headers.copy()\n", "            headers.update(self.proxy_headers)\n", "\n", "        # Must keep the exception bound to a separate variable or else Python 3\n", "        # complains about UnboundLocalError.\n", "        err = None\n", "\n", "        try:\n", "            # Request a connection from the queue.\n", "            conn = self._get_conn(timeout=pool_timeout)\n", "\n", "            # Make the request on the httplib connection object.\n", "            httplib_response = self._make_request(conn, method, url,\n", "                                                  timeout=timeout,\n", "                                                  body=body, headers=headers)\n", "\n", "            # If we're going to release the connection in ``finally:``, then\n", "            # the request doesn't need to know about the connection. Otherwise\n", "            # it will also try to release it and we'll have a double-release\n", "            # mess.\n", "            response_conn = not release_conn and conn\n", "\n", "            # Import httplib's response into our own wrapper object\n", "            response = HTTPResponse.from_httplib(httplib_response,\n", "                                                 pool=self,\n", "                                                 connection=response_conn,\n", "                                                 **response_kw)\n", "\n", "            # else:\n", "            #     The connection will be put back into the pool when\n", "            #     ``response.release_conn()`` is called (implicitly by\n", "            #     ``response.read()``)\n", "\n", "        except Empty:\n", "            # Timed out by queue.\n", "            raise EmptyPoolError(self, \"No pool connections are available.\")\n", "\n", "        except (BaseSSLError, CertificateError) as e:\n", "            # Release connection unconditionally because there is no way to\n", "            # close it externally in case of exception.\n", "            release_conn = True\n", "            raise SSLError(e)\n", "\n", "        except (TimeoutError, HTTPException, SocketError) as e:\n", "            if conn:\n", "                # Discard the connection for these exceptions. It will be\n", "                # be replaced during the next _get_conn() call.\n", "                conn.close()\n", "                conn = None\n", "\n", "            stacktrace = sys.exc_info()[2]\n", "            if isinstance(e, SocketError) and self.proxy:\n", "                e = ProxyError('Cannot connect to proxy.', e)\n", "            elif isinstance(e, (SocketError, HTTPException)):\n", "                e = ProtocolError('Connection aborted.', e)\n", "\n", "            retries = retries.increment(method, url, error=e,\n", "                                        _pool=self, _stacktrace=stacktrace)\n", "            retries.sleep()\n", "\n", "            # Keep track of the error for the retry warning.\n", "            err = e\n", "\n", "        finally:\n", "            if release_conn:\n", "                # Put the connection back to be reused. If the connection is\n", "                # expired then it will be None, which will get replaced with a\n", "                # fresh connection during _get_conn.\n", "                self._put_conn(conn)\n", "\n", "        if not conn:\n", "            # Try again\n", "            log.warning(\"Retrying (%r) after connection \"\n", "                        \"broken by '%r': %s\" % (retries, err, url))\n", "            return self.urlopen(method, url, body, headers, retries,\n", "                                redirect, assert_same_host,\n", "                                timeout=timeout, pool_timeout=pool_timeout,\n", "                                release_conn=release_conn, **response_kw)\n", "\n", "        # Handle redirect?\n", "        redirect_location = redirect and response.get_redirect_location()\n", "        if redirect_location:\n", "            if response.status == 303:\n", "                method = 'GET'\n", "\n", "            try:\n", "                retries = retries.increment(method, url, response=response, _pool=self)\n", "            except MaxRetryError:\n", "                if retries.raise_on_redirect:\n", "                    raise\n", "                return response\n", "\n", "            log.info(\"Redirecting %s -> %s\" % (url, redirect_location))\n", "            return self.urlopen(method, redirect_location, body, headers,\n", "                    retries=retries, redirect=redirect,\n", "                    assert_same_host=assert_same_host,\n", "                    timeout=timeout, pool_timeout=pool_timeout,\n", "                    release_conn=release_conn, **response_kw)\n", "\n", "        # Check if we should retry the HTTP response.\n", "        if retries.is_forced_retry(method, status_code=response.status):\n", "            retries = retries.increment(method, url, response=response, _pool=self)\n", "            retries.sleep()\n", "            log.info(\"Forced retry: %s\" % url)\n", "            return self.urlopen(method, url, body, headers,\n", "                    retries=retries, redirect=redirect,\n", "                    assert_same_host=assert_same_host,\n", "                    timeout=timeout, pool_timeout=pool_timeout,\n", "                    release_conn=release_conn, **response_kw)\n", "\n", "        return response\n"]}]}, {"file_path": "requests/packages/urllib3/exceptions.py", "span_ids": ["ProtocolError", "impl"], "content": [{"span_id": "ProtocolError", "start_line": 51, "end_line": 53, "content": ["class ProtocolError(HTTPError):\n", "    \"Raised when something unexpected happens mid-request/response.\"\n", "    pass\n"]}, {"span_id": "impl", "start_line": 57, "end_line": 57, "content": ["ConnectionError = ProtocolError\n"]}]}]}