{"instance_id": "matplotlib__matplotlib-24149", "identified_spans": [{"file_path": "lib/matplotlib/axes/_axes.py", "span_ids": ["Axes._convert_dx", "Axes.bar"], "content": [{"span_id": "Axes._convert_dx", "start_line": 2152, "end_line": 2202, "content": ["    @staticmethod\n", "    def _convert_dx(dx, x0, xconv, convert):\n", "        \"\"\"\n", "        Small helper to do logic of width conversion flexibly.\n", "\n", "        *dx* and *x0* have units, but *xconv* has already been converted\n", "        to unitless (and is an ndarray).  This allows the *dx* to have units\n", "        that are different from *x0*, but are still accepted by the\n", "        ``__add__`` operator of *x0*.\n", "        \"\"\"\n", "\n", "        # x should be an array...\n", "        assert type(xconv) is np.ndarray\n", "\n", "        if xconv.size == 0:\n", "            # xconv has already been converted, but maybe empty...\n", "            return convert(dx)\n", "\n", "        try:\n", "            # attempt to add the width to x0; this works for\n", "            # datetime+timedelta, for instance\n", "\n", "            # only use the first element of x and x0.  This saves\n", "            # having to be sure addition works across the whole\n", "            # vector.  This is particularly an issue if\n", "            # x0 and dx are lists so x0 + dx just concatenates the lists.\n", "            # We can't just cast x0 and dx to numpy arrays because that\n", "            # removes the units from unit packages like `pint` that\n", "            # wrap numpy arrays.\n", "            try:\n", "                x0 = cbook._safe_first_finite(x0)\n", "            except (TypeError, IndexError, KeyError):\n", "                pass\n", "\n", "            try:\n", "                x = cbook._safe_first_finite(xconv)\n", "            except (TypeError, IndexError, KeyError):\n", "                x = xconv\n", "\n", "            delist = False\n", "            if not np.iterable(dx):\n", "                dx = [dx]\n", "                delist = True\n", "            dx = [convert(x0 + ddx) - x for ddx in dx]\n", "            if delist:\n", "                dx = dx[0]\n", "        except (ValueError, TypeError, AttributeError):\n", "            # if the above fails (for any reason) just fallback to what\n", "            # we do by default and convert dx by itself.\n", "            dx = convert(dx)\n", "        return dx\n"]}, {"span_id": "Axes.bar", "start_line": 2204, "end_line": 2499, "content": ["    @_preprocess_data()\n", "    @_docstring.dedent_interpd\n", "    def bar(self, x, height, width=0.8, bottom=None, *, align=\"center\",\n", "            **kwargs):\n", "        r\"\"\"\n", "        Make a bar plot.\n", "\n", "        The bars are positioned at *x* with the given *align*\\ment. Their\n", "        dimensions are given by *height* and *width*. The vertical baseline\n", "        is *bottom* (default 0).\n", "\n", "        Many parameters can take either a single value applying to all bars\n", "        or a sequence of values, one for each bar.\n", "\n", "        Parameters\n", "        ----------\n", "        x : float or array-like\n", "            The x coordinates of the bars. See also *align* for the\n", "            alignment of the bars to the coordinates.\n", "\n", "        height : float or array-like\n", "            The height(s) of the bars.\n", "\n", "        width : float or array-like, default: 0.8\n", "            The width(s) of the bars.\n", "\n", "        bottom : float or array-like, default: 0\n", "            The y coordinate(s) of the bottom side(s) of the bars.\n", "\n", "        align : {'center', 'edge'}, default: 'center'\n", "            Alignment of the bars to the *x* coordinates:\n", "\n", "            - 'center': Center the base on the *x* positions.\n", "            - 'edge': Align the left edges of the bars with the *x* positions.\n", "\n", "            To align the bars on the right edge pass a negative *width* and\n", "            ``align='edge'``.\n", "\n", "        Returns\n", "        -------\n", "        `.BarContainer`\n", "            Container with all the bars and optionally errorbars.\n", "\n", "        Other Parameters\n", "        ----------------\n", "        color : color or list of color, optional\n", "            The colors of the bar faces.\n", "\n", "        edgecolor : color or list of color, optional\n", "            The colors of the bar edges.\n", "\n", "        linewidth : float or array-like, optional\n", "            Width of the bar edge(s). If 0, don't draw edges.\n", "\n", "        tick_label : str or list of str, optional\n", "            The tick labels of the bars.\n", "            Default: None (Use default numeric labels.)\n", "\n", "        label : str or list of str, optional\n", "            A single label is attached to the resulting `.BarContainer` as a\n", "            label for the whole dataset.\n", "            If a list is provided, it must be the same length as *x* and\n", "            labels the individual bars. Repeated labels are not de-duplicated\n", "            and will cause repeated label entries, so this is best used when\n", "            bars also differ in style (e.g., by passing a list to *color*.)\n", "\n", "        xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional\n", "            If not *None*, add horizontal / vertical errorbars to the bar tips.\n", "            The values are +/- sizes relative to the data:\n", "\n", "            - scalar: symmetric +/- values for all bars\n", "            - shape(N,): symmetric +/- values for each bar\n", "            - shape(2, N): Separate - and + values for each bar. First row\n", "              contains the lower errors, the second row contains the upper\n", "              errors.\n", "            - *None*: No errorbar. (Default)\n", "\n", "            See :doc:`/gallery/statistics/errorbar_features` for an example on\n", "            the usage of *xerr* and *yerr*.\n", "\n", "        ecolor : color or list of color, default: 'black'\n", "            The line color of the errorbars.\n", "\n", "        capsize : float, default: :rc:`errorbar.capsize`\n", "           The length of the error bar caps in points.\n", "\n", "        error_kw : dict, optional\n", "            Dictionary of keyword arguments to be passed to the\n", "            `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined\n", "            here take precedence over the independent keyword arguments.\n", "\n", "        log : bool, default: False\n", "            If *True*, set the y-axis to be log scale.\n", "\n", "        data : indexable object, optional\n", "            DATA_PARAMETER_PLACEHOLDER\n", "\n", "        **kwargs : `.Rectangle` properties\n", "\n", "        %(Rectangle:kwdoc)s\n", "\n", "        See Also\n", "        --------\n", "        barh : Plot a horizontal bar plot.\n", "\n", "        Notes\n", "        -----\n", "        Stacked bars can be achieved by passing individual *bottom* values per\n", "        bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.\n", "        \"\"\"\n", "        kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)\n", "        color = kwargs.pop('color', None)\n", "        if color is None:\n", "            color = self._get_patches_for_fill.get_next_color()\n", "        edgecolor = kwargs.pop('edgecolor', None)\n", "        linewidth = kwargs.pop('linewidth', None)\n", "        hatch = kwargs.pop('hatch', None)\n", "\n", "        # Because xerr and yerr will be passed to errorbar, most dimension\n", "        # checking and processing will be left to the errorbar method.\n", "        xerr = kwargs.pop('xerr', None)\n", "        yerr = kwargs.pop('yerr', None)\n", "        error_kw = kwargs.pop('error_kw', {})\n", "        ezorder = error_kw.pop('zorder', None)\n", "        if ezorder is None:\n", "            ezorder = kwargs.get('zorder', None)\n", "            if ezorder is not None:\n", "                # If using the bar zorder, increment slightly to make sure\n", "                # errorbars are drawn on top of bars\n", "                ezorder += 0.01\n", "        error_kw.setdefault('zorder', ezorder)\n", "        ecolor = kwargs.pop('ecolor', 'k')\n", "        capsize = kwargs.pop('capsize', mpl.rcParams[\"errorbar.capsize\"])\n", "        error_kw.setdefault('ecolor', ecolor)\n", "        error_kw.setdefault('capsize', capsize)\n", "\n", "        # The keyword argument *orientation* is used by barh() to defer all\n", "        # logic and drawing to bar(). It is considered internal and is\n", "        # intentionally not mentioned in the docstring.\n", "        orientation = kwargs.pop('orientation', 'vertical')\n", "        _api.check_in_list(['vertical', 'horizontal'], orientation=orientation)\n", "        log = kwargs.pop('log', False)\n", "        label = kwargs.pop('label', '')\n", "        tick_labels = kwargs.pop('tick_label', None)\n", "\n", "        y = bottom  # Matches barh call signature.\n", "        if orientation == 'vertical':\n", "            if y is None:\n", "                y = 0\n", "        else:  # horizontal\n", "            if x is None:\n", "                x = 0\n", "\n", "        if orientation == 'vertical':\n", "            self._process_unit_info(\n", "                [(\"x\", x), (\"y\", height)], kwargs, convert=False)\n", "            if log:\n", "                self.set_yscale('log', nonpositive='clip')\n", "        else:  # horizontal\n", "            self._process_unit_info(\n", "                [(\"x\", width), (\"y\", y)], kwargs, convert=False)\n", "            if log:\n", "                self.set_xscale('log', nonpositive='clip')\n", "\n", "        # lets do some conversions now since some types cannot be\n", "        # subtracted uniformly\n", "        if self.xaxis is not None:\n", "            x0 = x\n", "            x = np.asarray(self.convert_xunits(x))\n", "            width = self._convert_dx(width, x0, x, self.convert_xunits)\n", "            if xerr is not None:\n", "                xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)\n", "        if self.yaxis is not None:\n", "            y0 = y\n", "            y = np.asarray(self.convert_yunits(y))\n", "            height = self._convert_dx(height, y0, y, self.convert_yunits)\n", "            if yerr is not None:\n", "                yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)\n", "\n", "        x, height, width, y, linewidth, hatch = np.broadcast_arrays(\n", "            # Make args iterable too.\n", "            np.atleast_1d(x), height, width, y, linewidth, hatch)\n", "\n", "        # Now that units have been converted, set the tick locations.\n", "        if orientation == 'vertical':\n", "            tick_label_axis = self.xaxis\n", "            tick_label_position = x\n", "        else:  # horizontal\n", "            tick_label_axis = self.yaxis\n", "            tick_label_position = y\n", "\n", "        if not isinstance(label, str) and np.iterable(label):\n", "            bar_container_label = '_nolegend_'\n", "            patch_labels = label\n", "        else:\n", "            bar_container_label = label\n", "            patch_labels = ['_nolegend_'] * len(x)\n", "        if len(patch_labels) != len(x):\n", "            raise ValueError(f'number of labels ({len(patch_labels)}) '\n", "                             f'does not match number of bars ({len(x)}).')\n", "\n", "        linewidth = itertools.cycle(np.atleast_1d(linewidth))\n", "        hatch = itertools.cycle(np.atleast_1d(hatch))\n", "        color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),\n", "                                # Fallback if color == \"none\".\n", "                                itertools.repeat('none'))\n", "        if edgecolor is None:\n", "            edgecolor = itertools.repeat(None)\n", "        else:\n", "            edgecolor = itertools.chain(\n", "                itertools.cycle(mcolors.to_rgba_array(edgecolor)),\n", "                # Fallback if edgecolor == \"none\".\n", "                itertools.repeat('none'))\n", "\n", "        # We will now resolve the alignment and really have\n", "        # left, bottom, width, height vectors\n", "        _api.check_in_list(['center', 'edge'], align=align)\n", "        if align == 'center':\n", "            if orientation == 'vertical':\n", "                try:\n", "                    left = x - width / 2\n", "                except TypeError as e:\n", "                    raise TypeError(f'the dtypes of parameters x ({x.dtype}) '\n", "                                    f'and width ({width.dtype}) '\n", "                                    f'are incompatible') from e\n", "                bottom = y\n", "            else:  # horizontal\n", "                try:\n", "                    bottom = y - height / 2\n", "                except TypeError as e:\n", "                    raise TypeError(f'the dtypes of parameters y ({y.dtype}) '\n", "                                    f'and height ({height.dtype}) '\n", "                                    f'are incompatible') from e\n", "                left = x\n", "        else:  # edge\n", "            left = x\n", "            bottom = y\n", "\n", "        patches = []\n", "        args = zip(left, bottom, width, height, color, edgecolor, linewidth,\n", "                   hatch, patch_labels)\n", "        for l, b, w, h, c, e, lw, htch, lbl in args:\n", "            r = mpatches.Rectangle(\n", "                xy=(l, b), width=w, height=h,\n", "                facecolor=c,\n", "                edgecolor=e,\n", "                linewidth=lw,\n", "                label=lbl,\n", "                hatch=htch,\n", "                )\n", "            r._internal_update(kwargs)\n", "            r.get_path()._interpolation_steps = 100\n", "            if orientation == 'vertical':\n", "                r.sticky_edges.y.append(b)\n", "            else:  # horizontal\n", "                r.sticky_edges.x.append(l)\n", "            self.add_patch(r)\n", "            patches.append(r)\n", "\n", "        if xerr is not None or yerr is not None:\n", "            if orientation == 'vertical':\n", "                # using list comps rather than arrays to preserve unit info\n", "                ex = [l + 0.5 * w for l, w in zip(left, width)]\n", "                ey = [b + h for b, h in zip(bottom, height)]\n", "\n", "            else:  # horizontal\n", "                # using list comps rather than arrays to preserve unit info\n", "                ex = [l + w for l, w in zip(left, width)]\n", "                ey = [b + 0.5 * h for b, h in zip(bottom, height)]\n", "\n", "            error_kw.setdefault(\"label\", '_nolegend_')\n", "\n", "            errorbar = self.errorbar(ex, ey,\n", "                                     yerr=yerr, xerr=xerr,\n", "                                     fmt='none', **error_kw)\n", "        else:\n", "            errorbar = None\n", "\n", "        self._request_autoscale_view()\n", "\n", "        if orientation == 'vertical':\n", "            datavalues = height\n", "        else:  # horizontal\n", "            datavalues = width\n", "\n", "        bar_container = BarContainer(patches, errorbar, datavalues=datavalues,\n", "                                     orientation=orientation,\n", "                                     label=bar_container_label)\n", "        self.add_container(bar_container)\n", "\n", "        if tick_labels is not None:\n", "            tick_labels = np.broadcast_to(tick_labels, len(patches))\n", "            tick_label_axis.set_ticks(tick_label_position)\n", "            tick_label_axis.set_ticklabels(tick_labels)\n", "\n", "        return bar_container\n"]}]}, {"file_path": "lib/matplotlib/axes/_base.py", "span_ids": ["_AxesBase"], "content": [{"span_id": "_AxesBase", "start_line": 547, "end_line": 562, "content": ["@_api.define_aliases({\"facecolor\": [\"fc\"]})\n", "class _AxesBase(martist.Artist):\n", "    name = \"rectilinear\"\n", "\n", "    # axis names are the prefixes for the attributes that contain the\n", "    # respective axis; e.g. 'x' <-> self.xaxis, containing an XAxis.\n", "    # Note that PolarAxes uses these attributes as well, so that we have\n", "    # 'x' <-> self.xaxis, containing a ThetaAxis. In particular we do not\n", "    # have 'theta' in _axis_names.\n", "    # In practice, this is ('x', 'y') for all 2D Axes and ('x', 'y', 'z')\n", "    # for Axes3D.\n", "    _axis_names = (\"x\", \"y\")\n", "    _shared_axes = {name: cbook.Grouper() for name in _axis_names}\n", "    _twinned_axes = cbook.Grouper()\n", "\n", "    _subclass_uses_cla = False\n"]}]}]}