{"instance_id": "sympy__sympy-15011", "identified_spans": [{"file_path": "sympy/matrices/expressions/matexpr.py", "span_ids": ["MatrixSymbol", "MatrixSymbol.__new__", "MatrixSymbol.name"], "content": [{"span_id": "MatrixSymbol", "start_line": 643, "end_line": 658, "content": ["class MatrixSymbol(MatrixExpr):\n", "    \"\"\"Symbolic representation of a Matrix object\n", "\n", "    Creates a SymPy Symbol to represent a Matrix. This matrix has a shape and\n", "    can be included in Matrix Expressions\n", "\n", "    >>> from sympy import MatrixSymbol, Identity\n", "    >>> A = MatrixSymbol('A', 3, 4) # A 3 by 4 Matrix\n", "    >>> B = MatrixSymbol('B', 4, 3) # A 4 by 3 Matrix\n", "    >>> A.shape\n", "    (3, 4)\n", "    >>> 2*A*B + Identity(3)\n", "    I + 2*A*B\n", "    \"\"\"\n", "    is_commutative = False\n", "    _diff_wrt = True\n"]}, {"span_id": "MatrixSymbol.__new__", "start_line": 660, "end_line": 663, "content": ["    def __new__(cls, name, n, m):\n", "        n, m = sympify(n), sympify(m)\n", "        obj = Basic.__new__(cls, name, n, m)\n", "        return obj\n"]}, {"span_id": "MatrixSymbol.name", "start_line": 672, "end_line": 674, "content": ["    @property\n", "    def name(self):\n", "        return self.args[0]\n"]}]}, {"file_path": "sympy/utilities/lambdify.py", "span_ids": ["_EvaluatorPrinter._preprocess", "lambdify", "_EvaluatorPrinter:2", "_EvaluatorPrinter"], "content": [{"span_id": "_EvaluatorPrinter._preprocess", "start_line": 704, "end_line": 744, "content": ["    def _preprocess(self, args, expr):\n", "        \"\"\"Preprocess args, expr to replace arguments that do not map\n", "        to valid Python identifiers.\n", "\n", "        Returns string form of args, and updated expr.\n", "        \"\"\"\n", "        from sympy import Dummy, Symbol, Function, flatten\n", "        from sympy.matrices import DeferredVector\n", "\n", "        dummify = self._dummify\n", "\n", "        # Args of type Dummy can cause name collisions with args\n", "        # of type Symbol.  Force dummify of everything in this\n", "        # situation.\n", "        if not dummify:\n", "            dummify = any(isinstance(arg, Dummy) for arg in flatten(args))\n", "\n", "        argstrs = []\n", "        for arg in args:\n", "            if iterable(arg):\n", "                nested_argstrs, expr = self._preprocess(arg, expr)\n", "                argstrs.append(nested_argstrs)\n", "            elif isinstance(arg, DeferredVector):\n", "                argstrs.append(str(arg))\n", "            elif isinstance(arg, Symbol):\n", "                argrep = self._argrepr(arg)\n", "\n", "                if dummify or not self._is_safe_ident(argrep):\n", "                    dummy = Dummy()\n", "                    argstrs.append(self._argrepr(dummy))\n", "                    expr = self._subexpr(expr, {arg: dummy})\n", "                else:\n", "                    argstrs.append(argrep)\n", "            elif isinstance(arg, Function):\n", "                dummy = Dummy()\n", "                argstrs.append(self._argrepr(dummy))\n", "                expr = self._subexpr(expr, {arg: dummy})\n", "            else:\n", "                argstrs.append(str(arg))\n", "\n", "        return argstrs, expr\n"]}, {"span_id": "lambdify", "start_line": 165, "end_line": 487, "content": ["@doctest_depends_on(modules=('numpy'))\n", "def lambdify(args, expr, modules=None, printer=None, use_imps=True,\n", "             dummify=False):\n", "    \"\"\"\n", "    Returns an anonymous function for fast calculation of numerical values.\n", "\n", "    If not specified differently by the user, ``modules`` defaults to\n", "    ``[\"numpy\"]`` if NumPy is installed, and ``[\"math\", \"mpmath\", \"sympy\"]``\n", "    if it isn't, that is, SymPy functions are replaced as far as possible by\n", "    either ``numpy`` functions if available, and Python's standard library\n", "    ``math``, or ``mpmath`` functions otherwise. To change this behavior, the\n", "    \"modules\" argument can be used. It accepts:\n", "\n", "     - the strings \"math\", \"mpmath\", \"numpy\", \"numexpr\", \"sympy\", \"tensorflow\"\n", "     - any modules (e.g. math)\n", "     - dictionaries that map names of sympy functions to arbitrary functions\n", "     - lists that contain a mix of the arguments above, with higher priority\n", "       given to entries appearing first.\n", "\n", "    .. warning::\n", "        Note that this function uses ``eval``, and thus shouldn't be used on\n", "        unsanitized input.\n", "\n", "    Arguments in the provided expression that are not valid Python identifiers\n", "    are substitued with dummy symbols. This allows for applied functions\n", "    (e.g. f(t)) to be supplied as arguments. Call the function with\n", "    dummify=True to replace all arguments with dummy symbols (if `args` is\n", "    not a string) - for example, to ensure that the arguments do not\n", "    redefine any built-in names.\n", "\n", "    For functions involving large array calculations, numexpr can provide a\n", "    significant speedup over numpy.  Please note that the available functions\n", "    for numexpr are more limited than numpy but can be expanded with\n", "    implemented_function and user defined subclasses of Function.  If specified,\n", "    numexpr may be the only option in modules. The official list of numexpr\n", "    functions can be found at:\n", "    https://github.com/pydata/numexpr#supported-functions\n", "\n", "    In previous releases ``lambdify`` replaced ``Matrix`` with ``numpy.matrix``\n", "    by default. As of release 1.0 ``numpy.array`` is the default.\n", "    To get the old default behavior you must pass in ``[{'ImmutableDenseMatrix':\n", "    numpy.matrix}, 'numpy']`` to the ``modules`` kwarg.\n", "\n", "    >>> from sympy import lambdify, Matrix\n", "    >>> from sympy.abc import x, y\n", "    >>> import numpy\n", "    >>> array2mat = [{'ImmutableDenseMatrix': numpy.matrix}, 'numpy']\n", "    >>> f = lambdify((x, y), Matrix([x, y]), modules=array2mat)\n", "    >>> f(1, 2)\n", "    matrix([[1],\n", "            [2]])\n", "\n", "    Usage\n", "    =====\n", "\n", "    (1) Use one of the provided modules:\n", "\n", "        >>> from sympy import sin, tan, gamma\n", "        >>> from sympy.abc import x, y\n", "        >>> f = lambdify(x, sin(x), \"math\")\n", "\n", "        Attention: Functions that are not in the math module will throw a name\n", "                   error when the function definition is evaluated! So this\n", "                   would be better:\n", "\n", "        >>> f = lambdify(x, sin(x)*gamma(x), (\"math\", \"mpmath\", \"sympy\"))\n", "\n", "    (2) Use some other module:\n", "\n", "        >>> import numpy\n", "        >>> f = lambdify((x,y), tan(x*y), numpy)\n", "\n", "        Attention: There are naming differences between numpy and sympy. So if\n", "                   you simply take the numpy module, e.g. sympy.atan will not be\n", "                   translated to numpy.arctan. Use the modified module instead\n", "                   by passing the string \"numpy\":\n", "\n", "        >>> f = lambdify((x,y), tan(x*y), \"numpy\")\n", "        >>> f(1, 2)\n", "        -2.18503986326\n", "        >>> from numpy import array\n", "        >>> f(array([1, 2, 3]), array([2, 3, 5]))\n", "        [-2.18503986 -0.29100619 -0.8559934 ]\n", "\n", "        In the above examples, the generated functions can accept scalar\n", "        values or numpy arrays as arguments.  However, in some cases\n", "        the generated function relies on the input being a numpy array:\n", "\n", "        >>> from sympy import Piecewise\n", "        >>> f = lambdify(x, Piecewise((x, x <= 1), (1/x, x > 1)), \"numpy\")\n", "        >>> f(array([-1, 0, 1, 2]))\n", "        [-1.   0.   1.   0.5]\n", "        >>> f(0)\n", "        Traceback (most recent call last):\n", "            ...\n", "        ZeroDivisionError: division by zero\n", "\n", "        In such cases, the input should be wrapped in a numpy array:\n", "        >>> float(f(array([0])))\n", "        0.0\n", "\n", "        Or if numpy functionality is not required another module can be used:\n", "        >>> f = lambdify(x, Piecewise((x, x <= 1), (1/x, x > 1)), \"math\")\n", "        >>> f(0)\n", "        0\n", "\n", "    (3) Use a dictionary defining custom functions:\n", "\n", "        >>> def my_cool_function(x): return 'sin(%s) is cool' % x\n", "        >>> myfuncs = {\"sin\" : my_cool_function}\n", "        >>> f = lambdify(x, sin(x), myfuncs); f(1)\n", "        'sin(1) is cool'\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.utilities.lambdify import implemented_function\n", "    >>> from sympy import sqrt, sin, Matrix\n", "    >>> from sympy import Function\n", "    >>> from sympy.abc import w, x, y, z\n", "\n", "    >>> f = lambdify(x, x**2)\n", "    >>> f(2)\n", "    4\n", "    >>> f = lambdify((x, y, z), [z, y, x])\n", "    >>> f(1,2,3)\n", "    [3, 2, 1]\n", "    >>> f = lambdify(x, sqrt(x))\n", "    >>> f(4)\n", "    2.0\n", "    >>> f = lambdify((x, y), sin(x*y)**2)\n", "    >>> f(0, 5)\n", "    0.0\n", "    >>> row = lambdify((x, y), Matrix((x, x + y)).T, modules='sympy')\n", "    >>> row(1, 2)\n", "    Matrix([[1, 3]])\n", "\n", "    Tuple arguments are handled and the lambdified function should\n", "    be called with the same type of arguments as were used to create\n", "    the function.:\n", "\n", "    >>> f = lambdify((x, (y, z)), x + y)\n", "    >>> f(1, (2, 4))\n", "    3\n", "\n", "    A more robust way of handling this is to always work with flattened\n", "    arguments:\n", "\n", "    >>> from sympy.utilities.iterables import flatten\n", "    >>> args = w, (x, (y, z))\n", "    >>> vals = 1, (2, (3, 4))\n", "    >>> f = lambdify(flatten(args), w + x + y + z)\n", "    >>> f(*flatten(vals))\n", "    10\n", "\n", "    Functions present in `expr` can also carry their own numerical\n", "    implementations, in a callable attached to the ``_imp_``\n", "    attribute.  Usually you attach this using the\n", "    ``implemented_function`` factory:\n", "\n", "    >>> f = implemented_function(Function('f'), lambda x: x+1)\n", "    >>> func = lambdify(x, f(x))\n", "    >>> func(4)\n", "    5\n", "\n", "    ``lambdify`` always prefers ``_imp_`` implementations to implementations\n", "    in other namespaces, unless the ``use_imps`` input parameter is False.\n", "\n", "    Usage with Tensorflow module:\n", "\n", "    >>> import tensorflow as tf\n", "    >>> f = Max(x, sin(x))\n", "    >>> func = lambdify(x, f, 'tensorflow')\n", "    >>> result = func(tf.constant(1.0))\n", "    >>> result # a tf.Tensor representing the result of the calculation\n", "    <tf.Tensor 'Maximum:0' shape=() dtype=float32>\n", "    >>> sess = tf.Session()\n", "    >>> sess.run(result) # compute result\n", "    1.0\n", "    >>> var = tf.Variable(1.0)\n", "    >>> sess.run(tf.global_variables_initializer())\n", "    >>> sess.run(func(var)) # also works for tf.Variable and tf.Placeholder\n", "    1.0\n", "    >>> tensor = tf.constant([[1.0, 2.0], [3.0, 4.0]]) # works with any shape tensor\n", "    >>> sess.run(func(tensor))\n", "    array([[ 1.,  2.],\n", "           [ 3.,  4.]], dtype=float32)\n", "\n", "    \"\"\"\n", "    from sympy.core.symbol import Symbol\n", "    from sympy.utilities.iterables import flatten\n", "\n", "    # If the user hasn't specified any modules, use what is available.\n", "    module_provided = True\n", "    if modules is None:\n", "        module_provided = False\n", "\n", "        try:\n", "            _import(\"numpy\")\n", "        except ImportError:\n", "            # Use either numpy (if available) or python.math where possible.\n", "            # XXX: This leads to different behaviour on different systems and\n", "            #      might be the reason for irreproducible errors.\n", "            modules = [\"math\", \"mpmath\", \"sympy\"]\n", "        else:\n", "            modules = [\"numpy\"]\n", "\n", "    # Get the needed namespaces.\n", "    namespaces = []\n", "    # First find any function implementations\n", "    if use_imps:\n", "        namespaces.append(_imp_namespace(expr))\n", "    # Check for dict before iterating\n", "    if isinstance(modules, (dict, str)) or not hasattr(modules, '__iter__'):\n", "        namespaces.append(modules)\n", "    else:\n", "        # consistency check\n", "        if _module_present('numexpr', modules) and len(modules) > 1:\n", "            raise TypeError(\"numexpr must be the only item in 'modules'\")\n", "        namespaces += list(modules)\n", "    # fill namespace with first having highest priority\n", "    namespace = {}\n", "    for m in namespaces[::-1]:\n", "        buf = _get_namespace(m)\n", "        namespace.update(buf)\n", "\n", "    if hasattr(expr, \"atoms\"):\n", "        #Try if you can extract symbols from the expression.\n", "        #Move on if expr.atoms in not implemented.\n", "        syms = expr.atoms(Symbol)\n", "        for term in syms:\n", "            namespace.update({str(term): term})\n", "\n", "    if printer is None:\n", "        if _module_present('mpmath', namespaces):\n", "            from sympy.printing.pycode import MpmathPrinter as Printer\n", "        elif _module_present('numpy', namespaces):\n", "            from sympy.printing.pycode import NumPyPrinter as Printer\n", "        elif _module_present('numexpr', namespaces):\n", "            from sympy.printing.lambdarepr import NumExprPrinter as Printer\n", "        elif _module_present('tensorflow', namespaces):\n", "            from sympy.printing.lambdarepr import TensorflowPrinter as Printer\n", "        elif _module_present('sympy', namespaces):\n", "            from sympy.printing.pycode import SymPyPrinter as Printer\n", "        else:\n", "            from sympy.printing.pycode import PythonCodePrinter as Printer\n", "        user_functions = {}\n", "        for m in namespaces[::-1]:\n", "            if isinstance(m, dict):\n", "                for k in m:\n", "                    user_functions[k] = k\n", "        printer = Printer({'fully_qualified_modules': False, 'inline': True,\n", "                           'user_functions': user_functions})\n", "\n", "    # Get the names of the args, for creating a docstring\n", "    if not iterable(args):\n", "        args = (args,)\n", "    names = []\n", "    # Grab the callers frame, for getting the names by inspection (if needed)\n", "    callers_local_vars = inspect.currentframe().f_back.f_locals.items()\n", "    for n, var in enumerate(args):\n", "        if hasattr(var, 'name'):\n", "            names.append(var.name)\n", "        else:\n", "            # It's an iterable. Try to get name by inspection of calling frame.\n", "            name_list = [var_name for var_name, var_val in callers_local_vars\n", "                    if var_val is var]\n", "            if len(name_list) == 1:\n", "                names.append(name_list[0])\n", "            else:\n", "                # Cannot infer name with certainty. arg_# will have to do.\n", "                names.append('arg_' + str(n))\n", "\n", "    imp_mod_lines = []\n", "    for mod, keys in (getattr(printer, 'module_imports', None) or {}).items():\n", "        for k in keys:\n", "            if k not in namespace:\n", "                imp_mod_lines.append(\"from %s import %s\" % (mod, k))\n", "    for ln in imp_mod_lines:\n", "        exec_(ln, {}, namespace)\n", "\n", "    # Provide lambda expression with builtins, and compatible implementation of range\n", "    namespace.update({'builtins':builtins, 'range':range})\n", "\n", "    # Create the function definition code and execute it\n", "\n", "    funcname = '_lambdifygenerated'\n", "\n", "    if _module_present('tensorflow', namespaces):\n", "        funcprinter = _TensorflowEvaluatorPrinter(printer, dummify)\n", "    else:\n", "        funcprinter = _EvaluatorPrinter(printer, dummify)\n", "\n", "    funcstr = funcprinter.doprint(funcname, args, expr)\n", "\n", "    funclocals = {}\n", "    global _lambdify_generated_counter\n", "    filename = '<lambdifygenerated-%s>' % _lambdify_generated_counter\n", "    _lambdify_generated_counter += 1\n", "    c = compile(funcstr, filename, 'exec')\n", "    exec_(c, namespace, funclocals)\n", "    # mtime has to be None or else linecache.checkcache will remove it\n", "    linecache.cache[filename] = (len(funcstr), None, funcstr.splitlines(True), filename)\n", "\n", "    func = funclocals[funcname]\n", "\n", "    # Apply the docstring\n", "    sig = \"func({0})\".format(\", \".join(str(i) for i in names))\n", "    sig = textwrap.fill(sig, subsequent_indent=' '*8)\n", "    expr_str = str(expr)\n", "    if len(expr_str) > 78:\n", "        expr_str = textwrap.wrap(expr_str, 75)[0] + '...'\n", "    func.__doc__ = (\n", "        \"Created with lambdify. Signature:\\n\\n\"\n", "        \"{sig}\\n\\n\"\n", "        \"Expression:\\n\\n\"\n", "        \"{expr}\\n\\n\"\n", "        \"Source code:\\n\\n\"\n", "        \"{src}\\n\\n\"\n", "        \"Imported modules:\\n\\n\"\n", "        \"{imp_mods}\"\n", "        ).format(sig=sig, expr=expr_str, src=funcstr, imp_mods='\\n'.join(imp_mod_lines))\n", "    return func\n"]}, {"span_id": "_EvaluatorPrinter:2", "start_line": 690, "end_line": 701, "content": ["    if PY3:\n", "        @classmethod\n", "        def _is_safe_ident(cls, ident):\n", "            return isinstance(ident, str) and ident.isidentifier() \\\n", "                    and not keyword.iskeyword(ident)\n", "    else:\n", "        _safe_ident_re = re.compile('^[a-zA-Z_][a-zA-Z0-9_]*$')\n", "\n", "        @classmethod\n", "        def _is_safe_ident(cls, ident):\n", "            return isinstance(ident, str) and cls._safe_ident_re.match(ident) \\\n", "                and not (keyword.iskeyword(ident) or ident == 'None')\n"]}, {"span_id": "_EvaluatorPrinter", "start_line": 627, "end_line": 627, "content": ["class _EvaluatorPrinter(object):\n"]}]}]}