{"instance_id": "django__django-13448", "identified_spans": [{"file_path": "django/db/backends/base/creation.py", "span_ids": ["BaseDatabaseCreation.create_test_db", "BaseDatabaseCreation.serialize_db_to_string"], "content": [{"span_id": "BaseDatabaseCreation.create_test_db", "start_line": 30, "end_line": 85, "content": ["    def create_test_db(self, verbosity=1, autoclobber=False, serialize=True, keepdb=False):\n", "        \"\"\"\n", "        Create a test database, prompting the user for confirmation if the\n", "        database already exists. Return the name of the test database created.\n", "        \"\"\"\n", "        # Don't import django.core.management if it isn't needed.\n", "        from django.core.management import call_command\n", "\n", "        test_database_name = self._get_test_db_name()\n", "\n", "        if verbosity >= 1:\n", "            action = 'Creating'\n", "            if keepdb:\n", "                action = \"Using existing\"\n", "\n", "            self.log('%s test database for alias %s...' % (\n", "                action,\n", "                self._get_database_display_str(verbosity, test_database_name),\n", "            ))\n", "\n", "        # We could skip this call if keepdb is True, but we instead\n", "        # give it the keepdb param. This is to handle the case\n", "        # where the test DB doesn't exist, in which case we need to\n", "        # create it, then just not destroy it. If we instead skip\n", "        # this, we will get an exception.\n", "        self._create_test_db(verbosity, autoclobber, keepdb)\n", "\n", "        self.connection.close()\n", "        settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n", "        self.connection.settings_dict[\"NAME\"] = test_database_name\n", "\n", "        if self.connection.settings_dict['TEST']['MIGRATE']:\n", "            # We report migrate messages at one level lower than that\n", "            # requested. This ensures we don't get flooded with messages during\n", "            # testing (unless you really ask to be flooded).\n", "            call_command(\n", "                'migrate',\n", "                verbosity=max(verbosity - 1, 0),\n", "                interactive=False,\n", "                database=self.connection.alias,\n", "                run_syncdb=True,\n", "            )\n", "\n", "        # We then serialize the current state of the database into a string\n", "        # and store it on the connection. This slightly horrific process is so people\n", "        # who are testing on databases without transactions or who are using\n", "        # a TransactionTestCase still get a clean database on every test run.\n", "        if serialize:\n", "            self.connection._test_serialized_contents = self.serialize_db_to_string()\n", "\n", "        call_command('createcachetable', database=self.connection.alias)\n", "\n", "        # Ensure a connection for the side effect of initializing the test database.\n", "        self.connection.ensure_connection()\n", "\n", "        return test_database_name\n"]}, {"span_id": "BaseDatabaseCreation.serialize_db_to_string", "start_line": 94, "end_line": 122, "content": ["    def serialize_db_to_string(self):\n", "        \"\"\"\n", "        Serialize all data in the database into a JSON string.\n", "        Designed only for test runner usage; will not handle large\n", "        amounts of data.\n", "        \"\"\"\n", "        # Iteratively return every object for all models to serialize.\n", "        def get_objects():\n", "            from django.db.migrations.loader import MigrationLoader\n", "            loader = MigrationLoader(self.connection)\n", "            for app_config in apps.get_app_configs():\n", "                if (\n", "                    app_config.models_module is not None and\n", "                    app_config.label in loader.migrated_apps and\n", "                    app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n", "                ):\n", "                    for model in app_config.get_models():\n", "                        if (\n", "                            model._meta.can_migrate(self.connection) and\n", "                            router.allow_migrate_model(self.connection.alias, model)\n", "                        ):\n", "                            queryset = model._default_manager.using(\n", "                                self.connection.alias,\n", "                            ).order_by(model._meta.pk.name)\n", "                            yield from queryset.iterator()\n", "        # Serialize to a string\n", "        out = StringIO()\n", "        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n", "        return out.getvalue()\n"]}]}]}