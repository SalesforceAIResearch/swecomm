{"instance_id": "sympy__sympy-13471", "identified_spans": [{"file_path": "sympy/core/numbers.py", "span_ids": ["mpf_norm", "Float._as_mpf_val", "Float.__new__"], "content": [{"span_id": "mpf_norm", "start_line": 78, "end_line": 105, "content": ["def mpf_norm(mpf, prec):\n", "    \"\"\"Return the mpf tuple normalized appropriately for the indicated\n", "    precision after doing a check to see if zero should be returned or\n", "    not when the mantissa is 0. ``mpf_normlize`` always assumes that this\n", "    is zero, but it may not be since the mantissa for mpf's values \"+inf\",\n", "    \"-inf\" and \"nan\" have a mantissa of zero, too.\n", "\n", "    Note: this is not intended to validate a given mpf tuple, so sending\n", "    mpf tuples that were not created by mpmath may produce bad results. This\n", "    is only a wrapper to ``mpf_normalize`` which provides the check for non-\n", "    zero mpfs that have a 0 for the mantissa.\n", "    \"\"\"\n", "    sign, man, expt, bc = mpf\n", "    if not man:\n", "        # hack for mpf_normalize which does not do this;\n", "        # it assumes that if man is zero the result is 0\n", "        # (see issue 6639)\n", "        if not bc:\n", "            return _mpf_zero\n", "        else:\n", "            # don't change anything; this should already\n", "            # be a well formed mpf tuple\n", "            return mpf\n", "\n", "    # Necessary if mpmath is using the gmpy backend\n", "    from mpmath.libmp.backend import MPZ\n", "    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)\n", "    return rv\n"]}, {"span_id": "Float._as_mpf_val", "start_line": 1106, "end_line": 1110, "content": ["    def _as_mpf_val(self, prec):\n", "        rv = mpf_norm(self._mpf_, prec)\n", "        if rv != self._mpf_ and self._prec == prec:\n", "            debug(self._mpf_, rv)\n", "        return rv\n"]}, {"span_id": "Float.__new__", "start_line": 941, "end_line": 1068, "content": ["    def __new__(cls, num, dps=None, prec=None, precision=None):\n", "        if prec is not None:\n", "            SymPyDeprecationWarning(\n", "                            feature=\"Using 'prec=XX' to denote decimal precision\",\n", "                            useinstead=\"'dps=XX' for decimal precision and 'precision=XX' \"\\\n", "                                              \"for binary precision\",\n", "                            issue=12820,\n", "                            deprecated_since_version=\"1.1\").warn()\n", "            dps = prec\n", "        del prec  # avoid using this deprecated kwarg\n", "\n", "        if dps is not None and precision is not None:\n", "            raise ValueError('Both decimal and binary precision supplied. '\n", "                             'Supply only one. ')\n", "\n", "        if isinstance(num, string_types):\n", "            num = num.replace(' ', '')\n", "            if num.startswith('.') and len(num) > 1:\n", "                num = '0' + num\n", "            elif num.startswith('-.') and len(num) > 2:\n", "                num = '-0.' + num[2:]\n", "        elif isinstance(num, float) and num == 0:\n", "            num = '0'\n", "        elif isinstance(num, (SYMPY_INTS, Integer)):\n", "            num = str(num)  # faster than mlib.from_int\n", "        elif num is S.Infinity:\n", "            num = '+inf'\n", "        elif num is S.NegativeInfinity:\n", "            num = '-inf'\n", "        elif type(num).__module__ == 'numpy': # support for numpy datatypes\n", "            num = _convert_numpy_types(num)\n", "        elif isinstance(num, mpmath.mpf):\n", "            if precision is None:\n", "                if dps is None:\n", "                    precision = num.context.prec\n", "            num = num._mpf_\n", "\n", "        if dps is None and precision is None:\n", "            dps = 15\n", "            if isinstance(num, Float):\n", "                return num\n", "            if isinstance(num, string_types) and _literal_float(num):\n", "                try:\n", "                    Num = decimal.Decimal(num)\n", "                except decimal.InvalidOperation:\n", "                    pass\n", "                else:\n", "                    isint = '.' not in num\n", "                    num, dps = _decimal_to_Rational_prec(Num)\n", "                    if num.is_Integer and isint:\n", "                        dps = max(dps, len(str(num).lstrip('-')))\n", "                    dps = max(15, dps)\n", "                    precision = mlib.libmpf.dps_to_prec(dps)\n", "        elif precision == '' and dps is None or precision is None and dps == '':\n", "            if not isinstance(num, string_types):\n", "                raise ValueError('The null string can only be used when '\n", "                'the number to Float is passed as a string or an integer.')\n", "            ok = None\n", "            if _literal_float(num):\n", "                try:\n", "                    Num = decimal.Decimal(num)\n", "                except decimal.InvalidOperation:\n", "                    pass\n", "                else:\n", "                    isint = '.' not in num\n", "                    num, dps = _decimal_to_Rational_prec(Num)\n", "                    if num.is_Integer and isint:\n", "                        dps = max(dps, len(str(num).lstrip('-')))\n", "                        precision = mlib.libmpf.dps_to_prec(dps)\n", "                    ok = True\n", "            if ok is None:\n", "                raise ValueError('string-float not recognized: %s' % num)\n", "\n", "        # decimal precision(dps) is set and maybe binary precision(precision)\n", "        # as well.From here on binary precision is used to compute the Float.\n", "        # Hence, if supplied use binary precision else translate from decimal\n", "        # precision.\n", "\n", "        if precision is None or precision == '':\n", "            precision = mlib.libmpf.dps_to_prec(dps)\n", "\n", "        precision = int(precision)\n", "\n", "        if isinstance(num, float):\n", "            _mpf_ = mlib.from_float(num, precision, rnd)\n", "        elif isinstance(num, string_types):\n", "            _mpf_ = mlib.from_str(num, precision, rnd)\n", "        elif isinstance(num, decimal.Decimal):\n", "            if num.is_finite():\n", "                _mpf_ = mlib.from_str(str(num), precision, rnd)\n", "            elif num.is_nan():\n", "                _mpf_ = _mpf_nan\n", "            elif num.is_infinite():\n", "                if num > 0:\n", "                    _mpf_ = _mpf_inf\n", "                else:\n", "                    _mpf_ = _mpf_ninf\n", "            else:\n", "                raise ValueError(\"unexpected decimal value %s\" % str(num))\n", "        elif isinstance(num, tuple) and len(num) in (3, 4):\n", "            if type(num[1]) is str:\n", "                # it's a hexadecimal (coming from a pickled object)\n", "                # assume that it is in standard form\n", "                num = list(num)\n", "                num[1] = long(num[1], 16)\n", "                _mpf_ = tuple(num)\n", "            else:\n", "                if len(num) == 4:\n", "                    # handle normalization hack\n", "                    return Float._new(num, precision)\n", "                else:\n", "                    return (S.NegativeOne**num[0]*num[1]*S(2)**num[2]).evalf(precision)\n", "        else:\n", "            try:\n", "                _mpf_ = num._as_mpf_val(precision)\n", "            except (NotImplementedError, AttributeError):\n", "                _mpf_ = mpmath.mpf(num, prec=precision)._mpf_\n", "\n", "        # special cases\n", "        if _mpf_ == _mpf_zero:\n", "            pass  # we want a Float\n", "        elif _mpf_ == _mpf_nan:\n", "            return S.NaN\n", "\n", "        obj = Expr.__new__(cls)\n", "        obj._mpf_ = _mpf_\n", "        obj._prec = precision\n", "        return obj\n"]}]}]}