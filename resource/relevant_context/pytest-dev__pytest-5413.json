{"instance_id": "pytest-dev__pytest-5413", "identified_spans": [{"file_path": "src/_pytest/_code/code.py", "span_ids": ["ExceptionInfo.__str__", "ExceptionInfo"], "content": [{"span_id": "ExceptionInfo.__str__", "start_line": 537, "end_line": 542, "content": ["    def __str__(self):\n", "        if self._excinfo is None:\n", "            return repr(self)\n", "        entry = self.traceback[-1]\n", "        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n", "        return str(loc)\n"]}, {"span_id": "ExceptionInfo", "start_line": 373, "end_line": 383, "content": ["@attr.s(repr=False)\n", "class ExceptionInfo:\n", "    \"\"\" wraps sys.exc_info() objects and offers\n", "        help for navigating the traceback.\n", "    \"\"\"\n", "\n", "    _assert_start_repr = \"AssertionError('assert \"\n", "\n", "    _excinfo = attr.ib()\n", "    _striptext = attr.ib(default=\"\")\n", "    _traceback = attr.ib(default=None)\n"]}]}, {"file_path": "src/_pytest/python_api.py", "span_ids": ["raises"], "content": [{"span_id": "raises", "start_line": 543, "end_line": 703, "content": ["def raises(expected_exception, *args, **kwargs):\n", "    r\"\"\"\n", "    Assert that a code block/function call raises ``expected_exception``\n", "    or raise a failure exception otherwise.\n", "\n", "    :kwparam match: if specified, a string containing a regular expression,\n", "        or a regular expression object, that is tested against the string\n", "        representation of the exception using ``re.search``. To match a literal\n", "        string that may contain `special characters`__, the pattern can\n", "        first be escaped with ``re.escape``.\n", "\n", "    __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n", "\n", "    :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message\n", "        if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n", "\n", "    .. currentmodule:: _pytest._code\n", "\n", "    Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n", "    type::\n", "\n", "        >>> with raises(ZeroDivisionError):\n", "        ...    1/0\n", "\n", "    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n", "    above), or no exception at all, the check will fail instead.\n", "\n", "    You can also use the keyword argument ``match`` to assert that the\n", "    exception matches a text or regex::\n", "\n", "        >>> with raises(ValueError, match='must be 0 or None'):\n", "        ...     raise ValueError(\"value must be 0 or None\")\n", "\n", "        >>> with raises(ValueError, match=r'must be \\d+$'):\n", "        ...     raise ValueError(\"value must be 42\")\n", "\n", "    The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n", "    details of the captured exception::\n", "\n", "        >>> with raises(ValueError) as exc_info:\n", "        ...     raise ValueError(\"value must be 42\")\n", "        >>> assert exc_info.type is ValueError\n", "        >>> assert exc_info.value.args[0] == \"value must be 42\"\n", "\n", "    .. deprecated:: 4.1\n", "\n", "        In the context manager form you may use the keyword argument\n", "        ``message`` to specify a custom failure message that will be displayed\n", "        in case the ``pytest.raises`` check fails. This has been deprecated as it\n", "        is considered error prone as users often mean to use ``match`` instead.\n", "        See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n", "\n", "    .. note::\n", "\n", "       When using ``pytest.raises`` as a context manager, it's worthwhile to\n", "       note that normal context manager rules apply and that the exception\n", "       raised *must* be the final line in the scope of the context manager.\n", "       Lines of code after that, within the scope of the context manager will\n", "       not be executed. For example::\n", "\n", "           >>> value = 15\n", "           >>> with raises(ValueError) as exc_info:\n", "           ...     if value > 10:\n", "           ...         raise ValueError(\"value must be <= 10\")\n", "           ...     assert exc_info.type is ValueError  # this will not execute\n", "\n", "       Instead, the following approach must be taken (note the difference in\n", "       scope)::\n", "\n", "           >>> with raises(ValueError) as exc_info:\n", "           ...     if value > 10:\n", "           ...         raise ValueError(\"value must be <= 10\")\n", "           ...\n", "           >>> assert exc_info.type is ValueError\n", "\n", "    **Using with** ``pytest.mark.parametrize``\n", "\n", "    When using :ref:`pytest.mark.parametrize ref`\n", "    it is possible to parametrize tests such that\n", "    some runs raise an exception and others do not.\n", "\n", "    See :ref:`parametrizing_conditional_raising` for an example.\n", "\n", "    **Legacy form**\n", "\n", "    It is possible to specify a callable by passing a to-be-called lambda::\n", "\n", "        >>> raises(ZeroDivisionError, lambda: 1/0)\n", "        <ExceptionInfo ...>\n", "\n", "    or you can specify an arbitrary callable with arguments::\n", "\n", "        >>> def f(x): return 1/x\n", "        ...\n", "        >>> raises(ZeroDivisionError, f, 0)\n", "        <ExceptionInfo ...>\n", "        >>> raises(ZeroDivisionError, f, x=0)\n", "        <ExceptionInfo ...>\n", "\n", "    The form above is fully supported but discouraged for new code because the\n", "    context manager form is regarded as more readable and less error-prone.\n", "\n", "    .. note::\n", "        Similar to caught exception objects in Python, explicitly clearing\n", "        local references to returned ``ExceptionInfo`` objects can\n", "        help the Python interpreter speed up its garbage collection.\n", "\n", "        Clearing those references breaks a reference cycle\n", "        (``ExceptionInfo`` --> caught exception --> frame stack raising\n", "        the exception --> current frame stack --> local variables -->\n", "        ``ExceptionInfo``) which makes Python keep all objects referenced\n", "        from that cycle (including all local variables in the current\n", "        frame) alive until the next cyclic garbage collection run. See the\n", "        official Python ``try`` statement documentation for more detailed\n", "        information.\n", "\n", "    \"\"\"\n", "    __tracebackhide__ = True\n", "    for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):\n", "        msg = (\n", "            \"exceptions must be old-style classes or\"\n", "            \" derived from BaseException, not %s\"\n", "        )\n", "        raise TypeError(msg % type(exc))\n", "\n", "    message = \"DID NOT RAISE {}\".format(expected_exception)\n", "    match_expr = None\n", "\n", "    if not args:\n", "        if \"message\" in kwargs:\n", "            message = kwargs.pop(\"message\")\n", "            warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)\n", "        if \"match\" in kwargs:\n", "            match_expr = kwargs.pop(\"match\")\n", "        if kwargs:\n", "            msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n", "            msg += \", \".join(sorted(kwargs))\n", "            raise TypeError(msg)\n", "        return RaisesContext(expected_exception, message, match_expr)\n", "    elif isinstance(args[0], str):\n", "        warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)\n", "        code, = args\n", "        assert isinstance(code, str)\n", "        frame = sys._getframe(1)\n", "        loc = frame.f_locals.copy()\n", "        loc.update(kwargs)\n", "        # print \"raises frame scope: %r\" % frame.f_locals\n", "        try:\n", "            code = _pytest._code.Source(code).compile(_genframe=frame)\n", "            exec(code, frame.f_globals, loc)\n", "            # XXX didn't mean f_globals == f_locals something special?\n", "            #     this is destroyed here ...\n", "        except expected_exception:\n", "            return _pytest._code.ExceptionInfo.from_current()\n", "    else:\n", "        func = args[0]\n", "        try:\n", "            func(*args[1:], **kwargs)\n", "        except expected_exception:\n", "            return _pytest._code.ExceptionInfo.from_current()\n", "    fail(message)\n"]}]}]}