{"instance_id": "pytest-dev__pytest-11143", "identified_spans": [{"file_path": "src/_pytest/assertion/rewrite.py", "span_ids": ["AssertionRewriter.is_rewrite_disabled", "AssertionRewriter", "AssertionRewriter.run"], "content": [{"span_id": "AssertionRewriter.is_rewrite_disabled", "start_line": 744, "end_line": 746, "content": ["    @staticmethod\n", "    def is_rewrite_disabled(docstring: str) -> bool:\n", "        return \"PYTEST_DONT_REWRITE\" in docstring\n"]}, {"span_id": "AssertionRewriter", "start_line": 588, "end_line": 643, "content": ["class AssertionRewriter(ast.NodeVisitor):\n", "    \"\"\"Assertion rewriting implementation.\n", "\n", "    The main entrypoint is to call .run() with an ast.Module instance,\n", "    this will then find all the assert statements and rewrite them to\n", "    provide intermediate values and a detailed assertion error.  See\n", "    http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n", "    for an overview of how this works.\n", "\n", "    The entry point here is .run() which will iterate over all the\n", "    statements in an ast.Module and for each ast.Assert statement it\n", "    finds call .visit() with it.  Then .visit_Assert() takes over and\n", "    is responsible for creating new ast statements to replace the\n", "    original assert statement: it rewrites the test of an assertion\n", "    to provide intermediate values and replace it with an if statement\n", "    which raises an assertion error with a detailed explanation in\n", "    case the expression is false and calls pytest_assertion_pass hook\n", "    if expression is true.\n", "\n", "    For this .visit_Assert() uses the visitor pattern to visit all the\n", "    AST nodes of the ast.Assert.test field, each visit call returning\n", "    an AST node and the corresponding explanation string.  During this\n", "    state is kept in several instance attributes:\n", "\n", "    :statements: All the AST statements which will replace the assert\n", "       statement.\n", "\n", "    :variables: This is populated by .variable() with each variable\n", "       used by the statements so that they can all be set to None at\n", "       the end of the statements.\n", "\n", "    :variable_counter: Counter to create new unique variables needed\n", "       by statements.  Variables are created using .variable() and\n", "       have the form of \"@py_assert0\".\n", "\n", "    :expl_stmts: The AST statements which will be executed to get\n", "       data from the assertion.  This is the code which will construct\n", "       the detailed assertion message that is used in the AssertionError\n", "       or for the pytest_assertion_pass hook.\n", "\n", "    :explanation_specifiers: A dict filled by .explanation_param()\n", "       with %-formatting placeholders and their corresponding\n", "       expressions to use in the building of an assertion message.\n", "       This is used by .pop_format_context() to build a message.\n", "\n", "    :stack: A stack of the explanation_specifiers dicts maintained by\n", "       .push_format_context() and .pop_format_context() which allows\n", "       to build another %-formatted string while already building one.\n", "\n", "    :variables_overwrite: A dict filled with references to variables\n", "       that change value within an assert. This happens when a variable is\n", "       reassigned with the walrus operator\n", "\n", "    This state, except the variables_overwrite,  is reset on every new assert\n", "    statement visited and used by the other visitors.\n", "    \"\"\"\n"]}, {"span_id": "AssertionRewriter.run", "start_line": 660, "end_line": 742, "content": ["    def run(self, mod: ast.Module) -> None:\n", "        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n", "        if not mod.body:\n", "            # Nothing to do.\n", "            return\n", "\n", "        # We'll insert some special imports at the top of the module, but after any\n", "        # docstrings and __future__ imports, so first figure out where that is.\n", "        doc = getattr(mod, \"docstring\", None)\n", "        expect_docstring = doc is None\n", "        if doc is not None and self.is_rewrite_disabled(doc):\n", "            return\n", "        pos = 0\n", "        item = None\n", "        for item in mod.body:\n", "            if (\n", "                expect_docstring\n", "                and isinstance(item, ast.Expr)\n", "                and isinstance(item.value, ast.Constant)\n", "            ):\n", "                doc = item.value.value\n", "                if self.is_rewrite_disabled(doc):\n", "                    return\n", "                expect_docstring = False\n", "            elif (\n", "                isinstance(item, ast.ImportFrom)\n", "                and item.level == 0\n", "                and item.module == \"__future__\"\n", "            ):\n", "                pass\n", "            else:\n", "                break\n", "            pos += 1\n", "        # Special case: for a decorated function, set the lineno to that of the\n", "        # first decorator, not the `def`. Issue #4984.\n", "        if isinstance(item, ast.FunctionDef) and item.decorator_list:\n", "            lineno = item.decorator_list[0].lineno\n", "        else:\n", "            lineno = item.lineno\n", "        # Now actually insert the special imports.\n", "        if sys.version_info >= (3, 10):\n", "            aliases = [\n", "                ast.alias(\"builtins\", \"@py_builtins\", lineno=lineno, col_offset=0),\n", "                ast.alias(\n", "                    \"_pytest.assertion.rewrite\",\n", "                    \"@pytest_ar\",\n", "                    lineno=lineno,\n", "                    col_offset=0,\n", "                ),\n", "            ]\n", "        else:\n", "            aliases = [\n", "                ast.alias(\"builtins\", \"@py_builtins\"),\n", "                ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n", "            ]\n", "        imports = [\n", "            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n", "        ]\n", "        mod.body[pos:pos] = imports\n", "\n", "        # Collect asserts.\n", "        nodes: List[ast.AST] = [mod]\n", "        while nodes:\n", "            node = nodes.pop()\n", "            for name, field in ast.iter_fields(node):\n", "                if isinstance(field, list):\n", "                    new: List[ast.AST] = []\n", "                    for i, child in enumerate(field):\n", "                        if isinstance(child, ast.Assert):\n", "                            # Transform assert.\n", "                            new.extend(self.visit(child))\n", "                        else:\n", "                            new.append(child)\n", "                            if isinstance(child, ast.AST):\n", "                                nodes.append(child)\n", "                    setattr(node, name, new)\n", "                elif (\n", "                    isinstance(field, ast.AST)\n", "                    # Don't recurse into expressions as they can't contain\n", "                    # asserts.\n", "                    and not isinstance(field, ast.expr)\n", "                ):\n", "                    nodes.append(field)\n"]}]}]}