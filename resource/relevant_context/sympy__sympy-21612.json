{"instance_id": "sympy__sympy-21612", "identified_spans": [{"file_path": "sympy/parsing/latex/_parse_latex_antlr.py", "span_ids": ["parse_latex", "convert_frac"], "content": [{"span_id": "parse_latex", "start_line": 61, "end_line": 87, "content": ["def parse_latex(sympy):\n", "    antlr4 = import_module('antlr4', warn_not_installed=True)\n", "\n", "    if None in [antlr4, MathErrorListener]:\n", "        raise ImportError(\"LaTeX parsing requires the antlr4 python package,\"\n", "                          \" provided by pip (antlr4-python2-runtime or\"\n", "                          \" antlr4-python3-runtime) or\"\n", "                          \" conda (antlr-python-runtime)\")\n", "\n", "    matherror = MathErrorListener(sympy)\n", "\n", "    stream = antlr4.InputStream(sympy)\n", "    lex = LaTeXLexer(stream)\n", "    lex.removeErrorListeners()\n", "    lex.addErrorListener(matherror)\n", "\n", "    tokens = antlr4.CommonTokenStream(lex)\n", "    parser = LaTeXParser(tokens)\n", "\n", "    # remove default console error listener\n", "    parser.removeErrorListeners()\n", "    parser.addErrorListener(matherror)\n", "\n", "    relation = parser.math().relation()\n", "    expr = convert_relation(relation)\n", "\n", "    return expr\n"]}, {"span_id": "convert_frac", "start_line": 345, "end_line": 389, "content": ["def convert_frac(frac):\n", "    diff_op = False\n", "    partial_op = False\n", "    lower_itv = frac.lower.getSourceInterval()\n", "    lower_itv_len = lower_itv[1] - lower_itv[0] + 1\n", "    if (frac.lower.start == frac.lower.stop\n", "            and frac.lower.start.type == LaTeXLexer.DIFFERENTIAL):\n", "        wrt = get_differential_var_str(frac.lower.start.text)\n", "        diff_op = True\n", "    elif (lower_itv_len == 2 and frac.lower.start.type == LaTeXLexer.SYMBOL\n", "          and frac.lower.start.text == '\\\\partial'\n", "          and (frac.lower.stop.type == LaTeXLexer.LETTER\n", "               or frac.lower.stop.type == LaTeXLexer.SYMBOL)):\n", "        partial_op = True\n", "        wrt = frac.lower.stop.text\n", "        if frac.lower.stop.type == LaTeXLexer.SYMBOL:\n", "            wrt = wrt[1:]\n", "\n", "    if diff_op or partial_op:\n", "        wrt = sympy.Symbol(wrt)\n", "        if (diff_op and frac.upper.start == frac.upper.stop\n", "                and frac.upper.start.type == LaTeXLexer.LETTER\n", "                and frac.upper.start.text == 'd'):\n", "            return [wrt]\n", "        elif (partial_op and frac.upper.start == frac.upper.stop\n", "              and frac.upper.start.type == LaTeXLexer.SYMBOL\n", "              and frac.upper.start.text == '\\\\partial'):\n", "            return [wrt]\n", "        upper_text = rule2text(frac.upper)\n", "\n", "        expr_top = None\n", "        if diff_op and upper_text.startswith('d'):\n", "            expr_top = parse_latex(upper_text[1:])\n", "        elif partial_op and frac.upper.start.text == '\\\\partial':\n", "            expr_top = parse_latex(upper_text[len('\\\\partial'):])\n", "        if expr_top:\n", "            return sympy.Derivative(expr_top, wrt)\n", "\n", "    expr_top = convert_expr(frac.upper)\n", "    expr_bot = convert_expr(frac.lower)\n", "    inverse_denom = sympy.Pow(expr_bot, -1, evaluate=False)\n", "    if expr_top == 1:\n", "        return inverse_denom\n", "    else:\n", "        return sympy.Mul(expr_top, inverse_denom, evaluate=False)\n"]}]}]}