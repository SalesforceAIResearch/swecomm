{"instance_id": "django__django-15388", "identified_spans": [{"file_path": "django/core/management/commands/runserver.py", "span_ids": ["Command.inner_run", "Command", "Command.run"], "content": [{"span_id": "Command.inner_run", "start_line": 112, "end_line": 164, "content": ["    def inner_run(self, *args, **options):\n", "        # If an exception was silenced in ManagementUtility.execute in order\n", "        # to be raised in the child process, raise it now.\n", "        autoreload.raise_last_exception()\n", "\n", "        threading = options['use_threading']\n", "        # 'shutdown_message' is a stealth option.\n", "        shutdown_message = options.get('shutdown_message', '')\n", "        quit_command = 'CTRL-BREAK' if sys.platform == 'win32' else 'CONTROL-C'\n", "\n", "        if not options['skip_checks']:\n", "            self.stdout.write('Performing system checks...\\n\\n')\n", "            self.check(display_num_errors=True)\n", "        # Need to check migrations here, so can't use the\n", "        # requires_migrations_check attribute.\n", "        self.check_migrations()\n", "        now = datetime.now().strftime('%B %d, %Y - %X')\n", "        self.stdout.write(now)\n", "        self.stdout.write((\n", "            \"Django version %(version)s, using settings %(settings)r\\n\"\n", "            \"Starting development server at %(protocol)s://%(addr)s:%(port)s/\\n\"\n", "            \"Quit the server with %(quit_command)s.\"\n", "        ) % {\n", "            \"version\": self.get_version(),\n", "            \"settings\": settings.SETTINGS_MODULE,\n", "            \"protocol\": self.protocol,\n", "            \"addr\": '[%s]' % self.addr if self._raw_ipv6 else self.addr,\n", "            \"port\": self.port,\n", "            \"quit_command\": quit_command,\n", "        })\n", "\n", "        try:\n", "            handler = self.get_handler(*args, **options)\n", "            run(self.addr, int(self.port), handler,\n", "                ipv6=self.use_ipv6, threading=threading, server_cls=self.server_cls)\n", "        except OSError as e:\n", "            # Use helpful error messages instead of ugly tracebacks.\n", "            ERRORS = {\n", "                errno.EACCES: \"You don't have permission to access that port.\",\n", "                errno.EADDRINUSE: \"That port is already in use.\",\n", "                errno.EADDRNOTAVAIL: \"That IP address can't be assigned to.\",\n", "            }\n", "            try:\n", "                error_text = ERRORS[e.errno]\n", "            except KeyError:\n", "                error_text = e\n", "            self.stderr.write(\"Error: %s\" % error_text)\n", "            # Need to use an OS exit because sys.exit doesn't work in a thread\n", "            os._exit(1)\n", "        except KeyboardInterrupt:\n", "            if shutdown_message:\n", "                self.stdout.write(shutdown_message)\n", "            sys.exit(0)\n"]}, {"span_id": "Command", "start_line": 24, "end_line": 36, "content": ["class Command(BaseCommand):\n", "    help = \"Starts a lightweight web server for development.\"\n", "\n", "    # Validation is called explicitly each time the server is reloaded.\n", "    requires_system_checks = []\n", "    stealth_options = ('shutdown_message',)\n", "    suppressed_base_arguments = {'--verbosity', '--traceback'}\n", "\n", "    default_addr = '127.0.0.1'\n", "    default_addr_ipv6 = '::1'\n", "    default_port = '8000'\n", "    protocol = 'http'\n", "    server_cls = WSGIServer\n"]}, {"span_id": "Command.run", "start_line": 103, "end_line": 110, "content": ["    def run(self, **options):\n", "        \"\"\"Run the server, using the autoreloader if needed.\"\"\"\n", "        use_reloader = options['use_reloader']\n", "\n", "        if use_reloader:\n", "            autoreload.run_with_reloader(self.inner_run, **options)\n", "        else:\n", "            self.inner_run(None, **options)\n"]}]}, {"file_path": "django/template/autoreload.py", "span_ids": ["get_template_directories"], "content": [{"span_id": "get_template_directories", "start_line": 12, "end_line": 32, "content": ["def get_template_directories():\n", "    # Iterate through each template backend and find\n", "    # any template_loader that has a 'get_dirs' method.\n", "    # Collect the directories, filtering out Django templates.\n", "    cwd = Path.cwd()\n", "    items = set()\n", "    for backend in engines.all():\n", "        if not isinstance(backend, DjangoTemplates):\n", "            continue\n", "\n", "        items.update(cwd / to_path(dir) for dir in backend.engine.dirs)\n", "\n", "        for loader in backend.engine.template_loaders:\n", "            if not hasattr(loader, 'get_dirs'):\n", "                continue\n", "            items.update(\n", "                cwd / to_path(directory)\n", "                for directory in loader.get_dirs()\n", "                if not is_django_path(directory)\n", "            )\n", "    return items\n"]}]}, {"file_path": "django/utils/autoreload.py", "span_ids": ["WatchmanReloader", "BaseReloader", "iter_modules_and_files", "get_reloader", "run_with_reloader", "iter_all_python_module_files", "StatReloader"], "content": [{"span_id": "WatchmanReloader", "start_line": 417, "end_line": 417, "content": ["class WatchmanReloader(BaseReloader):\n"]}, {"span_id": "BaseReloader", "start_line": 270, "end_line": 270, "content": ["class BaseReloader:\n"]}, {"span_id": "iter_modules_and_files", "start_line": 119, "end_line": 162, "content": ["@functools.lru_cache(maxsize=1)\n", "def iter_modules_and_files(modules, extra_files):\n", "    \"\"\"Iterate through all modules needed to be watched.\"\"\"\n", "    sys_file_paths = []\n", "    for module in modules:\n", "        # During debugging (with PyDev) the 'typing.io' and 'typing.re' objects\n", "        # are added to sys.modules, however they are types not modules and so\n", "        # cause issues here.\n", "        if not isinstance(module, ModuleType):\n", "            continue\n", "        if module.__name__ == '__main__':\n", "            # __main__ (usually manage.py) doesn't always have a __spec__ set.\n", "            # Handle this by falling back to using __file__, resolved below.\n", "            # See https://docs.python.org/reference/import.html#main-spec\n", "            # __file__ may not exists, e.g. when running ipdb debugger.\n", "            if hasattr(module, '__file__'):\n", "                sys_file_paths.append(module.__file__)\n", "            continue\n", "        if getattr(module, '__spec__', None) is None:\n", "            continue\n", "        spec = module.__spec__\n", "        # Modules could be loaded from places without a concrete location. If\n", "        # this is the case, skip them.\n", "        if spec.has_location:\n", "            origin = spec.loader.archive if isinstance(spec.loader, zipimporter) else spec.origin\n", "            sys_file_paths.append(origin)\n", "\n", "    results = set()\n", "    for filename in itertools.chain(sys_file_paths, extra_files):\n", "        if not filename:\n", "            continue\n", "        path = Path(filename)\n", "        try:\n", "            if not path.exists():\n", "                # The module could have been removed, don't fail loudly if this\n", "                # is the case.\n", "                continue\n", "        except ValueError as e:\n", "            # Network filesystems may return null bytes in file paths.\n", "            logger.debug('\"%s\" raised when resolving path: \"%s\"', e, path)\n", "            continue\n", "        resolved_path = path.resolve().absolute()\n", "        results.add(resolved_path)\n", "    return frozenset(results)\n"]}, {"span_id": "get_reloader", "start_line": 610, "end_line": 616, "content": ["def get_reloader():\n", "    \"\"\"Return the most suitable reloader for this environment.\"\"\"\n", "    try:\n", "        WatchmanReloader.check_availability()\n", "    except WatchmanUnavailable:\n", "        return StatReloader()\n", "    return WatchmanReloader()\n"]}, {"span_id": "run_with_reloader", "start_line": 638, "end_line": 649, "content": ["def run_with_reloader(main_func, *args, **kwargs):\n", "    signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))\n", "    try:\n", "        if os.environ.get(DJANGO_AUTORELOAD_ENV) == 'true':\n", "            reloader = get_reloader()\n", "            logger.info('Watching for file changes with %s', reloader.__class__.__name__)\n", "            start_django(reloader, main_func, *args, **kwargs)\n", "        else:\n", "            exit_code = restart_with_reloader()\n", "            sys.exit(exit_code)\n", "    except KeyboardInterrupt:\n", "        pass\n"]}, {"span_id": "iter_all_python_module_files", "start_line": 109, "end_line": 116, "content": ["def iter_all_python_module_files():\n", "    # This is a hot path during reloading. Create a stable sorted list of\n", "    # modules based on the module name and pass it to iter_modules_and_files().\n", "    # This ensures cached results are returned in the usual case that modules\n", "    # aren't loaded on the fly.\n", "    keys = sorted(sys.modules)\n", "    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not isinstance(m, weakref.ProxyTypes))\n", "    return iter_modules_and_files(modules, frozenset(_error_files))\n"]}, {"span_id": "StatReloader", "start_line": 375, "end_line": 376, "content": ["class StatReloader(BaseReloader):\n", "    SLEEP_TIME = 1  # Check for changes once per second.\n"]}]}]}