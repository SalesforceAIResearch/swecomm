{"instance_id": "django__django-11797", "identified_spans": [{"file_path": "django/db/models/expressions.py", "span_ids": ["Subquery"], "content": [{"span_id": "Subquery", "start_line": 1022, "end_line": 1028, "content": ["class Subquery(Expression):\n", "    \"\"\"\n", "    An explicit subquery. It may contain OuterRef() references to the outer\n", "    query which will be resolved when it is applied to that query.\n", "    \"\"\"\n", "    template = '(%(subquery)s)'\n", "    contains_aggregate = False\n"]}]}, {"file_path": "django/db/models/sql/compiler.py", "span_ids": ["SQLCompiler.collapse_group_by", "SQLCompiler.as_sql", "SQLCompiler.get_group_by"], "content": [{"span_id": "SQLCompiler.collapse_group_by", "start_line": 134, "end_line": 182, "content": ["    def collapse_group_by(self, expressions, having):\n", "        # If the DB can group by primary key, then group by the primary key of\n", "        # query's main model. Note that for PostgreSQL the GROUP BY clause must\n", "        # include the primary key of every table, but for MySQL it is enough to\n", "        # have the main table's primary key.\n", "        if self.connection.features.allows_group_by_pk:\n", "            # Determine if the main model's primary key is in the query.\n", "            pk = None\n", "            for expr in expressions:\n", "                # Is this a reference to query's base table primary key? If the\n", "                # expression isn't a Col-like, then skip the expression.\n", "                if (getattr(expr, 'target', None) == self.query.model._meta.pk and\n", "                        getattr(expr, 'alias', None) == self.query.base_table):\n", "                    pk = expr\n", "                    break\n", "            # If the main model's primary key is in the query, group by that\n", "            # field, HAVING expressions, and expressions associated with tables\n", "            # that don't have a primary key included in the grouped columns.\n", "            if pk:\n", "                pk_aliases = {\n", "                    expr.alias for expr in expressions\n", "                    if hasattr(expr, 'target') and expr.target.primary_key\n", "                }\n", "                expressions = [pk] + [\n", "                    expr for expr in expressions\n", "                    if expr in having or (\n", "                        getattr(expr, 'alias', None) is not None and expr.alias not in pk_aliases\n", "                    )\n", "                ]\n", "        elif self.connection.features.allows_group_by_selected_pks:\n", "            # Filter out all expressions associated with a table's primary key\n", "            # present in the grouped columns. This is done by identifying all\n", "            # tables that have their primary key included in the grouped\n", "            # columns and removing non-primary key columns referring to them.\n", "            # Unmanaged models are excluded because they could be representing\n", "            # database views on which the optimization might not be allowed.\n", "            pks = {\n", "                expr for expr in expressions\n", "                if (\n", "                    hasattr(expr, 'target') and\n", "                    expr.target.primary_key and\n", "                    self.connection.features.allows_group_by_selected_pks_on_model(expr.target.model)\n", "                )\n", "            }\n", "            aliases = {expr.alias for expr in pks}\n", "            expressions = [\n", "                expr for expr in expressions if expr in pks or getattr(expr, 'alias', None) not in aliases\n", "            ]\n", "        return expressions\n"]}, {"span_id": "SQLCompiler.as_sql", "start_line": 470, "end_line": 620, "content": ["    def as_sql(self, with_limits=True, with_col_aliases=False):\n", "        \"\"\"\n", "        Create the SQL for this query. Return the SQL string and list of\n", "        parameters.\n", "\n", "        If 'with_limits' is False, any limit/offset information is not included\n", "        in the query.\n", "        \"\"\"\n", "        refcounts_before = self.query.alias_refcount.copy()\n", "        try:\n", "            extra_select, order_by, group_by = self.pre_sql_setup()\n", "            for_update_part = None\n", "            # Is a LIMIT/OFFSET clause needed?\n", "            with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n", "            combinator = self.query.combinator\n", "            features = self.connection.features\n", "            if combinator:\n", "                if not getattr(features, 'supports_select_{}'.format(combinator)):\n", "                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n", "                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n", "            else:\n", "                distinct_fields, distinct_params = self.get_distinct()\n", "                # This must come after 'select', 'ordering', and 'distinct'\n", "                # (see docstring of get_from_clause() for details).\n", "                from_, f_params = self.get_from_clause()\n", "                where, w_params = self.compile(self.where) if self.where is not None else (\"\", [])\n", "                having, h_params = self.compile(self.having) if self.having is not None else (\"\", [])\n", "                result = ['SELECT']\n", "                params = []\n", "\n", "                if self.query.distinct:\n", "                    distinct_result, distinct_params = self.connection.ops.distinct_sql(\n", "                        distinct_fields,\n", "                        distinct_params,\n", "                    )\n", "                    result += distinct_result\n", "                    params += distinct_params\n", "\n", "                out_cols = []\n", "                col_idx = 1\n", "                for _, (s_sql, s_params), alias in self.select + extra_select:\n", "                    if alias:\n", "                        s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n", "                    elif with_col_aliases:\n", "                        s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)\n", "                        col_idx += 1\n", "                    params.extend(s_params)\n", "                    out_cols.append(s_sql)\n", "\n", "                result += [', '.join(out_cols), 'FROM', *from_]\n", "                params.extend(f_params)\n", "\n", "                if self.query.select_for_update and self.connection.features.has_select_for_update:\n", "                    if self.connection.get_autocommit():\n", "                        raise TransactionManagementError('select_for_update cannot be used outside of a transaction.')\n", "\n", "                    if with_limit_offset and not self.connection.features.supports_select_for_update_with_limit:\n", "                        raise NotSupportedError(\n", "                            'LIMIT/OFFSET is not supported with '\n", "                            'select_for_update on this database backend.'\n", "                        )\n", "                    nowait = self.query.select_for_update_nowait\n", "                    skip_locked = self.query.select_for_update_skip_locked\n", "                    of = self.query.select_for_update_of\n", "                    # If it's a NOWAIT/SKIP LOCKED/OF query but the backend\n", "                    # doesn't support it, raise NotSupportedError to prevent a\n", "                    # possible deadlock.\n", "                    if nowait and not self.connection.features.has_select_for_update_nowait:\n", "                        raise NotSupportedError('NOWAIT is not supported on this database backend.')\n", "                    elif skip_locked and not self.connection.features.has_select_for_update_skip_locked:\n", "                        raise NotSupportedError('SKIP LOCKED is not supported on this database backend.')\n", "                    elif of and not self.connection.features.has_select_for_update_of:\n", "                        raise NotSupportedError('FOR UPDATE OF is not supported on this database backend.')\n", "                    for_update_part = self.connection.ops.for_update_sql(\n", "                        nowait=nowait,\n", "                        skip_locked=skip_locked,\n", "                        of=self.get_select_for_update_of_arguments(),\n", "                    )\n", "\n", "                if for_update_part and self.connection.features.for_update_after_from:\n", "                    result.append(for_update_part)\n", "\n", "                if where:\n", "                    result.append('WHERE %s' % where)\n", "                    params.extend(w_params)\n", "\n", "                grouping = []\n", "                for g_sql, g_params in group_by:\n", "                    grouping.append(g_sql)\n", "                    params.extend(g_params)\n", "                if grouping:\n", "                    if distinct_fields:\n", "                        raise NotImplementedError('annotate() + distinct(fields) is not implemented.')\n", "                    order_by = order_by or self.connection.ops.force_no_ordering()\n", "                    result.append('GROUP BY %s' % ', '.join(grouping))\n", "                    if self._meta_ordering:\n", "                        order_by = None\n", "                if having:\n", "                    result.append('HAVING %s' % having)\n", "                    params.extend(h_params)\n", "\n", "            if self.query.explain_query:\n", "                result.insert(0, self.connection.ops.explain_query_prefix(\n", "                    self.query.explain_format,\n", "                    **self.query.explain_options\n", "                ))\n", "\n", "            if order_by:\n", "                ordering = []\n", "                for _, (o_sql, o_params, _) in order_by:\n", "                    ordering.append(o_sql)\n", "                    params.extend(o_params)\n", "                result.append('ORDER BY %s' % ', '.join(ordering))\n", "\n", "            if with_limit_offset:\n", "                result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))\n", "\n", "            if for_update_part and not self.connection.features.for_update_after_from:\n", "                result.append(for_update_part)\n", "\n", "            if self.query.subquery and extra_select:\n", "                # If the query is used as a subquery, the extra selects would\n", "                # result in more columns than the left-hand side expression is\n", "                # expecting. This can happen when a subquery uses a combination\n", "                # of order_by() and distinct(), forcing the ordering expressions\n", "                # to be selected as well. Wrap the query in another subquery\n", "                # to exclude extraneous selects.\n", "                sub_selects = []\n", "                sub_params = []\n", "                for index, (select, _, alias) in enumerate(self.select, start=1):\n", "                    if not alias and with_col_aliases:\n", "                        alias = 'col%d' % index\n", "                    if alias:\n", "                        sub_selects.append(\"%s.%s\" % (\n", "                            self.connection.ops.quote_name('subquery'),\n", "                            self.connection.ops.quote_name(alias),\n", "                        ))\n", "                    else:\n", "                        select_clone = select.relabeled_clone({select.alias: 'subquery'})\n", "                        subselect, subparams = select_clone.as_sql(self, self.connection)\n", "                        sub_selects.append(subselect)\n", "                        sub_params.extend(subparams)\n", "                return 'SELECT %s FROM (%s) subquery' % (\n", "                    ', '.join(sub_selects),\n", "                    ' '.join(result),\n", "                ), tuple(sub_params + params)\n", "\n", "            return ' '.join(result), tuple(params)\n", "        finally:\n", "            # Finally do cleanup - get rid of the joins we created above.\n", "            self.query.reset_refcounts(refcounts_before)\n"]}, {"span_id": "SQLCompiler.get_group_by", "start_line": 56, "end_line": 132, "content": ["    def get_group_by(self, select, order_by):\n", "        \"\"\"\n", "        Return a list of 2-tuples of form (sql, params).\n", "\n", "        The logic of what exactly the GROUP BY clause contains is hard\n", "        to describe in other words than \"if it passes the test suite,\n", "        then it is correct\".\n", "        \"\"\"\n", "        # Some examples:\n", "        #     SomeModel.objects.annotate(Count('somecol'))\n", "        #     GROUP BY: all fields of the model\n", "        #\n", "        #    SomeModel.objects.values('name').annotate(Count('somecol'))\n", "        #    GROUP BY: name\n", "        #\n", "        #    SomeModel.objects.annotate(Count('somecol')).values('name')\n", "        #    GROUP BY: all cols of the model\n", "        #\n", "        #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n", "        #    GROUP BY: name, pk\n", "        #\n", "        #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n", "        #    GROUP BY: name, pk\n", "        #\n", "        # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n", "        # can't be ever restricted to a smaller set, but additional columns in\n", "        # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n", "        # the end result is that it is impossible to force the query to have\n", "        # a chosen GROUP BY clause - you can almost do this by using the form:\n", "        #     .values(*wanted_cols).annotate(AnAggregate())\n", "        # but any later annotations, extra selects, values calls that\n", "        # refer some column outside of the wanted_cols, order_by, or even\n", "        # filter calls can alter the GROUP BY clause.\n", "\n", "        # The query.group_by is either None (no GROUP BY at all), True\n", "        # (group by select fields), or a list of expressions to be added\n", "        # to the group by.\n", "        if self.query.group_by is None:\n", "            return []\n", "        expressions = []\n", "        if self.query.group_by is not True:\n", "            # If the group by is set to a list (by .values() call most likely),\n", "            # then we need to add everything in it to the GROUP BY clause.\n", "            # Backwards compatibility hack for setting query.group_by. Remove\n", "            # when  we have public API way of forcing the GROUP BY clause.\n", "            # Converts string references to expressions.\n", "            for expr in self.query.group_by:\n", "                if not hasattr(expr, 'as_sql'):\n", "                    expressions.append(self.query.resolve_ref(expr))\n", "                else:\n", "                    expressions.append(expr)\n", "        # Note that even if the group_by is set, it is only the minimal\n", "        # set to group by. So, we need to add cols in select, order_by, and\n", "        # having into the select in any case.\n", "        for expr, _, _ in select:\n", "            cols = expr.get_group_by_cols()\n", "            for col in cols:\n", "                expressions.append(col)\n", "        for expr, (sql, params, is_ref) in order_by:\n", "            # Skip References to the select clause, as all expressions in the\n", "            # select clause are already part of the group by.\n", "            if not expr.contains_aggregate and not is_ref:\n", "                expressions.extend(expr.get_source_expressions())\n", "        having_group_by = self.having.get_group_by_cols() if self.having else ()\n", "        for expr in having_group_by:\n", "            expressions.append(expr)\n", "        result = []\n", "        seen = set()\n", "        expressions = self.collapse_group_by(expressions, having_group_by)\n", "\n", "        for expr in expressions:\n", "            sql, params = self.compile(expr)\n", "            params_hash = make_hashable(params)\n", "            if (sql, params_hash) not in seen:\n", "                result.append((sql, params))\n", "                seen.add((sql, params_hash))\n", "        return result\n"]}]}, {"file_path": "django/db/models/sql/query.py", "span_ids": ["Query.set_group_by"], "content": [{"span_id": "Query.set_group_by", "start_line": 1911, "end_line": 1936, "content": ["    def set_group_by(self):\n", "        \"\"\"\n", "        Expand the GROUP BY clause required by the query.\n", "\n", "        This will usually be the set of all non-aggregate fields in the\n", "        return data. If the database backend supports grouping by the\n", "        primary key, and the query would be equivalent, the optimization\n", "        will be made automatically.\n", "        \"\"\"\n", "        group_by = list(self.select)\n", "        if self.annotation_select:\n", "            for alias, annotation in self.annotation_select.items():\n", "                try:\n", "                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)\n", "                except TypeError:\n", "                    annotation_class = annotation.__class__\n", "                    msg = (\n", "                        '`alias=None` must be added to the signature of '\n", "                        '%s.%s.get_group_by_cols().'\n", "                    ) % (annotation_class.__module__, annotation_class.__qualname__)\n", "                    warnings.warn(msg, category=RemovedInDjango40Warning)\n", "                    group_by_cols = annotation.get_group_by_cols()\n", "                else:\n", "                    group_by_cols = annotation.get_group_by_cols(alias=alias)\n", "                group_by.extend(group_by_cols)\n", "        self.group_by = tuple(group_by)\n"]}]}]}