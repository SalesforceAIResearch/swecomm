{"instance_id": "django__django-15498", "identified_spans": [{"file_path": "django/utils/cache.py", "span_ids": ["get_conditional_response"], "content": [{"span_id": "get_conditional_response", "start_line": 165, "end_line": 210, "content": ["def get_conditional_response(request, etag=None, last_modified=None, response=None):\n", "    # Only return conditional responses on successful requests.\n", "    if response and not (200 <= response.status_code < 300):\n", "        return response\n", "\n", "    # Get HTTP request headers.\n", "    if_match_etags = parse_etags(request.META.get(\"HTTP_IF_MATCH\", \"\"))\n", "    if_unmodified_since = request.META.get(\"HTTP_IF_UNMODIFIED_SINCE\")\n", "    if_unmodified_since = if_unmodified_since and parse_http_date_safe(\n", "        if_unmodified_since\n", "    )\n", "    if_none_match_etags = parse_etags(request.META.get(\"HTTP_IF_NONE_MATCH\", \"\"))\n", "    if_modified_since = request.META.get(\"HTTP_IF_MODIFIED_SINCE\")\n", "    if_modified_since = if_modified_since and parse_http_date_safe(if_modified_since)\n", "\n", "    # Step 1 of section 6 of RFC 7232: Test the If-Match precondition.\n", "    if if_match_etags and not _if_match_passes(etag, if_match_etags):\n", "        return _precondition_failed(request)\n", "\n", "    # Step 2: Test the If-Unmodified-Since precondition.\n", "    if (\n", "        not if_match_etags\n", "        and if_unmodified_since\n", "        and not _if_unmodified_since_passes(last_modified, if_unmodified_since)\n", "    ):\n", "        return _precondition_failed(request)\n", "\n", "    # Step 3: Test the If-None-Match precondition.\n", "    if if_none_match_etags and not _if_none_match_passes(etag, if_none_match_etags):\n", "        if request.method in (\"GET\", \"HEAD\"):\n", "            return _not_modified(request, response)\n", "        else:\n", "            return _precondition_failed(request)\n", "\n", "    # Step 4: Test the If-Modified-Since precondition.\n", "    if (\n", "        not if_none_match_etags\n", "        and if_modified_since\n", "        and not _if_modified_since_passes(last_modified, if_modified_since)\n", "        and request.method in (\"GET\", \"HEAD\")\n", "    ):\n", "        return _not_modified(request, response)\n", "\n", "    # Step 5: Test the If-Range precondition (not supported).\n", "    # Step 6: Return original response since there isn't a conditional response.\n", "    return response\n"]}]}, {"file_path": "django/utils/http.py", "span_ids": ["parse_http_date", "parse_http_date_safe"], "content": [{"span_id": "parse_http_date", "start_line": 104, "end_line": 142, "content": ["def parse_http_date(date):\n", "    \"\"\"\n", "    Parse a date format as specified by HTTP RFC7231 section 7.1.1.1.\n", "\n", "    The three formats allowed by the RFC are accepted, even if only the first\n", "    one is still in widespread use.\n", "\n", "    Return an integer expressed in seconds since the epoch, in UTC.\n", "    \"\"\"\n", "    # email.utils.parsedate() does the job for RFC1123 dates; unfortunately\n", "    # RFC7231 makes it mandatory to support RFC850 dates too. So we roll\n", "    # our own RFC-compliant parsing.\n", "    for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:\n", "        m = regex.match(date)\n", "        if m is not None:\n", "            break\n", "    else:\n", "        raise ValueError(\"%r is not in a valid HTTP date format\" % date)\n", "    try:\n", "        tz = datetime.timezone.utc\n", "        year = int(m[\"year\"])\n", "        if year < 100:\n", "            current_year = datetime.datetime.now(tz=tz).year\n", "            current_century = current_year - (current_year % 100)\n", "            if year - (current_year % 100) > 50:\n", "                # year that appears to be more than 50 years in the future are\n", "                # interpreted as representing the past.\n", "                year += current_century - 100\n", "            else:\n", "                year += current_century\n", "        month = MONTHS.index(m[\"mon\"].lower()) + 1\n", "        day = int(m[\"day\"])\n", "        hour = int(m[\"hour\"])\n", "        min = int(m[\"min\"])\n", "        sec = int(m[\"sec\"])\n", "        result = datetime.datetime(year, month, day, hour, min, sec, tzinfo=tz)\n", "        return int(result.timestamp())\n", "    except Exception as exc:\n", "        raise ValueError(\"%r is not a valid date\" % date) from exc\n"]}, {"span_id": "parse_http_date_safe", "start_line": 145, "end_line": 152, "content": ["def parse_http_date_safe(date):\n", "    \"\"\"\n", "    Same as parse_http_date, but return None if the input is invalid.\n", "    \"\"\"\n", "    try:\n", "        return parse_http_date(date)\n", "    except Exception:\n", "        pass\n"]}]}]}