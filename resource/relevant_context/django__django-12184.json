{"instance_id": "django__django-12184", "identified_spans": [{"file_path": "django/urls/resolvers.py", "span_ids": ["URLPattern.__init__", "ResolverMatch.__init__", "ResolverMatch", "URLResolver.__init__", "URLPattern.resolve", "URLResolver.resolve", "URLResolver", "URLPattern"], "content": [{"span_id": "URLPattern.__init__", "start_line": 323, "end_line": 327, "content": ["    def __init__(self, pattern, callback, default_args=None, name=None):\n", "        self.pattern = pattern\n", "        self.callback = callback  # the view\n", "        self.default_args = default_args or {}\n", "        self.name = name\n"]}, {"span_id": "ResolverMatch.__init__", "start_line": 33, "end_line": 55, "content": ["    def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None):\n", "        self.func = func\n", "        self.args = args\n", "        self.kwargs = kwargs\n", "        self.url_name = url_name\n", "        self.route = route\n", "\n", "        # If a URLRegexResolver doesn't have a namespace or app_name, it passes\n", "        # in an empty value.\n", "        self.app_names = [x for x in app_names if x] if app_names else []\n", "        self.app_name = ':'.join(self.app_names)\n", "        self.namespaces = [x for x in namespaces if x] if namespaces else []\n", "        self.namespace = ':'.join(self.namespaces)\n", "\n", "        if not hasattr(func, '__name__'):\n", "            # A class-based view\n", "            self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n", "        else:\n", "            # A function-based view\n", "            self._func_path = func.__module__ + '.' + func.__name__\n", "\n", "        view_path = url_name or self._func_path\n", "        self.view_name = ':'.join(self.namespaces + [view_path])\n"]}, {"span_id": "ResolverMatch", "start_line": 32, "end_line": 32, "content": ["class ResolverMatch:\n"]}, {"span_id": "URLResolver.__init__", "start_line": 374, "end_line": 391, "content": ["    def __init__(self, pattern, urlconf_name, default_kwargs=None, app_name=None, namespace=None):\n", "        self.pattern = pattern\n", "        # urlconf_name is the dotted Python path to the module defining\n", "        # urlpatterns. It may also be an object with an urlpatterns attribute\n", "        # or urlpatterns itself.\n", "        self.urlconf_name = urlconf_name\n", "        self.callback = None\n", "        self.default_kwargs = default_kwargs or {}\n", "        self.namespace = namespace\n", "        self.app_name = app_name\n", "        self._reverse_dict = {}\n", "        self._namespace_dict = {}\n", "        self._app_dict = {}\n", "        # set of dotted paths to all functions and classes that are used in\n", "        # urlpatterns\n", "        self._callback_strs = set()\n", "        self._populated = False\n", "        self._local = Local()\n"]}, {"span_id": "URLPattern.resolve", "start_line": 351, "end_line": 357, "content": ["    def resolve(self, path):\n", "        match = self.pattern.match(path)\n", "        if match:\n", "            new_path, args, kwargs = match\n", "            # Pass any extra_kwargs as **kwargs.\n", "            kwargs.update(self.default_args)\n", "            return ResolverMatch(self.callback, args, kwargs, self.pattern.name, route=str(self.pattern))\n"]}, {"span_id": "URLResolver.resolve", "start_line": 537, "end_line": 575, "content": ["    def resolve(self, path):\n", "        path = str(path)  # path may be a reverse_lazy object\n", "        tried = []\n", "        match = self.pattern.match(path)\n", "        if match:\n", "            new_path, args, kwargs = match\n", "            for pattern in self.url_patterns:\n", "                try:\n", "                    sub_match = pattern.resolve(new_path)\n", "                except Resolver404 as e:\n", "                    sub_tried = e.args[0].get('tried')\n", "                    if sub_tried is not None:\n", "                        tried.extend([pattern] + t for t in sub_tried)\n", "                    else:\n", "                        tried.append([pattern])\n", "                else:\n", "                    if sub_match:\n", "                        # Merge captured arguments in match with submatch\n", "                        sub_match_dict = {**kwargs, **self.default_kwargs}\n", "                        # Update the sub_match_dict with the kwargs from the sub_match.\n", "                        sub_match_dict.update(sub_match.kwargs)\n", "                        # If there are *any* named groups, ignore all non-named groups.\n", "                        # Otherwise, pass all non-named arguments as positional arguments.\n", "                        sub_match_args = sub_match.args\n", "                        if not sub_match_dict:\n", "                            sub_match_args = args + sub_match.args\n", "                        current_route = '' if isinstance(pattern, URLPattern) else str(pattern.pattern)\n", "                        return ResolverMatch(\n", "                            sub_match.func,\n", "                            sub_match_args,\n", "                            sub_match_dict,\n", "                            sub_match.url_name,\n", "                            [self.app_name] + sub_match.app_names,\n", "                            [self.namespace] + sub_match.namespaces,\n", "                            self._join_route(current_route, sub_match.route),\n", "                        )\n", "                    tried.append([pattern])\n", "            raise Resolver404({'tried': tried, 'path': new_path})\n", "        raise Resolver404({'path': path})\n"]}, {"span_id": "URLResolver", "start_line": 373, "end_line": 373, "content": ["class URLResolver:\n"]}, {"span_id": "URLPattern", "start_line": 322, "end_line": 322, "content": ["class URLPattern:\n"]}]}]}