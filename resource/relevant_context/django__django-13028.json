{"instance_id": "django__django-13028", "identified_spans": [{"file_path": "django/db/models/sql/query.py", "span_ids": ["Query.check_filterable", "Query.build_filter"], "content": [{"span_id": "Query.check_filterable", "start_line": 1125, "end_line": 1134, "content": ["    def check_filterable(self, expression):\n", "        \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\n", "        if not getattr(expression, 'filterable', True):\n", "            raise NotSupportedError(\n", "                expression.__class__.__name__ + ' is disallowed in the filter '\n", "                'clause.'\n", "            )\n", "        if hasattr(expression, 'get_source_expressions'):\n", "            for expr in expression.get_source_expressions():\n", "                self.check_filterable(expr)\n"]}, {"span_id": "Query.build_filter", "start_line": 1201, "end_line": 1339, "content": ["    def build_filter(self, filter_expr, branch_negated=False, current_negated=False,\n", "                     can_reuse=None, allow_joins=True, split_subq=True,\n", "                     reuse_with_filtered_relation=False, check_filterable=True):\n", "        \"\"\"\n", "        Build a WhereNode for a single filter clause but don't add it\n", "        to this Query. Query.add_q() will then add this filter to the where\n", "        Node.\n", "\n", "        The 'branch_negated' tells us if the current branch contains any\n", "        negations. This will be used to determine if subqueries are needed.\n", "\n", "        The 'current_negated' is used to determine if the current filter is\n", "        negated or not and this will be used to determine if IS NULL filtering\n", "        is needed.\n", "\n", "        The difference between current_negated and branch_negated is that\n", "        branch_negated is set on first negation, but current_negated is\n", "        flipped for each negation.\n", "\n", "        Note that add_filter will not do any negating itself, that is done\n", "        upper in the code by add_q().\n", "\n", "        The 'can_reuse' is a set of reusable joins for multijoins.\n", "\n", "        If 'reuse_with_filtered_relation' is True, then only joins in can_reuse\n", "        will be reused.\n", "\n", "        The method will create a filter clause that can be added to the current\n", "        query. However, if the filter isn't added to the query then the caller\n", "        is responsible for unreffing the joins used.\n", "        \"\"\"\n", "        if isinstance(filter_expr, dict):\n", "            raise FieldError(\"Cannot parse keyword query as dict\")\n", "        if isinstance(filter_expr, Q):\n", "            return self._add_q(\n", "                filter_expr,\n", "                branch_negated=branch_negated,\n", "                current_negated=current_negated,\n", "                used_aliases=can_reuse,\n", "                allow_joins=allow_joins,\n", "                split_subq=split_subq,\n", "                check_filterable=check_filterable,\n", "            )\n", "        if hasattr(filter_expr, 'resolve_expression'):\n", "            if not getattr(filter_expr, 'conditional', False):\n", "                raise TypeError('Cannot filter against a non-conditional expression.')\n", "            condition = self.build_lookup(\n", "                ['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True\n", "            )\n", "            clause = self.where_class()\n", "            clause.add(condition, AND)\n", "            return clause, []\n", "        arg, value = filter_expr\n", "        if not arg:\n", "            raise FieldError(\"Cannot parse keyword query %r\" % arg)\n", "        lookups, parts, reffed_expression = self.solve_lookup_type(arg)\n", "\n", "        if check_filterable:\n", "            self.check_filterable(reffed_expression)\n", "\n", "        if not allow_joins and len(parts) > 1:\n", "            raise FieldError(\"Joined field references are not permitted in this query\")\n", "\n", "        pre_joins = self.alias_refcount.copy()\n", "        value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n", "        used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n", "\n", "        if check_filterable:\n", "            self.check_filterable(value)\n", "\n", "        clause = self.where_class()\n", "        if reffed_expression:\n", "            condition = self.build_lookup(lookups, reffed_expression, value)\n", "            clause.add(condition, AND)\n", "            return clause, []\n", "\n", "        opts = self.get_meta()\n", "        alias = self.get_initial_alias()\n", "        allow_many = not branch_negated or not split_subq\n", "\n", "        try:\n", "            join_info = self.setup_joins(\n", "                parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,\n", "                reuse_with_filtered_relation=reuse_with_filtered_relation,\n", "            )\n", "\n", "            # Prevent iterator from being consumed by check_related_objects()\n", "            if isinstance(value, Iterator):\n", "                value = list(value)\n", "            self.check_related_objects(join_info.final_field, value, join_info.opts)\n", "\n", "            # split_exclude() needs to know which joins were generated for the\n", "            # lookup parts\n", "            self._lookup_joins = join_info.joins\n", "        except MultiJoin as e:\n", "            return self.split_exclude(filter_expr, can_reuse, e.names_with_path)\n", "\n", "        # Update used_joins before trimming since they are reused to determine\n", "        # which joins could be later promoted to INNER.\n", "        used_joins.update(join_info.joins)\n", "        targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)\n", "        if can_reuse is not None:\n", "            can_reuse.update(join_list)\n", "\n", "        if join_info.final_field.is_relation:\n", "            # No support for transforms for relational fields\n", "            num_lookups = len(lookups)\n", "            if num_lookups > 1:\n", "                raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))\n", "            if len(targets) == 1:\n", "                col = self._get_col(targets[0], join_info.final_field, alias)\n", "            else:\n", "                col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)\n", "        else:\n", "            col = self._get_col(targets[0], join_info.final_field, alias)\n", "\n", "        condition = self.build_lookup(lookups, col, value)\n", "        lookup_type = condition.lookup_name\n", "        clause.add(condition, AND)\n", "\n", "        require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated\n", "        if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:\n", "            require_outer = True\n", "            if (lookup_type != 'isnull' and (\n", "                    self.is_nullable(targets[0]) or\n", "                    self.alias_map[join_list[-1]].join_type == LOUTER)):\n", "                # The condition added here will be SQL like this:\n", "                # NOT (col IS NOT NULL), where the first NOT is added in\n", "                # upper layers of code. The reason for addition is that if col\n", "                # is null, then col != someval will result in SQL \"unknown\"\n", "                # which isn't the same as in Python. The Python None handling\n", "                # is wanted, and it can be gotten by\n", "                # (col IS NULL OR col != someval)\n", "                #   <=>\n", "                # NOT (col IS NOT NULL AND col = someval).\n", "                lookup_class = targets[0].get_lookup('isnull')\n", "                col = self._get_col(targets[0], join_info.targets[0], alias)\n", "                clause.add(lookup_class(col, False), AND)\n", "        return clause, used_joins if not require_outer else ()\n"]}]}]}