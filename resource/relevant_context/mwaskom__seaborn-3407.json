{"instance_id": "mwaskom__seaborn-3407", "identified_spans": [{"file_path": "seaborn/axisgrid.py", "span_ids": ["pairplot"], "content": [{"span_id": "pairplot", "start_line": 2005, "end_line": 2176, "content": ["def pairplot(\n", "    data, *,\n", "    hue=None, hue_order=None, palette=None,\n", "    vars=None, x_vars=None, y_vars=None,\n", "    kind=\"scatter\", diag_kind=\"auto\", markers=None,\n", "    height=2.5, aspect=1, corner=False, dropna=False,\n", "    plot_kws=None, diag_kws=None, grid_kws=None, size=None,\n", "):\n", "    \"\"\"Plot pairwise relationships in a dataset.\n", "\n", "    By default, this function will create a grid of Axes such that each numeric\n", "    variable in ``data`` will by shared across the y-axes across a single row and\n", "    the x-axes across a single column. The diagonal plots are treated\n", "    differently: a univariate distribution plot is drawn to show the marginal\n", "    distribution of the data in each column.\n", "\n", "    It is also possible to show a subset of variables or plot different\n", "    variables on the rows and columns.\n", "\n", "    This is a high-level interface for :class:`PairGrid` that is intended to\n", "    make it easy to draw a few common styles. You should use :class:`PairGrid`\n", "    directly if you need more flexibility.\n", "\n", "    Parameters\n", "    ----------\n", "    data : `pandas.DataFrame`\n", "        Tidy (long-form) dataframe where each column is a variable and\n", "        each row is an observation.\n", "    hue : name of variable in ``data``\n", "        Variable in ``data`` to map plot aspects to different colors.\n", "    hue_order : list of strings\n", "        Order for the levels of the hue variable in the palette\n", "    palette : dict or seaborn color palette\n", "        Set of colors for mapping the ``hue`` variable. If a dict, keys\n", "        should be values  in the ``hue`` variable.\n", "    vars : list of variable names\n", "        Variables within ``data`` to use, otherwise use every column with\n", "        a numeric datatype.\n", "    {x, y}_vars : lists of variable names\n", "        Variables within ``data`` to use separately for the rows and\n", "        columns of the figure; i.e. to make a non-square plot.\n", "    kind : {'scatter', 'kde', 'hist', 'reg'}\n", "        Kind of plot to make.\n", "    diag_kind : {'auto', 'hist', 'kde', None}\n", "        Kind of plot for the diagonal subplots. If 'auto', choose based on\n", "        whether or not ``hue`` is used.\n", "    markers : single matplotlib marker code or list\n", "        Either the marker to use for all scatterplot points or a list of markers\n", "        with a length the same as the number of levels in the hue variable so that\n", "        differently colored points will also have different scatterplot\n", "        markers.\n", "    height : scalar\n", "        Height (in inches) of each facet.\n", "    aspect : scalar\n", "        Aspect * height gives the width (in inches) of each facet.\n", "    corner : bool\n", "        If True, don't add axes to the upper (off-diagonal) triangle of the\n", "        grid, making this a \"corner\" plot.\n", "    dropna : boolean\n", "        Drop missing values from the data before plotting.\n", "    {plot, diag, grid}_kws : dicts\n", "        Dictionaries of keyword arguments. ``plot_kws`` are passed to the\n", "        bivariate plotting function, ``diag_kws`` are passed to the univariate\n", "        plotting function, and ``grid_kws`` are passed to the :class:`PairGrid`\n", "        constructor.\n", "\n", "    Returns\n", "    -------\n", "    grid : :class:`PairGrid`\n", "        Returns the underlying :class:`PairGrid` instance for further tweaking.\n", "\n", "    See Also\n", "    --------\n", "    PairGrid : Subplot grid for more flexible plotting of pairwise relationships.\n", "    JointGrid : Grid for plotting joint and marginal distributions of two variables.\n", "\n", "    Examples\n", "    --------\n", "\n", "    .. include:: ../docstrings/pairplot.rst\n", "\n", "    \"\"\"\n", "    # Avoid circular import\n", "    from .distributions import histplot, kdeplot\n", "\n", "    # Handle deprecations\n", "    if size is not None:\n", "        height = size\n", "        msg = (\"The `size` parameter has been renamed to `height`; \"\n", "               \"please update your code.\")\n", "        warnings.warn(msg, UserWarning)\n", "\n", "    if not isinstance(data, pd.DataFrame):\n", "        raise TypeError(\n", "            f\"'data' must be pandas DataFrame object, not: {type(data)}\")\n", "\n", "    plot_kws = {} if plot_kws is None else plot_kws.copy()\n", "    diag_kws = {} if diag_kws is None else diag_kws.copy()\n", "    grid_kws = {} if grid_kws is None else grid_kws.copy()\n", "\n", "    # Resolve \"auto\" diag kind\n", "    if diag_kind == \"auto\":\n", "        if hue is None:\n", "            diag_kind = \"kde\" if kind == \"kde\" else \"hist\"\n", "        else:\n", "            diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n", "\n", "    # Set up the PairGrid\n", "    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n", "    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n", "                    hue_order=hue_order, palette=palette, corner=corner,\n", "                    height=height, aspect=aspect, dropna=dropna, **grid_kws)\n", "\n", "    # Add the markers here as PairGrid has figured out how many levels of the\n", "    # hue variable are needed and we don't want to duplicate that process\n", "    if markers is not None:\n", "        if kind == \"reg\":\n", "            # Needed until regplot supports style\n", "            if grid.hue_names is None:\n", "                n_markers = 1\n", "            else:\n", "                n_markers = len(grid.hue_names)\n", "            if not isinstance(markers, list):\n", "                markers = [markers] * n_markers\n", "            if len(markers) != n_markers:\n", "                raise ValueError(\"markers must be a singleton or a list of \"\n", "                                 \"markers for each level of the hue variable\")\n", "            grid.hue_kws = {\"marker\": markers}\n", "        elif kind == \"scatter\":\n", "            if isinstance(markers, str):\n", "                plot_kws[\"marker\"] = markers\n", "            elif hue is not None:\n", "                plot_kws[\"style\"] = data[hue]\n", "                plot_kws[\"markers\"] = markers\n", "\n", "    # Draw the marginal plots on the diagonal\n", "    diag_kws = diag_kws.copy()\n", "    diag_kws.setdefault(\"legend\", False)\n", "    if diag_kind == \"hist\":\n", "        grid.map_diag(histplot, **diag_kws)\n", "    elif diag_kind == \"kde\":\n", "        diag_kws.setdefault(\"fill\", True)\n", "        diag_kws.setdefault(\"warn_singular\", False)\n", "        grid.map_diag(kdeplot, **diag_kws)\n", "\n", "    # Maybe plot on the off-diagonals\n", "    if diag_kind is not None:\n", "        plotter = grid.map_offdiag\n", "    else:\n", "        plotter = grid.map\n", "\n", "    if kind == \"scatter\":\n", "        from .relational import scatterplot  # Avoid circular import\n", "        plotter(scatterplot, **plot_kws)\n", "    elif kind == \"reg\":\n", "        from .regression import regplot  # Avoid circular import\n", "        plotter(regplot, **plot_kws)\n", "    elif kind == \"kde\":\n", "        from .distributions import kdeplot  # Avoid circular import\n", "        plot_kws.setdefault(\"warn_singular\", False)\n", "        plotter(kdeplot, **plot_kws)\n", "    elif kind == \"hist\":\n", "        from .distributions import histplot  # Avoid circular import\n", "        plotter(histplot, **plot_kws)\n", "\n", "    # Add a legend\n", "    if hue is not None:\n", "        grid.add_legend()\n", "\n", "    grid.tight_layout()\n", "\n", "    return grid\n"]}]}]}