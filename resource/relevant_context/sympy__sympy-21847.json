{"instance_id": "sympy__sympy-21847", "identified_spans": [{"file_path": "sympy/polys/monomials.py", "span_ids": ["itermonomials"], "content": [{"span_id": "itermonomials", "start_line": 14, "end_line": 152, "content": ["@public\n", "def itermonomials(variables, max_degrees, min_degrees=None):\n", "    r\"\"\"\n", "    ``max_degrees`` and ``min_degrees`` are either both integers or both lists.\n", "    Unless otherwise specified, ``min_degrees`` is either ``0`` or\n", "    ``[0, ..., 0]``.\n", "\n", "    A generator of all monomials ``monom`` is returned, such that\n", "    either\n", "    ``min_degree <= total_degree(monom) <= max_degree``,\n", "    or\n", "    ``min_degrees[i] <= degree_list(monom)[i] <= max_degrees[i]``,\n", "    for all ``i``.\n", "\n", "    Case I. ``max_degrees`` and ``min_degrees`` are both integers\n", "    =============================================================\n", "\n", "    Given a set of variables $V$ and a min_degree $N$ and a max_degree $M$\n", "    generate a set of monomials of degree less than or equal to $N$ and greater\n", "    than or equal to $M$. The total number of monomials in commutative\n", "    variables is huge and is given by the following formula if $M = 0$:\n", "\n", "        .. math::\n", "            \\frac{(\\#V + N)!}{\\#V! N!}\n", "\n", "    For example if we would like to generate a dense polynomial of\n", "    a total degree $N = 50$ and $M = 0$, which is the worst case, in 5\n", "    variables, assuming that exponents and all of coefficients are 32-bit long\n", "    and stored in an array we would need almost 80 GiB of memory! Fortunately\n", "    most polynomials, that we will encounter, are sparse.\n", "\n", "    Consider monomials in commutative variables $x$ and $y$\n", "    and non-commutative variables $a$ and $b$::\n", "\n", "        >>> from sympy import symbols\n", "        >>> from sympy.polys.monomials import itermonomials\n", "        >>> from sympy.polys.orderings import monomial_key\n", "        >>> from sympy.abc import x, y\n", "\n", "        >>> sorted(itermonomials([x, y], 2), key=monomial_key('grlex', [y, x]))\n", "        [1, x, y, x**2, x*y, y**2]\n", "\n", "        >>> sorted(itermonomials([x, y], 3), key=monomial_key('grlex', [y, x]))\n", "        [1, x, y, x**2, x*y, y**2, x**3, x**2*y, x*y**2, y**3]\n", "\n", "        >>> a, b = symbols('a, b', commutative=False)\n", "        >>> set(itermonomials([a, b, x], 2))\n", "        {1, a, a**2, b, b**2, x, x**2, a*b, b*a, x*a, x*b}\n", "\n", "        >>> sorted(itermonomials([x, y], 2, 1), key=monomial_key('grlex', [y, x]))\n", "        [x, y, x**2, x*y, y**2]\n", "\n", "    Case II. ``max_degrees`` and ``min_degrees`` are both lists\n", "    ===========================================================\n", "\n", "    If ``max_degrees = [d_1, ..., d_n]`` and\n", "    ``min_degrees = [e_1, ..., e_n]``, the number of monomials generated\n", "    is:\n", "\n", "    .. math::\n", "        (d_1 - e_1 + 1) (d_2 - e_2 + 1) \\cdots (d_n - e_n + 1)\n", "\n", "    Let us generate all monomials ``monom`` in variables $x$ and $y$\n", "    such that ``[1, 2][i] <= degree_list(monom)[i] <= [2, 4][i]``,\n", "    ``i = 0, 1`` ::\n", "\n", "        >>> from sympy import symbols\n", "        >>> from sympy.polys.monomials import itermonomials\n", "        >>> from sympy.polys.orderings import monomial_key\n", "        >>> from sympy.abc import x, y\n", "\n", "        >>> sorted(itermonomials([x, y], [2, 4], [1, 2]), reverse=True, key=monomial_key('lex', [x, y]))\n", "        [x**2*y**4, x**2*y**3, x**2*y**2, x*y**4, x*y**3, x*y**2]\n", "    \"\"\"\n", "    n = len(variables)\n", "    if is_sequence(max_degrees):\n", "        if len(max_degrees) != n:\n", "            raise ValueError('Argument sizes do not match')\n", "        if min_degrees is None:\n", "            min_degrees = [0]*n\n", "        elif not is_sequence(min_degrees):\n", "            raise ValueError('min_degrees is not a list')\n", "        else:\n", "            if len(min_degrees) != n:\n", "                raise ValueError('Argument sizes do not match')\n", "            if any(i < 0 for i in min_degrees):\n", "                raise ValueError(\"min_degrees can't contain negative numbers\")\n", "        total_degree = False\n", "    else:\n", "        max_degree = max_degrees\n", "        if max_degree < 0:\n", "            raise ValueError(\"max_degrees can't be negative\")\n", "        if min_degrees is None:\n", "            min_degree = 0\n", "        else:\n", "            if min_degrees < 0:\n", "                raise ValueError(\"min_degrees can't be negative\")\n", "            min_degree = min_degrees\n", "        total_degree = True\n", "    if total_degree:\n", "        if min_degree > max_degree:\n", "            return\n", "        if not variables or max_degree == 0:\n", "            yield S.One\n", "            return\n", "        # Force to list in case of passed tuple or other incompatible collection\n", "        variables = list(variables) + [S.One]\n", "        if all(variable.is_commutative for variable in variables):\n", "            monomials_list_comm = []\n", "            for item in combinations_with_replacement(variables, max_degree):\n", "                powers = dict()\n", "                for variable in variables:\n", "                    powers[variable] = 0\n", "                for variable in item:\n", "                    if variable != 1:\n", "                        powers[variable] += 1\n", "                if max(powers.values()) >= min_degree:\n", "                    monomials_list_comm.append(Mul(*item))\n", "            yield from set(monomials_list_comm)\n", "        else:\n", "            monomials_list_non_comm = []\n", "            for item in product(variables, repeat=max_degree):\n", "                powers = dict()\n", "                for variable in variables:\n", "                    powers[variable] = 0\n", "                for variable in item:\n", "                    if variable != 1:\n", "                        powers[variable] += 1\n", "                if max(powers.values()) >= min_degree:\n", "                    monomials_list_non_comm.append(Mul(*item))\n", "            yield from set(monomials_list_non_comm)\n", "    else:\n", "        if any(min_degrees[i] > max_degrees[i] for i in range(n)):\n", "            raise ValueError('min_degrees[i] must be <= max_degrees[i] for all i')\n", "        power_lists = []\n", "        for var, min_d, max_d in zip(variables, min_degrees, max_degrees):\n", "            power_lists.append([var**i for i in range(min_d, max_d + 1)])\n", "        for powers in product(*power_lists):\n", "            yield Mul(*powers)\n"]}]}]}