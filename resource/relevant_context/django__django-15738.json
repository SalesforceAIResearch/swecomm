{"instance_id": "django__django-15738", "identified_spans": [{"file_path": "django/db/backends/base/schema.py", "span_ids": ["BaseDatabaseSchemaEditor._alter_many_to_many", "BaseDatabaseSchemaEditor"], "content": [{"span_id": "BaseDatabaseSchemaEditor._alter_many_to_many", "start_line": 1241, "end_line": 1271, "content": ["    def _alter_many_to_many(self, model, old_field, new_field, strict):\n", "        \"\"\"Alter M2Ms to repoint their to= endpoints.\"\"\"\n", "        # Rename the through table\n", "        if (\n", "            old_field.remote_field.through._meta.db_table\n", "            != new_field.remote_field.through._meta.db_table\n", "        ):\n", "            self.alter_db_table(\n", "                old_field.remote_field.through,\n", "                old_field.remote_field.through._meta.db_table,\n", "                new_field.remote_field.through._meta.db_table,\n", "            )\n", "        # Repoint the FK to the other side\n", "        self.alter_field(\n", "            new_field.remote_field.through,\n", "            # The field that points to the target model is needed, so we can\n", "            # tell alter_field to change it - this is m2m_reverse_field_name()\n", "            # (as opposed to m2m_field_name(), which points to our model).\n", "            old_field.remote_field.through._meta.get_field(\n", "                old_field.m2m_reverse_field_name()\n", "            ),\n", "            new_field.remote_field.through._meta.get_field(\n", "                new_field.m2m_reverse_field_name()\n", "            ),\n", "        )\n", "        self.alter_field(\n", "            new_field.remote_field.through,\n", "            # for self-referential models we need to alter field from the other end too\n", "            old_field.remote_field.through._meta.get_field(old_field.m2m_field_name()),\n", "            new_field.remote_field.through._meta.get_field(new_field.m2m_field_name()),\n", "        )\n"]}, {"span_id": "BaseDatabaseSchemaEditor", "start_line": 74, "end_line": 142, "content": ["class BaseDatabaseSchemaEditor:\n", "    \"\"\"\n", "    This class and its subclasses are responsible for emitting schema-changing\n", "    statements to the databases - model creation/removal/alteration, field\n", "    renaming, index fiddling, and so on.\n", "    \"\"\"\n", "\n", "    # Overrideable SQL templates\n", "    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n", "    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n", "    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n", "    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n", "\n", "    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n", "    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n", "    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n", "    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n", "    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n", "    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n", "    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n", "    sql_alter_column_no_default_null = sql_alter_column_no_default\n", "    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n", "    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n", "    sql_rename_column = (\n", "        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n", "    )\n", "    sql_update_with_default = (\n", "        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n", "    )\n", "\n", "    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n", "    sql_check_constraint = \"CHECK (%(check)s)\"\n", "    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n", "    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n", "\n", "    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n", "    sql_delete_check = sql_delete_constraint\n", "\n", "    sql_create_unique = (\n", "        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n", "        \"UNIQUE (%(columns)s)%(deferrable)s\"\n", "    )\n", "    sql_delete_unique = sql_delete_constraint\n", "\n", "    sql_create_fk = (\n", "        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n", "        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n", "    )\n", "    sql_create_inline_fk = None\n", "    sql_create_column_inline_fk = None\n", "    sql_delete_fk = sql_delete_constraint\n", "\n", "    sql_create_index = (\n", "        \"CREATE INDEX %(name)s ON %(table)s \"\n", "        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n", "    )\n", "    sql_create_unique_index = (\n", "        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n", "        \"(%(columns)s)%(include)s%(condition)s\"\n", "    )\n", "    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n", "    sql_delete_index = \"DROP INDEX %(name)s\"\n", "\n", "    sql_create_pk = (\n", "        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n", "    )\n", "    sql_delete_pk = sql_delete_constraint\n", "\n", "    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n"]}]}, {"file_path": "django/db/migrations/autodetector.py", "span_ids": ["MigrationAutodetector.generate_altered_fields", "MigrationAutodetector._generate_removed_altered_foo_together", "MigrationAutodetector", "MigrationAutodetector.generate_removed_altered_unique_together"], "content": [{"span_id": "MigrationAutodetector.generate_altered_fields", "start_line": 1096, "end_line": 1213, "content": ["    def generate_altered_fields(self):\n", "        \"\"\"\n", "        Make AlterField operations, or possibly RemovedField/AddField if alter\n", "        isn't possible.\n", "        \"\"\"\n", "        for app_label, model_name, field_name in sorted(\n", "            self.old_field_keys & self.new_field_keys\n", "        ):\n", "            # Did the field change?\n", "            old_model_name = self.renamed_models.get(\n", "                (app_label, model_name), model_name\n", "            )\n", "            old_field_name = self.renamed_fields.get(\n", "                (app_label, model_name, field_name), field_name\n", "            )\n", "            old_field = self.from_state.models[app_label, old_model_name].get_field(\n", "                old_field_name\n", "            )\n", "            new_field = self.to_state.models[app_label, model_name].get_field(\n", "                field_name\n", "            )\n", "            dependencies = []\n", "            # Implement any model renames on relations; these are handled by RenameModel\n", "            # so we need to exclude them from the comparison\n", "            if hasattr(new_field, \"remote_field\") and getattr(\n", "                new_field.remote_field, \"model\", None\n", "            ):\n", "                rename_key = resolve_relation(\n", "                    new_field.remote_field.model, app_label, model_name\n", "                )\n", "                if rename_key in self.renamed_models:\n", "                    new_field.remote_field.model = old_field.remote_field.model\n", "                # Handle ForeignKey which can only have a single to_field.\n", "                remote_field_name = getattr(new_field.remote_field, \"field_name\", None)\n", "                if remote_field_name:\n", "                    to_field_rename_key = rename_key + (remote_field_name,)\n", "                    if to_field_rename_key in self.renamed_fields:\n", "                        # Repoint both model and field name because to_field\n", "                        # inclusion in ForeignKey.deconstruct() is based on\n", "                        # both.\n", "                        new_field.remote_field.model = old_field.remote_field.model\n", "                        new_field.remote_field.field_name = (\n", "                            old_field.remote_field.field_name\n", "                        )\n", "                # Handle ForeignObjects which can have multiple from_fields/to_fields.\n", "                from_fields = getattr(new_field, \"from_fields\", None)\n", "                if from_fields:\n", "                    from_rename_key = (app_label, model_name)\n", "                    new_field.from_fields = tuple(\n", "                        [\n", "                            self.renamed_fields.get(\n", "                                from_rename_key + (from_field,), from_field\n", "                            )\n", "                            for from_field in from_fields\n", "                        ]\n", "                    )\n", "                    new_field.to_fields = tuple(\n", "                        [\n", "                            self.renamed_fields.get(rename_key + (to_field,), to_field)\n", "                            for to_field in new_field.to_fields\n", "                        ]\n", "                    )\n", "                dependencies.extend(\n", "                    self._get_dependencies_for_foreign_key(\n", "                        app_label,\n", "                        model_name,\n", "                        new_field,\n", "                        self.to_state,\n", "                    )\n", "                )\n", "            if hasattr(new_field, \"remote_field\") and getattr(\n", "                new_field.remote_field, \"through\", None\n", "            ):\n", "                rename_key = resolve_relation(\n", "                    new_field.remote_field.through, app_label, model_name\n", "                )\n", "                if rename_key in self.renamed_models:\n", "                    new_field.remote_field.through = old_field.remote_field.through\n", "            old_field_dec = self.deep_deconstruct(old_field)\n", "            new_field_dec = self.deep_deconstruct(new_field)\n", "            # If the field was confirmed to be renamed it means that only\n", "            # db_column was allowed to change which generate_renamed_fields()\n", "            # already accounts for by adding an AlterField operation.\n", "            if old_field_dec != new_field_dec and old_field_name == field_name:\n", "                both_m2m = old_field.many_to_many and new_field.many_to_many\n", "                neither_m2m = not old_field.many_to_many and not new_field.many_to_many\n", "                if both_m2m or neither_m2m:\n", "                    # Either both fields are m2m or neither is\n", "                    preserve_default = True\n", "                    if (\n", "                        old_field.null\n", "                        and not new_field.null\n", "                        and not new_field.has_default()\n", "                        and not new_field.many_to_many\n", "                    ):\n", "                        field = new_field.clone()\n", "                        new_default = self.questioner.ask_not_null_alteration(\n", "                            field_name, model_name\n", "                        )\n", "                        if new_default is not models.NOT_PROVIDED:\n", "                            field.default = new_default\n", "                            preserve_default = False\n", "                    else:\n", "                        field = new_field\n", "                    self.add_operation(\n", "                        app_label,\n", "                        operations.AlterField(\n", "                            model_name=model_name,\n", "                            name=field_name,\n", "                            field=field,\n", "                            preserve_default=preserve_default,\n", "                        ),\n", "                        dependencies=dependencies,\n", "                    )\n", "                else:\n", "                    # We cannot alter between m2m and concrete fields\n", "                    self._generate_removed_field(app_label, model_name, field_name)\n", "                    self._generate_added_field(app_label, model_name, field_name)\n"]}, {"span_id": "MigrationAutodetector._generate_removed_altered_foo_together", "start_line": 1474, "end_line": 1497, "content": ["    def _generate_removed_altered_foo_together(self, operation):\n", "        for (\n", "            old_value,\n", "            new_value,\n", "            app_label,\n", "            model_name,\n", "            dependencies,\n", "        ) in self._get_altered_foo_together_operations(operation.option_name):\n", "            if operation == operations.AlterIndexTogether:\n", "                old_value = {\n", "                    value\n", "                    for value in old_value\n", "                    if value\n", "                    not in self.renamed_index_together_values[app_label, model_name]\n", "                }\n", "            removal_value = new_value.intersection(old_value)\n", "            if removal_value or old_value:\n", "                self.add_operation(\n", "                    app_label,\n", "                    operation(\n", "                        name=model_name, **{operation.option_name: removal_value}\n", "                    ),\n", "                    dependencies=dependencies,\n", "                )\n"]}, {"span_id": "MigrationAutodetector", "start_line": 21, "end_line": 32, "content": ["class MigrationAutodetector:\n", "    \"\"\"\n", "    Take a pair of ProjectStates and compare them to see what the first would\n", "    need doing to make it match the second (the second usually being the\n", "    project's current state).\n", "\n", "    Note that this naturally operates on entire projects at a time,\n", "    as it's likely that changes interact (for example, you can't\n", "    add a ForeignKey without having a migration to add the table it\n", "    depends on first). A user interface may offer single-app usage\n", "    if it wishes, with the caveat that it may not always be possible.\n", "    \"\"\"\n"]}, {"span_id": "MigrationAutodetector.generate_removed_altered_unique_together", "start_line": 1499, "end_line": 1500, "content": ["    def generate_removed_altered_unique_together(self):\n", "        self._generate_removed_altered_foo_together(operations.AlterUniqueTogether)\n"]}]}, {"file_path": "django/db/migrations/operations/models.py", "span_ids": ["AlterUniqueTogether"], "content": [{"span_id": "AlterUniqueTogether", "start_line": 598, "end_line": 604, "content": ["class AlterUniqueTogether(AlterTogetherOptionOperation):\n", "    \"\"\"\n", "    Change the value of unique_together to the target one.\n", "    Input value of unique_together must be a set of tuples.\n", "    \"\"\"\n", "\n", "    option_name = \"unique_together\"\n"]}]}, {"file_path": "django/db/models/fields/related.py", "span_ids": ["ManyToManyField", "ManyToManyField.__init__"], "content": [{"span_id": "ManyToManyField", "start_line": 1318, "end_line": 1336, "content": ["class ManyToManyField(RelatedField):\n", "    \"\"\"\n", "    Provide a many-to-many relation by using an intermediary model that\n", "    holds two ForeignKey fields pointed at the two sides of the relation.\n", "\n", "    Unless a ``through`` model was provided, ManyToManyField will use the\n", "    create_many_to_many_intermediary_model factory to automatically generate\n", "    the intermediary model.\n", "    \"\"\"\n", "\n", "    # Field flags\n", "    many_to_many = True\n", "    many_to_one = False\n", "    one_to_many = False\n", "    one_to_one = False\n", "\n", "    rel_class = ManyToManyRel\n", "\n", "    description = _(\"Many-to-many relationship\")\n"]}, {"span_id": "ManyToManyField.__init__", "start_line": 1338, "end_line": 1395, "content": ["    def __init__(\n", "        self,\n", "        to,\n", "        related_name=None,\n", "        related_query_name=None,\n", "        limit_choices_to=None,\n", "        symmetrical=None,\n", "        through=None,\n", "        through_fields=None,\n", "        db_constraint=True,\n", "        db_table=None,\n", "        swappable=True,\n", "        **kwargs,\n", "    ):\n", "        try:\n", "            to._meta\n", "        except AttributeError:\n", "            if not isinstance(to, str):\n", "                raise TypeError(\n", "                    \"%s(%r) is invalid. First parameter to ManyToManyField \"\n", "                    \"must be either a model, a model name, or the string %r\"\n", "                    % (\n", "                        self.__class__.__name__,\n", "                        to,\n", "                        RECURSIVE_RELATIONSHIP_CONSTANT,\n", "                    )\n", "                )\n", "\n", "        if symmetrical is None:\n", "            symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT\n", "\n", "        if through is not None and db_table is not None:\n", "            raise ValueError(\n", "                \"Cannot specify a db_table if an intermediary model is used.\"\n", "            )\n", "\n", "        kwargs[\"rel\"] = self.rel_class(\n", "            self,\n", "            to,\n", "            related_name=related_name,\n", "            related_query_name=related_query_name,\n", "            limit_choices_to=limit_choices_to,\n", "            symmetrical=symmetrical,\n", "            through=through,\n", "            through_fields=through_fields,\n", "            db_constraint=db_constraint,\n", "        )\n", "        self.has_null_arg = \"null\" in kwargs\n", "\n", "        super().__init__(\n", "            related_name=related_name,\n", "            related_query_name=related_query_name,\n", "            limit_choices_to=limit_choices_to,\n", "            **kwargs,\n", "        )\n", "\n", "        self.db_table = db_table\n", "        self.swappable = swappable\n"]}]}]}