{"instance_id": "pylint-dev__pylint-7114", "identified_spans": [{"file_path": "pylint/lint/expand_modules.py", "span_ids": ["expand_modules"], "content": [{"span_id": "expand_modules", "start_line": 64, "end_line": 162, "content": ["def expand_modules(\n", "    files_or_modules: Sequence[str],\n", "    ignore_list: list[str],\n", "    ignore_list_re: list[Pattern[str]],\n", "    ignore_list_paths_re: list[Pattern[str]],\n", ") -> tuple[list[ModuleDescriptionDict], list[ErrorDescriptionDict]]:\n", "    \"\"\"Take a list of files/modules/packages and return the list of tuple\n", "    (file, module name) which have to be actually checked.\n", "    \"\"\"\n", "    result: list[ModuleDescriptionDict] = []\n", "    errors: list[ErrorDescriptionDict] = []\n", "    path = sys.path.copy()\n", "\n", "    for something in files_or_modules:\n", "        basename = os.path.basename(something)\n", "        if _is_ignored_file(\n", "            something, ignore_list, ignore_list_re, ignore_list_paths_re\n", "        ):\n", "            continue\n", "        module_path = get_python_path(something)\n", "        additional_search_path = [\".\", module_path] + path\n", "        if os.path.exists(something):\n", "            # this is a file or a directory\n", "            try:\n", "                modname = \".\".join(\n", "                    modutils.modpath_from_file(something, path=additional_search_path)\n", "                )\n", "            except ImportError:\n", "                modname = os.path.splitext(basename)[0]\n", "            if os.path.isdir(something):\n", "                filepath = os.path.join(something, \"__init__.py\")\n", "            else:\n", "                filepath = something\n", "        else:\n", "            # suppose it's a module or package\n", "            modname = something\n", "            try:\n", "                filepath = modutils.file_from_modpath(\n", "                    modname.split(\".\"), path=additional_search_path\n", "                )\n", "                if filepath is None:\n", "                    continue\n", "            except (ImportError, SyntaxError) as ex:\n", "                # The SyntaxError is a Python bug and should be\n", "                # removed once we move away from imp.find_module: https://bugs.python.org/issue10588\n", "                errors.append({\"key\": \"fatal\", \"mod\": modname, \"ex\": ex})\n", "                continue\n", "        filepath = os.path.normpath(filepath)\n", "        modparts = (modname or something).split(\".\")\n", "        try:\n", "            spec = modutils.file_info_from_modpath(\n", "                modparts, path=additional_search_path\n", "            )\n", "        except ImportError:\n", "            # Might not be acceptable, don't crash.\n", "            is_namespace = False\n", "            is_directory = os.path.isdir(something)\n", "        else:\n", "            is_namespace = modutils.is_namespace(spec)\n", "            is_directory = modutils.is_directory(spec)\n", "        if not is_namespace:\n", "            result.append(\n", "                {\n", "                    \"path\": filepath,\n", "                    \"name\": modname,\n", "                    \"isarg\": True,\n", "                    \"basepath\": filepath,\n", "                    \"basename\": modname,\n", "                }\n", "            )\n", "        has_init = (\n", "            not (modname.endswith(\".__init__\") or modname == \"__init__\")\n", "            and os.path.basename(filepath) == \"__init__.py\"\n", "        )\n", "        if has_init or is_namespace or is_directory:\n", "            for subfilepath in modutils.get_module_files(\n", "                os.path.dirname(filepath), ignore_list, list_all=is_namespace\n", "            ):\n", "                if filepath == subfilepath:\n", "                    continue\n", "                if _is_in_ignore_list_re(\n", "                    os.path.basename(subfilepath), ignore_list_re\n", "                ) or _is_in_ignore_list_re(subfilepath, ignore_list_paths_re):\n", "                    continue\n", "\n", "                modpath = _modpath_from_file(\n", "                    subfilepath, is_namespace, path=additional_search_path\n", "                )\n", "                submodname = \".\".join(modpath)\n", "                result.append(\n", "                    {\n", "                        \"path\": subfilepath,\n", "                        \"name\": submodname,\n", "                        \"isarg\": False,\n", "                        \"basepath\": filepath,\n", "                        \"basename\": modname,\n", "                    }\n", "                )\n", "    return result, errors\n"]}]}, {"file_path": "pylint/lint/pylinter.py", "span_ids": ["PyLinter._expand_files", "PyLinter._discover_files"], "content": [{"span_id": "PyLinter._expand_files", "start_line": 774, "end_line": 789, "content": ["    def _expand_files(self, modules: Sequence[str]) -> list[ModuleDescriptionDict]:\n", "        \"\"\"Get modules and errors from a list of modules and handle errors.\"\"\"\n", "        result, errors = expand_modules(\n", "            modules,\n", "            self.config.ignore,\n", "            self.config.ignore_patterns,\n", "            self._ignore_paths,\n", "        )\n", "        for error in errors:\n", "            message = modname = error[\"mod\"]\n", "            key = error[\"key\"]\n", "            self.set_current_module(modname)\n", "            if key == \"fatal\":\n", "                message = str(error[\"ex\"]).replace(os.getcwd() + os.sep, \"\")\n", "            self.add_message(key, args=message)\n", "        return result\n"]}, {"span_id": "PyLinter._discover_files", "start_line": 585, "end_line": 619, "content": ["    def _discover_files(self, files_or_modules: Sequence[str]) -> Iterator[str]:\n", "        \"\"\"Discover python modules and packages in sub-directory.\n", "\n", "        Returns iterator of paths to discovered modules and packages.\n", "        \"\"\"\n", "        for something in files_or_modules:\n", "            if os.path.isdir(something) and not os.path.isfile(\n", "                os.path.join(something, \"__init__.py\")\n", "            ):\n", "                skip_subtrees: list[str] = []\n", "                for root, _, files in os.walk(something):\n", "                    if any(root.startswith(s) for s in skip_subtrees):\n", "                        # Skip subtree of already discovered package.\n", "                        continue\n", "\n", "                    if _is_ignored_file(\n", "                        root,\n", "                        self.config.ignore,\n", "                        self.config.ignore_patterns,\n", "                        self.config.ignore_paths,\n", "                    ):\n", "                        skip_subtrees.append(root)\n", "                        continue\n", "\n", "                    if \"__init__.py\" in files:\n", "                        skip_subtrees.append(root)\n", "                        yield root\n", "                    else:\n", "                        yield from (\n", "                            os.path.join(root, file)\n", "                            for file in files\n", "                            if file.endswith(\".py\")\n", "                        )\n", "            else:\n", "                yield something\n"]}]}]}