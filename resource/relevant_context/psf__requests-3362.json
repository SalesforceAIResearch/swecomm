{"instance_id": "psf__requests-3362", "identified_spans": [{"file_path": "requests/models.py", "span_ids": ["Response.iter_content", "Response.text", "Response.content", "Response"], "content": [{"span_id": "Response.iter_content", "start_line": 653, "end_line": 700, "content": ["    def iter_content(self, chunk_size=1, decode_unicode=False):\n", "        \"\"\"Iterates over the response data.  When stream=True is set on the\n", "        request, this avoids reading the content at once into memory for\n", "        large responses.  The chunk size is the number of bytes it should\n", "        read into memory.  This is not necessarily the length of each item\n", "        returned as decoding can take place.\n", "\n", "        If decode_unicode is True, content will be decoded using the best\n", "        available encoding based on the response.\n", "        \"\"\"\n", "\n", "        def generate():\n", "            # Special case for urllib3.\n", "            if hasattr(self.raw, 'stream'):\n", "                try:\n", "                    for chunk in self.raw.stream(chunk_size, decode_content=True):\n", "                        yield chunk\n", "                except ProtocolError as e:\n", "                    raise ChunkedEncodingError(e)\n", "                except DecodeError as e:\n", "                    raise ContentDecodingError(e)\n", "                except ReadTimeoutError as e:\n", "                    raise ConnectionError(e)\n", "            else:\n", "                # Standard file-like object.\n", "                while True:\n", "                    chunk = self.raw.read(chunk_size)\n", "                    if not chunk:\n", "                        break\n", "                    yield chunk\n", "\n", "            self._content_consumed = True\n", "\n", "        if self._content_consumed and isinstance(self._content, bool):\n", "            raise StreamConsumedError()\n", "        elif not isinstance(chunk_size, int):\n", "            raise TypeError(\"chunk_size must be an int, it is instead a %s.\" % type(chunk_size))\n", "        # simulate reading small chunks of the content\n", "        reused_chunks = iter_slices(self._content, chunk_size)\n", "\n", "        stream_chunks = generate()\n", "\n", "        chunks = reused_chunks if self._content_consumed else stream_chunks\n", "\n", "        if decode_unicode:\n", "            chunks = stream_decode_response_unicode(chunks, self)\n", "\n", "        return chunks\n"]}, {"span_id": "Response.text", "start_line": 757, "end_line": 793, "content": ["    @property\n", "    def text(self):\n", "        \"\"\"Content of the response, in unicode.\n", "\n", "        If Response.encoding is None, encoding will be guessed using\n", "        ``chardet``.\n", "\n", "        The encoding of the response content is determined based solely on HTTP\n", "        headers, following RFC 2616 to the letter. If you can take advantage of\n", "        non-HTTP knowledge to make a better guess at the encoding, you should\n", "        set ``r.encoding`` appropriately before accessing this property.\n", "        \"\"\"\n", "\n", "        # Try charset from content-type\n", "        content = None\n", "        encoding = self.encoding\n", "\n", "        if not self.content:\n", "            return str('')\n", "\n", "        # Fallback to auto-detected encoding.\n", "        if self.encoding is None:\n", "            encoding = self.apparent_encoding\n", "\n", "        # Decode unicode from given encoding.\n", "        try:\n", "            content = str(self.content, encoding, errors='replace')\n", "        except (LookupError, TypeError):\n", "            # A LookupError is raised if the encoding was not found which could\n", "            # indicate a misspelling or similar mistake.\n", "            #\n", "            # A TypeError can be raised if encoding is None\n", "            #\n", "            # So we try blindly encoding.\n", "            content = str(self.content, errors='replace')\n", "\n", "        return content\n"]}, {"span_id": "Response.content", "start_line": 733, "end_line": 755, "content": ["    @property\n", "    def content(self):\n", "        \"\"\"Content of the response, in bytes.\"\"\"\n", "\n", "        if self._content is False:\n", "            # Read the contents.\n", "            try:\n", "                if self._content_consumed:\n", "                    raise RuntimeError(\n", "                        'The content for this response was already consumed')\n", "\n", "                if self.status_code == 0:\n", "                    self._content = None\n", "                else:\n", "                    self._content = bytes().join(self.iter_content(CONTENT_CHUNK_SIZE)) or bytes()\n", "\n", "            except AttributeError:\n", "                self._content = None\n", "\n", "        self._content_consumed = True\n", "        # don't need to release the connection; that's been handled by urllib3\n", "        # since we exhausted the data.\n", "        return self._content\n"]}, {"span_id": "Response", "start_line": 536, "end_line": 544, "content": ["class Response(object):\n", "    \"\"\"The :class:`Response <Response>` object, which contains a\n", "    server's response to an HTTP request.\n", "    \"\"\"\n", "\n", "    __attrs__ = [\n", "        '_content', 'status_code', 'headers', 'url', 'history',\n", "        'encoding', 'reason', 'cookies', 'elapsed', 'request'\n", "    ]\n"]}]}]}