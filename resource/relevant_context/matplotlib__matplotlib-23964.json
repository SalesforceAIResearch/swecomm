{"instance_id": "matplotlib__matplotlib-23964", "identified_spans": [{"file_path": "lib/matplotlib/backends/backend_ps.py", "span_ids": ["RendererPS", "RendererPS.draw_text"], "content": [{"span_id": "RendererPS", "start_line": 253, "end_line": 260, "content": ["class RendererPS(_backend_pdf_ps.RendererPDFPSBase):\n", "    \"\"\"\n", "    The renderer handles all the drawing primitives using a graphics\n", "    context instance that controls the colors/styles.\n", "    \"\"\"\n", "\n", "    _afm_font_dir = cbook._get_data_path(\"fonts/afm\")\n", "    _use_afm_rc_name = \"ps.useafm\"\n"]}, {"span_id": "RendererPS.draw_text", "start_line": 616, "end_line": 684, "content": ["    @_log_if_debug_on\n", "    def draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):\n", "        # docstring inherited\n", "\n", "        if self._is_transparent(gc.get_rgb()):\n", "            return  # Special handling for fully transparent.\n", "\n", "        if ismath == 'TeX':\n", "            return self.draw_tex(gc, x, y, s, prop, angle)\n", "\n", "        if ismath:\n", "            return self.draw_mathtext(gc, x, y, s, prop, angle)\n", "\n", "        if mpl.rcParams['ps.useafm']:\n", "            font = self._get_font_afm(prop)\n", "            scale = 0.001 * prop.get_size_in_points()\n", "            stream = []\n", "            thisx = 0\n", "            last_name = None  # kerns returns 0 for None.\n", "            xs_names = []\n", "            for c in s:\n", "                name = uni2type1.get(ord(c), f\"uni{ord(c):04X}\")\n", "                try:\n", "                    width = font.get_width_from_char_name(name)\n", "                except KeyError:\n", "                    name = 'question'\n", "                    width = font.get_width_char('?')\n", "                kern = font.get_kern_dist_from_name(last_name, name)\n", "                last_name = name\n", "                thisx += kern * scale\n", "                xs_names.append((thisx, name))\n", "                thisx += width * scale\n", "            ps_name = (font.postscript_name\n", "                       .encode(\"ascii\", \"replace\").decode(\"ascii\"))\n", "            stream.append((ps_name, xs_names))\n", "\n", "        else:\n", "            font = self._get_font_ttf(prop)\n", "            self._character_tracker.track(font, s)\n", "            stream = []\n", "            prev_font = curr_stream = None\n", "            for item in _text_helpers.layout(s, font):\n", "                ps_name = (item.ft_object.postscript_name\n", "                           .encode(\"ascii\", \"replace\").decode(\"ascii\"))\n", "                if item.ft_object is not prev_font:\n", "                    if curr_stream:\n", "                        stream.append(curr_stream)\n", "                    prev_font = item.ft_object\n", "                    curr_stream = [ps_name, []]\n", "                curr_stream[1].append(\n", "                    (item.x, item.ft_object.get_glyph_name(item.glyph_idx))\n", "                )\n", "            # append the last entry\n", "            stream.append(curr_stream)\n", "\n", "        self.set_color(*gc.get_rgb())\n", "\n", "        for ps_name, xs_names in stream:\n", "            self.set_font(ps_name, prop.get_size_in_points(), False)\n", "            thetext = \"\\n\".join(f\"{x:g} 0 m /{name:s} glyphshow\"\n", "                                for x, name in xs_names)\n", "            self._pswriter.write(f\"\"\"\\\n", "gsave\n", "{self._get_clip_cmd(gc)}\n", "{x:g} {y:g} translate\n", "{angle:g} rotate\n", "{thetext}\n", "grestore\n", "\"\"\")\n"]}]}]}