{"instance_id": "django__django-16910", "identified_spans": [{"file_path": "django/db/models/query.py", "span_ids": ["QuerySet.select_related", "QuerySet.only"], "content": [{"span_id": "QuerySet.select_related", "start_line": 1546, "end_line": 1568, "content": ["    def select_related(self, *fields):\n", "        \"\"\"\n", "        Return a new QuerySet instance that will select related objects.\n", "\n", "        If fields are specified, they must be ForeignKey fields and only those\n", "        related objects are included in the selection.\n", "\n", "        If select_related(None) is called, clear the list.\n", "        \"\"\"\n", "        self._not_support_combined_queries(\"select_related\")\n", "        if self._fields is not None:\n", "            raise TypeError(\n", "                \"Cannot call select_related() after .values() or .values_list()\"\n", "            )\n", "\n", "        obj = self._chain()\n", "        if fields == (None,):\n", "            obj.query.select_related = False\n", "        elif fields:\n", "            obj.query.add_select_related(fields)\n", "        else:\n", "            obj.query.select_related = True\n", "        return obj\n"]}, {"span_id": "QuerySet.only", "start_line": 1728, "end_line": 1747, "content": ["    def only(self, *fields):\n", "        \"\"\"\n", "        Essentially, the opposite of defer(). Only the fields passed into this\n", "        method and that are not already specified as deferred are loaded\n", "        immediately when the queryset is evaluated.\n", "        \"\"\"\n", "        self._not_support_combined_queries(\"only\")\n", "        if self._fields is not None:\n", "            raise TypeError(\"Cannot call only() after .values() or .values_list()\")\n", "        if fields == (None,):\n", "            # Can only pass None to defer(), not only(), as the rest option.\n", "            # That won't stop people trying to do this, so let's be explicit.\n", "            raise TypeError(\"Cannot pass None as an argument to only().\")\n", "        for field in fields:\n", "            field = field.split(LOOKUP_SEP, 1)[0]\n", "            if field in self.query._filtered_relations:\n", "                raise ValueError(\"only() is not supported with FilteredRelation.\")\n", "        clone = self._chain()\n", "        clone.query.add_immediate_loading(fields)\n", "        return clone\n"]}]}, {"file_path": "django/db/models/sql/query.py", "span_ids": ["Query.get_select_mask", "Query.add_select_related", "Query.add_immediate_loading", "Query.solve_lookup_type", "Query._get_only_select_mask"], "content": [{"span_id": "Query.get_select_mask", "start_line": 792, "end_line": 812, "content": ["    def get_select_mask(self):\n", "        \"\"\"\n", "        Convert the self.deferred_loading data structure to an alternate data\n", "        structure, describing the field that *will* be loaded. This is used to\n", "        compute the columns to select from the database and also by the\n", "        QuerySet class to work out which fields are being initialized on each\n", "        model. Models that have all their fields included aren't mentioned in\n", "        the result, only those that have field restrictions in place.\n", "        \"\"\"\n", "        field_names, defer = self.deferred_loading\n", "        if not field_names:\n", "            return {}\n", "        mask = {}\n", "        for field_name in field_names:\n", "            part_mask = mask\n", "            for part in field_name.split(LOOKUP_SEP):\n", "                part_mask = part_mask.setdefault(part, {})\n", "        opts = self.get_meta()\n", "        if defer:\n", "            return self._get_defer_select_mask(opts, mask)\n", "        return self._get_only_select_mask(opts, mask)\n"]}, {"span_id": "Query.add_select_related", "start_line": 2252, "end_line": 2266, "content": ["    def add_select_related(self, fields):\n", "        \"\"\"\n", "        Set up the select_related data structure so that we only select\n", "        certain related models (as opposed to all models, when\n", "        self.select_related=True).\n", "        \"\"\"\n", "        if isinstance(self.select_related, bool):\n", "            field_dict = {}\n", "        else:\n", "            field_dict = self.select_related\n", "        for field in fields:\n", "            d = field_dict\n", "            for part in field.split(LOOKUP_SEP):\n", "                d = d.setdefault(part, {})\n", "        self.select_related = field_dict\n"]}, {"span_id": "Query.add_immediate_loading", "start_line": 2330, "end_line": 2352, "content": ["    def add_immediate_loading(self, field_names):\n", "        \"\"\"\n", "        Add the given list of model field names to the set of fields to\n", "        retrieve when the SQL is executed (\"immediate loading\" fields). The\n", "        field names replace any existing immediate loading field names. If\n", "        there are field names already specified for deferred loading, remove\n", "        those names from the new field_names before storing the new names\n", "        for immediate loading. (That is, immediate loading overrides any\n", "        existing immediate values, but respects existing deferrals.)\n", "        \"\"\"\n", "        existing, defer = self.deferred_loading\n", "        field_names = set(field_names)\n", "        if \"pk\" in field_names:\n", "            field_names.remove(\"pk\")\n", "            field_names.add(self.get_meta().pk.name)\n", "\n", "        if defer:\n", "            # Remove any existing deferred names from the current set before\n", "            # setting the new names.\n", "            self.deferred_loading = field_names.difference(existing), False\n", "        else:\n", "            # Replace any existing \"immediate load\" field names.\n", "            self.deferred_loading = frozenset(field_names), False\n"]}, {"span_id": "Query.solve_lookup_type", "start_line": 1227, "end_line": 1248, "content": ["    def solve_lookup_type(self, lookup, summarize=False):\n", "        \"\"\"\n", "        Solve the lookup type from the lookup (e.g.: 'foobar__id__icontains').\n", "        \"\"\"\n", "        lookup_splitted = lookup.split(LOOKUP_SEP)\n", "        if self.annotations:\n", "            annotation, expression_lookups = refs_expression(\n", "                lookup_splitted, self.annotations\n", "            )\n", "            if annotation:\n", "                expression = self.annotations[annotation]\n", "                if summarize:\n", "                    expression = Ref(annotation, expression)\n", "                return expression_lookups, (), expression\n", "        _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())\n", "        field_parts = lookup_splitted[0 : len(lookup_splitted) - len(lookup_parts)]\n", "        if len(lookup_parts) > 1 and not field_parts:\n", "            raise FieldError(\n", "                'Invalid lookup \"%s\" for model %s\".'\n", "                % (lookup, self.get_meta().model.__name__)\n", "            )\n", "        return lookup_parts, field_parts, False\n"]}, {"span_id": "Query._get_only_select_mask", "start_line": 775, "end_line": 790, "content": ["    def _get_only_select_mask(self, opts, mask, select_mask=None):\n", "        if select_mask is None:\n", "            select_mask = {}\n", "        select_mask[opts.pk] = {}\n", "        # Only include fields mentioned in the mask.\n", "        for field_name, field_mask in mask.items():\n", "            field = opts.get_field(field_name)\n", "            field_select_mask = select_mask.setdefault(field, {})\n", "            if field_mask:\n", "                if not field.is_relation:\n", "                    raise FieldError(next(iter(field_mask)))\n", "                related_model = field.remote_field.model._meta.concrete_model\n", "                self._get_only_select_mask(\n", "                    related_model._meta, field_mask, field_select_mask\n", "                )\n", "        return select_mask\n"]}]}]}