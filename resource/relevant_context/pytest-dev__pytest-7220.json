{"instance_id": "pytest-dev__pytest-7220", "identified_spans": [{"file_path": "src/_pytest/_code/code.py", "span_ids": ["ReprFileLocation", "getfslineno", "ReprFileLocation.toterminal"], "content": [{"span_id": "ReprFileLocation", "start_line": 1105, "end_line": 1109, "content": ["@attr.s(**{ATTRS_EQ_FIELD: False})  # type: ignore\n", "class ReprFileLocation(TerminalRepr):\n", "    path = attr.ib(type=str, converter=str)\n", "    lineno = attr.ib(type=int)\n", "    message = attr.ib(type=str)\n"]}, {"span_id": "getfslineno", "start_line": 1154, "end_line": 1184, "content": ["def getfslineno(obj: Any) -> Tuple[Union[str, py.path.local], int]:\n", "    \"\"\" Return source location (path, lineno) for the given object.\n", "    If the source cannot be determined return (\"\", -1).\n", "\n", "    The line number is 0-based.\n", "    \"\"\"\n", "    # xxx let decorators etc specify a sane ordering\n", "    # NOTE: this used to be done in _pytest.compat.getfslineno, initially added\n", "    #       in 6ec13a2b9.  It (\"place_as\") appears to be something very custom.\n", "    obj = get_real_func(obj)\n", "    if hasattr(obj, \"place_as\"):\n", "        obj = obj.place_as\n", "\n", "    try:\n", "        code = Code(obj)\n", "    except TypeError:\n", "        try:\n", "            fn = inspect.getsourcefile(obj) or inspect.getfile(obj)\n", "        except TypeError:\n", "            return \"\", -1\n", "\n", "        fspath = fn and py.path.local(fn) or \"\"\n", "        lineno = -1\n", "        if fspath:\n", "            try:\n", "                _, lineno = findsource(obj)\n", "            except OSError:\n", "                pass\n", "        return fspath, lineno\n", "    else:\n", "        return code.path, code.firstlineno\n"]}, {"span_id": "ReprFileLocation.toterminal", "start_line": 1111, "end_line": 1119, "content": ["    def toterminal(self, tw: TerminalWriter) -> None:\n", "        # filename and lineno output for each entry,\n", "        # using an output format that most editors understand\n", "        msg = self.message\n", "        i = msg.find(\"\\n\")\n", "        if i != -1:\n", "            msg = msg[:i]\n", "        tw.write(self.path, bold=True, red=True)\n", "        tw.line(\":{}: {}\".format(self.lineno, msg))\n"]}]}, {"file_path": "src/_pytest/terminal.py", "span_ids": ["TerminalReporter._locationline", "TerminalReporter.__init__", "TerminalReporter", "TerminalReporter.pytest_runtest_logstart"], "content": [{"span_id": "TerminalReporter._locationline", "start_line": 777, "end_line": 797, "content": ["    def _locationline(self, nodeid, fspath, lineno, domain):\n", "        def mkrel(nodeid):\n", "            line = self.config.cwd_relative_nodeid(nodeid)\n", "            if domain and line.endswith(domain):\n", "                line = line[: -len(domain)]\n", "                values = domain.split(\"[\")\n", "                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n", "                line += \"[\".join(values)\n", "            return line\n", "\n", "        # collect_fspath comes from testid which has a \"/\"-normalized path\n", "\n", "        if fspath:\n", "            res = mkrel(nodeid)\n", "            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n", "                \"\\\\\", nodes.SEP\n", "            ):\n", "                res += \" <- \" + self.startdir.bestrelpath(fspath)\n", "        else:\n", "            res = \"[location]\"\n", "        return res + \" \"\n"]}, {"span_id": "TerminalReporter.__init__", "start_line": 263, "end_line": 285, "content": ["    def __init__(self, config: Config, file=None) -> None:\n", "        import _pytest.config\n", "\n", "        self.config = config\n", "        self._numcollected = 0\n", "        self._session = None  # type: Optional[Session]\n", "        self._showfspath = None\n", "\n", "        self.stats = {}  # type: Dict[str, List[Any]]\n", "        self._main_color = None  # type: Optional[str]\n", "        self._known_types = None  # type: Optional[List]\n", "        self.startdir = config.invocation_dir\n", "        if file is None:\n", "            file = sys.stdout\n", "        self._tw = _pytest.config.create_terminal_writer(config, file)\n", "        self._screen_width = self._tw.fullwidth\n", "        self.currentfspath = None  # type: Any\n", "        self.reportchars = getreportopt(config)\n", "        self.hasmarkup = self._tw.hasmarkup\n", "        self.isatty = file.isatty()\n", "        self._progress_nodeids_reported = set()  # type: Set[str]\n", "        self._show_progress_info = self._determine_show_progress_info()\n", "        self._collect_report_last_write = None  # type: Optional[float]\n"]}, {"span_id": "TerminalReporter", "start_line": 262, "end_line": 262, "content": ["class TerminalReporter:\n"]}, {"span_id": "TerminalReporter.pytest_runtest_logstart", "start_line": 438, "end_line": 447, "content": ["    def pytest_runtest_logstart(self, nodeid, location):\n", "        # ensure that the path is printed before the\n", "        # 1st test of a module starts running\n", "        if self.showlongtestinfo:\n", "            line = self._locationline(nodeid, *location)\n", "            self.write_ensure_prefix(line, \"\")\n", "            self.flush()\n", "        elif self.showfspath:\n", "            self.write_fspath_result(nodeid, \"\")\n", "            self.flush()\n"]}]}, {"file_path": "testing/example_scripts/tmpdir/tmpdir_fixture.py", "span_ids": ["fix2"], "content": []}]}