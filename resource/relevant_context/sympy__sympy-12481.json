{"instance_id": "sympy__sympy-12481", "identified_spans": [{"file_path": "sympy/combinatorics/permutations.py", "span_ids": ["Permutation.__new__", "Permutation.list"], "content": [{"span_id": "Permutation.__new__", "start_line": 801, "end_line": 929, "content": ["    def __new__(cls, *args, **kwargs):\n", "        \"\"\"\n", "        Constructor for the Permutation object from a list or a\n", "        list of lists in which all elements of the permutation may\n", "        appear only once.\n", "\n", "        Examples\n", "        ========\n", "\n", "        >>> from sympy.combinatorics.permutations import Permutation\n", "        >>> Permutation.print_cyclic = False\n", "\n", "        Permutations entered in array-form are left unaltered:\n", "\n", "        >>> Permutation([0, 2, 1])\n", "        Permutation([0, 2, 1])\n", "\n", "        Permutations entered in cyclic form are converted to array form;\n", "        singletons need not be entered, but can be entered to indicate the\n", "        largest element:\n", "\n", "        >>> Permutation([[4, 5, 6], [0, 1]])\n", "        Permutation([1, 0, 2, 3, 5, 6, 4])\n", "        >>> Permutation([[4, 5, 6], [0, 1], [19]])\n", "        Permutation([1, 0, 2, 3, 5, 6, 4], size=20)\n", "\n", "        All manipulation of permutations assumes that the smallest element\n", "        is 0 (in keeping with 0-based indexing in Python) so if the 0 is\n", "        missing when entering a permutation in array form, an error will be\n", "        raised:\n", "\n", "        >>> Permutation([2, 1])\n", "        Traceback (most recent call last):\n", "        ...\n", "        ValueError: Integers 0 through 2 must be present.\n", "\n", "        If a permutation is entered in cyclic form, it can be entered without\n", "        singletons and the ``size`` specified so those values can be filled\n", "        in, otherwise the array form will only extend to the maximum value\n", "        in the cycles:\n", "\n", "        >>> Permutation([[1, 4], [3, 5, 2]], size=10)\n", "        Permutation([0, 4, 3, 5, 1, 2], size=10)\n", "        >>> _.array_form\n", "        [0, 4, 3, 5, 1, 2, 6, 7, 8, 9]\n", "        \"\"\"\n", "        size = kwargs.pop('size', None)\n", "        if size is not None:\n", "            size = int(size)\n", "\n", "        #a) ()\n", "        #b) (1) = identity\n", "        #c) (1, 2) = cycle\n", "        #d) ([1, 2, 3]) = array form\n", "        #e) ([[1, 2]]) = cyclic form\n", "        #f) (Cycle) = conversion to permutation\n", "        #g) (Permutation) = adjust size or return copy\n", "        ok = True\n", "        if not args:  # a\n", "            return _af_new(list(range(size or 0)))\n", "        elif len(args) > 1:  # c\n", "            return _af_new(Cycle(*args).list(size))\n", "        if len(args) == 1:\n", "            a = args[0]\n", "            if isinstance(a, Perm):  # g\n", "                if size is None or size == a.size:\n", "                    return a\n", "                return Perm(a.array_form, size=size)\n", "            if isinstance(a, Cycle):  # f\n", "                return _af_new(a.list(size))\n", "            if not is_sequence(a):  # b\n", "                return _af_new(list(range(a + 1)))\n", "            if has_variety(is_sequence(ai) for ai in a):\n", "                ok = False\n", "        else:\n", "            ok = False\n", "        if not ok:\n", "            raise ValueError(\"Permutation argument must be a list of ints, \"\n", "                             \"a list of lists, Permutation or Cycle.\")\n", "\n", "\n", "        # safe to assume args are valid; this also makes a copy\n", "        # of the args\n", "        args = list(args[0])\n", "\n", "        is_cycle = args and is_sequence(args[0])\n", "        if is_cycle:  # e\n", "            args = [[int(i) for i in c] for c in args]\n", "        else:  # d\n", "            args = [int(i) for i in args]\n", "\n", "        # if there are n elements present, 0, 1, ..., n-1 should be present\n", "        # unless a cycle notation has been provided. A 0 will be added\n", "        # for convenience in case one wants to enter permutations where\n", "        # counting starts from 1.\n", "\n", "        temp = flatten(args)\n", "        if has_dups(temp):\n", "            if is_cycle:\n", "                raise ValueError('there were repeated elements; to resolve '\n", "                'cycles use Cycle%s.' % ''.join([str(tuple(c)) for c in args]))\n", "            else:\n", "                raise ValueError('there were repeated elements.')\n", "        temp = set(temp)\n", "\n", "        if not is_cycle and \\\n", "                any(i not in temp for i in range(len(temp))):\n", "            raise ValueError(\"Integers 0 through %s must be present.\" %\n", "                             max(temp))\n", "\n", "        if is_cycle:\n", "            # it's not necessarily canonical so we won't store\n", "            # it -- use the array form instead\n", "            c = Cycle()\n", "            for ci in args:\n", "                c = c(*ci)\n", "            aform = c.list()\n", "        else:\n", "            aform = list(args)\n", "        if size and size > len(aform):\n", "            # don't allow for truncation of permutation which\n", "            # might split a cycle and lead to an invalid aform\n", "            # but do allow the permutation size to be increased\n", "            aform.extend(list(range(len(aform), size)))\n", "        size = len(aform)\n", "        obj = Basic.__new__(cls, aform)\n", "        obj._array_form = aform\n", "        obj._size = size\n", "        return obj\n"]}, {"span_id": "Permutation.list", "start_line": 1006, "end_line": 1045, "content": ["    def list(self, size=None):\n", "        \"\"\"Return the permutation as an explicit list, possibly\n", "        trimming unmoved elements if size is less than the maximum\n", "        element in the permutation; if this is desired, setting\n", "        ``size=-1`` will guarantee such trimming.\n", "\n", "        Examples\n", "        ========\n", "\n", "        >>> from sympy.combinatorics.permutations import Permutation\n", "        >>> Permutation.print_cyclic = False\n", "        >>> p = Permutation(2, 3)(4, 5)\n", "        >>> p.list()\n", "        [0, 1, 3, 2, 5, 4]\n", "        >>> p.list(10)\n", "        [0, 1, 3, 2, 5, 4, 6, 7, 8, 9]\n", "\n", "        Passing a length too small will trim trailing, unchanged elements\n", "        in the permutation:\n", "\n", "        >>> Permutation(2, 4)(1, 2, 4).list(-1)\n", "        [0, 2, 1]\n", "        >>> Permutation(3).list(-1)\n", "        []\n", "        \"\"\"\n", "        if not self and size is None:\n", "            raise ValueError('must give size for empty Cycle')\n", "        rv = self.array_form\n", "        if size is not None:\n", "            if size > self.size:\n", "                rv.extend(list(range(self.size, size)))\n", "            else:\n", "                # find first value from rhs where rv[i] != i\n", "                i = self.size - 1\n", "                while rv:\n", "                    if rv[-1] != i:\n", "                        break\n", "                    rv.pop()\n", "                    i -= 1\n", "        return rv\n"]}]}]}