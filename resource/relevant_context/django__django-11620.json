{"instance_id": "django__django-11620", "identified_spans": [{"file_path": "django/core/handlers/base.py", "span_ids": ["BaseHandler.get_response"], "content": [{"span_id": "BaseHandler.get_response", "start_line": 71, "end_line": 83, "content": ["    def get_response(self, request):\n", "        \"\"\"Return an HttpResponse object for the given HttpRequest.\"\"\"\n", "        # Setup default url resolver for this thread\n", "        set_urlconf(settings.ROOT_URLCONF)\n", "        response = self._middleware_chain(request)\n", "        response._closable_objects.append(request)\n", "        if response.status_code >= 400:\n", "            log_response(\n", "                '%s: %s', response.reason_phrase, request.path,\n", "                response=response,\n", "                request=request,\n", "            )\n", "        return response\n"]}]}, {"file_path": "django/core/handlers/exception.py", "span_ids": ["response_for_exception"], "content": [{"span_id": "response_for_exception", "start_line": 41, "end_line": 102, "content": ["def response_for_exception(request, exc):\n", "    if isinstance(exc, Http404):\n", "        if settings.DEBUG:\n", "            response = debug.technical_404_response(request, exc)\n", "        else:\n", "            response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)\n", "\n", "    elif isinstance(exc, PermissionDenied):\n", "        response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)\n", "        log_response(\n", "            'Forbidden (Permission denied): %s', request.path,\n", "            response=response,\n", "            request=request,\n", "            exc_info=sys.exc_info(),\n", "        )\n", "\n", "    elif isinstance(exc, MultiPartParserError):\n", "        response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)\n", "        log_response(\n", "            'Bad request (Unable to parse request body): %s', request.path,\n", "            response=response,\n", "            request=request,\n", "            exc_info=sys.exc_info(),\n", "        )\n", "\n", "    elif isinstance(exc, SuspiciousOperation):\n", "        if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):\n", "            # POST data can't be accessed again, otherwise the original\n", "            # exception would be raised.\n", "            request._mark_post_parse_error()\n", "\n", "        # The request logger receives events for any problematic request\n", "        # The security logger receives events for all SuspiciousOperations\n", "        security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)\n", "        security_logger.error(\n", "            str(exc),\n", "            extra={'status_code': 400, 'request': request},\n", "        )\n", "        if settings.DEBUG:\n", "            response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)\n", "        else:\n", "            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)\n", "\n", "    elif isinstance(exc, SystemExit):\n", "        # Allow sys.exit() to actually exit. See tickets #1023 and #4701\n", "        raise\n", "\n", "    else:\n", "        signals.got_request_exception.send(sender=None, request=request)\n", "        response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())\n", "        log_response(\n", "            '%s: %s', response.reason_phrase, request.path,\n", "            response=response,\n", "            request=request,\n", "            exc_info=sys.exc_info(),\n", "        )\n", "\n", "    # Force a TemplateResponse to be rendered.\n", "    if not getattr(response, 'is_rendered', True) and callable(getattr(response, 'render', None)):\n", "        response = response.render()\n", "\n", "    return response\n"]}]}, {"file_path": "django/urls/resolvers.py", "span_ids": ["URLResolver.resolve"], "content": [{"span_id": "URLResolver.resolve", "start_line": 534, "end_line": 572, "content": ["    def resolve(self, path):\n", "        path = str(path)  # path may be a reverse_lazy object\n", "        tried = []\n", "        match = self.pattern.match(path)\n", "        if match:\n", "            new_path, args, kwargs = match\n", "            for pattern in self.url_patterns:\n", "                try:\n", "                    sub_match = pattern.resolve(new_path)\n", "                except Resolver404 as e:\n", "                    sub_tried = e.args[0].get('tried')\n", "                    if sub_tried is not None:\n", "                        tried.extend([pattern] + t for t in sub_tried)\n", "                    else:\n", "                        tried.append([pattern])\n", "                else:\n", "                    if sub_match:\n", "                        # Merge captured arguments in match with submatch\n", "                        sub_match_dict = {**kwargs, **self.default_kwargs}\n", "                        # Update the sub_match_dict with the kwargs from the sub_match.\n", "                        sub_match_dict.update(sub_match.kwargs)\n", "                        # If there are *any* named groups, ignore all non-named groups.\n", "                        # Otherwise, pass all non-named arguments as positional arguments.\n", "                        sub_match_args = sub_match.args\n", "                        if not sub_match_dict:\n", "                            sub_match_args = args + sub_match.args\n", "                        current_route = '' if isinstance(pattern, URLPattern) else str(pattern.pattern)\n", "                        return ResolverMatch(\n", "                            sub_match.func,\n", "                            sub_match_args,\n", "                            sub_match_dict,\n", "                            sub_match.url_name,\n", "                            [self.app_name] + sub_match.app_names,\n", "                            [self.namespace] + sub_match.namespaces,\n", "                            self._join_route(current_route, sub_match.route),\n", "                        )\n", "                    tried.append([pattern])\n", "            raise Resolver404({'tried': tried, 'path': new_path})\n", "        raise Resolver404({'path': path})\n"]}]}, {"file_path": "django/views/debug.py", "span_ids": ["technical_404_response"], "content": [{"span_id": "technical_404_response", "start_line": 459, "end_line": 512, "content": ["def technical_404_response(request, exception):\n", "    \"\"\"Create a technical 404 error response. `exception` is the Http404.\"\"\"\n", "    try:\n", "        error_url = exception.args[0]['path']\n", "    except (IndexError, TypeError, KeyError):\n", "        error_url = request.path_info[1:]  # Trim leading slash\n", "\n", "    try:\n", "        tried = exception.args[0]['tried']\n", "    except (IndexError, TypeError, KeyError):\n", "        tried = []\n", "    else:\n", "        if (not tried or (                  # empty URLconf\n", "            request.path == '/' and\n", "            len(tried) == 1 and             # default URLconf\n", "            len(tried[0]) == 1 and\n", "            getattr(tried[0][0], 'app_name', '') == getattr(tried[0][0], 'namespace', '') == 'admin'\n", "        )):\n", "            return default_urlconf(request)\n", "\n", "    urlconf = getattr(request, 'urlconf', settings.ROOT_URLCONF)\n", "    if isinstance(urlconf, types.ModuleType):\n", "        urlconf = urlconf.__name__\n", "\n", "    caller = ''\n", "    try:\n", "        resolver_match = resolve(request.path)\n", "    except Resolver404:\n", "        pass\n", "    else:\n", "        obj = resolver_match.func\n", "\n", "        if hasattr(obj, '__name__'):\n", "            caller = obj.__name__\n", "        elif hasattr(obj, '__class__') and hasattr(obj.__class__, '__name__'):\n", "            caller = obj.__class__.__name__\n", "\n", "        if hasattr(obj, '__module__'):\n", "            module = obj.__module__\n", "            caller = '%s.%s' % (module, caller)\n", "\n", "    with Path(CURRENT_DIR, 'templates', 'technical_404.html').open(encoding='utf-8') as fh:\n", "        t = DEBUG_ENGINE.from_string(fh.read())\n", "    c = Context({\n", "        'urlconf': urlconf,\n", "        'root_urlconf': settings.ROOT_URLCONF,\n", "        'request_path': error_url,\n", "        'urlpatterns': tried,\n", "        'reason': str(exception),\n", "        'request': request,\n", "        'settings': get_safe_settings(),\n", "        'raising_view_name': caller,\n", "    })\n", "    return HttpResponseNotFound(t.render(c), content_type='text/html')\n"]}]}]}