{"instance_id": "pylint-dev__pylint-6506", "identified_spans": [{"file_path": "pylint/config/config_initialization.py", "span_ids": ["_config_initialization"], "content": [{"span_id": "_config_initialization", "start_line": 20, "end_line": 106, "content": ["def _config_initialization(\n", "    linter: PyLinter,\n", "    args_list: list[str],\n", "    reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n", "    config_file: None | str | Path = None,\n", "    verbose_mode: bool = False,\n", ") -> list[str]:\n", "    \"\"\"Parse all available options, read config files and command line arguments and\n", "    set options accordingly.\n", "    \"\"\"\n", "    config_file = Path(config_file) if config_file else None\n", "\n", "    # Set the current module to the configuration file\n", "    # to allow raising messages on the configuration file.\n", "    linter.set_current_module(str(config_file) if config_file else None)\n", "\n", "    # Read the configuration file\n", "    config_file_parser = _ConfigurationFileParser(verbose_mode, linter)\n", "    try:\n", "        config_data, config_args = config_file_parser.parse_config_file(\n", "            file_path=config_file\n", "        )\n", "    except OSError as ex:\n", "        print(ex, file=sys.stderr)\n", "        sys.exit(32)\n", "\n", "    # Run init hook, if present, before loading plugins\n", "    if \"init-hook\" in config_data:\n", "        exec(utils._unquote(config_data[\"init-hook\"]))  # pylint: disable=exec-used\n", "\n", "    # Load plugins if specified in the config file\n", "    if \"load-plugins\" in config_data:\n", "        linter.load_plugin_modules(utils._splitstrip(config_data[\"load-plugins\"]))\n", "\n", "    # First we parse any options from a configuration file\n", "    try:\n", "        linter._parse_configuration_file(config_args)\n", "    except _UnrecognizedOptionError as exc:\n", "        msg = \", \".join(exc.options)\n", "        linter.add_message(\"unrecognized-option\", line=0, args=msg)\n", "\n", "    # Then, if a custom reporter is provided as argument, it may be overridden\n", "    # by file parameters, so we re-set it here. We do this before command line\n", "    # parsing, so it's still overridable by command line options\n", "    if reporter:\n", "        linter.set_reporter(reporter)\n", "\n", "    # Set the current module to the command line\n", "    # to allow raising messages on it\n", "    linter.set_current_module(\"Command line\")\n", "\n", "    # Now we parse any options from the command line, so they can override\n", "    # the configuration file\n", "    parsed_args_list = linter._parse_command_line_configuration(args_list)\n", "\n", "    # Check if there are any options that we do not recognize\n", "    unrecognized_options: list[str] = []\n", "    for opt in parsed_args_list:\n", "        if opt.startswith(\"--\"):\n", "            unrecognized_options.append(opt[2:])\n", "        elif opt.startswith(\"-\"):\n", "            unrecognized_options.append(opt[1:])\n", "    if unrecognized_options:\n", "        msg = \", \".join(unrecognized_options)\n", "        linter.add_message(\"unrecognized-option\", line=0, args=msg)\n", "        raise _UnrecognizedOptionError(options=unrecognized_options)\n", "\n", "    # Set the current module to configuration as we don't know where\n", "    # the --load-plugins key is coming from\n", "    linter.set_current_module(\"Command line or configuration file\")\n", "\n", "    # We have loaded configuration from config file and command line. Now, we can\n", "    # load plugin specific configuration.\n", "    linter.load_plugin_configuration()\n", "\n", "    # parsed_args_list should now only be a list of files/directories to lint.\n", "    # All other options have been removed from the list.\n", "    if not parsed_args_list:\n", "        print(linter.help())\n", "        sys.exit(32)\n", "\n", "    # Now that plugins are loaded, get list of all fail_on messages, and enable them\n", "    linter.enable_fail_on_messages()\n", "\n", "    linter._parse_error_mode()\n", "\n", "    return parsed_args_list\n"]}]}, {"file_path": "pylint/config/exceptions.py", "span_ids": ["_UnrecognizedOptionError"], "content": [{"span_id": "_UnrecognizedOptionError", "start_line": 14, "end_line": 15, "content": ["class _UnrecognizedOptionError(Exception):\n", "    \"\"\"Raised if an ArgumentManager instance tries to parse an option that is unknown.\"\"\"\n"]}]}, {"file_path": "pylint/lint/run.py", "span_ids": ["Run.__init__"], "content": [{"span_id": "Run.__init__", "start_line": 92, "end_line": 190, "content": ["    def __init__(\n", "        self,\n", "        args: Sequence[str],\n", "        reporter: BaseReporter | None = None,\n", "        exit: bool = True,  # pylint: disable=redefined-builtin\n", "        do_exit: Any = UNUSED_PARAM_SENTINEL,\n", "    ) -> None:\n", "        # Immediately exit if user asks for version\n", "        if \"--version\" in args:\n", "            print(full_version)\n", "            sys.exit(0)\n", "\n", "        self._rcfile: str | None = None\n", "        self._output: str | None = None\n", "        self._plugins: list[str] = []\n", "        self.verbose: bool = False\n", "\n", "        # Pre-process certain options and remove them from args list\n", "        try:\n", "            args = _preprocess_options(self, args)\n", "        except ArgumentPreprocessingError as ex:\n", "            print(ex, file=sys.stderr)\n", "            sys.exit(32)\n", "\n", "        # Determine configuration file\n", "        if self._rcfile is None:\n", "            default_file = next(config.find_default_config_files(), None)\n", "            if default_file:\n", "                self._rcfile = str(default_file)\n", "\n", "        self.linter = linter = self.LinterClass(\n", "            _make_run_options(self),\n", "            option_groups=self.option_groups,\n", "            pylintrc=self._rcfile,\n", "        )\n", "        # register standard checkers\n", "        linter.load_default_plugins()\n", "        # load command line plugins\n", "        linter.load_plugin_modules(self._plugins)\n", "\n", "        linter.disable(\"I\")\n", "        linter.enable(\"c-extension-no-member\")\n", "\n", "        args = _config_initialization(\n", "            linter, args, reporter, config_file=self._rcfile, verbose_mode=self.verbose\n", "        )\n", "\n", "        if linter.config.jobs < 0:\n", "            print(\n", "                f\"Jobs number ({linter.config.jobs}) should be greater than or equal to 0\",\n", "                file=sys.stderr,\n", "            )\n", "            sys.exit(32)\n", "        if linter.config.jobs > 1 or linter.config.jobs == 0:\n", "            if multiprocessing is None:\n", "                print(\n", "                    \"Multiprocessing library is missing, fallback to single process\",\n", "                    file=sys.stderr,\n", "                )\n", "                linter.set_option(\"jobs\", 1)\n", "            elif linter.config.jobs == 0:\n", "                linter.config.jobs = _cpu_count()\n", "\n", "        if self._output:\n", "            try:\n", "                with open(self._output, \"w\", encoding=\"utf-8\") as output:\n", "                    linter.reporter.out = output\n", "                    linter.check(args)\n", "                    score_value = linter.generate_reports()\n", "            except OSError as ex:\n", "                print(ex, file=sys.stderr)\n", "                sys.exit(32)\n", "        else:\n", "            linter.check(args)\n", "            score_value = linter.generate_reports()\n", "\n", "        if do_exit is not UNUSED_PARAM_SENTINEL:\n", "            warnings.warn(\n", "                \"do_exit is deprecated and it is going to be removed in a future version.\",\n", "                DeprecationWarning,\n", "            )\n", "            exit = do_exit\n", "\n", "        if exit:\n", "            if linter.config.exit_zero:\n", "                sys.exit(0)\n", "            elif linter.any_fail_on_issues():\n", "                # We need to make sure we return a failing exit code in this case.\n", "                # So we use self.linter.msg_status if that is non-zero, otherwise we just return 1.\n", "                sys.exit(self.linter.msg_status or 1)\n", "            elif score_value is not None:\n", "                if score_value >= linter.config.fail_under:\n", "                    sys.exit(0)\n", "                else:\n", "                    # We need to make sure we return a failing exit code in this case.\n", "                    # So we use self.linter.msg_status if that is non-zero, otherwise we just return 1.\n", "                    sys.exit(self.linter.msg_status or 1)\n", "            else:\n", "                sys.exit(self.linter.msg_status)\n"]}]}]}