{"instance_id": "matplotlib__matplotlib-26011", "identified_spans": [{"file_path": "lib/matplotlib/axes/_base.py", "span_ids": ["_AxesBase.sharex", "_AxesBase.set_xlim"], "content": [{"span_id": "_AxesBase.sharex", "start_line": 1216, "end_line": 1233, "content": ["    def sharex(self, other):\n", "        \"\"\"\n", "        Share the x-axis with *other*.\n", "\n", "        This is equivalent to passing ``sharex=other`` when constructing the\n", "        Axes, and cannot be used if the x-axis is already being shared with\n", "        another Axes.\n", "        \"\"\"\n", "        _api.check_isinstance(_AxesBase, other=other)\n", "        if self._sharex is not None and other is not self._sharex:\n", "            raise ValueError(\"x-axis is already shared\")\n", "        self._shared_axes[\"x\"].join(self, other)\n", "        self._sharex = other\n", "        self.xaxis.major = other.xaxis.major  # Ticker instances holding\n", "        self.xaxis.minor = other.xaxis.minor  # locator and formatter.\n", "        x0, x1 = other.get_xlim()\n", "        self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n", "        self.xaxis._scale = other.xaxis._scale\n"]}, {"span_id": "_AxesBase.set_xlim", "start_line": 3570, "end_line": 3646, "content": ["    def set_xlim(self, left=None, right=None, *, emit=True, auto=False,\n", "                 xmin=None, xmax=None):\n", "        \"\"\"\n", "        Set the x-axis view limits.\n", "\n", "        Parameters\n", "        ----------\n", "        left : float, optional\n", "            The left xlim in data coordinates. Passing *None* leaves the\n", "            limit unchanged.\n", "\n", "            The left and right xlims may also be passed as the tuple\n", "            (*left*, *right*) as the first positional argument (or as\n", "            the *left* keyword argument).\n", "\n", "            .. ACCEPTS: (bottom: float, top: float)\n", "\n", "        right : float, optional\n", "            The right xlim in data coordinates. Passing *None* leaves the\n", "            limit unchanged.\n", "\n", "        emit : bool, default: True\n", "            Whether to notify observers of limit change.\n", "\n", "        auto : bool or None, default: False\n", "            Whether to turn on autoscaling of the x-axis. True turns on,\n", "            False turns off, None leaves unchanged.\n", "\n", "        xmin, xmax : float, optional\n", "            They are equivalent to left and right respectively, and it is an\n", "            error to pass both *xmin* and *left* or *xmax* and *right*.\n", "\n", "        Returns\n", "        -------\n", "        left, right : (float, float)\n", "            The new x-axis limits in data coordinates.\n", "\n", "        See Also\n", "        --------\n", "        get_xlim\n", "        set_xbound, get_xbound\n", "        invert_xaxis, xaxis_inverted\n", "\n", "        Notes\n", "        -----\n", "        The *left* value may be greater than the *right* value, in which\n", "        case the x-axis values will decrease from left to right.\n", "\n", "        Examples\n", "        --------\n", "        >>> set_xlim(left, right)\n", "        >>> set_xlim((left, right))\n", "        >>> left, right = set_xlim(left, right)\n", "\n", "        One limit may be left unchanged.\n", "\n", "        >>> set_xlim(right=right_lim)\n", "\n", "        Limits may be passed in reverse order to flip the direction of\n", "        the x-axis. For example, suppose *x* represents the number of\n", "        years before present. The x-axis limits might be set like the\n", "        following so 5000 years ago is on the left of the plot and the\n", "        present is on the right.\n", "\n", "        >>> set_xlim(5000, 0)\n", "        \"\"\"\n", "        if right is None and np.iterable(left):\n", "            left, right = left\n", "        if xmin is not None:\n", "            if left is not None:\n", "                raise TypeError(\"Cannot pass both 'left' and 'xmin'\")\n", "            left = xmin\n", "        if xmax is not None:\n", "            if right is not None:\n", "                raise TypeError(\"Cannot pass both 'right' and 'xmax'\")\n", "            right = xmax\n", "        return self.xaxis._set_lim(left, right, emit=emit, auto=auto)\n"]}]}, {"file_path": "lib/matplotlib/axis.py", "span_ids": ["Axis._set_lim"], "content": [{"span_id": "Axis._set_lim", "start_line": 1179, "end_line": 1251, "content": ["    def _set_lim(self, v0, v1, *, emit=True, auto):\n", "        \"\"\"\n", "        Set view limits.\n", "\n", "        This method is a helper for the Axes ``set_xlim``, ``set_ylim``, and\n", "        ``set_zlim`` methods.\n", "\n", "        Parameters\n", "        ----------\n", "        v0, v1 : float\n", "            The view limits.  (Passing *v0* as a (low, high) pair is not\n", "            supported; normalization must occur in the Axes setters.)\n", "        emit : bool, default: True\n", "            Whether to notify observers of limit change.\n", "        auto : bool or None, default: False\n", "            Whether to turn on autoscaling of the x-axis. True turns on, False\n", "            turns off, None leaves unchanged.\n", "        \"\"\"\n", "        name = self._get_axis_name()\n", "\n", "        self.axes._process_unit_info([(name, (v0, v1))], convert=False)\n", "        v0 = self.axes._validate_converted_limits(v0, self.convert_units)\n", "        v1 = self.axes._validate_converted_limits(v1, self.convert_units)\n", "\n", "        if v0 is None or v1 is None:\n", "            # Axes init calls set_xlim(0, 1) before get_xlim() can be called,\n", "            # so only grab the limits if we really need them.\n", "            old0, old1 = self.get_view_interval()\n", "            if v0 is None:\n", "                v0 = old0\n", "            if v1 is None:\n", "                v1 = old1\n", "\n", "        if self.get_scale() == 'log' and (v0 <= 0 or v1 <= 0):\n", "            # Axes init calls set_xlim(0, 1) before get_xlim() can be called,\n", "            # so only grab the limits if we really need them.\n", "            old0, old1 = self.get_view_interval()\n", "            if v0 <= 0:\n", "                _api.warn_external(f\"Attempt to set non-positive {name}lim on \"\n", "                                   f\"a log-scaled axis will be ignored.\")\n", "                v0 = old0\n", "            if v1 <= 0:\n", "                _api.warn_external(f\"Attempt to set non-positive {name}lim on \"\n", "                                   f\"a log-scaled axis will be ignored.\")\n", "                v1 = old1\n", "        if v0 == v1:\n", "            _api.warn_external(\n", "                f\"Attempting to set identical low and high {name}lims \"\n", "                f\"makes transformation singular; automatically expanding.\")\n", "        reverse = bool(v0 > v1)  # explicit cast needed for python3.8+np.bool_.\n", "        v0, v1 = self.get_major_locator().nonsingular(v0, v1)\n", "        v0, v1 = self.limit_range_for_scale(v0, v1)\n", "        v0, v1 = sorted([v0, v1], reverse=bool(reverse))\n", "\n", "        self.set_view_interval(v0, v1, ignore=True)\n", "        # Mark viewlims as no longer stale without triggering an autoscale.\n", "        for ax in self._get_shared_axes():\n", "            ax._stale_viewlims[name] = False\n", "        if auto is not None:\n", "            self._set_autoscale_on(bool(auto))\n", "\n", "        if emit:\n", "            self.axes.callbacks.process(f\"{name}lim_changed\", self.axes)\n", "            # Call all of the other axes that are shared with this one\n", "            for other in self._get_shared_axes():\n", "                if other is not self.axes:\n", "                    other._axis_map[name]._set_lim(\n", "                        v0, v1, emit=False, auto=auto)\n", "                    if other.figure != self.figure:\n", "                        other.figure.canvas.draw_idle()\n", "\n", "        self.stale = True\n", "        return v0, v1\n"]}]}]}