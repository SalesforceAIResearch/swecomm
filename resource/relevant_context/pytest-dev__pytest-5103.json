{"instance_id": "pytest-dev__pytest-5103", "identified_spans": [{"file_path": "src/_pytest/assertion/rewrite.py", "span_ids": ["AssertionRewritingHook.find_module", "AssertionRewritingHook", "AssertionRewriter.visit_Assert", "AssertionRewriter.visit_Call_legacy", "_call_reprcompare", "AssertionRewriter.visit_Call_35", "AssertionRewriter"], "content": [{"span_id": "AssertionRewritingHook.find_module", "start_line": 84, "end_line": 179, "content": ["    def find_module(self, name, path=None):\n", "        if self._writing_pyc:\n", "            return None\n", "        state = self.config._assertstate\n", "        if self._early_rewrite_bailout(name, state):\n", "            return None\n", "        state.trace(\"find_module called for: %s\" % name)\n", "        names = name.rsplit(\".\", 1)\n", "        lastname = names[-1]\n", "        pth = None\n", "        if path is not None:\n", "            # Starting with Python 3.3, path is a _NamespacePath(), which\n", "            # causes problems if not converted to list.\n", "            path = list(path)\n", "            if len(path) == 1:\n", "                pth = path[0]\n", "        if pth is None:\n", "            try:\n", "                fd, fn, desc = self._imp_find_module(lastname, path)\n", "            except ImportError:\n", "                return None\n", "            if fd is not None:\n", "                fd.close()\n", "            tp = desc[2]\n", "            if tp == imp.PY_COMPILED:\n", "                if hasattr(imp, \"source_from_cache\"):\n", "                    try:\n", "                        fn = imp.source_from_cache(fn)\n", "                    except ValueError:\n", "                        # Python 3 doesn't like orphaned but still-importable\n", "                        # .pyc files.\n", "                        fn = fn[:-1]\n", "                else:\n", "                    fn = fn[:-1]\n", "            elif tp != imp.PY_SOURCE:\n", "                # Don't know what this is.\n", "                return None\n", "        else:\n", "            fn = os.path.join(pth, name.rpartition(\".\")[2] + \".py\")\n", "\n", "        fn_pypath = py.path.local(fn)\n", "        if not self._should_rewrite(name, fn_pypath, state):\n", "            return None\n", "\n", "        self._rewritten_names.add(name)\n", "\n", "        # The requested module looks like a test file, so rewrite it. This is\n", "        # the most magical part of the process: load the source, rewrite the\n", "        # asserts, and load the rewritten source. We also cache the rewritten\n", "        # module code in a special pyc. We must be aware of the possibility of\n", "        # concurrent pytest processes rewriting and loading pycs. To avoid\n", "        # tricky race conditions, we maintain the following invariant: The\n", "        # cached pyc is always a complete, valid pyc. Operations on it must be\n", "        # atomic. POSIX's atomic rename comes in handy.\n", "        write = not sys.dont_write_bytecode\n", "        cache_dir = os.path.join(fn_pypath.dirname, \"__pycache__\")\n", "        if write:\n", "            try:\n", "                os.mkdir(cache_dir)\n", "            except OSError:\n", "                e = sys.exc_info()[1].errno\n", "                if e == errno.EEXIST:\n", "                    # Either the __pycache__ directory already exists (the\n", "                    # common case) or it's blocked by a non-dir node. In the\n", "                    # latter case, we'll ignore it in _write_pyc.\n", "                    pass\n", "                elif e in [errno.ENOENT, errno.ENOTDIR]:\n", "                    # One of the path components was not a directory, likely\n", "                    # because we're in a zip file.\n", "                    write = False\n", "                elif e in [errno.EACCES, errno.EROFS, errno.EPERM]:\n", "                    state.trace(\"read only directory: %r\" % fn_pypath.dirname)\n", "                    write = False\n", "                else:\n", "                    raise\n", "        cache_name = fn_pypath.basename[:-3] + PYC_TAIL\n", "        pyc = os.path.join(cache_dir, cache_name)\n", "        # Notice that even if we're in a read-only directory, I'm going\n", "        # to check for a cached pyc. This may not be optimal...\n", "        co = _read_pyc(fn_pypath, pyc, state.trace)\n", "        if co is None:\n", "            state.trace(\"rewriting %r\" % (fn,))\n", "            source_stat, co = _rewrite_test(self.config, fn_pypath)\n", "            if co is None:\n", "                # Probably a SyntaxError in the test.\n", "                return None\n", "            if write:\n", "                self._writing_pyc = True\n", "                try:\n", "                    _write_pyc(state, co, source_stat, pyc)\n", "                finally:\n", "                    self._writing_pyc = False\n", "        else:\n", "            state.trace(\"found cached rewritten pyc for %r\" % (fn,))\n", "        self.modules[name] = co, pyc\n", "        return self\n"]}, {"span_id": "AssertionRewritingHook", "start_line": 58, "end_line": 59, "content": ["class AssertionRewritingHook(object):\n", "    \"\"\"PEP302 Import hook which rewrites asserts.\"\"\"\n"]}, {"span_id": "AssertionRewriter.visit_Assert", "start_line": 814, "end_line": 879, "content": ["    def visit_Assert(self, assert_):\n", "        \"\"\"Return the AST statements to replace the ast.Assert instance.\n", "\n", "        This rewrites the test of an assertion to provide\n", "        intermediate values and replace it with an if statement which\n", "        raises an assertion error with a detailed explanation in case\n", "        the expression is false.\n", "\n", "        \"\"\"\n", "        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n", "            from _pytest.warning_types import PytestAssertRewriteWarning\n", "            import warnings\n", "\n", "            warnings.warn_explicit(\n", "                PytestAssertRewriteWarning(\n", "                    \"assertion is always true, perhaps remove parentheses?\"\n", "                ),\n", "                category=None,\n", "                filename=str(self.module_path),\n", "                lineno=assert_.lineno,\n", "            )\n", "\n", "        self.statements = []\n", "        self.variables = []\n", "        self.variable_counter = itertools.count()\n", "        self.stack = []\n", "        self.on_failure = []\n", "        self.push_format_context()\n", "        # Rewrite assert into a bunch of statements.\n", "        top_condition, explanation = self.visit(assert_.test)\n", "        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n", "        if self.module_path is not None:\n", "            self.statements.append(\n", "                self.warn_about_none_ast(\n", "                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n", "                )\n", "            )\n", "        # Create failure message.\n", "        body = self.on_failure\n", "        negation = ast.UnaryOp(ast.Not(), top_condition)\n", "        self.statements.append(ast.If(negation, body, []))\n", "        if assert_.msg:\n", "            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n", "            explanation = \"\\n>assert \" + explanation\n", "        else:\n", "            assertmsg = ast.Str(\"\")\n", "            explanation = \"assert \" + explanation\n", "        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n", "        msg = self.pop_format_context(template)\n", "        fmt = self.helper(\"_format_explanation\", msg)\n", "        err_name = ast.Name(\"AssertionError\", ast.Load())\n", "        exc = ast_Call(err_name, [fmt], [])\n", "        if sys.version_info[0] >= 3:\n", "            raise_ = ast.Raise(exc, None)\n", "        else:\n", "            raise_ = ast.Raise(exc, None, None)\n", "        body.append(raise_)\n", "        # Clear temporary variables by setting them to None.\n", "        if self.variables:\n", "            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n", "            clear = ast.Assign(variables, _NameConstant(None))\n", "            self.statements.append(clear)\n", "        # Fix line numbers.\n", "        for stmt in self.statements:\n", "            set_location(stmt, assert_.lineno, assert_.col_offset)\n", "        return self.statements\n"]}, {"span_id": "AssertionRewriter.visit_Call_legacy", "start_line": 1000, "end_line": 1028, "content": ["    def visit_Call_legacy(self, call):\n", "        \"\"\"\n", "        visit `ast.Call nodes on 3.4 and below`\n", "        \"\"\"\n", "        new_func, func_expl = self.visit(call.func)\n", "        arg_expls = []\n", "        new_args = []\n", "        new_kwargs = []\n", "        new_star = new_kwarg = None\n", "        for arg in call.args:\n", "            res, expl = self.visit(arg)\n", "            new_args.append(res)\n", "            arg_expls.append(expl)\n", "        for keyword in call.keywords:\n", "            res, expl = self.visit(keyword.value)\n", "            new_kwargs.append(ast.keyword(keyword.arg, res))\n", "            arg_expls.append(keyword.arg + \"=\" + expl)\n", "        if call.starargs:\n", "            new_star, expl = self.visit(call.starargs)\n", "            arg_expls.append(\"*\" + expl)\n", "        if call.kwargs:\n", "            new_kwarg, expl = self.visit(call.kwargs)\n", "            arg_expls.append(\"**\" + expl)\n", "        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n", "        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n", "        res = self.assign(new_call)\n", "        res_expl = self.explanation_param(self.display(res))\n", "        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n", "        return res, outer_expl\n"]}, {"span_id": "_call_reprcompare", "start_line": 537, "end_line": 549, "content": ["def _call_reprcompare(ops, results, expls, each_obj):\n", "    for i, res, expl in zip(range(len(ops)), results, expls):\n", "        try:\n", "            done = not res\n", "        except Exception:\n", "            done = True\n", "        if done:\n", "            break\n", "    if util._reprcompare is not None:\n", "        custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])\n", "        if custom is not None:\n", "            return custom\n", "    return expl\n"]}, {"span_id": "AssertionRewriter.visit_Call_35", "start_line": 967, "end_line": 992, "content": ["    def visit_Call_35(self, call):\n", "        \"\"\"\n", "        visit `ast.Call` nodes on Python3.5 and after\n", "        \"\"\"\n", "        new_func, func_expl = self.visit(call.func)\n", "        arg_expls = []\n", "        new_args = []\n", "        new_kwargs = []\n", "        for arg in call.args:\n", "            res, expl = self.visit(arg)\n", "            arg_expls.append(expl)\n", "            new_args.append(res)\n", "        for keyword in call.keywords:\n", "            res, expl = self.visit(keyword.value)\n", "            new_kwargs.append(ast.keyword(keyword.arg, res))\n", "            if keyword.arg:\n", "                arg_expls.append(keyword.arg + \"=\" + expl)\n", "            else:  # **args have `arg` keywords with an .arg of None\n", "                arg_expls.append(\"**\" + expl)\n", "\n", "        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n", "        new_call = ast.Call(new_func, new_args, new_kwargs)\n", "        res = self.assign(new_call)\n", "        res_expl = self.explanation_param(self.display(res))\n", "        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n", "        return res, outer_expl\n"]}, {"span_id": "AssertionRewriter", "start_line": 608, "end_line": 658, "content": ["class AssertionRewriter(ast.NodeVisitor):\n", "    \"\"\"Assertion rewriting implementation.\n", "\n", "    The main entrypoint is to call .run() with an ast.Module instance,\n", "    this will then find all the assert statements and rewrite them to\n", "    provide intermediate values and a detailed assertion error.  See\n", "    http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n", "    for an overview of how this works.\n", "\n", "    The entry point here is .run() which will iterate over all the\n", "    statements in an ast.Module and for each ast.Assert statement it\n", "    finds call .visit() with it.  Then .visit_Assert() takes over and\n", "    is responsible for creating new ast statements to replace the\n", "    original assert statement: it rewrites the test of an assertion\n", "    to provide intermediate values and replace it with an if statement\n", "    which raises an assertion error with a detailed explanation in\n", "    case the expression is false.\n", "\n", "    For this .visit_Assert() uses the visitor pattern to visit all the\n", "    AST nodes of the ast.Assert.test field, each visit call returning\n", "    an AST node and the corresponding explanation string.  During this\n", "    state is kept in several instance attributes:\n", "\n", "    :statements: All the AST statements which will replace the assert\n", "       statement.\n", "\n", "    :variables: This is populated by .variable() with each variable\n", "       used by the statements so that they can all be set to None at\n", "       the end of the statements.\n", "\n", "    :variable_counter: Counter to create new unique variables needed\n", "       by statements.  Variables are created using .variable() and\n", "       have the form of \"@py_assert0\".\n", "\n", "    :on_failure: The AST statements which will be executed if the\n", "       assertion test fails.  This is the code which will construct\n", "       the failure message and raises the AssertionError.\n", "\n", "    :explanation_specifiers: A dict filled by .explanation_param()\n", "       with %-formatting placeholders and their corresponding\n", "       expressions to use in the building of an assertion message.\n", "       This is used by .pop_format_context() to build a message.\n", "\n", "    :stack: A stack of the explanation_specifiers dicts maintained by\n", "       .push_format_context() and .pop_format_context() which allows\n", "       to build another %-formatted string while already building one.\n", "\n", "    This state is reset on every new assert statement visited and used\n", "    by the other visitors.\n", "\n", "    \"\"\"\n"]}]}]}