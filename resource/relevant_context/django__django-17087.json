{"instance_id": "django__django-17087", "identified_spans": [{"file_path": "django/contrib/postgres/fields/array.py", "span_ids": ["ArrayField", "ArrayField.__init__"], "content": [{"span_id": "ArrayField", "start_line": 18, "end_line": 24, "content": ["class ArrayField(CheckFieldDefaultMixin, Field):\n", "    empty_strings_allowed = False\n", "    default_error_messages = {\n", "        \"item_invalid\": _(\"Item %(nth)s in the array did not validate:\"),\n", "        \"nested_array_mismatch\": _(\"Nested arrays must have the same length.\"),\n", "    }\n", "    _default_hint = (\"list\", \"[]\")\n"]}, {"span_id": "ArrayField.__init__", "start_line": 26, "end_line": 39, "content": ["    def __init__(self, base_field, size=None, **kwargs):\n", "        self.base_field = base_field\n", "        self.db_collation = getattr(self.base_field, \"db_collation\", None)\n", "        self.size = size\n", "        if self.size:\n", "            self.default_validators = [\n", "                *self.default_validators,\n", "                ArrayMaxLengthValidator(self.size),\n", "            ]\n", "        # For performance, only add a from_db_value() method if the base field\n", "        # implements it.\n", "        if hasattr(self.base_field, \"from_db_value\"):\n", "            self.from_db_value = self._from_db_value\n", "        super().__init__(**kwargs)\n"]}]}, {"file_path": "django/db/migrations/writer.py", "span_ids": ["MigrationWriter.as_string", "MigrationWriter", "OperationWriter", "OperationWriter.serialize"], "content": [{"span_id": "MigrationWriter.as_string", "start_line": 129, "end_line": 209, "content": ["    def as_string(self):\n", "        \"\"\"Return a string of the file contents.\"\"\"\n", "        items = {\n", "            \"replaces_str\": \"\",\n", "            \"initial_str\": \"\",\n", "        }\n", "\n", "        imports = set()\n", "\n", "        # Deconstruct operations\n", "        operations = []\n", "        for operation in self.migration.operations:\n", "            operation_string, operation_imports = OperationWriter(operation).serialize()\n", "            imports.update(operation_imports)\n", "            operations.append(operation_string)\n", "        items[\"operations\"] = \"\\n\".join(operations) + \"\\n\" if operations else \"\"\n", "\n", "        # Format dependencies and write out swappable dependencies right\n", "        dependencies = []\n", "        for dependency in self.migration.dependencies:\n", "            if dependency[0] == \"__setting__\":\n", "                dependencies.append(\n", "                    \"        migrations.swappable_dependency(settings.%s),\"\n", "                    % dependency[1]\n", "                )\n", "                imports.add(\"from django.conf import settings\")\n", "            else:\n", "                dependencies.append(\"        %s,\" % self.serialize(dependency)[0])\n", "        items[\"dependencies\"] = (\n", "            \"\\n\".join(sorted(dependencies)) + \"\\n\" if dependencies else \"\"\n", "        )\n", "\n", "        # Format imports nicely, swapping imports of functions from migration files\n", "        # for comments\n", "        migration_imports = set()\n", "        for line in list(imports):\n", "            if re.match(r\"^import (.*)\\.\\d+[^\\s]*$\", line):\n", "                migration_imports.add(line.split(\"import\")[1].strip())\n", "                imports.remove(line)\n", "                self.needs_manual_porting = True\n", "\n", "        # django.db.migrations is always used, but models import may not be.\n", "        # If models import exists, merge it with migrations import.\n", "        if \"from django.db import models\" in imports:\n", "            imports.discard(\"from django.db import models\")\n", "            imports.add(\"from django.db import migrations, models\")\n", "        else:\n", "            imports.add(\"from django.db import migrations\")\n", "\n", "        # Sort imports by the package / module to be imported (the part after\n", "        # \"from\" in \"from ... import ...\" or after \"import\" in \"import ...\").\n", "        # First group the \"import\" statements, then \"from ... import ...\".\n", "        sorted_imports = sorted(\n", "            imports, key=lambda i: (i.split()[0] == \"from\", i.split()[1])\n", "        )\n", "        items[\"imports\"] = \"\\n\".join(sorted_imports) + \"\\n\" if imports else \"\"\n", "        if migration_imports:\n", "            items[\"imports\"] += (\n", "                \"\\n\\n# Functions from the following migrations need manual \"\n", "                \"copying.\\n# Move them and any dependencies into this file, \"\n", "                \"then update the\\n# RunPython operations to refer to the local \"\n", "                \"versions:\\n# %s\"\n", "            ) % \"\\n# \".join(sorted(migration_imports))\n", "        # If there's a replaces, make a string for it\n", "        if self.migration.replaces:\n", "            items[\"replaces_str\"] = (\n", "                \"\\n    replaces = %s\\n\" % self.serialize(self.migration.replaces)[0]\n", "            )\n", "        # Hinting that goes into comment\n", "        if self.include_header:\n", "            items[\"migration_header\"] = MIGRATION_HEADER_TEMPLATE % {\n", "                \"version\": get_version(),\n", "                \"timestamp\": now().strftime(\"%Y-%m-%d %H:%M\"),\n", "            }\n", "        else:\n", "            items[\"migration_header\"] = \"\"\n", "\n", "        if self.migration.initial:\n", "            items[\"initial_str\"] = \"\\n    initial = True\\n\"\n", "\n", "        return MIGRATION_TEMPLATE % items\n"]}, {"span_id": "MigrationWriter", "start_line": 118, "end_line": 122, "content": ["class MigrationWriter:\n", "    \"\"\"\n", "    Take a Migration instance and is able to produce the contents\n", "    of the migration file from it.\n", "    \"\"\"\n"]}, {"span_id": "OperationWriter", "start_line": 18, "end_line": 18, "content": ["class OperationWriter:\n"]}, {"span_id": "OperationWriter.serialize", "start_line": 24, "end_line": 103, "content": ["    def serialize(self):\n", "        def _write(_arg_name, _arg_value):\n", "            if _arg_name in self.operation.serialization_expand_args and isinstance(\n", "                _arg_value, (list, tuple, dict)\n", "            ):\n", "                if isinstance(_arg_value, dict):\n", "                    self.feed(\"%s={\" % _arg_name)\n", "                    self.indent()\n", "                    for key, value in _arg_value.items():\n", "                        key_string, key_imports = MigrationWriter.serialize(key)\n", "                        arg_string, arg_imports = MigrationWriter.serialize(value)\n", "                        args = arg_string.splitlines()\n", "                        if len(args) > 1:\n", "                            self.feed(\"%s: %s\" % (key_string, args[0]))\n", "                            for arg in args[1:-1]:\n", "                                self.feed(arg)\n", "                            self.feed(\"%s,\" % args[-1])\n", "                        else:\n", "                            self.feed(\"%s: %s,\" % (key_string, arg_string))\n", "                        imports.update(key_imports)\n", "                        imports.update(arg_imports)\n", "                    self.unindent()\n", "                    self.feed(\"},\")\n", "                else:\n", "                    self.feed(\"%s=[\" % _arg_name)\n", "                    self.indent()\n", "                    for item in _arg_value:\n", "                        arg_string, arg_imports = MigrationWriter.serialize(item)\n", "                        args = arg_string.splitlines()\n", "                        if len(args) > 1:\n", "                            for arg in args[:-1]:\n", "                                self.feed(arg)\n", "                            self.feed(\"%s,\" % args[-1])\n", "                        else:\n", "                            self.feed(\"%s,\" % arg_string)\n", "                        imports.update(arg_imports)\n", "                    self.unindent()\n", "                    self.feed(\"],\")\n", "            else:\n", "                arg_string, arg_imports = MigrationWriter.serialize(_arg_value)\n", "                args = arg_string.splitlines()\n", "                if len(args) > 1:\n", "                    self.feed(\"%s=%s\" % (_arg_name, args[0]))\n", "                    for arg in args[1:-1]:\n", "                        self.feed(arg)\n", "                    self.feed(\"%s,\" % args[-1])\n", "                else:\n", "                    self.feed(\"%s=%s,\" % (_arg_name, arg_string))\n", "                imports.update(arg_imports)\n", "\n", "        imports = set()\n", "        name, args, kwargs = self.operation.deconstruct()\n", "        operation_args = get_func_args(self.operation.__init__)\n", "\n", "        # See if this operation is in django.db.migrations. If it is,\n", "        # We can just use the fact we already have that imported,\n", "        # otherwise, we need to add an import for the operation class.\n", "        if getattr(migrations, name, None) == self.operation.__class__:\n", "            self.feed(\"migrations.%s(\" % name)\n", "        else:\n", "            imports.add(\"import %s\" % (self.operation.__class__.__module__))\n", "            self.feed(\"%s.%s(\" % (self.operation.__class__.__module__, name))\n", "\n", "        self.indent()\n", "\n", "        for i, arg in enumerate(args):\n", "            arg_value = arg\n", "            arg_name = operation_args[i]\n", "            _write(arg_name, arg_value)\n", "\n", "        i = len(args)\n", "        # Only iterate over remaining arguments\n", "        for arg_name in operation_args[i:]:\n", "            if arg_name in kwargs:  # Don't sort to maintain signature order\n", "                arg_value = kwargs[arg_name]\n", "                _write(arg_name, arg_value)\n", "\n", "        self.unindent()\n", "        self.feed(\"),\")\n", "        return self.render(), imports\n"]}]}, {"file_path": "django/db/models/fields/__init__.py", "span_ids": ["Field._get_default", "Field.__init__", "Field.get_default"], "content": [{"span_id": "Field._get_default", "start_line": 1016, "end_line": 1034, "content": ["    @cached_property\n", "    def _get_default(self):\n", "        if self.has_default():\n", "            if callable(self.default):\n", "                return self.default\n", "            return lambda: self.default\n", "\n", "        if self.db_default is not NOT_PROVIDED:\n", "            from django.db.models.expressions import DatabaseDefault\n", "\n", "            return DatabaseDefault\n", "\n", "        if (\n", "            not self.empty_strings_allowed\n", "            or self.null\n", "            and not connection.features.interprets_empty_strings_as_nulls\n", "        ):\n", "            return return_None\n", "        return str  # return empty string\n"]}, {"span_id": "Field.__init__", "start_line": 180, "end_line": 250, "content": ["    def __init__(\n", "        self,\n", "        verbose_name=None,\n", "        name=None,\n", "        primary_key=False,\n", "        max_length=None,\n", "        unique=False,\n", "        blank=False,\n", "        null=False,\n", "        db_index=False,\n", "        rel=None,\n", "        default=NOT_PROVIDED,\n", "        editable=True,\n", "        serialize=True,\n", "        unique_for_date=None,\n", "        unique_for_month=None,\n", "        unique_for_year=None,\n", "        choices=None,\n", "        help_text=\"\",\n", "        db_column=None,\n", "        db_tablespace=None,\n", "        auto_created=False,\n", "        validators=(),\n", "        error_messages=None,\n", "        db_comment=None,\n", "        db_default=NOT_PROVIDED,\n", "    ):\n", "        self.name = name\n", "        self.verbose_name = verbose_name  # May be set by set_attributes_from_name\n", "        self._verbose_name = verbose_name  # Store original for deconstruction\n", "        self.primary_key = primary_key\n", "        self.max_length, self._unique = max_length, unique\n", "        self.blank, self.null = blank, null\n", "        self.remote_field = rel\n", "        self.is_relation = self.remote_field is not None\n", "        self.default = default\n", "        if db_default is not NOT_PROVIDED and not hasattr(\n", "            db_default, \"resolve_expression\"\n", "        ):\n", "            from django.db.models.expressions import Value\n", "\n", "            db_default = Value(db_default)\n", "        self.db_default = db_default\n", "        self.editable = editable\n", "        self.serialize = serialize\n", "        self.unique_for_date = unique_for_date\n", "        self.unique_for_month = unique_for_month\n", "        self.unique_for_year = unique_for_year\n", "        if isinstance(choices, ChoicesMeta):\n", "            choices = choices.choices\n", "        if isinstance(choices, collections.abc.Iterator):\n", "            choices = list(choices)\n", "        self.choices = choices\n", "        self.help_text = help_text\n", "        self.db_index = db_index\n", "        self.db_column = db_column\n", "        self.db_comment = db_comment\n", "        self._db_tablespace = db_tablespace\n", "        self.auto_created = auto_created\n", "\n", "        # Adjust the appropriate creation counter, and save our local copy.\n", "        if auto_created:\n", "            self.creation_counter = Field.auto_creation_counter\n", "            Field.auto_creation_counter -= 1\n", "        else:\n", "            self.creation_counter = Field.creation_counter\n", "            Field.creation_counter += 1\n", "\n", "        self._validators = list(validators)  # Store for deconstruction later\n", "\n", "        self._error_messages = error_messages  # Store for deconstruction later\n"]}, {"span_id": "Field.get_default", "start_line": 1012, "end_line": 1014, "content": ["    def get_default(self):\n", "        \"\"\"Return the default value for this field.\"\"\"\n", "        return self._get_default()\n"]}]}]}