{"instance_id": "django__django-11742", "identified_spans": [{"file_path": "django/db/models/fields/__init__.py", "span_ids": ["CharField", "CharField.__init__", "CharField.check", "CharField._check_max_length_attribute", "Field.__init__", "Field._check_choices"], "content": [{"span_id": "CharField", "start_line": 947, "end_line": 948, "content": ["class CharField(Field):\n", "    description = _(\"String (up to %(max_length)s)\")\n"]}, {"span_id": "CharField.__init__", "start_line": 950, "end_line": 952, "content": ["    def __init__(self, *args, **kwargs):\n", "        super().__init__(*args, **kwargs)\n", "        self.validators.append(validators.MaxLengthValidator(self.max_length))\n"]}, {"span_id": "CharField.check", "start_line": 954, "end_line": 958, "content": ["    def check(self, **kwargs):\n", "        return [\n", "            *super().check(**kwargs),\n", "            *self._check_max_length_attribute(**kwargs),\n", "        ]\n"]}, {"span_id": "CharField._check_max_length_attribute", "start_line": 960, "end_line": 979, "content": ["    def _check_max_length_attribute(self, **kwargs):\n", "        if self.max_length is None:\n", "            return [\n", "                checks.Error(\n", "                    \"CharFields must define a 'max_length' attribute.\",\n", "                    obj=self,\n", "                    id='fields.E120',\n", "                )\n", "            ]\n", "        elif (not isinstance(self.max_length, int) or isinstance(self.max_length, bool) or\n", "                self.max_length <= 0):\n", "            return [\n", "                checks.Error(\n", "                    \"'max_length' must be a positive integer.\",\n", "                    obj=self,\n", "                    id='fields.E121',\n", "                )\n", "            ]\n", "        else:\n", "            return []\n"]}, {"span_id": "Field.__init__", "start_line": 135, "end_line": 180, "content": ["    def __init__(self, verbose_name=None, name=None, primary_key=False,\n", "                 max_length=None, unique=False, blank=False, null=False,\n", "                 db_index=False, rel=None, default=NOT_PROVIDED, editable=True,\n", "                 serialize=True, unique_for_date=None, unique_for_month=None,\n", "                 unique_for_year=None, choices=None, help_text='', db_column=None,\n", "                 db_tablespace=None, auto_created=False, validators=(),\n", "                 error_messages=None):\n", "        self.name = name\n", "        self.verbose_name = verbose_name  # May be set by set_attributes_from_name\n", "        self._verbose_name = verbose_name  # Store original for deconstruction\n", "        self.primary_key = primary_key\n", "        self.max_length, self._unique = max_length, unique\n", "        self.blank, self.null = blank, null\n", "        self.remote_field = rel\n", "        self.is_relation = self.remote_field is not None\n", "        self.default = default\n", "        self.editable = editable\n", "        self.serialize = serialize\n", "        self.unique_for_date = unique_for_date\n", "        self.unique_for_month = unique_for_month\n", "        self.unique_for_year = unique_for_year\n", "        if isinstance(choices, collections.abc.Iterator):\n", "            choices = list(choices)\n", "        self.choices = choices\n", "        self.help_text = help_text\n", "        self.db_index = db_index\n", "        self.db_column = db_column\n", "        self._db_tablespace = db_tablespace\n", "        self.auto_created = auto_created\n", "\n", "        # Adjust the appropriate creation counter, and save our local copy.\n", "        if auto_created:\n", "            self.creation_counter = Field.auto_creation_counter\n", "            Field.auto_creation_counter -= 1\n", "        else:\n", "            self.creation_counter = Field.creation_counter\n", "            Field.creation_counter += 1\n", "\n", "        self._validators = list(validators)  # Store for deconstruction later\n", "\n", "        messages = {}\n", "        for c in reversed(self.__class__.__mro__):\n", "            messages.update(getattr(c, 'default_error_messages', {}))\n", "        messages.update(error_messages or {})\n", "        self._error_messages = error_messages  # Store for deconstruction later\n", "        self.error_messages = messages\n"]}, {"span_id": "Field._check_choices", "start_line": 244, "end_line": 292, "content": ["    def _check_choices(self):\n", "        if not self.choices:\n", "            return []\n", "\n", "        def is_value(value, accept_promise=True):\n", "            return isinstance(value, (str, Promise) if accept_promise else str) or not is_iterable(value)\n", "\n", "        if is_value(self.choices, accept_promise=False):\n", "            return [\n", "                checks.Error(\n", "                    \"'choices' must be an iterable (e.g., a list or tuple).\",\n", "                    obj=self,\n", "                    id='fields.E004',\n", "                )\n", "            ]\n", "\n", "        # Expect [group_name, [value, display]]\n", "        for choices_group in self.choices:\n", "            try:\n", "                group_name, group_choices = choices_group\n", "            except (TypeError, ValueError):\n", "                # Containing non-pairs\n", "                break\n", "            try:\n", "                if not all(\n", "                    is_value(value) and is_value(human_name)\n", "                    for value, human_name in group_choices\n", "                ):\n", "                    break\n", "            except (TypeError, ValueError):\n", "                # No groups, choices in the form [value, display]\n", "                value, human_name = group_name, group_choices\n", "                if not is_value(value) or not is_value(human_name):\n", "                    break\n", "\n", "            # Special case: choices=['ab']\n", "            if isinstance(choices_group, str):\n", "                break\n", "        else:\n", "            return []\n", "\n", "        return [\n", "            checks.Error(\n", "                \"'choices' must be an iterable containing \"\n", "                \"(actual value, human readable name) tuples.\",\n", "                obj=self,\n", "                id='fields.E005',\n", "            )\n", "        ]\n"]}]}]}