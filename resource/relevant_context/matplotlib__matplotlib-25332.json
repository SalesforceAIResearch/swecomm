{"instance_id": "matplotlib__matplotlib-25332", "identified_spans": [{"file_path": "lib/matplotlib/cbook.py", "span_ids": ["Grouper", "Grouper.__init__", "Grouper.join"], "content": [{"span_id": "Grouper", "start_line": 754, "end_line": 786, "content": ["class Grouper:\n", "    \"\"\"\n", "    A disjoint-set data structure.\n", "\n", "    Objects can be joined using :meth:`join`, tested for connectedness\n", "    using :meth:`joined`, and all disjoint sets can be retrieved by\n", "    using the object as an iterator.\n", "\n", "    The objects being joined must be hashable and weak-referenceable.\n", "\n", "    Examples\n", "    --------\n", "    >>> from matplotlib.cbook import Grouper\n", "    >>> class Foo:\n", "    ...     def __init__(self, s):\n", "    ...         self.s = s\n", "    ...     def __repr__(self):\n", "    ...         return self.s\n", "    ...\n", "    >>> a, b, c, d, e, f = [Foo(x) for x in 'abcdef']\n", "    >>> grp = Grouper()\n", "    >>> grp.join(a, b)\n", "    >>> grp.join(b, c)\n", "    >>> grp.join(d, e)\n", "    >>> list(grp)\n", "    [[a, b, c], [d, e]]\n", "    >>> grp.joined(a, b)\n", "    True\n", "    >>> grp.joined(a, c)\n", "    True\n", "    >>> grp.joined(a, d)\n", "    False\n", "    \"\"\"\n"]}, {"span_id": "Grouper.__init__", "start_line": 788, "end_line": 789, "content": ["    def __init__(self, init=()):\n", "        self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n"]}, {"span_id": "Grouper.join", "start_line": 802, "end_line": 818, "content": ["    def join(self, a, *args):\n", "        \"\"\"\n", "        Join given arguments into the same set.  Accepts one or more arguments.\n", "        \"\"\"\n", "        mapping = self._mapping\n", "        set_a = mapping.setdefault(weakref.ref(a), [weakref.ref(a)])\n", "\n", "        for arg in args:\n", "            set_b = mapping.get(weakref.ref(arg), [weakref.ref(arg)])\n", "            if set_b is not set_a:\n", "                if len(set_b) > len(set_a):\n", "                    set_a, set_b = set_b, set_a\n", "                set_a.extend(set_b)\n", "                for elem in set_b:\n", "                    mapping[elem] = set_a\n", "\n", "        self.clean()\n"]}]}, {"file_path": "lib/matplotlib/figure.py", "span_ids": ["Figure.__setstate__", "FigureBase.align_labels", "Figure.__getstate__"], "content": [{"span_id": "Figure.__setstate__", "start_line": 3179, "end_line": 3204, "content": ["    def __setstate__(self, state):\n", "        version = state.pop('__mpl_version__')\n", "        restore_to_pylab = state.pop('_restore_to_pylab', False)\n", "\n", "        if version != mpl.__version__:\n", "            _api.warn_external(\n", "                f\"This figure was saved with matplotlib version {version} and \"\n", "                f\"is unlikely to function correctly.\")\n", "\n", "        self.__dict__ = state\n", "\n", "        # re-initialise some of the unstored state information\n", "        FigureCanvasBase(self)  # Set self.canvas.\n", "\n", "        if restore_to_pylab:\n", "            # lazy import to avoid circularity\n", "            import matplotlib.pyplot as plt\n", "            import matplotlib._pylab_helpers as pylab_helpers\n", "            allnums = plt.get_fignums()\n", "            num = max(allnums) + 1 if allnums else 1\n", "            backend = plt._get_backend_mod()\n", "            mgr = backend.new_figure_manager_given_figure(num, self)\n", "            pylab_helpers.Gcf._set_new_active_manager(mgr)\n", "            plt.draw_if_interactive()\n", "\n", "        self.stale = True\n"]}, {"span_id": "FigureBase.align_labels", "start_line": 1456, "end_line": 1478, "content": ["    def align_labels(self, axs=None):\n", "        \"\"\"\n", "        Align the xlabels and ylabels of subplots with the same subplots\n", "        row or column (respectively) if label alignment is being\n", "        done automatically (i.e. the label position is not manually set).\n", "\n", "        Alignment persists for draw events after this is called.\n", "\n", "        Parameters\n", "        ----------\n", "        axs : list of `~matplotlib.axes.Axes`\n", "            Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`\n", "            to align the labels.\n", "            Default is to align all Axes on the figure.\n", "\n", "        See Also\n", "        --------\n", "        matplotlib.figure.Figure.align_xlabels\n", "\n", "        matplotlib.figure.Figure.align_ylabels\n", "        \"\"\"\n", "        self.align_xlabels(axs=axs)\n", "        self.align_ylabels(axs=axs)\n"]}, {"span_id": "Figure.__getstate__", "start_line": 3159, "end_line": 3177, "content": ["    def __getstate__(self):\n", "        state = super().__getstate__()\n", "\n", "        # The canvas cannot currently be pickled, but this has the benefit\n", "        # of meaning that a figure can be detached from one canvas, and\n", "        # re-attached to another.\n", "        state.pop(\"canvas\")\n", "\n", "        # discard any changes to the dpi due to pixel ratio changes\n", "        state[\"_dpi\"] = state.get('_original_dpi', state['_dpi'])\n", "\n", "        # add version information to the state\n", "        state['__mpl_version__'] = mpl.__version__\n", "\n", "        # check whether the figure manager (if any) is registered with pyplot\n", "        from matplotlib import _pylab_helpers\n", "        if self.canvas.manager in _pylab_helpers.Gcf.figs.values():\n", "            state['_restore_to_pylab'] = True\n", "        return state\n"]}]}]}