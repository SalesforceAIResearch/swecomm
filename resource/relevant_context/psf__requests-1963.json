{"instance_id": "psf__requests-1963", "identified_spans": [{"file_path": "requests/sessions.py", "span_ids": ["SessionRedirectMixin.resolve_redirects"], "content": [{"span_id": "SessionRedirectMixin.resolve_redirects", "start_line": 84, "end_line": 184, "content": ["    def resolve_redirects(self, resp, req, stream=False, timeout=None,\n", "                          verify=True, cert=None, proxies=None):\n", "        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n", "\n", "        i = 0\n", "\n", "        while resp.is_redirect:\n", "            prepared_request = req.copy()\n", "\n", "            resp.content  # Consume socket so it can be released\n", "\n", "            if i >= self.max_redirects:\n", "                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)\n", "\n", "            # Release the connection back into the pool.\n", "            resp.close()\n", "\n", "            url = resp.headers['location']\n", "            method = req.method\n", "\n", "            # Handle redirection without scheme (see: RFC 1808 Section 4)\n", "            if url.startswith('//'):\n", "                parsed_rurl = urlparse(resp.url)\n", "                url = '%s:%s' % (parsed_rurl.scheme, url)\n", "\n", "            # The scheme should be lower case...\n", "            parsed = urlparse(url)\n", "            url = parsed.geturl()\n", "\n", "            # Facilitate non-RFC2616-compliant 'location' headers\n", "            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n", "            # Compliant with RFC3986, we percent encode the url.\n", "            if not urlparse(url).netloc:\n", "                url = urljoin(resp.url, requote_uri(url))\n", "            else:\n", "                url = requote_uri(url)\n", "\n", "            prepared_request.url = to_native_string(url)\n", "\n", "            # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n", "            if (resp.status_code == codes.see_other and\n", "                    method != 'HEAD'):\n", "                method = 'GET'\n", "\n", "            # Do what the browsers do, despite standards...\n", "            # First, turn 302s into GETs.\n", "            if resp.status_code == codes.found and method != 'HEAD':\n", "                method = 'GET'\n", "\n", "            # Second, if a POST is responded to with a 301, turn it into a GET.\n", "            # This bizarre behaviour is explained in Issue 1704.\n", "            if resp.status_code == codes.moved and method == 'POST':\n", "                method = 'GET'\n", "\n", "            prepared_request.method = method\n", "\n", "            # https://github.com/kennethreitz/requests/issues/1084\n", "            if resp.status_code not in (codes.temporary, codes.resume):\n", "                if 'Content-Length' in prepared_request.headers:\n", "                    del prepared_request.headers['Content-Length']\n", "\n", "                prepared_request.body = None\n", "\n", "            headers = prepared_request.headers\n", "            try:\n", "                del headers['Cookie']\n", "            except KeyError:\n", "                pass\n", "\n", "            extract_cookies_to_jar(prepared_request._cookies, prepared_request, resp.raw)\n", "            prepared_request._cookies.update(self.cookies)\n", "            prepared_request.prepare_cookies(prepared_request._cookies)\n", "\n", "            if 'Authorization' in headers:\n", "                # If we get redirected to a new host, we should strip out any\n", "                #\u00a0authentication headers.\n", "                original_parsed = urlparse(resp.request.url)\n", "                redirect_parsed = urlparse(url)\n", "\n", "                if (original_parsed.hostname != redirect_parsed.hostname):\n", "                    del headers['Authorization']\n", "\n", "            # .netrc might have more auth for us.\n", "            new_auth = get_netrc_auth(url) if self.trust_env else None\n", "            if new_auth is not None:\n", "                prepared_request.prepare_auth(new_auth)\n", "\n", "            resp = self.send(\n", "                prepared_request,\n", "                stream=stream,\n", "                timeout=timeout,\n", "                verify=verify,\n", "                cert=cert,\n", "                proxies=proxies,\n", "                allow_redirects=False,\n", "            )\n", "\n", "            extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)\n", "\n", "            i += 1\n", "            yield resp\n"]}]}]}