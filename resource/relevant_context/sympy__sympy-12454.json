{"instance_id": "sympy__sympy-12454", "identified_spans": [{"file_path": "sympy/matrices/dense.py", "span_ids": ["DenseMatrix.__getitem__"], "content": [{"span_id": "DenseMatrix.__getitem__", "start_line": 48, "end_line": 116, "content": ["    def __getitem__(self, key):\n", "        \"\"\"Return portion of self defined by key. If the key involves a slice\n", "        then a list will be returned (if key is a single slice) or a matrix\n", "        (if key was a tuple involving a slice).\n", "\n", "        Examples\n", "        ========\n", "\n", "        >>> from sympy import Matrix, I\n", "        >>> m = Matrix([\n", "        ... [1, 2 + I],\n", "        ... [3, 4    ]])\n", "\n", "        If the key is a tuple that doesn't involve a slice then that element\n", "        is returned:\n", "\n", "        >>> m[1, 0]\n", "        3\n", "\n", "        When a tuple key involves a slice, a matrix is returned. Here, the\n", "        first column is selected (all rows, column 0):\n", "\n", "        >>> m[:, 0]\n", "        Matrix([\n", "        [1],\n", "        [3]])\n", "\n", "        If the slice is not a tuple then it selects from the underlying\n", "        list of elements that are arranged in row order and a list is\n", "        returned if a slice is involved:\n", "\n", "        >>> m[0]\n", "        1\n", "        >>> m[::2]\n", "        [1, 3]\n", "        \"\"\"\n", "        if isinstance(key, tuple):\n", "            i, j = key\n", "            try:\n", "                i, j = self.key2ij(key)\n", "                return self._mat[i*self.cols + j]\n", "            except (TypeError, IndexError):\n", "                if (isinstance(i, Expr) and not i.is_number) or (isinstance(j, Expr) and not j.is_number):\n", "                    if ((j < 0) is True) or ((j >= self.shape[1]) is True) or\\\n", "                       ((i < 0) is True) or ((i >= self.shape[0]) is True):\n", "                        raise ValueError(\"index out of boundary\")\n", "                    from sympy.matrices.expressions.matexpr import MatrixElement\n", "                    return MatrixElement(self, i, j)\n", "\n", "                if isinstance(i, slice):\n", "                    # XXX remove list() when PY2 support is dropped\n", "                    i = list(range(self.rows))[i]\n", "                elif is_sequence(i):\n", "                    pass\n", "                else:\n", "                    i = [i]\n", "                if isinstance(j, slice):\n", "                    # XXX remove list() when PY2 support is dropped\n", "                    j = list(range(self.cols))[j]\n", "                elif is_sequence(j):\n", "                    pass\n", "                else:\n", "                    j = [j]\n", "                return self.extract(i, j)\n", "        else:\n", "            # row-wise decomposition of matrix\n", "            if isinstance(key, slice):\n", "                return self._mat[key]\n", "            return self._mat[a2idx(key)]\n"]}]}, {"file_path": "sympy/matrices/matrices.py", "span_ids": ["MatrixProperties.is_upper", "a2idx", "MatrixBase.key2ij"], "content": [{"span_id": "MatrixProperties.is_upper", "start_line": 1071, "end_line": 1115, "content": ["    @property\n", "    def is_upper(self):\n", "        \"\"\"Check if matrix is an upper triangular matrix. True can be returned\n", "        even if the matrix is not square.\n", "\n", "        Examples\n", "        ========\n", "\n", "        >>> from sympy import Matrix\n", "        >>> m = Matrix(2, 2, [1, 0, 0, 1])\n", "        >>> m\n", "        Matrix([\n", "        [1, 0],\n", "        [0, 1]])\n", "        >>> m.is_upper\n", "        True\n", "\n", "        >>> m = Matrix(4, 3, [5, 1, 9, 0, 4 , 6, 0, 0, 5, 0, 0, 0])\n", "        >>> m\n", "        Matrix([\n", "        [5, 1, 9],\n", "        [0, 4, 6],\n", "        [0, 0, 5],\n", "        [0, 0, 0]])\n", "        >>> m.is_upper\n", "        True\n", "\n", "        >>> m = Matrix(2, 3, [4, 2, 5, 6, 1, 1])\n", "        >>> m\n", "        Matrix([\n", "        [4, 2, 5],\n", "        [6, 1, 1]])\n", "        >>> m.is_upper\n", "        False\n", "\n", "        See Also\n", "        ========\n", "\n", "        is_lower\n", "        is_diagonal\n", "        is_upper_hessenberg\n", "        \"\"\"\n", "        return all(self[i, j].is_zero\n", "                   for i in range(1, self.rows)\n", "                   for j in range(i))\n"]}, {"span_id": "a2idx", "start_line": 5337, "end_line": 5349, "content": ["def a2idx(j, n=None):\n", "    \"\"\"Return integer after making positive and validating against n.\"\"\"\n", "    if type(j) is not int:\n", "        try:\n", "            j = j.__index__()\n", "        except AttributeError:\n", "            raise IndexError(\"Invalid index a[%r]\" % (j,))\n", "    if n is not None:\n", "        if j < 0:\n", "            j += n\n", "        if not (j >= 0 and j < n):\n", "            raise IndexError(\"Index out of range: a[%s]\" % (j,))\n", "    return int(j)\n"]}, {"span_id": "MatrixBase.key2ij", "start_line": 4053, "end_line": 4071, "content": ["    def key2ij(self, key):\n", "        \"\"\"Converts key into canonical form, converting integers or indexable\n", "        items into valid integers for self's range or returning slices\n", "        unchanged.\n", "\n", "        See Also\n", "        ========\n", "\n", "        key2bounds\n", "        \"\"\"\n", "        if is_sequence(key):\n", "            if not len(key) == 2:\n", "                raise TypeError('key must be a sequence of length 2')\n", "            return [a2idx(i, n) if not isinstance(i, slice) else i\n", "                    for i, n in zip(key, self.shape)]\n", "        elif isinstance(key, slice):\n", "            return key.indices(len(self))[:2]\n", "        else:\n", "            return divmod(a2idx(key, len(self)), self.cols)\n"]}]}]}