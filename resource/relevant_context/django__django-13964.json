{"instance_id": "django__django-13964", "identified_spans": [{"file_path": "django/db/models/base.py", "span_ids": ["Model._save_table", "Model"], "content": [{"span_id": "Model._save_table", "start_line": 809, "end_line": 872, "content": ["    def _save_table(self, raw=False, cls=None, force_insert=False,\n", "                    force_update=False, using=None, update_fields=None):\n", "        \"\"\"\n", "        Do the heavy-lifting involved in saving. Update or insert the data\n", "        for a single table.\n", "        \"\"\"\n", "        meta = cls._meta\n", "        non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]\n", "\n", "        if update_fields:\n", "            non_pks = [f for f in non_pks\n", "                       if f.name in update_fields or f.attname in update_fields]\n", "\n", "        pk_val = self._get_pk_val(meta)\n", "        if pk_val is None:\n", "            pk_val = meta.pk.get_pk_value_on_save(self)\n", "            setattr(self, meta.pk.attname, pk_val)\n", "        pk_set = pk_val is not None\n", "        if not pk_set and (force_update or update_fields):\n", "            raise ValueError(\"Cannot force an update in save() with no primary key.\")\n", "        updated = False\n", "        # Skip an UPDATE when adding an instance and primary key has a default.\n", "        if (\n", "            not raw and\n", "            not force_insert and\n", "            self._state.adding and\n", "            meta.pk.default and\n", "            meta.pk.default is not NOT_PROVIDED\n", "        ):\n", "            force_insert = True\n", "        # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.\n", "        if pk_set and not force_insert:\n", "            base_qs = cls._base_manager.using(using)\n", "            values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n", "                      for f in non_pks]\n", "            forced_update = update_fields or force_update\n", "            updated = self._do_update(base_qs, using, pk_val, values, update_fields,\n", "                                      forced_update)\n", "            if force_update and not updated:\n", "                raise DatabaseError(\"Forced update did not affect any rows.\")\n", "            if update_fields and not updated:\n", "                raise DatabaseError(\"Save with update_fields did not affect any rows.\")\n", "        if not updated:\n", "            if meta.order_with_respect_to:\n", "                # If this is a model with an order_with_respect_to\n", "                # autopopulate the _order field\n", "                field = meta.order_with_respect_to\n", "                filter_args = field.get_filter_kwargs_for_object(self)\n", "                self._order = cls._base_manager.using(using).filter(**filter_args).aggregate(\n", "                    _order__max=Coalesce(\n", "                        ExpressionWrapper(Max('_order') + Value(1), output_field=IntegerField()),\n", "                        Value(0),\n", "                    ),\n", "                )['_order__max']\n", "            fields = meta.local_concrete_fields\n", "            if not pk_set:\n", "                fields = [f for f in fields if f is not meta.auto_field]\n", "\n", "            returning_fields = meta.db_returning_fields\n", "            results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)\n", "            if results:\n", "                for value, field in zip(results[0], returning_fields):\n", "                    setattr(self, field.attname, value)\n", "        return updated\n"]}, {"span_id": "Model", "start_line": 404, "end_line": 404, "content": ["class Model(metaclass=ModelBase):\n"]}]}, {"file_path": "django/db/models/fields/__init__.py", "span_ids": ["CharField", "Field", "Field.get_prep_value"], "content": [{"span_id": "CharField", "start_line": 1001, "end_line": 1002, "content": ["class CharField(Field):\n", "    description = _(\"String (up to %(max_length)s)\")\n"]}, {"span_id": "Field", "start_line": 84, "end_line": 122, "content": ["@total_ordering\n", "class Field(RegisterLookupMixin):\n", "    \"\"\"Base class for all field types\"\"\"\n", "\n", "    # Designates whether empty strings fundamentally are allowed at the\n", "    # database level.\n", "    empty_strings_allowed = True\n", "    empty_values = list(validators.EMPTY_VALUES)\n", "\n", "    # These track each time a Field instance is created. Used to retain order.\n", "    # The auto_creation_counter is used for fields that Django implicitly\n", "    # creates, creation_counter is used for all user-specified fields.\n", "    creation_counter = 0\n", "    auto_creation_counter = -1\n", "    default_validators = []  # Default set of validators\n", "    default_error_messages = {\n", "        'invalid_choice': _('Value %(value)r is not a valid choice.'),\n", "        'null': _('This field cannot be null.'),\n", "        'blank': _('This field cannot be blank.'),\n", "        'unique': _('%(model_name)s with this %(field_label)s '\n", "                    'already exists.'),\n", "        # Translators: The 'lookup_type' is one of 'date', 'year' or 'month'.\n", "        # Eg: \"Title must be unique for pub_date year\"\n", "        'unique_for_date': _(\"%(field_label)s must be unique for \"\n", "                             \"%(date_field_label)s %(lookup_type)s.\"),\n", "    }\n", "    system_check_deprecated_details = None\n", "    system_check_removed_details = None\n", "\n", "    # Field flags\n", "    hidden = False\n", "\n", "    many_to_many = None\n", "    many_to_one = None\n", "    one_to_many = None\n", "    one_to_one = None\n", "    related_model = None\n", "\n", "    descriptor_class = DeferredAttribute\n"]}, {"span_id": "Field.get_prep_value", "start_line": 824, "end_line": 828, "content": ["    def get_prep_value(self, value):\n", "        \"\"\"Perform preliminary non-db specific value checks and conversions.\"\"\"\n", "        if isinstance(value, Promise):\n", "            value = value._proxy____cast()\n", "        return value\n"]}]}, {"file_path": "django/db/models/fields/related.py", "span_ids": ["ForwardManyToOneDescriptor.__set__", "ForeignKey", "ForeignKey._check_unique", "ForwardManyToOneDescriptor.__get__", "ForeignKey.get_attname", "ForeignKey.deconstruct", "ForeignKey.get_attname_column", "ForeignKey.check", "ForwardManyToOneDescriptor"], "content": [{"span_id": "ForeignKey", "start_line": 771, "end_line": 792, "content": ["class ForeignKey(ForeignObject):\n", "    \"\"\"\n", "    Provide a many-to-one relation by adding a column to the local model\n", "    to hold the remote value.\n", "\n", "    By default ForeignKey will target the pk of the remote model but this\n", "    behavior can be changed by using the ``to_field`` argument.\n", "    \"\"\"\n", "    descriptor_class = ForeignKeyDeferredAttribute\n", "    # Field flags\n", "    many_to_many = False\n", "    many_to_one = True\n", "    one_to_many = False\n", "    one_to_one = False\n", "\n", "    rel_class = ManyToOneRel\n", "\n", "    empty_strings_allowed = False\n", "    default_error_messages = {\n", "        'invalid': _('%(model)s instance with %(field)s %(value)r does not exist.')\n", "    }\n", "    description = _(\"Foreign Key (type determined by related field)\")\n"]}, {"span_id": "ForeignKey._check_unique", "start_line": 864, "end_line": 872, "content": ["    def _check_unique(self, **kwargs):\n", "        return [\n", "            checks.Warning(\n", "                'Setting unique=True on a ForeignKey has the same effect as using a OneToOneField.',\n", "                hint='ForeignKey(unique=True) is usually better served by a OneToOneField.',\n", "                obj=self,\n", "                id='fields.W342',\n", "            )\n", "        ] if self.unique else []\n"]}, {"span_id": "ForeignKey.get_attname", "start_line": 950, "end_line": 951, "content": ["    def get_attname(self):\n", "        return '%s_id' % self.name\n"]}, {"span_id": "ForeignKey.deconstruct", "start_line": 874, "end_line": 890, "content": ["    def deconstruct(self):\n", "        name, path, args, kwargs = super().deconstruct()\n", "        del kwargs['to_fields']\n", "        del kwargs['from_fields']\n", "        # Handle the simpler arguments\n", "        if self.db_index:\n", "            del kwargs['db_index']\n", "        else:\n", "            kwargs['db_index'] = False\n", "        if self.db_constraint is not True:\n", "            kwargs['db_constraint'] = self.db_constraint\n", "        # Rel needs more work.\n", "        to_meta = getattr(self.remote_field.model, \"_meta\", None)\n", "        if self.remote_field.field_name and (\n", "                not to_meta or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)):\n", "            kwargs['to_field'] = self.remote_field.field_name\n", "        return name, path, args, kwargs\n"]}, {"span_id": "ForeignKey.get_attname_column", "start_line": 953, "end_line": 956, "content": ["    def get_attname_column(self):\n", "        attname = self.get_attname()\n", "        column = self.db_column or attname\n", "        return attname, column\n"]}, {"span_id": "ForeignKey.check", "start_line": 834, "end_line": 839, "content": ["    def check(self, **kwargs):\n", "        return [\n", "            *super().check(**kwargs),\n", "            *self._check_on_delete(),\n", "            *self._check_unique(),\n", "        ]\n"]}]}]}