{"instance_id": "matplotlib__matplotlib-24970", "identified_spans": [{"file_path": "lib/matplotlib/colors.py", "span_ids": ["to_rgba_array", "ColorConverter", "Colormap", "_to_rgba_no_colorcycle", "Colormap.__call__"], "content": [{"span_id": "to_rgba_array", "start_line": 399, "end_line": 491, "content": ["def to_rgba_array(c, alpha=None):\n", "    \"\"\"\n", "    Convert *c* to a (n, 4) array of RGBA colors.\n", "\n", "    Parameters\n", "    ----------\n", "    c : Matplotlib color or array of colors\n", "        If *c* is a masked array, an `~numpy.ndarray` is returned with a\n", "        (0, 0, 0, 0) row for each masked value or row in *c*.\n", "\n", "    alpha : float or sequence of floats, optional\n", "        If *alpha* is given, force the alpha value of the returned RGBA tuple\n", "        to *alpha*.\n", "\n", "        If None, the alpha value from *c* is used. If *c* does not have an\n", "        alpha channel, then alpha defaults to 1.\n", "\n", "        *alpha* is ignored for the color value ``\"none\"`` (case-insensitive),\n", "        which always maps to ``(0, 0, 0, 0)``.\n", "\n", "        If *alpha* is a sequence and *c* is a single color, *c* will be\n", "        repeated to match the length of *alpha*.\n", "\n", "    Returns\n", "    -------\n", "    array\n", "        (n, 4) array of RGBA colors,  where each channel (red, green, blue,\n", "        alpha) can assume values between 0 and 1.\n", "    \"\"\"\n", "    # Special-case inputs that are already arrays, for performance.  (If the\n", "    # array has the wrong kind or shape, raise the error during one-at-a-time\n", "    # conversion.)\n", "    if np.iterable(alpha):\n", "        alpha = np.asarray(alpha).ravel()\n", "    if (isinstance(c, np.ndarray) and c.dtype.kind in \"if\"\n", "            and c.ndim == 2 and c.shape[1] in [3, 4]):\n", "        mask = c.mask.any(axis=1) if np.ma.is_masked(c) else None\n", "        c = np.ma.getdata(c)\n", "        if np.iterable(alpha):\n", "            if c.shape[0] == 1 and alpha.shape[0] > 1:\n", "                c = np.tile(c, (alpha.shape[0], 1))\n", "            elif c.shape[0] != alpha.shape[0]:\n", "                raise ValueError(\"The number of colors must match the number\"\n", "                                 \" of alpha values if there are more than one\"\n", "                                 \" of each.\")\n", "        if c.shape[1] == 3:\n", "            result = np.column_stack([c, np.zeros(len(c))])\n", "            result[:, -1] = alpha if alpha is not None else 1.\n", "        elif c.shape[1] == 4:\n", "            result = c.copy()\n", "            if alpha is not None:\n", "                result[:, -1] = alpha\n", "        if mask is not None:\n", "            result[mask] = 0\n", "        if np.any((result < 0) | (result > 1)):\n", "            raise ValueError(\"RGBA values should be within 0-1 range\")\n", "        return result\n", "    # Handle single values.\n", "    # Note that this occurs *after* handling inputs that are already arrays, as\n", "    # `to_rgba(c, alpha)` (below) is expensive for such inputs, due to the need\n", "    # to format the array in the ValueError message(!).\n", "    if cbook._str_lower_equal(c, \"none\"):\n", "        return np.zeros((0, 4), float)\n", "    try:\n", "        if np.iterable(alpha):\n", "            return np.array([to_rgba(c, a) for a in alpha], float)\n", "        else:\n", "            return np.array([to_rgba(c, alpha)], float)\n", "    except (ValueError, TypeError):\n", "        pass\n", "\n", "    if isinstance(c, str):\n", "        raise ValueError(f\"{c!r} is not a valid color value.\")\n", "\n", "    if len(c) == 0:\n", "        return np.zeros((0, 4), float)\n", "\n", "    # Quick path if the whole sequence can be directly converted to a numpy\n", "    # array in one shot.\n", "    if isinstance(c, Sequence):\n", "        lens = {len(cc) if isinstance(cc, (list, tuple)) else -1 for cc in c}\n", "        if lens == {3}:\n", "            rgba = np.column_stack([c, np.ones(len(c))])\n", "        elif lens == {4}:\n", "            rgba = np.array(c)\n", "        else:\n", "            rgba = np.array([to_rgba(cc) for cc in c])\n", "    else:\n", "        rgba = np.array([to_rgba(cc) for cc in c])\n", "\n", "    if alpha is not None:\n", "        rgba[:, 3] = alpha\n", "    return rgba\n"]}, {"span_id": "ColorConverter", "start_line": 530, "end_line": 540, "content": ["class ColorConverter:\n", "    \"\"\"\n", "    A class only kept for backwards compatibility.\n", "\n", "    Its functionality is entirely provided by module-level functions.\n", "    \"\"\"\n", "    colors = _colors_full_map\n", "    cache = _colors_full_map.cache\n", "    to_rgb = staticmethod(to_rgb)\n", "    to_rgba = staticmethod(to_rgba)\n", "    to_rgba_array = staticmethod(to_rgba_array)\n"]}, {"span_id": "Colormap", "start_line": 647, "end_line": 657, "content": ["class Colormap:\n", "    \"\"\"\n", "    Baseclass for all scalar to RGBA mappings.\n", "\n", "    Typically, Colormap instances are used to convert data values (floats)\n", "    from the interval ``[0, 1]`` to the RGBA color that the respective\n", "    Colormap represents. For scaling of data into the ``[0, 1]`` interval see\n", "    `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`\n", "    make heavy use of this ``data -> normalize -> map-to-color`` processing\n", "    chain.\n", "    \"\"\"\n"]}, {"span_id": "_to_rgba_no_colorcycle", "start_line": 307, "end_line": 396, "content": ["def _to_rgba_no_colorcycle(c, alpha=None):\n", "    \"\"\"\n", "    Convert *c* to an RGBA color, with no support for color-cycle syntax.\n", "\n", "    If *alpha* is given, force the alpha value of the returned RGBA tuple\n", "    to *alpha*. Otherwise, the alpha value from *c* is used, if it has alpha\n", "    information, or defaults to 1.\n", "\n", "    *alpha* is ignored for the color value ``\"none\"`` (case-insensitive),\n", "    which always maps to ``(0, 0, 0, 0)``.\n", "    \"\"\"\n", "    orig_c = c\n", "    if c is np.ma.masked:\n", "        return (0., 0., 0., 0.)\n", "    if isinstance(c, str):\n", "        if c.lower() == \"none\":\n", "            return (0., 0., 0., 0.)\n", "        # Named color.\n", "        try:\n", "            # This may turn c into a non-string, so we check again below.\n", "            c = _colors_full_map[c]\n", "        except KeyError:\n", "            if len(orig_c) != 1:\n", "                try:\n", "                    c = _colors_full_map[c.lower()]\n", "                except KeyError:\n", "                    pass\n", "    if isinstance(c, str):\n", "        # hex color in #rrggbb format.\n", "        match = re.match(r\"\\A#[a-fA-F0-9]{6}\\Z\", c)\n", "        if match:\n", "            return (tuple(int(n, 16) / 255\n", "                          for n in [c[1:3], c[3:5], c[5:7]])\n", "                    + (alpha if alpha is not None else 1.,))\n", "        # hex color in #rgb format, shorthand for #rrggbb.\n", "        match = re.match(r\"\\A#[a-fA-F0-9]{3}\\Z\", c)\n", "        if match:\n", "            return (tuple(int(n, 16) / 255\n", "                          for n in [c[1]*2, c[2]*2, c[3]*2])\n", "                    + (alpha if alpha is not None else 1.,))\n", "        # hex color with alpha in #rrggbbaa format.\n", "        match = re.match(r\"\\A#[a-fA-F0-9]{8}\\Z\", c)\n", "        if match:\n", "            color = [int(n, 16) / 255\n", "                     for n in [c[1:3], c[3:5], c[5:7], c[7:9]]]\n", "            if alpha is not None:\n", "                color[-1] = alpha\n", "            return tuple(color)\n", "        # hex color with alpha in #rgba format, shorthand for #rrggbbaa.\n", "        match = re.match(r\"\\A#[a-fA-F0-9]{4}\\Z\", c)\n", "        if match:\n", "            color = [int(n, 16) / 255\n", "                     for n in [c[1]*2, c[2]*2, c[3]*2, c[4]*2]]\n", "            if alpha is not None:\n", "                color[-1] = alpha\n", "            return tuple(color)\n", "        # string gray.\n", "        try:\n", "            c = float(c)\n", "        except ValueError:\n", "            pass\n", "        else:\n", "            if not (0 <= c <= 1):\n", "                raise ValueError(\n", "                    f\"Invalid string grayscale value {orig_c!r}. \"\n", "                    f\"Value must be within 0-1 range\")\n", "            return c, c, c, alpha if alpha is not None else 1.\n", "        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n", "    # turn 2-D array into 1-D array\n", "    if isinstance(c, np.ndarray):\n", "        if c.ndim == 2 and c.shape[0] == 1:\n", "            c = c.reshape(-1)\n", "    # tuple color.\n", "    if not np.iterable(c):\n", "        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n", "    if len(c) not in [3, 4]:\n", "        raise ValueError(\"RGBA sequence should have length 3 or 4\")\n", "    if not all(isinstance(x, Number) for x in c):\n", "        # Checks that don't work: `map(float, ...)`, `np.array(..., float)` and\n", "        # `np.array(...).astype(float)` would all convert \"0.5\" to 0.5.\n", "        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n", "    # Return a tuple to prevent the cached value from being modified.\n", "    c = tuple(map(float, c))\n", "    if len(c) == 3 and alpha is None:\n", "        alpha = 1\n", "    if alpha is not None:\n", "        c = c[:3] + (alpha,)\n", "    if any(elem < 0 or elem > 1 for elem in c):\n", "        raise ValueError(\"RGBA values should be within 0-1 range\")\n", "    return c\n"]}, {"span_id": "Colormap.__call__", "start_line": 683, "end_line": 759, "content": ["    def __call__(self, X, alpha=None, bytes=False):\n", "        \"\"\"\n", "        Parameters\n", "        ----------\n", "        X : float or int, `~numpy.ndarray` or scalar\n", "            The data value(s) to convert to RGBA.\n", "            For floats, *X* should be in the interval ``[0.0, 1.0]`` to\n", "            return the RGBA values ``X*100`` percent along the Colormap line.\n", "            For integers, *X* should be in the interval ``[0, Colormap.N)`` to\n", "            return RGBA values *indexed* from the Colormap with index ``X``.\n", "        alpha : float or array-like or None\n", "            Alpha must be a scalar between 0 and 1, a sequence of such\n", "            floats with shape matching X, or None.\n", "        bytes : bool\n", "            If False (default), the returned RGBA values will be floats in the\n", "            interval ``[0, 1]`` otherwise they will be uint8s in the interval\n", "            ``[0, 255]``.\n", "\n", "        Returns\n", "        -------\n", "        Tuple of RGBA values if X is scalar, otherwise an array of\n", "        RGBA values with a shape of ``X.shape + (4, )``.\n", "        \"\"\"\n", "        if not self._isinit:\n", "            self._init()\n", "\n", "        # Take the bad mask from a masked array, or in all other cases defer\n", "        # np.isnan() to after we have converted to an array.\n", "        mask_bad = X.mask if np.ma.is_masked(X) else None\n", "        xa = np.array(X, copy=True)\n", "        if mask_bad is None:\n", "            mask_bad = np.isnan(xa)\n", "        if not xa.dtype.isnative:\n", "            xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n", "        if xa.dtype.kind == \"f\":\n", "            with np.errstate(invalid=\"ignore\"):\n", "                xa *= self.N\n", "                # Negative values are out of range, but astype(int) would\n", "                # truncate them towards zero.\n", "                xa[xa < 0] = -1\n", "                # xa == 1 (== N after multiplication) is not out of range.\n", "                xa[xa == self.N] = self.N - 1\n", "                # Avoid converting large positive values to negative integers.\n", "                np.clip(xa, -1, self.N, out=xa)\n", "                xa = xa.astype(int)\n", "        # Set the over-range indices before the under-range;\n", "        # otherwise the under-range values get converted to over-range.\n", "        xa[xa > self.N - 1] = self._i_over\n", "        xa[xa < 0] = self._i_under\n", "        xa[mask_bad] = self._i_bad\n", "\n", "        lut = self._lut\n", "        if bytes:\n", "            lut = (lut * 255).astype(np.uint8)\n", "\n", "        rgba = lut.take(xa, axis=0, mode='clip')\n", "\n", "        if alpha is not None:\n", "            alpha = np.clip(alpha, 0, 1)\n", "            if bytes:\n", "                alpha *= 255  # Will be cast to uint8 upon assignment.\n", "            if alpha.shape not in [(), xa.shape]:\n", "                raise ValueError(\n", "                    f\"alpha is array-like but its shape {alpha.shape} does \"\n", "                    f\"not match that of X {xa.shape}\")\n", "            rgba[..., -1] = alpha\n", "\n", "            # If the \"bad\" color is all zeros, then ignore alpha input.\n", "            if (lut[-1] == 0).all() and np.any(mask_bad):\n", "                if np.iterable(mask_bad) and mask_bad.shape == xa.shape:\n", "                    rgba[mask_bad] = (0, 0, 0, 0)\n", "                else:\n", "                    rgba[..., :] = (0, 0, 0, 0)\n", "\n", "        if not np.iterable(X):\n", "            rgba = tuple(rgba)\n", "        return rgba\n"]}]}]}