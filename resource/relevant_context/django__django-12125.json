{"instance_id": "django__django-12125", "identified_spans": [{"file_path": "django/db/migrations/serializer.py", "span_ids": ["FunctionTypeSerializer.serialize", "serializer_factory", "FunctionTypeSerializer"], "content": [{"span_id": "FunctionTypeSerializer.serialize", "start_line": 142, "end_line": 160, "content": ["    def serialize(self):\n", "        if getattr(self.value, \"__self__\", None) and isinstance(self.value.__self__, type):\n", "            klass = self.value.__self__\n", "            module = klass.__module__\n", "            return \"%s.%s.%s\" % (module, klass.__name__, self.value.__name__), {\"import %s\" % module}\n", "        # Further error checking\n", "        if self.value.__name__ == '<lambda>':\n", "            raise ValueError(\"Cannot serialize function: lambda\")\n", "        if self.value.__module__ is None:\n", "            raise ValueError(\"Cannot serialize function %r: No module\" % self.value)\n", "\n", "        module_name = self.value.__module__\n", "\n", "        if '<' not in self.value.__qualname__:  # Qualname can include <locals>\n", "            return '%s.%s' % (module_name, self.value.__qualname__), {'import %s' % self.value.__module__}\n", "\n", "        raise ValueError(\n", "            'Could not find function %s in %s.\\n' % (self.value.__name__, module_name)\n", "        )\n"]}, {"span_id": "serializer_factory", "start_line": 314, "end_line": 340, "content": ["def serializer_factory(value):\n", "    if isinstance(value, Promise):\n", "        value = str(value)\n", "    elif isinstance(value, LazyObject):\n", "        # The unwrapped value is returned as the first item of the arguments\n", "        # tuple.\n", "        value = value.__reduce__()[1][0]\n", "\n", "    if isinstance(value, models.Field):\n", "        return ModelFieldSerializer(value)\n", "    if isinstance(value, models.manager.BaseManager):\n", "        return ModelManagerSerializer(value)\n", "    if isinstance(value, Operation):\n", "        return OperationSerializer(value)\n", "    if isinstance(value, type):\n", "        return TypeSerializer(value)\n", "    # Anything that knows how to deconstruct itself.\n", "    if hasattr(value, 'deconstruct'):\n", "        return DeconstructableSerializer(value)\n", "    for type_, serializer_cls in Serializer._registry.items():\n", "        if isinstance(value, type_):\n", "            return serializer_cls(value)\n", "    raise ValueError(\n", "        \"Cannot serialize: %r\\nThere are some values Django cannot serialize into \"\n", "        \"migration files.\\nFor more, see https://docs.djangoproject.com/en/%s/\"\n", "        \"topics/migrations/#migration-serializing\" % (value, get_docs_version())\n", "    )\n"]}, {"span_id": "FunctionTypeSerializer", "start_line": 141, "end_line": 141, "content": ["class FunctionTypeSerializer(BaseSerializer):\n"]}]}, {"file_path": "django/db/migrations/state.py", "span_ids": ["ModelState.from_model"], "content": [{"span_id": "ModelState.from_model", "start_line": 401, "end_line": 528, "content": ["    @classmethod\n", "    def from_model(cls, model, exclude_rels=False):\n", "        \"\"\"Given a model, return a ModelState representing it.\"\"\"\n", "        # Deconstruct the fields\n", "        fields = []\n", "        for field in model._meta.local_fields:\n", "            if getattr(field, \"remote_field\", None) and exclude_rels:\n", "                continue\n", "            if isinstance(field, OrderWrt):\n", "                continue\n", "            name = field.name\n", "            try:\n", "                fields.append((name, field.clone()))\n", "            except TypeError as e:\n", "                raise TypeError(\"Couldn't reconstruct field %s on %s: %s\" % (\n", "                    name,\n", "                    model._meta.label,\n", "                    e,\n", "                ))\n", "        if not exclude_rels:\n", "            for field in model._meta.local_many_to_many:\n", "                name = field.name\n", "                try:\n", "                    fields.append((name, field.clone()))\n", "                except TypeError as e:\n", "                    raise TypeError(\"Couldn't reconstruct m2m field %s on %s: %s\" % (\n", "                        name,\n", "                        model._meta.object_name,\n", "                        e,\n", "                    ))\n", "        # Extract the options\n", "        options = {}\n", "        for name in DEFAULT_NAMES:\n", "            # Ignore some special options\n", "            if name in [\"apps\", \"app_label\"]:\n", "                continue\n", "            elif name in model._meta.original_attrs:\n", "                if name == \"unique_together\":\n", "                    ut = model._meta.original_attrs[\"unique_together\"]\n", "                    options[name] = set(normalize_together(ut))\n", "                elif name == \"index_together\":\n", "                    it = model._meta.original_attrs[\"index_together\"]\n", "                    options[name] = set(normalize_together(it))\n", "                elif name == \"indexes\":\n", "                    indexes = [idx.clone() for idx in model._meta.indexes]\n", "                    for index in indexes:\n", "                        if not index.name:\n", "                            index.set_name_with_model(model)\n", "                    options['indexes'] = indexes\n", "                elif name == 'constraints':\n", "                    options['constraints'] = [con.clone() for con in model._meta.constraints]\n", "                else:\n", "                    options[name] = model._meta.original_attrs[name]\n", "        # If we're ignoring relationships, remove all field-listing model\n", "        # options (that option basically just means \"make a stub model\")\n", "        if exclude_rels:\n", "            for key in [\"unique_together\", \"index_together\", \"order_with_respect_to\"]:\n", "                if key in options:\n", "                    del options[key]\n", "        # Private fields are ignored, so remove options that refer to them.\n", "        elif options.get('order_with_respect_to') in {field.name for field in model._meta.private_fields}:\n", "            del options['order_with_respect_to']\n", "\n", "        def flatten_bases(model):\n", "            bases = []\n", "            for base in model.__bases__:\n", "                if hasattr(base, \"_meta\") and base._meta.abstract:\n", "                    bases.extend(flatten_bases(base))\n", "                else:\n", "                    bases.append(base)\n", "            return bases\n", "\n", "        # We can't rely on __mro__ directly because we only want to flatten\n", "        # abstract models and not the whole tree. However by recursing on\n", "        # __bases__ we may end up with duplicates and ordering issues, we\n", "        # therefore discard any duplicates and reorder the bases according\n", "        # to their index in the MRO.\n", "        flattened_bases = sorted(set(flatten_bases(model)), key=lambda x: model.__mro__.index(x))\n", "\n", "        # Make our record\n", "        bases = tuple(\n", "            (\n", "                base._meta.label_lower\n", "                if hasattr(base, \"_meta\") else\n", "                base\n", "            )\n", "            for base in flattened_bases\n", "        )\n", "        # Ensure at least one base inherits from models.Model\n", "        if not any((isinstance(base, str) or issubclass(base, models.Model)) for base in bases):\n", "            bases = (models.Model,)\n", "\n", "        managers = []\n", "        manager_names = set()\n", "        default_manager_shim = None\n", "        for manager in model._meta.managers:\n", "            if manager.name in manager_names:\n", "                # Skip overridden managers.\n", "                continue\n", "            elif manager.use_in_migrations:\n", "                # Copy managers usable in migrations.\n", "                new_manager = copy.copy(manager)\n", "                new_manager._set_creation_counter()\n", "            elif manager is model._base_manager or manager is model._default_manager:\n", "                # Shim custom managers used as default and base managers.\n", "                new_manager = models.Manager()\n", "                new_manager.model = manager.model\n", "                new_manager.name = manager.name\n", "                if manager is model._default_manager:\n", "                    default_manager_shim = new_manager\n", "            else:\n", "                continue\n", "            manager_names.add(manager.name)\n", "            managers.append((manager.name, new_manager))\n", "\n", "        # Ignore a shimmed default manager called objects if it's the only one.\n", "        if managers == [('objects', default_manager_shim)]:\n", "            managers = []\n", "\n", "        # Construct the new ModelState\n", "        return cls(\n", "            model._meta.app_label,\n", "            model._meta.object_name,\n", "            fields,\n", "            options,\n", "            bases,\n", "            managers,\n", "        )\n"]}]}, {"file_path": "django/db/migrations/writer.py", "span_ids": ["MigrationWriter.as_string"], "content": [{"span_id": "MigrationWriter.as_string", "start_line": 129, "end_line": 199, "content": ["    def as_string(self):\n", "        \"\"\"Return a string of the file contents.\"\"\"\n", "        items = {\n", "            \"replaces_str\": \"\",\n", "            \"initial_str\": \"\",\n", "        }\n", "\n", "        imports = set()\n", "\n", "        # Deconstruct operations\n", "        operations = []\n", "        for operation in self.migration.operations:\n", "            operation_string, operation_imports = OperationWriter(operation).serialize()\n", "            imports.update(operation_imports)\n", "            operations.append(operation_string)\n", "        items[\"operations\"] = \"\\n\".join(operations) + \"\\n\" if operations else \"\"\n", "\n", "        # Format dependencies and write out swappable dependencies right\n", "        dependencies = []\n", "        for dependency in self.migration.dependencies:\n", "            if dependency[0] == \"__setting__\":\n", "                dependencies.append(\"        migrations.swappable_dependency(settings.%s),\" % dependency[1])\n", "                imports.add(\"from django.conf import settings\")\n", "            else:\n", "                dependencies.append(\"        %s,\" % self.serialize(dependency)[0])\n", "        items[\"dependencies\"] = \"\\n\".join(dependencies) + \"\\n\" if dependencies else \"\"\n", "\n", "        # Format imports nicely, swapping imports of functions from migration files\n", "        # for comments\n", "        migration_imports = set()\n", "        for line in list(imports):\n", "            if re.match(r\"^import (.*)\\.\\d+[^\\s]*$\", line):\n", "                migration_imports.add(line.split(\"import\")[1].strip())\n", "                imports.remove(line)\n", "                self.needs_manual_porting = True\n", "\n", "        # django.db.migrations is always used, but models import may not be.\n", "        # If models import exists, merge it with migrations import.\n", "        if \"from django.db import models\" in imports:\n", "            imports.discard(\"from django.db import models\")\n", "            imports.add(\"from django.db import migrations, models\")\n", "        else:\n", "            imports.add(\"from django.db import migrations\")\n", "\n", "        # Sort imports by the package / module to be imported (the part after\n", "        # \"from\" in \"from ... import ...\" or after \"import\" in \"import ...\").\n", "        sorted_imports = sorted(imports, key=lambda i: i.split()[1])\n", "        items[\"imports\"] = \"\\n\".join(sorted_imports) + \"\\n\" if imports else \"\"\n", "        if migration_imports:\n", "            items[\"imports\"] += (\n", "                \"\\n\\n# Functions from the following migrations need manual \"\n", "                \"copying.\\n# Move them and any dependencies into this file, \"\n", "                \"then update the\\n# RunPython operations to refer to the local \"\n", "                \"versions:\\n# %s\"\n", "            ) % \"\\n# \".join(sorted(migration_imports))\n", "        # If there's a replaces, make a string for it\n", "        if self.migration.replaces:\n", "            items['replaces_str'] = \"\\n    replaces = %s\\n\" % self.serialize(self.migration.replaces)[0]\n", "        # Hinting that goes into comment\n", "        if self.include_header:\n", "            items['migration_header'] = MIGRATION_HEADER_TEMPLATE % {\n", "                'version': get_version(),\n", "                'timestamp': now().strftime(\"%Y-%m-%d %H:%M\"),\n", "            }\n", "        else:\n", "            items['migration_header'] = \"\"\n", "\n", "        if self.migration.initial:\n", "            items['initial_str'] = \"\\n    initial = True\\n\"\n", "\n", "        return MIGRATION_TEMPLATE % items\n"]}]}]}