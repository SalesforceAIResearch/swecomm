{"instance_id": "django__django-11133", "identified_spans": [{"file_path": "django/db/models/fields/__init__.py", "span_ids": ["BinaryField.value_to_string", "BinaryField.get_db_prep_value", "BinaryField", "BinaryField.to_python"], "content": [{"span_id": "BinaryField.value_to_string", "start_line": 2298, "end_line": 2300, "content": ["    def value_to_string(self, obj):\n", "        \"\"\"Binary data is serialized as base64\"\"\"\n", "        return b64encode(self.value_from_object(obj)).decode('ascii')\n"]}, {"span_id": "BinaryField.get_db_prep_value", "start_line": 2292, "end_line": 2296, "content": ["    def get_db_prep_value(self, value, connection, prepared=False):\n", "        value = super().get_db_prep_value(value, connection, prepared)\n", "        if value is not None:\n", "            return connection.Database.Binary(value)\n", "        return value\n"]}, {"span_id": "BinaryField", "start_line": 2245, "end_line": 2247, "content": ["class BinaryField(Field):\n", "    description = _(\"Raw binary data\")\n", "    empty_values = [None, b'']\n"]}, {"span_id": "BinaryField.to_python", "start_line": 2302, "end_line": 2306, "content": ["    def to_python(self, value):\n", "        # If it's a string, it should be base64-encoded data\n", "        if isinstance(value, str):\n", "            return memoryview(b64decode(value.encode('ascii')))\n", "        return value\n"]}]}, {"file_path": "django/http/response.py", "span_ids": ["HttpResponse", "HttpResponse.content_3", "HttpResponseBase.make_bytes"], "content": [{"span_id": "HttpResponse", "start_line": 278, "end_line": 285, "content": ["class HttpResponse(HttpResponseBase):\n", "    \"\"\"\n", "    An HTTP response class with a string as content.\n", "\n", "    This content that can be read, appended to, or replaced.\n", "    \"\"\"\n", "\n", "    streaming = False\n"]}, {"span_id": "HttpResponse.content_3", "start_line": 309, "end_line": 322, "content": ["    @content.setter\n", "    def content(self, value):\n", "        # Consume iterators upon assignment to allow repeated iteration.\n", "        if hasattr(value, '__iter__') and not isinstance(value, (bytes, str)):\n", "            content = b''.join(self.make_bytes(chunk) for chunk in value)\n", "            if hasattr(value, 'close'):\n", "                try:\n", "                    value.close()\n", "                except Exception:\n", "                    pass\n", "        else:\n", "            content = self.make_bytes(value)\n", "        # Create a list of properly encoded bytestrings to support write().\n", "        self._container = [content]\n"]}, {"span_id": "HttpResponseBase.make_bytes", "start_line": 223, "end_line": 237, "content": ["    def make_bytes(self, value):\n", "        \"\"\"Turn a value into a bytestring encoded in the output charset.\"\"\"\n", "        # Per PEP 3333, this response body must be bytes. To avoid returning\n", "        # an instance of a subclass, this function returns `bytes(value)`.\n", "        # This doesn't make a copy when `value` already contains bytes.\n", "\n", "        # Handle string types -- we can't rely on force_bytes here because:\n", "        # - Python attempts str conversion first\n", "        # - when self._charset != 'utf-8' it re-encodes the content\n", "        if isinstance(value, bytes):\n", "            return bytes(value)\n", "        if isinstance(value, str):\n", "            return bytes(value.encode(self.charset))\n", "        # Handle non-string types.\n", "        return str(value).encode(self.charset)\n"]}]}]}