{"instance_id": "sphinx-doc__sphinx-8273", "identified_spans": [{"file_path": "sphinx/builders/manpage.py", "span_ids": ["ManualPageBuilder", "ManualPageBuilder.write"], "content": [{"span_id": "ManualPageBuilder", "start_line": 34, "end_line": 43, "content": ["class ManualPageBuilder(Builder):\n", "    \"\"\"\n", "    Builds groff output in manual page format.\n", "    \"\"\"\n", "    name = 'man'\n", "    format = 'man'\n", "    epilog = __('The manual pages are in %(outdir)s.')\n", "\n", "    default_translator_class = ManualPageTranslator\n", "    supported_image_types = []  # type: List[str]\n"]}, {"span_id": "ManualPageBuilder.write", "start_line": 58, "end_line": 100, "content": ["    @progress_message(__('writing'))\n", "    def write(self, *ignored: Any) -> None:\n", "        docwriter = ManualPageWriter(self)\n", "        docsettings = OptionParser(\n", "            defaults=self.env.settings,\n", "            components=(docwriter,),\n", "            read_config_files=True).get_default_values()  # type: Any\n", "\n", "        for info in self.config.man_pages:\n", "            docname, name, description, authors, section = info\n", "            if docname not in self.env.all_docs:\n", "                logger.warning(__('\"man_pages\" config value references unknown '\n", "                                  'document %s'), docname)\n", "                continue\n", "            if isinstance(authors, str):\n", "                if authors:\n", "                    authors = [authors]\n", "                else:\n", "                    authors = []\n", "\n", "            docsettings.title = name\n", "            docsettings.subtitle = description\n", "            docsettings.authors = authors\n", "            docsettings.section = section\n", "\n", "            targetname = '%s.%s' % (name, section)\n", "            logger.info(darkgreen(targetname) + ' { ', nonl=True)\n", "            destination = FileOutput(\n", "                destination_path=path.join(self.outdir, targetname),\n", "                encoding='utf-8')\n", "\n", "            tree = self.env.get_doctree(docname)\n", "            docnames = set()  # type: Set[str]\n", "            largetree = inline_all_toctrees(self, docnames, docname, tree,\n", "                                            darkgreen, [docname])\n", "            largetree.settings = docsettings\n", "            logger.info('} ', nonl=True)\n", "            self.env.resolve_references(largetree, docname, self)\n", "            # remove pending_xref nodes\n", "            for pendingnode in largetree.traverse(addnodes.pending_xref):\n", "                pendingnode.replace_self(pendingnode.children)\n", "\n", "            docwriter.write(largetree, destination)\n"]}]}]}