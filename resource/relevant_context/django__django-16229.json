{"instance_id": "django__django-16229", "identified_spans": [{"file_path": "django/contrib/admin/options.py", "span_ids": ["InlineModelAdmin.get_formset", "InlineModelAdmin"], "content": [{"span_id": "InlineModelAdmin.get_formset", "start_line": 2343, "end_line": 2435, "content": ["    def get_formset(self, request, obj=None, **kwargs):\n", "        \"\"\"Return a BaseInlineFormSet class for use in admin add/change views.\"\"\"\n", "        if \"fields\" in kwargs:\n", "            fields = kwargs.pop(\"fields\")\n", "        else:\n", "            fields = flatten_fieldsets(self.get_fieldsets(request, obj))\n", "        excluded = self.get_exclude(request, obj)\n", "        exclude = [] if excluded is None else list(excluded)\n", "        exclude.extend(self.get_readonly_fields(request, obj))\n", "        if excluded is None and hasattr(self.form, \"_meta\") and self.form._meta.exclude:\n", "            # Take the custom ModelForm's Meta.exclude into account only if the\n", "            # InlineModelAdmin doesn't define its own.\n", "            exclude.extend(self.form._meta.exclude)\n", "        # If exclude is an empty list we use None, since that's the actual\n", "        # default.\n", "        exclude = exclude or None\n", "        can_delete = self.can_delete and self.has_delete_permission(request, obj)\n", "        defaults = {\n", "            \"form\": self.form,\n", "            \"formset\": self.formset,\n", "            \"fk_name\": self.fk_name,\n", "            \"fields\": fields,\n", "            \"exclude\": exclude,\n", "            \"formfield_callback\": partial(self.formfield_for_dbfield, request=request),\n", "            \"extra\": self.get_extra(request, obj, **kwargs),\n", "            \"min_num\": self.get_min_num(request, obj, **kwargs),\n", "            \"max_num\": self.get_max_num(request, obj, **kwargs),\n", "            \"can_delete\": can_delete,\n", "            **kwargs,\n", "        }\n", "\n", "        base_model_form = defaults[\"form\"]\n", "        can_change = self.has_change_permission(request, obj) if request else True\n", "        can_add = self.has_add_permission(request, obj) if request else True\n", "\n", "        class DeleteProtectedModelForm(base_model_form):\n", "            def hand_clean_DELETE(self):\n", "                \"\"\"\n", "                We don't validate the 'DELETE' field itself because on\n", "                templates it's not rendered using the field information, but\n", "                just using a generic \"deletion_field\" of the InlineModelAdmin.\n", "                \"\"\"\n", "                if self.cleaned_data.get(DELETION_FIELD_NAME, False):\n", "                    using = router.db_for_write(self._meta.model)\n", "                    collector = NestedObjects(using=using)\n", "                    if self.instance._state.adding:\n", "                        return\n", "                    collector.collect([self.instance])\n", "                    if collector.protected:\n", "                        objs = []\n", "                        for p in collector.protected:\n", "                            objs.append(\n", "                                # Translators: Model verbose name and instance\n", "                                # representation, suitable to be an item in a\n", "                                # list.\n", "                                _(\"%(class_name)s %(instance)s\")\n", "                                % {\"class_name\": p._meta.verbose_name, \"instance\": p}\n", "                            )\n", "                        params = {\n", "                            \"class_name\": self._meta.model._meta.verbose_name,\n", "                            \"instance\": self.instance,\n", "                            \"related_objects\": get_text_list(objs, _(\"and\")),\n", "                        }\n", "                        msg = _(\n", "                            \"Deleting %(class_name)s %(instance)s would require \"\n", "                            \"deleting the following protected related objects: \"\n", "                            \"%(related_objects)s\"\n", "                        )\n", "                        raise ValidationError(\n", "                            msg, code=\"deleting_protected\", params=params\n", "                        )\n", "\n", "            def is_valid(self):\n", "                result = super().is_valid()\n", "                self.hand_clean_DELETE()\n", "                return result\n", "\n", "            def has_changed(self):\n", "                # Protect against unauthorized edits.\n", "                if not can_change and not self.instance._state.adding:\n", "                    return False\n", "                if not can_add and self.instance._state.adding:\n", "                    return False\n", "                return super().has_changed()\n", "\n", "        defaults[\"form\"] = DeleteProtectedModelForm\n", "\n", "        if defaults[\"fields\"] is None and not modelform_defines_fields(\n", "            defaults[\"form\"]\n", "        ):\n", "            defaults[\"fields\"] = forms.ALL_FIELDS\n", "\n", "        return inlineformset_factory(self.parent_model, self.model, **defaults)\n"]}, {"span_id": "InlineModelAdmin", "start_line": 2284, "end_line": 2305, "content": ["class InlineModelAdmin(BaseModelAdmin):\n", "    \"\"\"\n", "    Options for inline editing of ``model`` instances.\n", "\n", "    Provide ``fk_name`` to specify the attribute name of the ``ForeignKey``\n", "    from ``model`` to its parent. This is required if ``model`` has more than\n", "    one ``ForeignKey`` to its parent.\n", "    \"\"\"\n", "\n", "    model = None\n", "    fk_name = None\n", "    formset = BaseInlineFormSet\n", "    extra = 3\n", "    min_num = None\n", "    max_num = None\n", "    template = None\n", "    verbose_name = None\n", "    verbose_name_plural = None\n", "    can_delete = True\n", "    show_change_link = False\n", "    checks_class = InlineModelAdminChecks\n", "    classes = None\n"]}]}]}