{"instance_id": "sympy__sympy-16106", "identified_spans": [{"file_path": "sympy/printing/mathml.py", "span_ids": ["MathMLContentPrinter", "MathMLPrinterBase", "MathMLPresentationPrinter", "print_mathml"], "content": [{"span_id": "MathMLContentPrinter", "start_line": 119, "end_line": 124, "content": ["class MathMLContentPrinter(MathMLPrinterBase):\n", "    \"\"\"Prints an expression to the Content MathML markup language.\n", "\n", "    References: https://www.w3.org/TR/MathML2/chapter4.html\n", "    \"\"\"\n", "    printmethod = \"_mathml_content\"\n"]}, {"span_id": "MathMLPrinterBase", "start_line": 15, "end_line": 34, "content": ["class MathMLPrinterBase(Printer):\n", "    \"\"\"Contains common code required for MathMLContentPrinter and\n", "    MathMLPresentationPrinter.\n", "    \"\"\"\n", "\n", "    _default_settings = {\n", "        \"order\": None,\n", "        \"encoding\": \"utf-8\",\n", "        \"fold_frac_powers\": False,\n", "        \"fold_func_brackets\": False,\n", "        \"fold_short_frac\": None,\n", "        \"inv_trig_style\": \"abbreviated\",\n", "        \"ln_notation\": False,\n", "        \"long_frac_ratio\": None,\n", "        \"mat_delim\": \"[\",\n", "        \"mat_symbol_style\": \"plain\",\n", "        \"mul_symbol\": None,\n", "        \"root_notation\": True,\n", "        \"symbol_names\": {},\n", "    }\n"]}, {"span_id": "MathMLPresentationPrinter", "start_line": 481, "end_line": 486, "content": ["class MathMLPresentationPrinter(MathMLPrinterBase):\n", "    \"\"\"Prints an expression to the Presentation MathML markup language.\n", "\n", "    References: https://www.w3.org/TR/MathML2/chapter3.html\n", "    \"\"\"\n", "    printmethod = \"_mathml_presentation\"\n"]}, {"span_id": "print_mathml", "start_line": 1284, "end_line": 1318, "content": ["def print_mathml(expr, printer='content', **settings):\n", "    \"\"\"\n", "    Prints a pretty representation of the MathML code for expr. If printer is\n", "    presentation then prints Presentation MathML else prints content MathML.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> ##\n", "    >>> from sympy.printing.mathml import print_mathml\n", "    >>> from sympy.abc import x\n", "    >>> print_mathml(x+1) #doctest: +NORMALIZE_WHITESPACE\n", "    <apply>\n", "        <plus/>\n", "        <ci>x</ci>\n", "        <cn>1</cn>\n", "    </apply>\n", "    >>> print_mathml(x+1, printer='presentation')\n", "    <mrow>\n", "        <mi>x</mi>\n", "        <mo>+</mo>\n", "        <mn>1</mn>\n", "    </mrow>\n", "\n", "    \"\"\"\n", "    if printer == 'presentation':\n", "        s = MathMLPresentationPrinter(settings)\n", "    else:\n", "        s = MathMLContentPrinter(settings)\n", "    xml = s._print(sympify(expr))\n", "    s.apply_patch()\n", "    pretty_xml = xml.toprettyxml()\n", "    s.restore_patch()\n", "\n", "    print(pretty_xml)\n"]}]}, {"file_path": "sympy/tensor/indexed.py", "span_ids": ["IndexedBase", "Indexed.indices", "IndexedBase.__new__", "Indexed.__new__", "Indexed.base", "Indexed", "IndexedBase.__getitem__"], "content": [{"span_id": "IndexedBase", "start_line": 334, "end_line": 387, "content": ["class IndexedBase(Expr, NotIterable):\n", "    \"\"\"Represent the base or stem of an indexed object\n", "\n", "    The IndexedBase class represent an array that contains elements. The main purpose\n", "    of this class is to allow the convenient creation of objects of the Indexed\n", "    class.  The __getitem__ method of IndexedBase returns an instance of\n", "    Indexed.  Alone, without indices, the IndexedBase class can be used as a\n", "    notation for e.g. matrix equations, resembling what you could do with the\n", "    Symbol class.  But, the IndexedBase class adds functionality that is not\n", "    available for Symbol instances:\n", "\n", "      -  An IndexedBase object can optionally store shape information.  This can\n", "         be used in to check array conformance and conditions for numpy\n", "         broadcasting.  (TODO)\n", "      -  An IndexedBase object implements syntactic sugar that allows easy symbolic\n", "         representation of array operations, using implicit summation of\n", "         repeated indices.\n", "      -  The IndexedBase object symbolizes a mathematical structure equivalent\n", "         to arrays, and is recognized as such for code generation and automatic\n", "         compilation and wrapping.\n", "\n", "    >>> from sympy.tensor import IndexedBase, Idx\n", "    >>> from sympy import symbols\n", "    >>> A = IndexedBase('A'); A\n", "    A\n", "    >>> type(A)\n", "    <class 'sympy.tensor.indexed.IndexedBase'>\n", "\n", "    When an IndexedBase object receives indices, it returns an array with named\n", "    axes, represented by an Indexed object:\n", "\n", "    >>> i, j = symbols('i j', integer=True)\n", "    >>> A[i, j, 2]\n", "    A[i, j, 2]\n", "    >>> type(A[i, j, 2])\n", "    <class 'sympy.tensor.indexed.Indexed'>\n", "\n", "    The IndexedBase constructor takes an optional shape argument.  If given,\n", "    it overrides any shape information in the indices. (But not the index\n", "    ranges!)\n", "\n", "    >>> m, n, o, p = symbols('m n o p', integer=True)\n", "    >>> i = Idx('i', m)\n", "    >>> j = Idx('j', n)\n", "    >>> A[i, j].shape\n", "    (m, n)\n", "    >>> B = IndexedBase('B', shape=(o, p))\n", "    >>> B[i, j].shape\n", "    (o, p)\n", "\n", "    \"\"\"\n", "    is_commutative = True\n", "    is_symbol = True\n", "    is_Atom = True\n"]}, {"span_id": "Indexed.indices", "start_line": 208, "end_line": 222, "content": ["    @property\n", "    def indices(self):\n", "        \"\"\"\n", "        Returns the indices of the ``Indexed`` object.\n", "\n", "        Examples\n", "        ========\n", "\n", "        >>> from sympy import Indexed, Idx, symbols\n", "        >>> i, j = symbols('i j', cls=Idx)\n", "        >>> Indexed('A', i, j).indices\n", "        (i, j)\n", "\n", "        \"\"\"\n", "        return self.args[1:]\n"]}, {"span_id": "IndexedBase.__new__", "start_line": 389, "end_line": 419, "content": ["    def __new__(cls, label, shape=None, **kw_args):\n", "        from sympy import MatrixBase, NDimArray\n", "\n", "        if isinstance(label, string_types):\n", "            label = Symbol(label)\n", "        elif isinstance(label, Symbol):\n", "            pass\n", "        elif isinstance(label, (MatrixBase, NDimArray)):\n", "            return label\n", "        elif isinstance(label, Iterable):\n", "            return _sympify(label)\n", "        else:\n", "            label = _sympify(label)\n", "\n", "        if is_sequence(shape):\n", "            shape = Tuple(*shape)\n", "        elif shape is not None:\n", "            shape = Tuple(shape)\n", "\n", "        offset = kw_args.pop('offset', S.Zero)\n", "        strides = kw_args.pop('strides', None)\n", "\n", "        if shape is not None:\n", "            obj = Expr.__new__(cls, label, shape)\n", "        else:\n", "            obj = Expr.__new__(cls, label)\n", "        obj._shape = shape\n", "        obj._offset = offset\n", "        obj._strides = strides\n", "        obj._name = str(label)\n", "        return obj\n"]}, {"span_id": "Indexed.__new__", "start_line": 140, "end_line": 159, "content": ["    def __new__(cls, base, *args, **kw_args):\n", "        from sympy.utilities.misc import filldedent\n", "        from sympy.tensor.array.ndim_array import NDimArray\n", "        from sympy.matrices.matrices import MatrixBase\n", "\n", "        if not args:\n", "            raise IndexException(\"Indexed needs at least one index.\")\n", "        if isinstance(base, (string_types, Symbol)):\n", "            base = IndexedBase(base)\n", "        elif not hasattr(base, '__getitem__') and not isinstance(base, IndexedBase):\n", "            raise TypeError(filldedent(\"\"\"\n", "                Indexed expects string, Symbol, or IndexedBase as base.\"\"\"))\n", "        args = list(map(sympify, args))\n", "        if isinstance(base, (NDimArray, Iterable, Tuple, MatrixBase)) and all([i.is_number for i in args]):\n", "            if len(args) == 1:\n", "                return base[args[0]]\n", "            else:\n", "                return base[args]\n", "\n", "        return Expr.__new__(cls, base, *args, **kw_args)\n"]}, {"span_id": "Indexed.base", "start_line": 190, "end_line": 206, "content": ["    @property\n", "    def base(self):\n", "        \"\"\"Returns the ``IndexedBase`` of the ``Indexed`` object.\n", "\n", "        Examples\n", "        ========\n", "\n", "        >>> from sympy import Indexed, IndexedBase, Idx, symbols\n", "        >>> i, j = symbols('i j', cls=Idx)\n", "        >>> Indexed('A', i, j).base\n", "        A\n", "        >>> B = IndexedBase('B')\n", "        >>> B == B[i, j].base\n", "        True\n", "\n", "        \"\"\"\n", "        return self.args[0]\n"]}, {"span_id": "Indexed", "start_line": 120, "end_line": 138, "content": ["class Indexed(Expr):\n", "    \"\"\"Represents a mathematical object with indices.\n", "\n", "    >>> from sympy import Indexed, IndexedBase, Idx, symbols\n", "    >>> i, j = symbols('i j', cls=Idx)\n", "    >>> Indexed('A', i, j)\n", "    A[i, j]\n", "\n", "    It is recommended that ``Indexed`` objects be created via ``IndexedBase``:\n", "\n", "    >>> A = IndexedBase('A')\n", "    >>> Indexed('A', i, j) == A[i, j]\n", "    True\n", "\n", "    \"\"\"\n", "    is_commutative = True\n", "    is_Indexed = True\n", "    is_symbol = True\n", "    is_Atom = True\n"]}, {"span_id": "IndexedBase.__getitem__", "start_line": 425, "end_line": 434, "content": ["    def __getitem__(self, indices, **kw_args):\n", "        if is_sequence(indices):\n", "            # Special case needed because M[*my_tuple] is a syntax error.\n", "            if self.shape and len(self.shape) != len(indices):\n", "                raise IndexException(\"Rank mismatch.\")\n", "            return Indexed(self, *indices, **kw_args)\n", "        else:\n", "            if self.shape and len(self.shape) != 1:\n", "                raise IndexException(\"Rank mismatch.\")\n", "            return Indexed(self, indices, **kw_args)\n"]}]}]}