{"instance_id": "sympy__sympy-20154", "identified_spans": [{"file_path": "sympy/utilities/iterables.py", "span_ids": ["partitions"], "content": [{"span_id": "partitions", "start_line": 1696, "end_line": 1847, "content": ["def partitions(n, m=None, k=None, size=False):\n", "    \"\"\"Generate all partitions of positive integer, n.\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    m : integer (default gives partitions of all sizes)\n", "        limits number of parts in partition (mnemonic: m, maximum parts)\n", "    k : integer (default gives partitions number from 1 through n)\n", "        limits the numbers that are kept in the partition (mnemonic: k, keys)\n", "    size : bool (default False, only partition is returned)\n", "        when ``True`` then (M, P) is returned where M is the sum of the\n", "        multiplicities and P is the generated partition.\n", "\n", "    Each partition is represented as a dictionary, mapping an integer\n", "    to the number of copies of that integer in the partition.  For example,\n", "    the first partition of 4 returned is {4: 1}, \"4: one of them\".\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.utilities.iterables import partitions\n", "\n", "    The numbers appearing in the partition (the key of the returned dict)\n", "    are limited with k:\n", "\n", "    >>> for p in partitions(6, k=2):  # doctest: +SKIP\n", "    ...     print(p)\n", "    {2: 3}\n", "    {1: 2, 2: 2}\n", "    {1: 4, 2: 1}\n", "    {1: 6}\n", "\n", "    The maximum number of parts in the partition (the sum of the values in\n", "    the returned dict) are limited with m (default value, None, gives\n", "    partitions from 1 through n):\n", "\n", "    >>> for p in partitions(6, m=2):  # doctest: +SKIP\n", "    ...     print(p)\n", "    ...\n", "    {6: 1}\n", "    {1: 1, 5: 1}\n", "    {2: 1, 4: 1}\n", "    {3: 2}\n", "\n", "    Note that the _same_ dictionary object is returned each time.\n", "    This is for speed:  generating each partition goes quickly,\n", "    taking constant time, independent of n.\n", "\n", "    >>> [p for p in partitions(6, k=2)]\n", "    [{1: 6}, {1: 6}, {1: 6}, {1: 6}]\n", "\n", "    If you want to build a list of the returned dictionaries then\n", "    make a copy of them:\n", "\n", "    >>> [p.copy() for p in partitions(6, k=2)]  # doctest: +SKIP\n", "    [{2: 3}, {1: 2, 2: 2}, {1: 4, 2: 1}, {1: 6}]\n", "    >>> [(M, p.copy()) for M, p in partitions(6, k=2, size=True)]  # doctest: +SKIP\n", "    [(3, {2: 3}), (4, {1: 2, 2: 2}), (5, {1: 4, 2: 1}), (6, {1: 6})]\n", "\n", "    References\n", "    ==========\n", "\n", "    .. [1] modified from Tim Peter's version to allow for k and m values:\n", "           http://code.activestate.com/recipes/218332-generator-for-integer-partitions/\n", "\n", "    See Also\n", "    ========\n", "\n", "    sympy.combinatorics.partitions.Partition\n", "    sympy.combinatorics.partitions.IntegerPartition\n", "\n", "    \"\"\"\n", "    if (n <= 0 or\n", "        m is not None and m < 1 or\n", "        k is not None and k < 1 or\n", "        m and k and m*k < n):\n", "        # the empty set is the only way to handle these inputs\n", "        # and returning {} to represent it is consistent with\n", "        # the counting convention, e.g. nT(0) == 1.\n", "        if size:\n", "            yield 0, {}\n", "        else:\n", "            yield {}\n", "        return\n", "\n", "    if m is None:\n", "        m = n\n", "    else:\n", "        m = min(m, n)\n", "\n", "    if n == 0:\n", "        if size:\n", "            yield 1, {0: 1}\n", "        else:\n", "            yield {0: 1}\n", "        return\n", "\n", "    k = min(k or n, n)\n", "\n", "    n, m, k = as_int(n), as_int(m), as_int(k)\n", "    q, r = divmod(n, k)\n", "    ms = {k: q}\n", "    keys = [k]  # ms.keys(), from largest to smallest\n", "    if r:\n", "        ms[r] = 1\n", "        keys.append(r)\n", "    room = m - q - bool(r)\n", "    if size:\n", "        yield sum(ms.values()), ms\n", "    else:\n", "        yield ms\n", "\n", "    while keys != [1]:\n", "        # Reuse any 1's.\n", "        if keys[-1] == 1:\n", "            del keys[-1]\n", "            reuse = ms.pop(1)\n", "            room += reuse\n", "        else:\n", "            reuse = 0\n", "\n", "        while 1:\n", "            # Let i be the smallest key larger than 1.  Reuse one\n", "            # instance of i.\n", "            i = keys[-1]\n", "            newcount = ms[i] = ms[i] - 1\n", "            reuse += i\n", "            if newcount == 0:\n", "                del keys[-1], ms[i]\n", "            room += 1\n", "\n", "            # Break the remainder into pieces of size i-1.\n", "            i -= 1\n", "            q, r = divmod(reuse, i)\n", "            need = q + bool(r)\n", "            if need > room:\n", "                if not keys:\n", "                    return\n", "                continue\n", "\n", "            ms[i] = q\n", "            keys.append(i)\n", "            if r:\n", "                ms[r] = 1\n", "                keys.append(r)\n", "            break\n", "        room -= need\n", "        if size:\n", "            yield sum(ms.values()), ms\n", "        else:\n", "            yield ms\n"]}]}]}