{"instance_id": "astropy__astropy-12907", "identified_spans": [{"file_path": "astropy/modeling/separable.py", "span_ids": ["_separable", "separability_matrix", "_coord_matrix", "_cstack"], "content": [{"span_id": "_separable", "start_line": 290, "end_line": 311, "content": ["def _separable(transform):\n", "    \"\"\"\n", "    Calculate the separability of outputs.\n", "\n", "    Parameters\n", "    ----------\n", "    transform : `astropy.modeling.Model`\n", "        A transform (usually a compound model).\n", "\n", "    Returns :\n", "    is_separable : ndarray of dtype np.bool\n", "        An array of shape (transform.n_outputs,) of boolean type\n", "        Each element represents the separablity of the corresponding output.\n", "    \"\"\"\n", "    if (transform_matrix := transform._calculate_separability_matrix()) is not NotImplemented:\n", "        return transform_matrix\n", "    elif isinstance(transform, CompoundModel):\n", "        sepleft = _separable(transform.left)\n", "        sepright = _separable(transform.right)\n", "        return _operators[transform.op](sepleft, sepright)\n", "    elif isinstance(transform, Model):\n", "        return _coord_matrix(transform, 'left', transform.n_outputs)\n"]}, {"span_id": "separability_matrix", "start_line": 66, "end_line": 102, "content": ["def separability_matrix(transform):\n", "    \"\"\"\n", "    Compute the correlation between outputs and inputs.\n", "\n", "    Parameters\n", "    ----------\n", "    transform : `~astropy.modeling.core.Model`\n", "        A (compound) model.\n", "\n", "    Returns\n", "    -------\n", "    separable_matrix : ndarray\n", "        A boolean correlation matrix of shape (n_outputs, n_inputs).\n", "        Indicates the dependence of outputs on inputs. For completely\n", "        independent outputs, the diagonal elements are True and\n", "        off-diagonal elements are False.\n", "\n", "    Examples\n", "    --------\n", "    >>> from astropy.modeling.models import Shift, Scale, Rotation2D, Polynomial2D\n", "    >>> separability_matrix(Shift(1) & Shift(2) | Scale(1) & Scale(2))\n", "        array([[ True, False], [False,  True]]...)\n", "    >>> separability_matrix(Shift(1) & Shift(2) | Rotation2D(2))\n", "        array([[ True,  True], [ True,  True]]...)\n", "    >>> separability_matrix(Shift(1) & Shift(2) | Mapping([0, 1, 0, 1]) | \\\n", "        Polynomial2D(1) & Polynomial2D(2))\n", "        array([[ True,  True], [ True,  True]]...)\n", "    >>> separability_matrix(Shift(1) & Shift(2) | Mapping([0, 1, 0, 1]))\n", "        array([[ True, False], [False,  True], [ True, False], [False,  True]]...)\n", "\n", "    \"\"\"\n", "    if transform.n_inputs == 1 and transform.n_outputs > 1:\n", "        return np.ones((transform.n_outputs, transform.n_inputs),\n", "                       dtype=np.bool_)\n", "    separable_matrix = _separable(transform)\n", "    separable_matrix = np.where(separable_matrix != 0, True, False)\n", "    return separable_matrix\n"]}, {"span_id": "_coord_matrix", "start_line": 171, "end_line": 216, "content": ["def _coord_matrix(model, pos, noutp):\n", "    \"\"\"\n", "    Create an array representing inputs and outputs of a simple model.\n", "\n", "    The array has a shape (noutp, model.n_inputs).\n", "\n", "    Parameters\n", "    ----------\n", "    model : `astropy.modeling.Model`\n", "        model\n", "    pos : str\n", "        Position of this model in the expression tree.\n", "        One of ['left', 'right'].\n", "    noutp : int\n", "        Number of outputs of the compound model of which the input model\n", "        is a left or right child.\n", "\n", "    \"\"\"\n", "    if isinstance(model, Mapping):\n", "        axes = []\n", "        for i in model.mapping:\n", "            axis = np.zeros((model.n_inputs,))\n", "            axis[i] = 1\n", "            axes.append(axis)\n", "        m = np.vstack(axes)\n", "        mat = np.zeros((noutp, model.n_inputs))\n", "        if pos == 'left':\n", "            mat[: model.n_outputs, :model.n_inputs] = m\n", "        else:\n", "            mat[-model.n_outputs:, -model.n_inputs:] = m\n", "        return mat\n", "    if not model.separable:\n", "        # this does not work for more than 2 coordinates\n", "        mat = np.zeros((noutp, model.n_inputs))\n", "        if pos == 'left':\n", "            mat[:model.n_outputs, : model.n_inputs] = 1\n", "        else:\n", "            mat[-model.n_outputs:, -model.n_inputs:] = 1\n", "    else:\n", "        mat = np.zeros((noutp, model.n_inputs))\n", "\n", "        for i in range(model.n_inputs):\n", "            mat[i, i] = 1\n", "        if pos == 'right':\n", "            mat = np.roll(mat, (noutp - model.n_outputs))\n", "    return mat\n"]}, {"span_id": "_cstack", "start_line": 219, "end_line": 247, "content": ["def _cstack(left, right):\n", "    \"\"\"\n", "    Function corresponding to '&' operation.\n", "\n", "    Parameters\n", "    ----------\n", "    left, right : `astropy.modeling.Model` or ndarray\n", "        If input is of an array, it is the output of `coord_matrix`.\n", "\n", "    Returns\n", "    -------\n", "    result : ndarray\n", "        Result from this operation.\n", "\n", "    \"\"\"\n", "    noutp = _compute_n_outputs(left, right)\n", "\n", "    if isinstance(left, Model):\n", "        cleft = _coord_matrix(left, 'left', noutp)\n", "    else:\n", "        cleft = np.zeros((noutp, left.shape[1]))\n", "        cleft[: left.shape[0], : left.shape[1]] = left\n", "    if isinstance(right, Model):\n", "        cright = _coord_matrix(right, 'right', noutp)\n", "    else:\n", "        cright = np.zeros((noutp, right.shape[1]))\n", "        cright[-right.shape[0]:, -right.shape[1]:] = 1\n", "\n", "    return np.hstack([cleft, cright])\n"]}]}]}