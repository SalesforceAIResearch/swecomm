{"instance_id": "sympy__sympy-12236", "identified_spans": [{"file_path": "sympy/polys/partfrac.py", "span_ids": ["apart_list", "apart"], "content": [{"span_id": "apart_list", "start_line": 213, "end_line": 351, "content": ["@public\n", "def apart_list(f, x=None, dummies=None, **options):\n", "    \"\"\"\n", "    Compute partial fraction decomposition of a rational function\n", "    and return the result in structured form.\n", "\n", "    Given a rational function ``f`` compute the partial fraction decomposition\n", "    of ``f``. Only Bronstein's full partial fraction decomposition algorithm\n", "    is supported by this method. The return value is highly structured and\n", "    perfectly suited for further algorithmic treatment rather than being\n", "    human-readable. The function returns a tuple holding three elements:\n", "\n", "    * The first item is the common coefficient, free of the variable `x` used\n", "      for decomposition. (It is an element of the base field `K`.)\n", "\n", "    * The second item is the polynomial part of the decomposition. This can be\n", "      the zero polynomial. (It is an element of `K[x]`.)\n", "\n", "    * The third part itself is a list of quadruples. Each quadruple\n", "      has the following elements in this order:\n", "\n", "      - The (not necessarily irreducible) polynomial `D` whose roots `w_i` appear\n", "        in the linear denominator of a bunch of related fraction terms. (This item\n", "        can also be a list of explicit roots. However, at the moment ``apart_list``\n", "        never returns a result this way, but the related ``assemble_partfrac_list``\n", "        function accepts this format as input.)\n", "\n", "      - The numerator of the fraction, written as a function of the root `w`\n", "\n", "      - The linear denominator of the fraction *excluding its power exponent*,\n", "        written as a function of the root `w`.\n", "\n", "      - The power to which the denominator has to be raised.\n", "\n", "    On can always rebuild a plain expression by using the function ``assemble_partfrac_list``.\n", "\n", "    Examples\n", "    ========\n", "\n", "    A first example:\n", "\n", "    >>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list\n", "    >>> from sympy.abc import x, t\n", "\n", "    >>> f = (2*x**3 - 2*x) / (x**2 - 2*x + 1)\n", "    >>> pfd = apart_list(f)\n", "    >>> pfd\n", "    (1,\n", "    Poly(2*x + 4, x, domain='ZZ'),\n", "    [(Poly(_w - 1, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1)])\n", "\n", "    >>> assemble_partfrac_list(pfd)\n", "    2*x + 4 + 4/(x - 1)\n", "\n", "    Second example:\n", "\n", "    >>> f = (-2*x - 2*x**2) / (3*x**2 - 6*x)\n", "    >>> pfd = apart_list(f)\n", "    >>> pfd\n", "    (-1,\n", "    Poly(2/3, x, domain='QQ'),\n", "    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 2), Lambda(_a, -_a + x), 1)])\n", "\n", "    >>> assemble_partfrac_list(pfd)\n", "    -2/3 - 2/(x - 2)\n", "\n", "    Another example, showing symbolic parameters:\n", "\n", "    >>> pfd = apart_list(t/(x**2 + x + t), x)\n", "    >>> pfd\n", "    (1,\n", "    Poly(0, x, domain='ZZ[t]'),\n", "    [(Poly(_w**2 + _w + t, _w, domain='ZZ[t]'),\n", "    Lambda(_a, -2*_a*t/(4*t - 1) - t/(4*t - 1)),\n", "    Lambda(_a, -_a + x),\n", "    1)])\n", "\n", "    >>> assemble_partfrac_list(pfd)\n", "    RootSum(_w**2 + _w + t, Lambda(_a, (-2*_a*t/(4*t - 1) - t/(4*t - 1))/(-_a + x)))\n", "\n", "    This example is taken from Bronstein's original paper:\n", "\n", "    >>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)\n", "    >>> pfd = apart_list(f)\n", "    >>> pfd\n", "    (1,\n", "    Poly(0, x, domain='ZZ'),\n", "    [(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),\n", "    (Poly(_w**2 - 1, _w, domain='ZZ'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),\n", "    (Poly(_w + 1, _w, domain='ZZ'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)])\n", "\n", "    >>> assemble_partfrac_list(pfd)\n", "    -4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2)\n", "\n", "    See also\n", "    ========\n", "\n", "    apart, assemble_partfrac_list\n", "\n", "    References\n", "    ==========\n", "\n", "    1. [Bronstein93]_\n", "\n", "    \"\"\"\n", "    allowed_flags(options, [])\n", "\n", "    f = sympify(f)\n", "\n", "    if f.is_Atom:\n", "        return f\n", "    else:\n", "        P, Q = f.as_numer_denom()\n", "\n", "    options = set_defaults(options, extension=True)\n", "    (P, Q), opt = parallel_poly_from_expr((P, Q), x, **options)\n", "\n", "    if P.is_multivariate:\n", "        raise NotImplementedError(\n", "            \"multivariate partial fraction decomposition\")\n", "\n", "    common, P, Q = P.cancel(Q)\n", "\n", "    poly, P = P.div(Q, auto=True)\n", "    P, Q = P.rat_clear_denoms(Q)\n", "\n", "    polypart = poly\n", "\n", "    if dummies is None:\n", "        def dummies(name):\n", "            d = Dummy(name)\n", "            while True:\n", "                yield d\n", "\n", "        dummies = dummies(\"w\")\n", "\n", "    rationalpart = apart_list_full_decomposition(P, Q, dummies)\n", "\n", "    return (common, polypart, rationalpart)\n"]}, {"span_id": "apart", "start_line": 15, "end_line": 149, "content": ["@xthreaded\n", "@public\n", "def apart(f, x=None, full=False, **options):\n", "    \"\"\"\n", "    Compute partial fraction decomposition of a rational function.\n", "\n", "    Given a rational function ``f``, computes the partial fraction\n", "    decomposition of ``f``. Two algorithms are available: One is based on the\n", "    undertermined coefficients method, the other is Bronstein's full partial\n", "    fraction decomposition algorithm.\n", "\n", "    The undetermined coefficients method (selected by ``full=False``) uses\n", "    polynomial factorization (and therefore accepts the same options as\n", "    factor) for the denominator. Per default it works over the rational\n", "    numbers, therefore decomposition of denominators with non-rational roots\n", "    (e.g. irrational, complex roots) is not supported by default (see options\n", "    of factor).\n", "\n", "    Bronstein's algorithm can be selected by using ``full=True`` and allows a\n", "    decomposition of denominators with non-rational roots. A human-readable\n", "    result can be obtained via ``doit()`` (see examples below).\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.polys.partfrac import apart\n", "    >>> from sympy.abc import x, y\n", "\n", "    By default, using the undetermined coefficients method:\n", "\n", "    >>> apart(y/(x + 2)/(x + 1), x)\n", "    -y/(x + 2) + y/(x + 1)\n", "\n", "    The undetermined coefficients method does not provide a result when the\n", "    denominators roots are not rational:\n", "\n", "    >>> apart(y/(x**2 + x + 1), x)\n", "    y/(x**2 + x + 1)\n", "\n", "    You can choose Bronstein's algorithm by setting ``full=True``:\n", "\n", "    >>> apart(y/(x**2 + x + 1), x, full=True)\n", "    RootSum(_w**2 + _w + 1, Lambda(_a, (-2*_a*y/3 - y/3)/(-_a + x)))\n", "\n", "    Calling ``doit()`` yields a human-readable result:\n", "\n", "    >>> apart(y/(x**2 + x + 1), x, full=True).doit()\n", "    (-y/3 - 2*y*(-1/2 - sqrt(3)*I/2)/3)/(x + 1/2 + sqrt(3)*I/2) + (-y/3 -\n", "        2*y*(-1/2 + sqrt(3)*I/2)/3)/(x + 1/2 - sqrt(3)*I/2)\n", "\n", "\n", "    See Also\n", "    ========\n", "\n", "    apart_list, assemble_partfrac_list\n", "    \"\"\"\n", "    allowed_flags(options, [])\n", "\n", "    f = sympify(f)\n", "\n", "    if f.is_Atom:\n", "        return f\n", "    else:\n", "        P, Q = f.as_numer_denom()\n", "\n", "    _options = options.copy()\n", "    options = set_defaults(options, extension=True)\n", "    try:\n", "        (P, Q), opt = parallel_poly_from_expr((P, Q), x, **options)\n", "    except PolynomialError as msg:\n", "        if f.is_commutative:\n", "            raise PolynomialError(msg)\n", "        # non-commutative\n", "        if f.is_Mul:\n", "            c, nc = f.args_cnc(split_1=False)\n", "            nc = f.func(*nc)\n", "            if c:\n", "                c = apart(f.func._from_args(c), x=x, full=full, **_options)\n", "                return c*nc\n", "            else:\n", "                return nc\n", "        elif f.is_Add:\n", "            c = []\n", "            nc = []\n", "            for i in f.args:\n", "                if i.is_commutative:\n", "                    c.append(i)\n", "                else:\n", "                    try:\n", "                        nc.append(apart(i, x=x, full=full, **_options))\n", "                    except NotImplementedError:\n", "                        nc.append(i)\n", "            return apart(f.func(*c), x=x, full=full, **_options) + f.func(*nc)\n", "        else:\n", "            reps = []\n", "            pot = preorder_traversal(f)\n", "            next(pot)\n", "            for e in pot:\n", "                try:\n", "                    reps.append((e, apart(e, x=x, full=full, **_options)))\n", "                    pot.skip()  # this was handled successfully\n", "                except NotImplementedError:\n", "                    pass\n", "            return f.xreplace(dict(reps))\n", "\n", "    if P.is_multivariate:\n", "        fc = f.cancel()\n", "        if fc != f:\n", "            return apart(fc, x=x, full=full, **_options)\n", "\n", "        raise NotImplementedError(\n", "            \"multivariate partial fraction decomposition\")\n", "\n", "    common, P, Q = P.cancel(Q)\n", "\n", "    poly, P = P.div(Q, auto=True)\n", "    P, Q = P.rat_clear_denoms(Q)\n", "\n", "    if Q.degree() <= 1:\n", "        partial = P/Q\n", "    else:\n", "        if not full:\n", "            partial = apart_undetermined_coeffs(P, Q)\n", "        else:\n", "            partial = apart_full_decomposition(P, Q)\n", "\n", "    terms = S.Zero\n", "\n", "    for term in Add.make_args(partial):\n", "        if term.has(RootSum):\n", "            terms += term\n", "        else:\n", "            terms += factor(term)\n", "\n", "    return common*(poly.as_expr() + terms)\n"]}]}]}