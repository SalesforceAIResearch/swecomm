{"instance_id": "sympy__sympy-12419", "identified_spans": [{"file_path": "sympy/matrices/expressions/matadd.py", "span_ids": ["MatAdd.shape", "MatAdd.__new__", "MatAdd", "MatAdd._entry"], "content": [{"span_id": "MatAdd.shape", "start_line": 39, "end_line": 41, "content": ["    @property\n", "    def shape(self):\n", "        return self.args[0].shape\n"]}, {"span_id": "MatAdd.__new__", "start_line": 30, "end_line": 37, "content": ["    def __new__(cls, *args, **kwargs):\n", "        args = list(map(sympify, args))\n", "        check = kwargs.get('check', True)\n", "\n", "        obj = Basic.__new__(cls, *args)\n", "        if check:\n", "            validate(*args)\n", "        return obj\n"]}, {"span_id": "MatAdd", "start_line": 16, "end_line": 28, "content": ["class MatAdd(MatrixExpr):\n", "    \"\"\"A Sum of Matrix Expressions\n", "\n", "    MatAdd inherits from and operates like SymPy Add\n", "\n", "    >>> from sympy import MatAdd, MatrixSymbol\n", "    >>> A = MatrixSymbol('A', 5, 5)\n", "    >>> B = MatrixSymbol('B', 5, 5)\n", "    >>> C = MatrixSymbol('C', 5, 5)\n", "    >>> MatAdd(A, B, C)\n", "    A + B + C\n", "    \"\"\"\n", "    is_MatAdd = True\n"]}, {"span_id": "MatAdd._entry", "start_line": 43, "end_line": 44, "content": ["    def _entry(self, i, j):\n", "        return Add(*[arg._entry(i, j) for arg in self.args])\n"]}]}, {"file_path": "sympy/matrices/expressions/matexpr.py", "span_ids": ["MatrixExpr.is_square", "MatrixExpr.I", "MatrixExpr"], "content": [{"span_id": "MatrixExpr.is_square", "start_line": 165, "end_line": 167, "content": ["    @property\n", "    def is_square(self):\n", "        return self.rows == self.cols\n"]}, {"span_id": "MatrixExpr.I", "start_line": 219, "end_line": 221, "content": ["    @property\n", "    def I(self):\n", "        return self.inverse()\n"]}, {"span_id": "MatrixExpr", "start_line": 30, "end_line": 69, "content": ["class MatrixExpr(Basic):\n", "    \"\"\" Superclass for Matrix Expressions\n", "\n", "    MatrixExprs represent abstract matrices, linear transformations represented\n", "    within a particular basis.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import MatrixSymbol\n", "    >>> A = MatrixSymbol('A', 3, 3)\n", "    >>> y = MatrixSymbol('y', 3, 1)\n", "    >>> x = (A.T*A).I * A * y\n", "\n", "    See Also\n", "    ========\n", "        MatrixSymbol\n", "        MatAdd\n", "        MatMul\n", "        Transpose\n", "        Inverse\n", "    \"\"\"\n", "\n", "    # Should not be considered iterable by the\n", "    # sympy.core.compatibility.iterable function. Subclass that actually are\n", "    # iterable (i.e., explicit matrices) should set this to True.\n", "    _iterable = False\n", "\n", "    _op_priority = 11.0\n", "\n", "    is_Matrix = True\n", "    is_MatrixExpr = True\n", "    is_Identity = None\n", "    is_Inverse = False\n", "    is_Transpose = False\n", "    is_ZeroMatrix = False\n", "    is_MatAdd = False\n", "    is_MatMul = False\n", "\n", "    is_commutative = False\n"]}]}, {"file_path": "sympy/matrices/expressions/matmul.py", "span_ids": ["refine_MatMul"], "content": [{"span_id": "refine_MatMul", "start_line": 256, "end_line": 287, "content": ["def refine_MatMul(expr, assumptions):\n", "    \"\"\"\n", "    >>> from sympy import MatrixSymbol, Q, assuming, refine\n", "    >>> X = MatrixSymbol('X', 2, 2)\n", "    >>> expr = X * X.T\n", "    >>> print(expr)\n", "    X*X.T\n", "    >>> with assuming(Q.orthogonal(X)):\n", "    ...     print(refine(expr))\n", "    I\n", "    \"\"\"\n", "    newargs = []\n", "    exprargs = []\n", "\n", "    for args in expr.args:\n", "        if args.is_Matrix:\n", "            exprargs.append(args)\n", "        else:\n", "            newargs.append(args)\n", "\n", "    last = exprargs[0]\n", "    for arg in exprargs[1:]:\n", "        if arg == last.T and ask(Q.orthogonal(arg), assumptions):\n", "            last = Identity(arg.shape[0])\n", "        elif arg == last.conjugate() and ask(Q.unitary(arg), assumptions):\n", "            last = Identity(arg.shape[0])\n", "        else:\n", "            newargs.append(last)\n", "            last = arg\n", "    newargs.append(last)\n", "\n", "    return MatMul(*newargs)\n"]}]}, {"file_path": "sympy/physics/quantum/identitysearch.py", "span_ids": ["is_scalar_sparse_matrix"], "content": [{"span_id": "is_scalar_sparse_matrix", "start_line": 31, "end_line": 116, "content": ["def is_scalar_sparse_matrix(circuit, nqubits, identity_only, eps=1e-11):\n", "    \"\"\"Checks if a given scipy.sparse matrix is a scalar matrix.\n", "\n", "    A scalar matrix is such that B = bI, where B is the scalar\n", "    matrix, b is some scalar multiple, and I is the identity\n", "    matrix.  A scalar matrix would have only the element b along\n", "    it's main diagonal and zeroes elsewhere.\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    circuit : Gate tuple\n", "        Sequence of quantum gates representing a quantum circuit\n", "    nqubits : int\n", "        Number of qubits in the circuit\n", "    identity_only : bool\n", "        Check for only identity matrices\n", "    eps : number\n", "        The tolerance value for zeroing out elements in the matrix.\n", "        Values in the range [-eps, +eps] will be changed to a zero.\n", "    \"\"\"\n", "\n", "    if not np or not scipy:\n", "        pass\n", "\n", "    matrix = represent(Mul(*circuit), nqubits=nqubits,\n", "                       format='scipy.sparse')\n", "\n", "    # In some cases, represent returns a 1D scalar value in place\n", "    # of a multi-dimensional scalar matrix\n", "    if (isinstance(matrix, int)):\n", "        return matrix == 1 if identity_only else True\n", "\n", "    # If represent returns a matrix, check if the matrix is diagonal\n", "    # and if every item along the diagonal is the same\n", "    else:\n", "        # Due to floating pointing operations, must zero out\n", "        # elements that are \"very\" small in the dense matrix\n", "        # See parameter for default value.\n", "\n", "        # Get the ndarray version of the dense matrix\n", "        dense_matrix = matrix.todense().getA()\n", "        # Since complex values can't be compared, must split\n", "        # the matrix into real and imaginary components\n", "        # Find the real values in between -eps and eps\n", "        bool_real = np.logical_and(dense_matrix.real > -eps,\n", "                                   dense_matrix.real < eps)\n", "        # Find the imaginary values between -eps and eps\n", "        bool_imag = np.logical_and(dense_matrix.imag > -eps,\n", "                                   dense_matrix.imag < eps)\n", "        # Replaces values between -eps and eps with 0\n", "        corrected_real = np.where(bool_real, 0.0, dense_matrix.real)\n", "        corrected_imag = np.where(bool_imag, 0.0, dense_matrix.imag)\n", "        # Convert the matrix with real values into imaginary values\n", "        corrected_imag = corrected_imag * np.complex(1j)\n", "        # Recombine the real and imaginary components\n", "        corrected_dense = corrected_real + corrected_imag\n", "\n", "        # Check if it's diagonal\n", "        row_indices = corrected_dense.nonzero()[0]\n", "        col_indices = corrected_dense.nonzero()[1]\n", "        # Check if the rows indices and columns indices are the same\n", "        # If they match, then matrix only contains elements along diagonal\n", "        bool_indices = row_indices == col_indices\n", "        is_diagonal = bool_indices.all()\n", "\n", "        first_element = corrected_dense[0][0]\n", "        # If the first element is a zero, then can't rescale matrix\n", "        # and definitely not diagonal\n", "        if (first_element == 0.0 + 0.0j):\n", "            return False\n", "\n", "        # The dimensions of the dense matrix should still\n", "        # be 2^nqubits if there are elements all along the\n", "        # the main diagonal\n", "        trace_of_corrected = (corrected_dense/first_element).trace()\n", "        expected_trace = pow(2, nqubits)\n", "        has_correct_trace = trace_of_corrected == expected_trace\n", "\n", "        # If only looking for identity matrices\n", "        # first element must be a 1\n", "        real_is_one = abs(first_element.real - 1.0) < eps\n", "        imag_is_zero = abs(first_element.imag) < eps\n", "        is_one = real_is_one and imag_is_zero\n", "        is_identity = is_one if identity_only else True\n", "        return bool(is_diagonal and has_correct_trace and is_identity)\n"]}]}]}