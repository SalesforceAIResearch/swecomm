{"instance_id": "sphinx-doc__sphinx-10325", "identified_spans": [{"file_path": "sphinx/ext/autodoc/__init__.py", "span_ids": ["ClassDocumenter", "Documenter.filter_members", "ClassDocumenter.document_members", "ClassDocumenter.get_object_members"], "content": [{"span_id": "ClassDocumenter", "start_line": 1437, "end_line": 1453, "content": ["class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n", "    \"\"\"\n", "    Specialized Documenter subclass for classes.\n", "    \"\"\"\n", "    objtype = 'class'\n", "    member_order = 20\n", "    option_spec: OptionSpec = {\n", "        'members': members_option, 'undoc-members': bool_option,\n", "        'noindex': bool_option, 'inherited-members': inherited_members_option,\n", "        'show-inheritance': bool_option, 'member-order': member_order_option,\n", "        'exclude-members': exclude_members_option,\n", "        'private-members': members_option, 'special-members': members_option,\n", "        'class-doc-from': class_doc_from_option,\n", "    }\n", "\n", "    _signature_class: Any = None\n", "    _signature_method_name: str = None\n"]}, {"span_id": "Documenter.filter_members", "start_line": 667, "end_line": 818, "content": ["    def filter_members(self, members: ObjectMembers, want_all: bool\n", "                       ) -> List[Tuple[str, Any, bool]]:\n", "        \"\"\"Filter the given member list.\n", "\n", "        Members are skipped if\n", "\n", "        - they are private (except if given explicitly or the private-members\n", "          option is set)\n", "        - they are special methods (except if given explicitly or the\n", "          special-members option is set)\n", "        - they are undocumented (except if the undoc-members option is set)\n", "\n", "        The user can override the skipping decision by connecting to the\n", "        ``autodoc-skip-member`` event.\n", "        \"\"\"\n", "        def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n", "            if inspect.isclass(self.object):\n", "                for cls in self.object.__mro__:\n", "                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n", "                        # given member is a member of specified *super class*\n", "                        return True\n", "                    elif name in cls.__dict__:\n", "                        return False\n", "                    elif name in self.get_attr(cls, '__annotations__', {}):\n", "                        return False\n", "                    elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n", "                        return False\n", "\n", "            return False\n", "\n", "        ret = []\n", "\n", "        # search for members in source code too\n", "        namespace = '.'.join(self.objpath)  # will be empty for modules\n", "\n", "        if self.analyzer:\n", "            attr_docs = self.analyzer.find_attr_docs()\n", "        else:\n", "            attr_docs = {}\n", "\n", "        # process members and determine which to skip\n", "        for obj in members:\n", "            try:\n", "                membername, member = obj\n", "                # if isattr is True, the member is documented as an attribute\n", "                if member is INSTANCEATTR:\n", "                    isattr = True\n", "                elif (namespace, membername) in attr_docs:\n", "                    isattr = True\n", "                else:\n", "                    isattr = False\n", "\n", "                doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n", "                             self.object, membername)\n", "                if not isinstance(doc, str):\n", "                    # Ignore non-string __doc__\n", "                    doc = None\n", "\n", "                # if the member __doc__ is the same as self's __doc__, it's just\n", "                # inherited and therefore not the member's doc\n", "                cls = self.get_attr(member, '__class__', None)\n", "                if cls:\n", "                    cls_doc = self.get_attr(cls, '__doc__', None)\n", "                    if cls_doc == doc:\n", "                        doc = None\n", "\n", "                if isinstance(obj, ObjectMember) and obj.docstring:\n", "                    # hack for ClassDocumenter to inject docstring via ObjectMember\n", "                    doc = obj.docstring\n", "\n", "                doc, metadata = separate_metadata(doc)\n", "                has_doc = bool(doc)\n", "\n", "                if 'private' in metadata:\n", "                    # consider a member private if docstring has \"private\" metadata\n", "                    isprivate = True\n", "                elif 'public' in metadata:\n", "                    # consider a member public if docstring has \"public\" metadata\n", "                    isprivate = False\n", "                else:\n", "                    isprivate = membername.startswith('_')\n", "\n", "                keep = False\n", "                if ismock(member) and (namespace, membername) not in attr_docs:\n", "                    # mocked module or object\n", "                    pass\n", "                elif (self.options.exclude_members and\n", "                      membername in self.options.exclude_members):\n", "                    # remove members given by exclude-members\n", "                    keep = False\n", "                elif want_all and special_member_re.match(membername):\n", "                    # special __methods__\n", "                    if (self.options.special_members and\n", "                            membername in self.options.special_members):\n", "                        if membername == '__doc__':\n", "                            keep = False\n", "                        elif is_filtered_inherited_member(membername, obj):\n", "                            keep = False\n", "                        else:\n", "                            keep = has_doc or self.options.undoc_members\n", "                    else:\n", "                        keep = False\n", "                elif (namespace, membername) in attr_docs:\n", "                    if want_all and isprivate:\n", "                        if self.options.private_members is None:\n", "                            keep = False\n", "                        else:\n", "                            keep = membername in self.options.private_members\n", "                    else:\n", "                        # keep documented attributes\n", "                        keep = True\n", "                elif want_all and isprivate:\n", "                    if has_doc or self.options.undoc_members:\n", "                        if self.options.private_members is None:\n", "                            keep = False\n", "                        elif is_filtered_inherited_member(membername, obj):\n", "                            keep = False\n", "                        else:\n", "                            keep = membername in self.options.private_members\n", "                    else:\n", "                        keep = False\n", "                else:\n", "                    if (self.options.members is ALL and\n", "                            is_filtered_inherited_member(membername, obj)):\n", "                        keep = False\n", "                    else:\n", "                        # ignore undocumented members if :undoc-members: is not given\n", "                        keep = has_doc or self.options.undoc_members\n", "\n", "                if isinstance(obj, ObjectMember) and obj.skipped:\n", "                    # forcedly skipped member (ex. a module attribute not defined in __all__)\n", "                    keep = False\n", "\n", "                # give the user a chance to decide whether this member\n", "                # should be skipped\n", "                if self.env.app:\n", "                    # let extensions preprocess docstrings\n", "                    skip_user = self.env.app.emit_firstresult(\n", "                        'autodoc-skip-member', self.objtype, membername, member,\n", "                        not keep, self.options)\n", "                    if skip_user is not None:\n", "                        keep = not skip_user\n", "            except Exception as exc:\n", "                logger.warning(__('autodoc: failed to determine %s.%s (%r) to be documented, '\n", "                                  'the following exception was raised:\\n%s'),\n", "                               self.name, membername, member, exc, type='autodoc')\n", "                keep = False\n", "\n", "            if keep:\n", "                ret.append((membername, member, isattr))\n", "\n", "        return ret\n"]}, {"span_id": "ClassDocumenter.document_members", "start_line": 1803, "end_line": 1806, "content": ["    def document_members(self, all_members: bool = False) -> None:\n", "        if self.doc_as_attr:\n", "            return\n", "        super().document_members(all_members)\n"]}, {"span_id": "ClassDocumenter.get_object_members", "start_line": 1698, "end_line": 1715, "content": ["    def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n", "        members = get_class_members(self.object, self.objpath, self.get_attr)\n", "        if not want_all:\n", "            if not self.options.members:\n", "                return False, []  # type: ignore\n", "            # specific members given\n", "            selected = []\n", "            for name in self.options.members:  # type: str\n", "                if name in members:\n", "                    selected.append(members[name])\n", "                else:\n", "                    logger.warning(__('missing attribute %s in object %s') %\n", "                                   (name, self.fullname), type='autodoc')\n", "            return False, selected\n", "        elif self.options.inherited_members:\n", "            return False, list(members.values())\n", "        else:\n", "            return False, [m for m in members.values() if m.class_ == self.object]\n"]}]}]}