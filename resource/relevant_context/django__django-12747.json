{"instance_id": "django__django-12747", "identified_spans": [{"file_path": "django/db/models/deletion.py", "span_ids": ["Collector.delete"], "content": [{"span_id": "Collector.delete", "start_line": 379, "end_line": 445, "content": ["    def delete(self):\n", "        # sort instance collections\n", "        for model, instances in self.data.items():\n", "            self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n", "\n", "        # if possible, bring the models in an order suitable for databases that\n", "        # don't support transactions or cannot defer constraint checks until the\n", "        # end of a transaction.\n", "        self.sort()\n", "        # number of objects deleted for each model label\n", "        deleted_counter = Counter()\n", "\n", "        # Optimize for the case with a single obj and no dependencies\n", "        if len(self.data) == 1 and len(instances) == 1:\n", "            instance = list(instances)[0]\n", "            if self.can_fast_delete(instance):\n", "                with transaction.mark_for_rollback_on_error():\n", "                    count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\n", "                setattr(instance, model._meta.pk.attname, None)\n", "                return count, {model._meta.label: count}\n", "\n", "        with transaction.atomic(using=self.using, savepoint=False):\n", "            # send pre_delete signals\n", "            for model, obj in self.instances_with_model():\n", "                if not model._meta.auto_created:\n", "                    signals.pre_delete.send(\n", "                        sender=model, instance=obj, using=self.using\n", "                    )\n", "\n", "            # fast deletes\n", "            for qs in self.fast_deletes:\n", "                count = qs._raw_delete(using=self.using)\n", "                deleted_counter[qs.model._meta.label] += count\n", "\n", "            # update fields\n", "            for model, instances_for_fieldvalues in self.field_updates.items():\n", "                for (field, value), instances in instances_for_fieldvalues.items():\n", "                    query = sql.UpdateQuery(model)\n", "                    query.update_batch([obj.pk for obj in instances],\n", "                                       {field.name: value}, self.using)\n", "\n", "            # reverse instance collections\n", "            for instances in self.data.values():\n", "                instances.reverse()\n", "\n", "            # delete instances\n", "            for model, instances in self.data.items():\n", "                query = sql.DeleteQuery(model)\n", "                pk_list = [obj.pk for obj in instances]\n", "                count = query.delete_batch(pk_list, self.using)\n", "                deleted_counter[model._meta.label] += count\n", "\n", "                if not model._meta.auto_created:\n", "                    for obj in instances:\n", "                        signals.post_delete.send(\n", "                            sender=model, instance=obj, using=self.using\n", "                        )\n", "\n", "        # update collected instances\n", "        for instances_for_fieldvalues in self.field_updates.values():\n", "            for (field, value), instances in instances_for_fieldvalues.items():\n", "                for obj in instances:\n", "                    setattr(obj, field.attname, value)\n", "        for model, instances in self.data.items():\n", "            for instance in instances:\n", "                setattr(instance, model._meta.pk.attname, None)\n", "        return sum(deleted_counter.values()), dict(deleted_counter)\n"]}]}, {"file_path": "django/db/models/query.py", "span_ids": ["QuerySet.delete"], "content": [{"span_id": "QuerySet.delete", "start_line": 713, "end_line": 740, "content": ["    def delete(self):\n", "        \"\"\"Delete the records in the current QuerySet.\"\"\"\n", "        self._not_support_combined_queries('delete')\n", "        assert not self.query.is_sliced, \\\n", "            \"Cannot use 'limit' or 'offset' with delete.\"\n", "\n", "        if self._fields is not None:\n", "            raise TypeError(\"Cannot call delete() after .values() or .values_list()\")\n", "\n", "        del_query = self._chain()\n", "\n", "        # The delete is actually 2 queries - one to find related objects,\n", "        # and one to delete. Make sure that the discovery of related\n", "        # objects is performed on the same database as the deletion.\n", "        del_query._for_write = True\n", "\n", "        # Disable non-supported fields.\n", "        del_query.query.select_for_update = False\n", "        del_query.query.select_related = False\n", "        del_query.query.clear_ordering(force_empty=True)\n", "\n", "        collector = Collector(using=del_query.db)\n", "        collector.collect(del_query)\n", "        deleted, _rows_count = collector.delete()\n", "\n", "        # Clear the result cache, in case this QuerySet gets reused.\n", "        self._result_cache = None\n", "        return deleted, _rows_count\n"]}]}]}