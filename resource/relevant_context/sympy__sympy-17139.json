{"instance_id": "sympy__sympy-17139", "identified_spans": [{"file_path": "sympy/simplify/simplify.py", "span_ids": ["simplify"], "content": [{"span_id": "simplify", "start_line": 380, "end_line": 648, "content": ["def simplify(expr, ratio=1.7, measure=count_ops, rational=False, inverse=False):\n", "    \"\"\"Simplifies the given expression.\n", "\n", "    Simplification is not a well defined term and the exact strategies\n", "    this function tries can change in the future versions of SymPy. If\n", "    your algorithm relies on \"simplification\" (whatever it is), try to\n", "    determine what you need exactly  -  is it powsimp()?, radsimp()?,\n", "    together()?, logcombine()?, or something else? And use this particular\n", "    function directly, because those are well defined and thus your algorithm\n", "    will be robust.\n", "\n", "    Nonetheless, especially for interactive use, or when you don't know\n", "    anything about the structure of the expression, simplify() tries to apply\n", "    intelligent heuristics to make the input expression \"simpler\".  For\n", "    example:\n", "\n", "    >>> from sympy import simplify, cos, sin\n", "    >>> from sympy.abc import x, y\n", "    >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n", "    >>> a\n", "    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n", "    >>> simplify(a)\n", "    x + 1\n", "\n", "    Note that we could have obtained the same result by using specific\n", "    simplification functions:\n", "\n", "    >>> from sympy import trigsimp, cancel\n", "    >>> trigsimp(a)\n", "    (x**2 + x)/x\n", "    >>> cancel(_)\n", "    x + 1\n", "\n", "    In some cases, applying :func:`simplify` may actually result in some more\n", "    complicated expression. The default ``ratio=1.7`` prevents more extreme\n", "    cases: if (result length)/(input length) > ratio, then input is returned\n", "    unmodified.  The ``measure`` parameter lets you specify the function used\n", "    to determine how complex an expression is.  The function should take a\n", "    single argument as an expression and return a number such that if\n", "    expression ``a`` is more complex than expression ``b``, then\n", "    ``measure(a) > measure(b)``.  The default measure function is\n", "    :func:`count_ops`, which returns the total number of operations in the\n", "    expression.\n", "\n", "    For example, if ``ratio=1``, ``simplify`` output can't be longer\n", "    than input.\n", "\n", "    ::\n", "\n", "        >>> from sympy import sqrt, simplify, count_ops, oo\n", "        >>> root = 1/(sqrt(2)+3)\n", "\n", "    Since ``simplify(root)`` would result in a slightly longer expression,\n", "    root is returned unchanged instead::\n", "\n", "       >>> simplify(root, ratio=1) == root\n", "       True\n", "\n", "    If ``ratio=oo``, simplify will be applied anyway::\n", "\n", "        >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n", "        True\n", "\n", "    Note that the shortest expression is not necessary the simplest, so\n", "    setting ``ratio`` to 1 may not be a good idea.\n", "    Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n", "    choice.\n", "\n", "    You can easily define your own measure function based on what you feel\n", "    should represent the \"size\" or \"complexity\" of the input expression.  Note\n", "    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n", "    good metrics, but have other problems (in this case, the measure function\n", "    may slow down simplify too much for very large expressions).  If you don't\n", "    know what a good metric would be, the default, ``count_ops``, is a good\n", "    one.\n", "\n", "    For example:\n", "\n", "    >>> from sympy import symbols, log\n", "    >>> a, b = symbols('a b', positive=True)\n", "    >>> g = log(a) + log(b) + log(a)*log(1/b)\n", "    >>> h = simplify(g)\n", "    >>> h\n", "    log(a*b**(1 - log(a)))\n", "    >>> count_ops(g)\n", "    8\n", "    >>> count_ops(h)\n", "    5\n", "\n", "    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n", "    However, we may not like how ``simplify`` (in this case, using\n", "    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n", "    to reduce this would be to give more weight to powers as operations in\n", "    ``count_ops``.  We can do this by using the ``visual=True`` option:\n", "\n", "    >>> print(count_ops(g, visual=True))\n", "    2*ADD + DIV + 4*LOG + MUL\n", "    >>> print(count_ops(h, visual=True))\n", "    2*LOG + MUL + POW + SUB\n", "\n", "    >>> from sympy import Symbol, S\n", "    >>> def my_measure(expr):\n", "    ...     POW = Symbol('POW')\n", "    ...     # Discourage powers by giving POW a weight of 10\n", "    ...     count = count_ops(expr, visual=True).subs(POW, 10)\n", "    ...     # Every other operation gets a weight of 1 (the default)\n", "    ...     count = count.replace(Symbol, type(S.One))\n", "    ...     return count\n", "    >>> my_measure(g)\n", "    8\n", "    >>> my_measure(h)\n", "    14\n", "    >>> 15./8 > 1.7 # 1.7 is the default ratio\n", "    True\n", "    >>> simplify(g, measure=my_measure)\n", "    -log(a)*log(b) + log(a) + log(b)\n", "\n", "    Note that because ``simplify()`` internally tries many different\n", "    simplification strategies and then compares them using the measure\n", "    function, we get a completely different result that is still different\n", "    from the input expression by doing this.\n", "\n", "    If rational=True, Floats will be recast as Rationals before simplification.\n", "    If rational=None, Floats will be recast as Rationals but the result will\n", "    be recast as Floats. If rational=False(default) then nothing will be done\n", "    to the Floats.\n", "\n", "    If inverse=True, it will be assumed that a composition of inverse\n", "    functions, such as sin and asin, can be cancelled in any order.\n", "    For example, ``asin(sin(x))`` will yield ``x`` without checking whether\n", "    x belongs to the set where this relation is true. The default is\n", "    False.\n", "    \"\"\"\n", "\n", "    expr = sympify(expr)\n", "    kwargs = dict(ratio=ratio, measure=measure,\n", "        rational=rational, inverse=inverse)\n", "\n", "    # no routine for Expr needs to check for is_zero\n", "    if isinstance(expr, Expr) and expr.is_zero and expr*0 is S.Zero:\n", "        return S.Zero\n", "\n", "    _eval_simplify = getattr(expr, '_eval_simplify', None)\n", "    if _eval_simplify is not None:\n", "        return _eval_simplify(ratio=ratio, measure=measure, rational=rational, inverse=inverse)\n", "\n", "    original_expr = expr = signsimp(expr)\n", "\n", "    from sympy.simplify.hyperexpand import hyperexpand\n", "    from sympy.functions.special.bessel import BesselBase\n", "    from sympy import Sum, Product, Integral\n", "\n", "    if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n", "        return expr\n", "\n", "    if inverse and expr.has(Function):\n", "        expr = inversecombine(expr)\n", "        if not expr.args:  # simplified to atomic\n", "            return expr\n", "\n", "    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n", "        return expr.func(*[simplify(x, **kwargs) for x in expr.args])\n", "\n", "    if not expr.is_commutative:\n", "        expr = nc_simplify(expr)\n", "\n", "    # TODO: Apply different strategies, considering expression pattern:\n", "    # is it a purely rational function? Is there any trigonometric function?...\n", "    # See also https://github.com/sympy/sympy/pull/185.\n", "\n", "    def shorter(*choices):\n", "        '''Return the choice that has the fewest ops. In case of a tie,\n", "        the expression listed first is selected.'''\n", "        if not has_variety(choices):\n", "            return choices[0]\n", "        return min(choices, key=measure)\n", "\n", "    # rationalize Floats\n", "    floats = False\n", "    if rational is not False and expr.has(Float):\n", "        floats = True\n", "        expr = nsimplify(expr, rational=True)\n", "\n", "    expr = bottom_up(expr, lambda w: getattr(w, 'normal', lambda: w)())\n", "    expr = Mul(*powsimp(expr).as_content_primitive())\n", "    _e = cancel(expr)\n", "    expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n", "    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n", "\n", "    if ratio is S.Infinity:\n", "        expr = expr2\n", "    else:\n", "        expr = shorter(expr2, expr1, expr)\n", "    if not isinstance(expr, Basic):  # XXX: temporary hack\n", "        return expr\n", "\n", "    expr = factor_terms(expr, sign=False)\n", "\n", "    # hyperexpand automatically only works on hypergeometric terms\n", "    expr = hyperexpand(expr)\n", "\n", "    expr = piecewise_fold(expr)\n", "\n", "    if expr.has(BesselBase):\n", "        expr = besselsimp(expr)\n", "\n", "    if expr.has(TrigonometricFunction, HyperbolicFunction):\n", "        expr = trigsimp(expr, deep=True)\n", "\n", "    if expr.has(log):\n", "        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n", "\n", "    if expr.has(CombinatorialFunction, gamma):\n", "        # expression with gamma functions or non-integer arguments is\n", "        # automatically passed to gammasimp\n", "        expr = combsimp(expr)\n", "\n", "    if expr.has(Sum):\n", "        expr = sum_simplify(expr, **kwargs)\n", "\n", "    if expr.has(Integral):\n", "        expr = expr.xreplace(dict([\n", "            (i, factor_terms(i)) for i in expr.atoms(Integral)]))\n", "\n", "    if expr.has(Product):\n", "        expr = product_simplify(expr)\n", "\n", "    from sympy.physics.units import Quantity\n", "    from sympy.physics.units.util import quantity_simplify\n", "\n", "    if expr.has(Quantity):\n", "        expr = quantity_simplify(expr)\n", "\n", "    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n", "    short = shorter(short, cancel(short))\n", "    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n", "    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n", "        short = exptrigsimp(short)\n", "\n", "    # get rid of hollow 2-arg Mul factorization\n", "    hollow_mul = Transform(\n", "        lambda x: Mul(*x.args),\n", "        lambda x:\n", "        x.is_Mul and\n", "        len(x.args) == 2 and\n", "        x.args[0].is_Number and\n", "        x.args[1].is_Add and\n", "        x.is_commutative)\n", "    expr = short.xreplace(hollow_mul)\n", "\n", "    numer, denom = expr.as_numer_denom()\n", "    if denom.is_Add:\n", "        n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n", "        if n is not S.One:\n", "            expr = (numer*n).expand()/d\n", "\n", "    if expr.could_extract_minus_sign():\n", "        n, d = fraction(expr)\n", "        if d != 0:\n", "            expr = signsimp(-n/(-d))\n", "\n", "    if measure(expr) > ratio*measure(original_expr):\n", "        expr = original_expr\n", "\n", "    # restore floats\n", "    if floats and rational is None:\n", "        expr = nfloat(expr, exponent=False)\n", "\n", "    return expr\n"]}]}, {"file_path": "sympy/simplify/trigsimp.py", "span_ids": ["trigsimp"], "content": [{"span_id": "trigsimp", "start_line": 424, "end_line": 508, "content": ["def trigsimp(expr, **opts):\n", "    \"\"\"\n", "    reduces expression by using known trig identities\n", "\n", "    Notes\n", "    =====\n", "\n", "    method:\n", "    - Determine the method to use. Valid choices are 'matching' (default),\n", "    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n", "    expression recursively by targeting common patterns. If 'groebner', apply\n", "    an experimental groebner basis algorithm. In this case further options\n", "    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n", "    If 'combined', first run the groebner basis algorithm with small\n", "    default parameters, then run the 'matching' algorithm. 'fu' runs the\n", "    collection of trigonometric transformations described by Fu, et al.\n", "    (see the `fu` docstring).\n", "\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import trigsimp, sin, cos, log\n", "    >>> from sympy.abc import x, y\n", "    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n", "    >>> trigsimp(e)\n", "    2\n", "\n", "    Simplification occurs wherever trigonometric functions are located.\n", "\n", "    >>> trigsimp(log(e))\n", "    log(2)\n", "\n", "    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n", "    simplification.\n", "\n", "    The old trigsimp routine can be accessed as with method 'old'.\n", "\n", "    >>> from sympy import coth, tanh\n", "    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n", "    >>> trigsimp(t, method='old') == t\n", "    True\n", "    >>> trigsimp(t)\n", "    tanh(x)**7\n", "\n", "    \"\"\"\n", "    from sympy.simplify.fu import fu\n", "\n", "    expr = sympify(expr)\n", "\n", "    _eval_trigsimp = getattr(expr, '_eval_trigsimp', None)\n", "    if _eval_trigsimp is not None:\n", "        return _eval_trigsimp(**opts)\n", "\n", "    old = opts.pop('old', False)\n", "    if not old:\n", "        opts.pop('deep', None)\n", "        opts.pop('recursive', None)\n", "        method = opts.pop('method', 'matching')\n", "    else:\n", "        method = 'old'\n", "\n", "    def groebnersimp(ex, **opts):\n", "        def traverse(e):\n", "            if e.is_Atom:\n", "                return e\n", "            args = [traverse(x) for x in e.args]\n", "            if e.is_Function or e.is_Pow:\n", "                args = [trigsimp_groebner(x, **opts) for x in args]\n", "            return e.func(*args)\n", "        new = traverse(ex)\n", "        if not isinstance(new, Expr):\n", "            return new\n", "        return trigsimp_groebner(new, **opts)\n", "\n", "    trigsimpfunc = {\n", "        'fu': (lambda x: fu(x, **opts)),\n", "        'matching': (lambda x: futrig(x)),\n", "        'groebner': (lambda x: groebnersimp(x, **opts)),\n", "        'combined': (lambda x: futrig(groebnersimp(x,\n", "                               polynomial=True, hints=[2, tan]))),\n", "        'old': lambda x: trigsimp_old(x, **opts),\n", "                   }[method]\n", "\n", "    return trigsimpfunc(expr)\n"]}]}]}