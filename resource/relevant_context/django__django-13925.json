{"instance_id": "django__django-13925", "identified_spans": [{"file_path": "django/core/checks/model_checks.py", "span_ids": ["check_all_models"], "content": [{"span_id": "check_all_models", "start_line": 11, "end_line": 86, "content": ["@register(Tags.models)\n", "def check_all_models(app_configs=None, **kwargs):\n", "    db_table_models = defaultdict(list)\n", "    indexes = defaultdict(list)\n", "    constraints = defaultdict(list)\n", "    errors = []\n", "    if app_configs is None:\n", "        models = apps.get_models()\n", "    else:\n", "        models = chain.from_iterable(app_config.get_models() for app_config in app_configs)\n", "    for model in models:\n", "        if model._meta.managed and not model._meta.proxy:\n", "            db_table_models[model._meta.db_table].append(model._meta.label)\n", "        if not inspect.ismethod(model.check):\n", "            errors.append(\n", "                Error(\n", "                    \"The '%s.check()' class method is currently overridden by %r.\"\n", "                    % (model.__name__, model.check),\n", "                    obj=model,\n", "                    id='models.E020'\n", "                )\n", "            )\n", "        else:\n", "            errors.extend(model.check(**kwargs))\n", "        for model_index in model._meta.indexes:\n", "            indexes[model_index.name].append(model._meta.label)\n", "        for model_constraint in model._meta.constraints:\n", "            constraints[model_constraint.name].append(model._meta.label)\n", "    if settings.DATABASE_ROUTERS:\n", "        error_class, error_id = Warning, 'models.W035'\n", "        error_hint = (\n", "            'You have configured settings.DATABASE_ROUTERS. Verify that %s '\n", "            'are correctly routed to separate databases.'\n", "        )\n", "    else:\n", "        error_class, error_id = Error, 'models.E028'\n", "        error_hint = None\n", "    for db_table, model_labels in db_table_models.items():\n", "        if len(model_labels) != 1:\n", "            model_labels_str = ', '.join(model_labels)\n", "            errors.append(\n", "                error_class(\n", "                    \"db_table '%s' is used by multiple models: %s.\"\n", "                    % (db_table, model_labels_str),\n", "                    obj=db_table,\n", "                    hint=(error_hint % model_labels_str) if error_hint else None,\n", "                    id=error_id,\n", "                )\n", "            )\n", "    for index_name, model_labels in indexes.items():\n", "        if len(model_labels) > 1:\n", "            model_labels = set(model_labels)\n", "            errors.append(\n", "                Error(\n", "                    \"index name '%s' is not unique %s %s.\" % (\n", "                        index_name,\n", "                        'for model' if len(model_labels) == 1 else 'among models:',\n", "                        ', '.join(sorted(model_labels)),\n", "                    ),\n", "                    id='models.E029' if len(model_labels) == 1 else 'models.E030',\n", "                ),\n", "            )\n", "    for constraint_name, model_labels in constraints.items():\n", "        if len(model_labels) > 1:\n", "            model_labels = set(model_labels)\n", "            errors.append(\n", "                Error(\n", "                    \"constraint name '%s' is not unique %s %s.\" % (\n", "                        constraint_name,\n", "                        'for model' if len(model_labels) == 1 else 'among models:',\n", "                        ', '.join(sorted(model_labels)),\n", "                    ),\n", "                    id='models.E031' if len(model_labels) == 1 else 'models.E032',\n", "                ),\n", "            )\n", "    return errors\n"]}]}, {"file_path": "django/db/models/base.py", "span_ids": ["Model", "Model._check_default_pk"], "content": [{"span_id": "Model", "start_line": 404, "end_line": 404, "content": ["class Model(metaclass=ModelBase):\n"]}, {"span_id": "Model._check_default_pk", "start_line": 1298, "end_line": 1320, "content": ["    @classmethod\n", "    def _check_default_pk(cls):\n", "        if (\n", "            cls._meta.pk.auto_created and\n", "            not settings.is_overridden('DEFAULT_AUTO_FIELD') and\n", "            not cls._meta.app_config._is_default_auto_field_overridden\n", "        ):\n", "            return [\n", "                checks.Warning(\n", "                    f\"Auto-created primary key used when not defining a \"\n", "                    f\"primary key type, by default \"\n", "                    f\"'{settings.DEFAULT_AUTO_FIELD}'.\",\n", "                    hint=(\n", "                        f\"Configure the DEFAULT_AUTO_FIELD setting or the \"\n", "                        f\"{cls._meta.app_config.__class__.__qualname__}.\"\n", "                        f\"default_auto_field attribute to point to a subclass \"\n", "                        f\"of AutoField, e.g. 'django.db.models.BigAutoField'.\"\n", "                    ),\n", "                    obj=cls,\n", "                    id='models.W042',\n", "                ),\n", "            ]\n", "        return []\n"]}]}, {"file_path": "django/db/models/fields/__init__.py", "span_ids": ["AutoFieldMixin"], "content": [{"span_id": "AutoFieldMixin", "start_line": 2450, "end_line": 2451, "content": ["class AutoFieldMixin:\n", "    db_returning = True\n"]}]}, {"file_path": "django/db/models/options.py", "span_ids": ["Options.setup_pk", "Options._prepare", "Options", "Options._get_default_pk_class"], "content": [{"span_id": "Options.setup_pk", "start_line": 323, "end_line": 326, "content": ["    def setup_pk(self, field):\n", "        if not self.pk and field.primary_key:\n", "            self.pk = field\n", "            field.serialize = False\n"]}, {"span_id": "Options._prepare", "start_line": 252, "end_line": 287, "content": ["    def _prepare(self, model):\n", "        if self.order_with_respect_to:\n", "            # The app registry will not be ready at this point, so we cannot\n", "            # use get_field().\n", "            query = self.order_with_respect_to\n", "            try:\n", "                self.order_with_respect_to = next(\n", "                    f for f in self._get_fields(reverse=False)\n", "                    if f.name == query or f.attname == query\n", "                )\n", "            except StopIteration:\n", "                raise FieldDoesNotExist(\"%s has no field named '%s'\" % (self.object_name, query))\n", "\n", "            self.ordering = ('_order',)\n", "            if not any(isinstance(field, OrderWrt) for field in model._meta.local_fields):\n", "                model.add_to_class('_order', OrderWrt())\n", "        else:\n", "            self.order_with_respect_to = None\n", "\n", "        if self.pk is None:\n", "            if self.parents:\n", "                # Promote the first parent link in lieu of adding yet another\n", "                # field.\n", "                field = next(iter(self.parents.values()))\n", "                # Look for a local field with the same name as the\n", "                # first parent link. If a local field has already been\n", "                # created, use it instead of promoting the parent\n", "                already_created = [fld for fld in self.local_fields if fld.name == field.name]\n", "                if already_created:\n", "                    field = already_created[0]\n", "                field.primary_key = True\n", "                self.setup_pk(field)\n", "            else:\n", "                pk_class = self._get_default_pk_class()\n", "                auto = pk_class(verbose_name='ID', primary_key=True, auto_created=True)\n", "                model.add_to_class('id', auto)\n"]}, {"span_id": "Options", "start_line": 64, "end_line": 72, "content": ["class Options:\n", "    FORWARD_PROPERTIES = {\n", "        'fields', 'many_to_many', 'concrete_fields', 'local_concrete_fields',\n", "        '_forward_fields_map', 'managers', 'managers_map', 'base_manager',\n", "        'default_manager',\n", "    }\n", "    REVERSE_PROPERTIES = {'related_objects', 'fields_map', '_relation_tree'}\n", "\n", "    default_apps = apps\n"]}, {"span_id": "Options._get_default_pk_class", "start_line": 221, "end_line": 250, "content": ["    def _get_default_pk_class(self):\n", "        pk_class_path = getattr(\n", "            self.app_config,\n", "            'default_auto_field',\n", "            settings.DEFAULT_AUTO_FIELD,\n", "        )\n", "        if self.app_config and self.app_config._is_default_auto_field_overridden:\n", "            app_config_class = type(self.app_config)\n", "            source = (\n", "                f'{app_config_class.__module__}.'\n", "                f'{app_config_class.__qualname__}.default_auto_field'\n", "            )\n", "        else:\n", "            source = 'DEFAULT_AUTO_FIELD'\n", "        if not pk_class_path:\n", "            raise ImproperlyConfigured(f'{source} must not be empty.')\n", "        try:\n", "            pk_class = import_string(pk_class_path)\n", "        except ImportError as e:\n", "            msg = (\n", "                f\"{source} refers to the module '{pk_class_path}' that could \"\n", "                f\"not be imported.\"\n", "            )\n", "            raise ImproperlyConfigured(msg) from e\n", "        if not issubclass(pk_class, AutoField):\n", "            raise ValueError(\n", "                f\"Primary key '{pk_class_path}' referred by {source} must \"\n", "                f\"subclass AutoField.\"\n", "            )\n", "        return pk_class\n"]}]}]}