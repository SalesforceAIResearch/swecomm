{"instance_id": "matplotlib__matplotlib-23314", "identified_spans": [{"file_path": "lib/mpl_toolkits/mplot3d/axes3d.py", "span_ids": ["Axes3D.draw", "Axes3D.clear", "Axes3D"], "content": [{"span_id": "Axes3D.draw", "start_line": 388, "end_line": 444, "content": ["    @martist.allow_rasterization\n", "    def draw(self, renderer):\n", "        self._unstale_viewLim()\n", "\n", "        # draw the background patch\n", "        self.patch.draw(renderer)\n", "        self._frameon = False\n", "\n", "        # first, set the aspect\n", "        # this is duplicated from `axes._base._AxesBase.draw`\n", "        # but must be called before any of the artist are drawn as\n", "        # it adjusts the view limits and the size of the bounding box\n", "        # of the Axes\n", "        locator = self.get_axes_locator()\n", "        if locator:\n", "            pos = locator(self, renderer)\n", "            self.apply_aspect(pos)\n", "        else:\n", "            self.apply_aspect()\n", "\n", "        # add the projection matrix to the renderer\n", "        self.M = self.get_proj()\n", "\n", "        collections_and_patches = (\n", "            artist for artist in self._children\n", "            if isinstance(artist, (mcoll.Collection, mpatches.Patch))\n", "            and artist.get_visible())\n", "        if self.computed_zorder:\n", "            # Calculate projection of collections and patches and zorder\n", "            # them. Make sure they are drawn above the grids.\n", "            zorder_offset = max(axis.get_zorder()\n", "                                for axis in self._axis_map.values()) + 1\n", "            collection_zorder = patch_zorder = zorder_offset\n", "\n", "            for artist in sorted(collections_and_patches,\n", "                                 key=lambda artist: artist.do_3d_projection(),\n", "                                 reverse=True):\n", "                if isinstance(artist, mcoll.Collection):\n", "                    artist.zorder = collection_zorder\n", "                    collection_zorder += 1\n", "                elif isinstance(artist, mpatches.Patch):\n", "                    artist.zorder = patch_zorder\n", "                    patch_zorder += 1\n", "        else:\n", "            for artist in collections_and_patches:\n", "                artist.do_3d_projection()\n", "\n", "        if self._axis3don:\n", "            # Draw panes first\n", "            for axis in self._axis_map.values():\n", "                axis.draw_pane(renderer)\n", "            # Then axes\n", "            for axis in self._axis_map.values():\n", "                axis.draw(renderer)\n", "\n", "        # Then rest\n", "        super().draw(renderer)\n"]}, {"span_id": "Axes3D.clear", "start_line": 934, "end_line": 958, "content": ["    def clear(self):\n", "        # docstring inherited.\n", "        super().clear()\n", "        self.zaxis.clear()\n", "\n", "        if self._sharez is not None:\n", "            self.zaxis.major = self._sharez.zaxis.major\n", "            self.zaxis.minor = self._sharez.zaxis.minor\n", "            z0, z1 = self._sharez.get_zlim()\n", "            self.set_zlim(z0, z1, emit=False, auto=None)\n", "            self.zaxis._set_scale(self._sharez.zaxis.get_scale())\n", "        else:\n", "            self.zaxis._set_scale('linear')\n", "            try:\n", "                self.set_zlim(0, 1)\n", "            except TypeError:\n", "                pass\n", "\n", "        self.set_autoscalez_on(True)\n", "        if self._focal_length == np.inf:\n", "            self._zmargin = rcParams['axes.zmargin']\n", "        else:\n", "            self._zmargin = 0.\n", "\n", "        self.grid(rcParams['axes3d.grid'])\n"]}, {"span_id": "Axes3D", "start_line": 42, "end_line": 54, "content": ["@_docstring.interpd\n", "@_api.define_aliases({\n", "    \"xlim\": [\"xlim3d\"], \"ylim\": [\"ylim3d\"], \"zlim\": [\"zlim3d\"]})\n", "class Axes3D(Axes):\n", "    \"\"\"\n", "    3D Axes object.\n", "    \"\"\"\n", "    name = '3d'\n", "\n", "    _axis_names = (\"x\", \"y\", \"z\")\n", "    Axes._shared_axes[\"z\"] = cbook.Grouper()\n", "\n", "    dist = _api.deprecate_privatize_attribute(\"3.6\")\n"]}]}]}