{"instance_id": "sympy__sympy-11870", "identified_spans": [{"file_path": "sympy/functions/elementary/trigonometric.py", "span_ids": ["sinc"], "content": [{"span_id": "sinc", "start_line": 1740, "end_line": 1778, "content": ["class sinc(TrigonometricFunction):\n", "    r\"\"\"Represents unnormalized sinc function\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import sinc, oo, jn, Product, Symbol\n", "    >>> from sympy.abc import x\n", "    >>> sinc(x)\n", "    sinc(x)\n", "\n", "    * Automated Evaluation\n", "\n", "    >>> sinc(0)\n", "    1\n", "    >>> sinc(oo)\n", "    0\n", "\n", "    * Differentiation\n", "\n", "    >>> sinc(x).diff()\n", "    (x*cos(x) - sin(x))/x**2\n", "\n", "    * Series Expansion\n", "\n", "    >>> sinc(x).series()\n", "    1 - x**2/6 + x**4/120 + O(x**6)\n", "\n", "    * As zero'th order spherical Bessel Function\n", "\n", "    >>> sinc(x).rewrite(jn)\n", "    jn(0, x)\n", "\n", "    References\n", "    ==========\n", "\n", "    .. [1] http://en.wikipedia.org/wiki/Sinc_function\n", "\n", "    \"\"\"\n"]}]}, {"file_path": "sympy/simplify/trigsimp.py", "span_ids": ["exptrigsimp", "trigsimp"], "content": [{"span_id": "exptrigsimp", "start_line": 516, "end_line": 602, "content": ["def exptrigsimp(expr):\n", "    \"\"\"\n", "    Simplifies exponential / trigonometric / hyperbolic functions.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import exptrigsimp, exp, cosh, sinh\n", "    >>> from sympy.abc import z\n", "\n", "    >>> exptrigsimp(exp(z) + exp(-z))\n", "    2*cosh(z)\n", "    >>> exptrigsimp(cosh(z) - sinh(z))\n", "    exp(-z)\n", "    \"\"\"\n", "    from sympy.simplify.fu import hyper_as_trig, TR2i\n", "    from sympy.simplify.simplify import bottom_up\n", "\n", "    def exp_trig(e):\n", "        # select the better of e, and e rewritten in terms of exp or trig\n", "        # functions\n", "        choices = [e]\n", "        if e.has(*_trigs):\n", "            choices.append(e.rewrite(exp))\n", "        choices.append(e.rewrite(cos))\n", "        return min(*choices, key=count_ops)\n", "    newexpr = bottom_up(expr, exp_trig)\n", "\n", "    def f(rv):\n", "        if not rv.is_Mul:\n", "            return rv\n", "        rvd = rv.as_powers_dict()\n", "        newd = rvd.copy()\n", "\n", "        def signlog(expr, sign=1):\n", "            if expr is S.Exp1:\n", "                return sign, 1\n", "            elif isinstance(expr, exp):\n", "                return sign, expr.args[0]\n", "            elif sign == 1:\n", "                return signlog(-expr, sign=-1)\n", "            else:\n", "                return None, None\n", "\n", "        ee = rvd[S.Exp1]\n", "        for k in rvd:\n", "            if k.is_Add and len(k.args) == 2:\n", "                # k == c*(1 + sign*E**x)\n", "                c = k.args[0]\n", "                sign, x = signlog(k.args[1]/c)\n", "                if not x:\n", "                    continue\n", "                m = rvd[k]\n", "                newd[k] -= m\n", "                if ee == -x*m/2:\n", "                    # sinh and cosh\n", "                    newd[S.Exp1] -= ee\n", "                    ee = 0\n", "                    if sign == 1:\n", "                        newd[2*c*cosh(x/2)] += m\n", "                    else:\n", "                        newd[-2*c*sinh(x/2)] += m\n", "                elif newd[1 - sign*S.Exp1**x] == -m:\n", "                    # tanh\n", "                    del newd[1 - sign*S.Exp1**x]\n", "                    if sign == 1:\n", "                        newd[-c/tanh(x/2)] += m\n", "                    else:\n", "                        newd[-c*tanh(x/2)] += m\n", "                else:\n", "                    newd[1 + sign*S.Exp1**x] += m\n", "                    newd[c] += m\n", "\n", "        return Mul(*[k**newd[k] for k in newd])\n", "    newexpr = bottom_up(newexpr, f)\n", "\n", "    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n", "    if newexpr.has(HyperbolicFunction):\n", "        e, f = hyper_as_trig(newexpr)\n", "        newexpr = f(TR2i(e))\n", "    if newexpr.has(TrigonometricFunction):\n", "        newexpr = TR2i(newexpr)\n", "\n", "    # can we ever generate an I where there was none previously?\n", "    if not (newexpr.has(I) and not expr.has(I)):\n", "        expr = newexpr\n", "    return expr\n"]}, {"span_id": "trigsimp", "start_line": 428, "end_line": 513, "content": ["def trigsimp(expr, **opts):\n", "    \"\"\"\n", "    reduces expression by using known trig identities\n", "\n", "    Notes\n", "    =====\n", "\n", "    method:\n", "    - Determine the method to use. Valid choices are 'matching' (default),\n", "    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n", "    expression recursively by targeting common patterns. If 'groebner', apply\n", "    an experimental groebner basis algorithm. In this case further options\n", "    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n", "    If 'combined', first run the groebner basis algorithm with small\n", "    default parameters, then run the 'matching' algorithm. 'fu' runs the\n", "    collection of trigonometric transformations described by Fu, et al.\n", "    (see the `fu` docstring).\n", "\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import trigsimp, sin, cos, log\n", "    >>> from sympy.abc import x, y\n", "    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n", "    >>> trigsimp(e)\n", "    2\n", "\n", "    Simplification occurs wherever trigonometric functions are located.\n", "\n", "    >>> trigsimp(log(e))\n", "    log(2)\n", "\n", "    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n", "    simplification.\n", "\n", "    The old trigsimp routine can be accessed as with method 'old'.\n", "\n", "    >>> from sympy import coth, tanh\n", "    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n", "    >>> trigsimp(t, method='old') == t\n", "    True\n", "    >>> trigsimp(t)\n", "    tanh(x)**7\n", "\n", "    \"\"\"\n", "    from sympy.simplify.fu import fu\n", "\n", "    expr = sympify(expr)\n", "\n", "    try:\n", "        return expr._eval_trigsimp(**opts)\n", "    except AttributeError:\n", "        pass\n", "\n", "    old = opts.pop('old', False)\n", "    if not old:\n", "        opts.pop('deep', None)\n", "        recursive = opts.pop('recursive', None)\n", "        method = opts.pop('method', 'matching')\n", "    else:\n", "        method = 'old'\n", "\n", "    def groebnersimp(ex, **opts):\n", "        def traverse(e):\n", "            if e.is_Atom:\n", "                return e\n", "            args = [traverse(x) for x in e.args]\n", "            if e.is_Function or e.is_Pow:\n", "                args = [trigsimp_groebner(x, **opts) for x in args]\n", "            return e.func(*args)\n", "        new = traverse(ex)\n", "        if not isinstance(new, Expr):\n", "            return new\n", "        return trigsimp_groebner(new, **opts)\n", "\n", "    trigsimpfunc = {\n", "        'fu': (lambda x: fu(x, **opts)),\n", "        'matching': (lambda x: futrig(x)),\n", "        'groebner': (lambda x: groebnersimp(x, **opts)),\n", "        'combined': (lambda x: futrig(groebnersimp(x,\n", "                               polynomial=True, hints=[2, tan]))),\n", "        'old': lambda x: trigsimp_old(x, **opts),\n", "                   }[method]\n", "\n", "    return trigsimpfunc(expr)\n"]}]}]}