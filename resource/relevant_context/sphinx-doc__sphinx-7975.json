{"instance_id": "sphinx-doc__sphinx-7975", "identified_spans": [{"file_path": "sphinx/builders/html/__init__.py", "span_ids": ["StandaloneHTMLBuilder.write_genindex"], "content": [{"span_id": "StandaloneHTMLBuilder.write_genindex", "start_line": 658, "end_line": 685, "content": ["    def write_genindex(self) -> None:\n", "        # the total count of lines for each index letter, used to distribute\n", "        # the entries into two columns\n", "        genindex = IndexEntries(self.env).create_index(self)\n", "        indexcounts = []\n", "        for _k, entries in genindex:\n", "            indexcounts.append(sum(1 + len(subitems)\n", "                                   for _, (_, subitems, _) in entries))\n", "\n", "        genindexcontext = {\n", "            'genindexentries': genindex,\n", "            'genindexcounts': indexcounts,\n", "            'split_index': self.config.html_split_index,\n", "        }\n", "        logger.info(' genindex', nonl=True)\n", "\n", "        if self.config.html_split_index:\n", "            self.handle_page('genindex', genindexcontext,\n", "                             'genindex-split.html')\n", "            self.handle_page('genindex-all', genindexcontext,\n", "                             'genindex.html')\n", "            for (key, entries), count in zip(genindex, indexcounts):\n", "                ctx = {'key': key, 'entries': entries, 'count': count,\n", "                       'genindexentries': genindex}\n", "                self.handle_page('genindex-' + key, ctx,\n", "                                 'genindex-single.html')\n", "        else:\n", "            self.handle_page('genindex', genindexcontext, 'genindex.html')\n"]}]}, {"file_path": "sphinx/environment/adapters/indexentries.py", "span_ids": ["IndexEntries", "IndexEntries.create_index"], "content": [{"span_id": "IndexEntries", "start_line": 28, "end_line": 28, "content": ["class IndexEntries:\n"]}, {"span_id": "IndexEntries.create_index", "start_line": 32, "end_line": 176, "content": ["    def create_index(self, builder: Builder, group_entries: bool = True,\n", "                     _fixre: Pattern = re.compile(r'(.*) ([(][^()]*[)])')\n", "                     ) -> List[Tuple[str, List[Tuple[str, Any]]]]:\n", "        \"\"\"Create the real index from the collected index entries.\"\"\"\n", "        new = {}  # type: Dict[str, List]\n", "\n", "        def add_entry(word: str, subword: str, main: str, link: bool = True,\n", "                      dic: Dict = new, key: str = None) -> None:\n", "            # Force the word to be unicode if it's a ASCII bytestring.\n", "            # This will solve problems with unicode normalization later.\n", "            # For instance the RFC role will add bytestrings at the moment\n", "            word = str(word)\n", "            entry = dic.get(word)\n", "            if not entry:\n", "                dic[word] = entry = [[], {}, key]\n", "            if subword:\n", "                add_entry(subword, '', main, link=link, dic=entry[1], key=key)\n", "            elif link:\n", "                try:\n", "                    uri = builder.get_relative_uri('genindex', fn) + '#' + tid\n", "                except NoUri:\n", "                    pass\n", "                else:\n", "                    entry[0].append((main, uri))\n", "\n", "        domain = cast(IndexDomain, self.env.get_domain('index'))\n", "        for fn, entries in domain.entries.items():\n", "            # new entry types must be listed in directives/other.py!\n", "            for type, value, tid, main, index_key in entries:\n", "                try:\n", "                    if type == 'single':\n", "                        try:\n", "                            entry, subentry = split_into(2, 'single', value)\n", "                        except ValueError:\n", "                            entry, = split_into(1, 'single', value)\n", "                            subentry = ''\n", "                        add_entry(entry, subentry, main, key=index_key)\n", "                    elif type == 'pair':\n", "                        first, second = split_into(2, 'pair', value)\n", "                        add_entry(first, second, main, key=index_key)\n", "                        add_entry(second, first, main, key=index_key)\n", "                    elif type == 'triple':\n", "                        first, second, third = split_into(3, 'triple', value)\n", "                        add_entry(first, second + ' ' + third, main, key=index_key)\n", "                        add_entry(second, third + ', ' + first, main, key=index_key)\n", "                        add_entry(third, first + ' ' + second, main, key=index_key)\n", "                    elif type == 'see':\n", "                        first, second = split_into(2, 'see', value)\n", "                        add_entry(first, _('see %s') % second, None,\n", "                                  link=False, key=index_key)\n", "                    elif type == 'seealso':\n", "                        first, second = split_into(2, 'see', value)\n", "                        add_entry(first, _('see also %s') % second, None,\n", "                                  link=False, key=index_key)\n", "                    else:\n", "                        logger.warning(__('unknown index entry type %r'), type, location=fn)\n", "                except ValueError as err:\n", "                    logger.warning(str(err), location=fn)\n", "\n", "        # sort the index entries for same keyword.\n", "        def keyfunc0(entry: Tuple[str, str]) -> Tuple[bool, str]:\n", "            main, uri = entry\n", "            return (not main, uri)  # show main entries at first\n", "\n", "        for indexentry in new.values():\n", "            indexentry[0].sort(key=keyfunc0)\n", "            for subentry in indexentry[1].values():\n", "                subentry[0].sort(key=keyfunc0)  # type: ignore\n", "\n", "        # sort the index entries; put all symbols at the front, even those\n", "        # following the letters in ASCII, this is where the chr(127) comes from\n", "        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n", "            key, (void, void, category_key) = entry\n", "            if category_key:\n", "                # using specified category key to sort\n", "                key = category_key\n", "            lckey = unicodedata.normalize('NFD', key.lower())\n", "            if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n", "                lckey = lckey[1:]\n", "            if lckey[0:1].isalpha() or lckey.startswith('_'):\n", "                lckey = chr(127) + lckey\n", "            # ensure a determinstic order *within* letters by also sorting on\n", "            # the entry itself\n", "            return (lckey, entry[0])\n", "        newlist = sorted(new.items(), key=keyfunc)\n", "\n", "        if group_entries:\n", "            # fixup entries: transform\n", "            #   func() (in module foo)\n", "            #   func() (in module bar)\n", "            # into\n", "            #   func()\n", "            #     (in module foo)\n", "            #     (in module bar)\n", "            oldkey = ''\n", "            oldsubitems = None  # type: Dict[str, List]\n", "            i = 0\n", "            while i < len(newlist):\n", "                key, (targets, subitems, _key) = newlist[i]\n", "                # cannot move if it has subitems; structure gets too complex\n", "                if not subitems:\n", "                    m = _fixre.match(key)\n", "                    if m:\n", "                        if oldkey == m.group(1):\n", "                            # prefixes match: add entry as subitem of the\n", "                            # previous entry\n", "                            oldsubitems.setdefault(m.group(2), [[], {}, _key])[0].\\\n", "                                extend(targets)\n", "                            del newlist[i]\n", "                            continue\n", "                        oldkey = m.group(1)\n", "                    else:\n", "                        oldkey = key\n", "                oldsubitems = subitems\n", "                i += 1\n", "\n", "        # sort the sub-index entries\n", "        def keyfunc2(entry: Tuple[str, List]) -> str:\n", "            key = unicodedata.normalize('NFD', entry[0].lower())\n", "            if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n", "                key = key[1:]\n", "            if key[0:1].isalpha() or key.startswith('_'):\n", "                key = chr(127) + key\n", "            return key\n", "\n", "        # group the entries by letter\n", "        def keyfunc3(item: Tuple[str, List]) -> str:\n", "            # hack: mutating the subitems dicts to a list in the keyfunc\n", "            k, v = item\n", "            v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n", "                          key=keyfunc2)\n", "            if v[2] is None:\n", "                # now calculate the key\n", "                if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n", "                    k = k[1:]\n", "                letter = unicodedata.normalize('NFD', k[0])[0].upper()\n", "                if letter.isalpha() or letter == '_':\n", "                    return letter\n", "                else:\n", "                    # get all other symbols under one heading\n", "                    return _('Symbols')\n", "            else:\n", "                return v[2]\n", "        return [(key_, list(group))\n", "                for (key_, group) in groupby(newlist, keyfunc3)]\n"]}]}, {"file_path": "sphinx/util/nodes.py", "span_ids": ["process_index_entry"], "content": [{"span_id": "process_index_entry", "start_line": 370, "end_line": 405, "content": ["def process_index_entry(entry: str, targetid: str) -> List[Tuple[str, str, str, str, str]]:\n", "    from sphinx.domains.python import pairindextypes\n", "\n", "    indexentries = []  # type: List[Tuple[str, str, str, str, str]]\n", "    entry = entry.strip()\n", "    oentry = entry\n", "    main = ''\n", "    if entry.startswith('!'):\n", "        main = 'main'\n", "        entry = entry[1:].lstrip()\n", "    for type in pairindextypes:\n", "        if entry.startswith(type + ':'):\n", "            value = entry[len(type) + 1:].strip()\n", "            value = pairindextypes[type] + '; ' + value\n", "            indexentries.append(('pair', value, targetid, main, None))\n", "            break\n", "    else:\n", "        for type in indextypes:\n", "            if entry.startswith(type + ':'):\n", "                value = entry[len(type) + 1:].strip()\n", "                if type == 'double':\n", "                    type = 'pair'\n", "                indexentries.append((type, value, targetid, main, None))\n", "                break\n", "        # shorthand notation for single entries\n", "        else:\n", "            for value in oentry.split(','):\n", "                value = value.strip()\n", "                main = ''\n", "                if value.startswith('!'):\n", "                    main = 'main'\n", "                    value = value[1:].lstrip()\n", "                if not value:\n", "                    continue\n", "                indexentries.append(('single', value, targetid, main, None))\n", "    return indexentries\n"]}]}]}