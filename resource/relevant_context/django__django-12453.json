{"instance_id": "django__django-12453", "identified_spans": [{"file_path": "django/core/serializers/__init__.py", "span_ids": ["sort_dependencies"], "content": [{"span_id": "sort_dependencies", "start_line": 159, "end_line": 234, "content": ["def sort_dependencies(app_list):\n", "    \"\"\"Sort a list of (app_config, models) pairs into a single list of models.\n", "\n", "    The single list of models is sorted so that any model with a natural key\n", "    is serialized before a normal model, and any model with a natural key\n", "    dependency has it's dependencies serialized first.\n", "    \"\"\"\n", "    # Process the list of models, and get the list of dependencies\n", "    model_dependencies = []\n", "    models = set()\n", "    for app_config, model_list in app_list:\n", "        if model_list is None:\n", "            model_list = app_config.get_models()\n", "\n", "        for model in model_list:\n", "            models.add(model)\n", "            # Add any explicitly defined dependencies\n", "            if hasattr(model, 'natural_key'):\n", "                deps = getattr(model.natural_key, 'dependencies', [])\n", "                if deps:\n", "                    deps = [apps.get_model(dep) for dep in deps]\n", "            else:\n", "                deps = []\n", "\n", "            # Now add a dependency for any FK relation with a model that\n", "            # defines a natural key\n", "            for field in model._meta.fields:\n", "                if field.remote_field:\n", "                    rel_model = field.remote_field.model\n", "                    if hasattr(rel_model, 'natural_key') and rel_model != model:\n", "                        deps.append(rel_model)\n", "            # Also add a dependency for any simple M2M relation with a model\n", "            # that defines a natural key.  M2M relations with explicit through\n", "            # models don't count as dependencies.\n", "            for field in model._meta.many_to_many:\n", "                if field.remote_field.through._meta.auto_created:\n", "                    rel_model = field.remote_field.model\n", "                    if hasattr(rel_model, 'natural_key') and rel_model != model:\n", "                        deps.append(rel_model)\n", "            model_dependencies.append((model, deps))\n", "\n", "    model_dependencies.reverse()\n", "    # Now sort the models to ensure that dependencies are met. This\n", "    # is done by repeatedly iterating over the input list of models.\n", "    # If all the dependencies of a given model are in the final list,\n", "    # that model is promoted to the end of the final list. This process\n", "    # continues until the input list is empty, or we do a full iteration\n", "    # over the input models without promoting a model to the final list.\n", "    # If we do a full iteration without a promotion, that means there are\n", "    # circular dependencies in the list.\n", "    model_list = []\n", "    while model_dependencies:\n", "        skipped = []\n", "        changed = False\n", "        while model_dependencies:\n", "            model, deps = model_dependencies.pop()\n", "\n", "            # If all of the models in the dependency list are either already\n", "            # on the final model list, or not on the original serialization list,\n", "            # then we've found another model with all it's dependencies satisfied.\n", "            if all(d not in models or d in model_list for d in deps):\n", "                model_list.append(model)\n", "                changed = True\n", "            else:\n", "                skipped.append((model, deps))\n", "        if not changed:\n", "            raise RuntimeError(\n", "                \"Can't resolve dependencies for %s in serialized app list.\" %\n", "                ', '.join(\n", "                    model._meta.label\n", "                    for model, deps in sorted(skipped, key=lambda obj: obj[0].__name__)\n", "                )\n", "            )\n", "        model_dependencies = skipped\n", "\n", "    return model_list\n"]}]}, {"file_path": "django/db/backends/base/creation.py", "span_ids": ["BaseDatabaseCreation.serialize_db_to_string", "BaseDatabaseCreation.deserialize_db_from_string"], "content": [{"span_id": "BaseDatabaseCreation.serialize_db_to_string", "start_line": 93, "end_line": 121, "content": ["    def serialize_db_to_string(self):\n", "        \"\"\"\n", "        Serialize all data in the database into a JSON string.\n", "        Designed only for test runner usage; will not handle large\n", "        amounts of data.\n", "        \"\"\"\n", "        # Build list of all apps to serialize\n", "        from django.db.migrations.loader import MigrationLoader\n", "        loader = MigrationLoader(self.connection)\n", "        app_list = []\n", "        for app_config in apps.get_app_configs():\n", "            if (\n", "                app_config.models_module is not None and\n", "                app_config.label in loader.migrated_apps and\n", "                app_config.name not in settings.TEST_NON_SERIALIZED_APPS\n", "            ):\n", "                app_list.append((app_config, None))\n", "\n", "        # Make a function to iteratively return every object\n", "        def get_objects():\n", "            for model in serializers.sort_dependencies(app_list):\n", "                if (model._meta.can_migrate(self.connection) and\n", "                        router.allow_migrate_model(self.connection.alias, model)):\n", "                    queryset = model._default_manager.using(self.connection.alias).order_by(model._meta.pk.name)\n", "                    yield from queryset.iterator()\n", "        # Serialize to a string\n", "        out = StringIO()\n", "        serializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n", "        return out.getvalue()\n"]}, {"span_id": "BaseDatabaseCreation.deserialize_db_from_string", "start_line": 123, "end_line": 130, "content": ["    def deserialize_db_from_string(self, data):\n", "        \"\"\"\n", "        Reload the database with data from a string generated by\n", "        the serialize_db_to_string() method.\n", "        \"\"\"\n", "        data = StringIO(data)\n", "        for obj in serializers.deserialize(\"json\", data, using=self.connection.alias):\n", "            obj.save()\n"]}]}, {"file_path": "django/db/transaction.py", "span_ids": ["atomic"], "content": [{"span_id": "atomic", "start_line": 285, "end_line": 292, "content": ["def atomic(using=None, savepoint=True):\n", "    # Bare decorator: @atomic -- although the first argument is called\n", "    # `using`, it's actually the function being decorated.\n", "    if callable(using):\n", "        return Atomic(DEFAULT_DB_ALIAS, savepoint)(using)\n", "    # Decorator: @atomic(...) or context manager: with atomic(...): ...\n", "    else:\n", "        return Atomic(using, savepoint)\n"]}]}]}