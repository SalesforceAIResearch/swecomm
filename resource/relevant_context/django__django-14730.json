{"instance_id": "django__django-14730", "identified_spans": [{"file_path": "django/db/models/fields/related.py", "span_ids": ["ManyToManyField.contribute_to_class", "ManyToManyField.__init__"], "content": [{"span_id": "ManyToManyField.contribute_to_class", "start_line": 1628, "end_line": 1669, "content": ["    def contribute_to_class(self, cls, name, **kwargs):\n", "        # To support multiple relations to self, it's useful to have a non-None\n", "        # related name on symmetrical relations for internal reasons. The\n", "        # concept doesn't make a lot of sense externally (\"you want me to\n", "        # specify *what* on my non-reversible relation?!\"), so we set it up\n", "        # automatically. The funky name reduces the chance of an accidental\n", "        # clash.\n", "        if self.remote_field.symmetrical and (\n", "            self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or\n", "            self.remote_field.model == cls._meta.object_name\n", "        ):\n", "            self.remote_field.related_name = \"%s_rel_+\" % name\n", "        elif self.remote_field.is_hidden():\n", "            # If the backwards relation is disabled, replace the original\n", "            # related_name with one generated from the m2m field name. Django\n", "            # still uses backwards relations internally and we need to avoid\n", "            # clashes between multiple m2m fields with related_name == '+'.\n", "            self.remote_field.related_name = '_%s_%s_%s_+' % (\n", "                cls._meta.app_label,\n", "                cls.__name__.lower(),\n", "                name,\n", "            )\n", "\n", "        super().contribute_to_class(cls, name, **kwargs)\n", "\n", "        # The intermediate m2m model is not auto created if:\n", "        #  1) There is a manually specified intermediate, or\n", "        #  2) The class owning the m2m field is abstract.\n", "        #  3) The class owning the m2m field has been swapped out.\n", "        if not cls._meta.abstract:\n", "            if self.remote_field.through:\n", "                def resolve_through_model(_, model, field):\n", "                    field.remote_field.through = model\n", "                lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)\n", "            elif not cls._meta.swapped:\n", "                self.remote_field.through = create_many_to_many_intermediary_model(self, cls)\n", "\n", "        # Add the descriptor for the m2m relation.\n", "        setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))\n", "\n", "        # Set up the accessor for the m2m table name for the relation.\n", "        self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)\n"]}, {"span_id": "ManyToManyField.__init__", "start_line": 1165, "end_line": 1208, "content": ["    def __init__(self, to, related_name=None, related_query_name=None,\n", "                 limit_choices_to=None, symmetrical=None, through=None,\n", "                 through_fields=None, db_constraint=True, db_table=None,\n", "                 swappable=True, **kwargs):\n", "        try:\n", "            to._meta\n", "        except AttributeError:\n", "            if not isinstance(to, str):\n", "                raise TypeError(\n", "                    '%s(%r) is invalid. First parameter to ManyToManyField '\n", "                    'must be either a model, a model name, or the string %r' % (\n", "                        self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT,\n", "                    )\n", "                )\n", "\n", "        if symmetrical is None:\n", "            symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n", "\n", "        if through is not None and db_table is not None:\n", "            raise ValueError(\n", "                'Cannot specify a db_table if an intermediary model is used.'\n", "            )\n", "\n", "        kwargs['rel'] = self.rel_class(\n", "            self, to,\n", "            related_name=related_name,\n", "            related_query_name=related_query_name,\n", "            limit_choices_to=limit_choices_to,\n", "            symmetrical=symmetrical,\n", "            through=through,\n", "            through_fields=through_fields,\n", "            db_constraint=db_constraint,\n", "        )\n", "        self.has_null_arg = 'null' in kwargs\n", "\n", "        super().__init__(\n", "            related_name=related_name,\n", "            related_query_name=related_query_name,\n", "            limit_choices_to=limit_choices_to,\n", "            **kwargs,\n", "        )\n", "\n", "        self.db_table = db_table\n", "        self.swappable = swappable\n"]}]}]}