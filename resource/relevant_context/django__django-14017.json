{"instance_id": "django__django-14017", "identified_spans": [{"file_path": "django/db/models/expressions.py", "span_ids": ["Combinable", "Combinable.__rand__", "Combinable.__and__", "Exists"], "content": [{"span_id": "Combinable", "start_line": 33, "end_line": 56, "content": ["class Combinable:\n", "    \"\"\"\n", "    Provide the ability to combine one or two objects with\n", "    some connector. For example F('foo') + F('bar').\n", "    \"\"\"\n", "\n", "    # Arithmetic connectors\n", "    ADD = '+'\n", "    SUB = '-'\n", "    MUL = '*'\n", "    DIV = '/'\n", "    POW = '^'\n", "    # The following is a quoted % operator - it is quoted because it can be\n", "    # used in strings that also have parameter substitution.\n", "    MOD = '%%'\n", "\n", "    # Bitwise operators - note that these are generated by .bitand()\n", "    # and .bitor(), the '&' and '|' are reserved for boolean operator\n", "    # usage.\n", "    BITAND = '&'\n", "    BITOR = '|'\n", "    BITLEFTSHIFT = '<<'\n", "    BITRIGHTSHIFT = '>>'\n", "    BITXOR = '#'\n"]}, {"span_id": "Combinable.__rand__", "start_line": 139, "end_line": 142, "content": ["    def __rand__(self, other):\n", "        raise NotImplementedError(\n", "            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n", "        )\n"]}, {"span_id": "Combinable.__and__", "start_line": 92, "end_line": 97, "content": ["    def __and__(self, other):\n", "        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n", "            return Q(self) & Q(other)\n", "        raise NotImplementedError(\n", "            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n", "        )\n"]}, {"span_id": "Exists", "start_line": 1150, "end_line": 1152, "content": ["class Exists(Subquery):\n", "    template = 'EXISTS(%(subquery)s)'\n", "    output_field = fields.BooleanField()\n"]}]}, {"file_path": "django/db/models/query_utils.py", "span_ids": ["Q.__and__", "Q._combine", "Q"], "content": [{"span_id": "Q.__and__", "start_line": 64, "end_line": 65, "content": ["    def __and__(self, other):\n", "        return self._combine(other, self.AND)\n"]}, {"span_id": "Q._combine", "start_line": 42, "end_line": 59, "content": ["    def _combine(self, other, conn):\n", "        if not isinstance(other, Q):\n", "            raise TypeError(other)\n", "\n", "        # If the other Q() is empty, ignore it and just use `self`.\n", "        if not other:\n", "            _, args, kwargs = self.deconstruct()\n", "            return type(self)(*args, **kwargs)\n", "        # Or if this Q is empty, ignore it and just use `other`.\n", "        elif not self:\n", "            _, args, kwargs = other.deconstruct()\n", "            return type(other)(*args, **kwargs)\n", "\n", "        obj = type(self)()\n", "        obj.connector = conn\n", "        obj.add(self, conn)\n", "        obj.add(other, conn)\n", "        return obj\n"]}, {"span_id": "Q", "start_line": 28, "end_line": 37, "content": ["class Q(tree.Node):\n", "    \"\"\"\n", "    Encapsulate filters as objects that can then be combined logically (using\n", "    `&` and `|`).\n", "    \"\"\"\n", "    # Connection types\n", "    AND = 'AND'\n", "    OR = 'OR'\n", "    default = AND\n", "    conditional = True\n"]}]}]}