{"instance_id": "django__django-13033", "identified_spans": [{"file_path": "django/db/models/options.py", "span_ids": ["Options.__init__"], "content": [{"span_id": "Options.__init__", "start_line": 73, "end_line": 128, "content": ["    def __init__(self, meta, app_label=None):\n", "        self._get_fields_cache = {}\n", "        self.local_fields = []\n", "        self.local_many_to_many = []\n", "        self.private_fields = []\n", "        self.local_managers = []\n", "        self.base_manager_name = None\n", "        self.default_manager_name = None\n", "        self.model_name = None\n", "        self.verbose_name = None\n", "        self.verbose_name_plural = None\n", "        self.db_table = ''\n", "        self.ordering = []\n", "        self._ordering_clash = False\n", "        self.indexes = []\n", "        self.constraints = []\n", "        self.unique_together = []\n", "        self.index_together = []\n", "        self.select_on_save = False\n", "        self.default_permissions = ('add', 'change', 'delete', 'view')\n", "        self.permissions = []\n", "        self.object_name = None\n", "        self.app_label = app_label\n", "        self.get_latest_by = None\n", "        self.order_with_respect_to = None\n", "        self.db_tablespace = settings.DEFAULT_TABLESPACE\n", "        self.required_db_features = []\n", "        self.required_db_vendor = None\n", "        self.meta = meta\n", "        self.pk = None\n", "        self.auto_field = None\n", "        self.abstract = False\n", "        self.managed = True\n", "        self.proxy = False\n", "        # For any class that is a proxy (including automatically created\n", "        # classes for deferred object loading), proxy_for_model tells us\n", "        # which class this model is proxying. Note that proxy_for_model\n", "        # can create a chain of proxy models. For non-proxy models, the\n", "        # variable is always None.\n", "        self.proxy_for_model = None\n", "        # For any non-abstract class, the concrete class is the model\n", "        # in the end of the proxy_for_model chain. In particular, for\n", "        # concrete models, the concrete_model is always the class itself.\n", "        self.concrete_model = None\n", "        self.swappable = None\n", "        self.parents = {}\n", "        self.auto_created = False\n", "\n", "        # List of all lookups defined in ForeignKey 'limit_choices_to' options\n", "        # from *other* models. Needed for some admin checks. Internal use only.\n", "        self.related_fkey_lookups = []\n", "\n", "        # A custom app registry to use, if you're making a separate model set.\n", "        self.apps = self.default_apps\n", "\n", "        self.default_related_name = None\n"]}]}, {"file_path": "django/db/models/sql/compiler.py", "span_ids": ["SQLCompiler.get_order_by"], "content": [{"span_id": "SQLCompiler.get_order_by", "start_line": 271, "end_line": 396, "content": ["    def get_order_by(self):\n", "        \"\"\"\n", "        Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n", "        ORDER BY clause.\n", "\n", "        The order_by clause can alter the select clause (for example it\n", "        can add aliases to clauses that do not yet have one, or it can\n", "        add totally new select clauses).\n", "        \"\"\"\n", "        if self.query.extra_order_by:\n", "            ordering = self.query.extra_order_by\n", "        elif not self.query.default_ordering:\n", "            ordering = self.query.order_by\n", "        elif self.query.order_by:\n", "            ordering = self.query.order_by\n", "        elif self.query.get_meta().ordering:\n", "            ordering = self.query.get_meta().ordering\n", "            self._meta_ordering = ordering\n", "        else:\n", "            ordering = []\n", "        if self.query.standard_ordering:\n", "            asc, desc = ORDER_DIR['ASC']\n", "        else:\n", "            asc, desc = ORDER_DIR['DESC']\n", "\n", "        order_by = []\n", "        for field in ordering:\n", "            if hasattr(field, 'resolve_expression'):\n", "                if isinstance(field, Value):\n", "                    # output_field must be resolved for constants.\n", "                    field = Cast(field, field.output_field)\n", "                if not isinstance(field, OrderBy):\n", "                    field = field.asc()\n", "                if not self.query.standard_ordering:\n", "                    field = field.copy()\n", "                    field.reverse_ordering()\n", "                order_by.append((field, False))\n", "                continue\n", "            if field == '?':  # random\n", "                order_by.append((OrderBy(Random()), False))\n", "                continue\n", "\n", "            col, order = get_order_dir(field, asc)\n", "            descending = order == 'DESC'\n", "\n", "            if col in self.query.annotation_select:\n", "                # Reference to expression in SELECT clause\n", "                order_by.append((\n", "                    OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),\n", "                    True))\n", "                continue\n", "            if col in self.query.annotations:\n", "                # References to an expression which is masked out of the SELECT\n", "                # clause.\n", "                expr = self.query.annotations[col]\n", "                if isinstance(expr, Value):\n", "                    # output_field must be resolved for constants.\n", "                    expr = Cast(expr, expr.output_field)\n", "                order_by.append((OrderBy(expr, descending=descending), False))\n", "                continue\n", "\n", "            if '.' in field:\n", "                # This came in through an extra(order_by=...) addition. Pass it\n", "                # on verbatim.\n", "                table, col = col.split('.', 1)\n", "                order_by.append((\n", "                    OrderBy(\n", "                        RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),\n", "                        descending=descending\n", "                    ), False))\n", "                continue\n", "\n", "            if not self.query.extra or col not in self.query.extra:\n", "                # 'col' is of the form 'field' or 'field1__field2' or\n", "                # '-field1__field2__field', etc.\n", "                order_by.extend(self.find_ordering_name(\n", "                    field, self.query.get_meta(), default_order=asc))\n", "            else:\n", "                if col not in self.query.extra_select:\n", "                    order_by.append((\n", "                        OrderBy(RawSQL(*self.query.extra[col]), descending=descending),\n", "                        False))\n", "                else:\n", "                    order_by.append((\n", "                        OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),\n", "                        True))\n", "        result = []\n", "        seen = set()\n", "\n", "        for expr, is_ref in order_by:\n", "            resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n", "            if self.query.combinator:\n", "                src = resolved.get_source_expressions()[0]\n", "                expr_src = expr.get_source_expressions()[0]\n", "                # Relabel order by columns to raw numbers if this is a combined\n", "                # query; necessary since the columns can't be referenced by the\n", "                # fully qualified name and the simple column names may collide.\n", "                for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n", "                    if is_ref and col_alias == src.refs:\n", "                        src = src.source\n", "                    elif col_alias and not (\n", "                        isinstance(expr_src, F) and col_alias == expr_src.name\n", "                    ):\n", "                        continue\n", "                    if src == sel_expr:\n", "                        resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n", "                        break\n", "                else:\n", "                    if col_alias:\n", "                        raise DatabaseError('ORDER BY term does not match any column in the result set.')\n", "                    # Add column used in ORDER BY clause without an alias to\n", "                    # the selected columns.\n", "                    self.query.add_select_col(src)\n", "                    resolved.set_source_expressions([RawSQL('%d' % len(self.query.select), ())])\n", "            sql, params = self.compile(resolved)\n", "            # Don't add the same column twice, but the order direction is\n", "            # not taken into account so we strip it. When this entire method\n", "            # is refactored into expressions, then we can check each part as we\n", "            # generate it.\n", "            without_ordering = self.ordering_parts.search(sql)[1]\n", "            params_hash = make_hashable(params)\n", "            if (without_ordering, params_hash) in seen:\n", "                continue\n", "            seen.add((without_ordering, params_hash))\n", "            result.append((resolved, (sql, params, is_ref)))\n", "        return result\n"]}]}, {"file_path": "django/db/models/sql/query.py", "span_ids": ["Query.names_to_path", "Query.setup_joins", "Query.add_ordering"], "content": [{"span_id": "Query.names_to_path", "start_line": 1424, "end_line": 1518, "content": ["    def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n", "        \"\"\"\n", "        Walk the list of names and turns them into PathInfo tuples. A single\n", "        name in 'names' can generate multiple PathInfos (m2m, for example).\n", "\n", "        'names' is the path of names to travel, 'opts' is the model Options we\n", "        start the name resolving from, 'allow_many' is as for setup_joins().\n", "        If fail_on_missing is set to True, then a name that can't be resolved\n", "        will generate a FieldError.\n", "\n", "        Return a list of PathInfo tuples. In addition return the final field\n", "        (the last used join field) and target (which is a field guaranteed to\n", "        contain the same value as the final field). Finally, return those names\n", "        that weren't found (which are likely transforms and the final lookup).\n", "        \"\"\"\n", "        path, names_with_path = [], []\n", "        for pos, name in enumerate(names):\n", "            cur_names_with_path = (name, [])\n", "            if name == 'pk':\n", "                name = opts.pk.name\n", "\n", "            field = None\n", "            filtered_relation = None\n", "            try:\n", "                field = opts.get_field(name)\n", "            except FieldDoesNotExist:\n", "                if name in self.annotation_select:\n", "                    field = self.annotation_select[name].output_field\n", "                elif name in self._filtered_relations and pos == 0:\n", "                    filtered_relation = self._filtered_relations[name]\n", "                    field = opts.get_field(filtered_relation.relation_name)\n", "            if field is not None:\n", "                # Fields that contain one-to-many relations with a generic\n", "                # model (like a GenericForeignKey) cannot generate reverse\n", "                # relations and therefore cannot be used for reverse querying.\n", "                if field.is_relation and not field.related_model:\n", "                    raise FieldError(\n", "                        \"Field %r does not generate an automatic reverse \"\n", "                        \"relation and therefore cannot be used for reverse \"\n", "                        \"querying. If it is a GenericForeignKey, consider \"\n", "                        \"adding a GenericRelation.\" % name\n", "                    )\n", "                try:\n", "                    model = field.model._meta.concrete_model\n", "                except AttributeError:\n", "                    # QuerySet.annotate() may introduce fields that aren't\n", "                    # attached to a model.\n", "                    model = None\n", "            else:\n", "                # We didn't find the current field, so move position back\n", "                # one step.\n", "                pos -= 1\n", "                if pos == -1 or fail_on_missing:\n", "                    available = sorted([\n", "                        *get_field_names_from_opts(opts),\n", "                        *self.annotation_select,\n", "                        *self._filtered_relations,\n", "                    ])\n", "                    raise FieldError(\"Cannot resolve keyword '%s' into field. \"\n", "                                     \"Choices are: %s\" % (name, \", \".join(available)))\n", "                break\n", "            # Check if we need any joins for concrete inheritance cases (the\n", "            # field lives in parent, but we are currently in one of its\n", "            # children)\n", "            if model is not opts.model:\n", "                path_to_parent = opts.get_path_to_parent(model)\n", "                if path_to_parent:\n", "                    path.extend(path_to_parent)\n", "                    cur_names_with_path[1].extend(path_to_parent)\n", "                    opts = path_to_parent[-1].to_opts\n", "            if hasattr(field, 'get_path_info'):\n", "                pathinfos = field.get_path_info(filtered_relation)\n", "                if not allow_many:\n", "                    for inner_pos, p in enumerate(pathinfos):\n", "                        if p.m2m:\n", "                            cur_names_with_path[1].extend(pathinfos[0:inner_pos + 1])\n", "                            names_with_path.append(cur_names_with_path)\n", "                            raise MultiJoin(pos + 1, names_with_path)\n", "                last = pathinfos[-1]\n", "                path.extend(pathinfos)\n", "                final_field = last.join_field\n", "                opts = last.to_opts\n", "                targets = last.target_fields\n", "                cur_names_with_path[1].extend(pathinfos)\n", "                names_with_path.append(cur_names_with_path)\n", "            else:\n", "                # Local non-relational field.\n", "                final_field = field\n", "                targets = (field,)\n", "                if fail_on_missing and pos + 1 != len(names):\n", "                    raise FieldError(\n", "                        \"Cannot resolve keyword %r into field. Join on '%s'\"\n", "                        \" not permitted.\" % (names[pos + 1], name))\n", "                break\n", "        return path, final_field, targets, names[pos + 1:]\n"]}, {"span_id": "Query.setup_joins", "start_line": 1520, "end_line": 1620, "content": ["    def setup_joins(self, names, opts, alias, can_reuse=None, allow_many=True,\n", "                    reuse_with_filtered_relation=False):\n", "        \"\"\"\n", "        Compute the necessary table joins for the passage through the fields\n", "        given in 'names'. 'opts' is the Options class for the current model\n", "        (which gives the table we are starting from), 'alias' is the alias for\n", "        the table to start the joining from.\n", "\n", "        The 'can_reuse' defines the reverse foreign key joins we can reuse. It\n", "        can be None in which case all joins are reusable or a set of aliases\n", "        that can be reused. Note that non-reverse foreign keys are always\n", "        reusable when using setup_joins().\n", "\n", "        The 'reuse_with_filtered_relation' can be used to force 'can_reuse'\n", "        parameter and force the relation on the given connections.\n", "\n", "        If 'allow_many' is False, then any reverse foreign key seen will\n", "        generate a MultiJoin exception.\n", "\n", "        Return the final field involved in the joins, the target field (used\n", "        for any 'where' constraint), the final 'opts' value, the joins, the\n", "        field path traveled to generate the joins, and a transform function\n", "        that takes a field and alias and is equivalent to `field.get_col(alias)`\n", "        in the simple case but wraps field transforms if they were included in\n", "        names.\n", "\n", "        The target field is the field containing the concrete value. Final\n", "        field can be something different, for example foreign key pointing to\n", "        that value. Final field is needed for example in some value\n", "        conversions (convert 'obj' in fk__id=obj to pk val using the foreign\n", "        key field for example).\n", "        \"\"\"\n", "        joins = [alias]\n", "        # The transform can't be applied yet, as joins must be trimmed later.\n", "        # To avoid making every caller of this method look up transforms\n", "        # directly, compute transforms here and create a partial that converts\n", "        # fields to the appropriate wrapped version.\n", "\n", "        def final_transformer(field, alias):\n", "            return field.get_col(alias)\n", "\n", "        # Try resolving all the names as fields first. If there's an error,\n", "        # treat trailing names as lookups until a field can be resolved.\n", "        last_field_exception = None\n", "        for pivot in range(len(names), 0, -1):\n", "            try:\n", "                path, final_field, targets, rest = self.names_to_path(\n", "                    names[:pivot], opts, allow_many, fail_on_missing=True,\n", "                )\n", "            except FieldError as exc:\n", "                if pivot == 1:\n", "                    # The first item cannot be a lookup, so it's safe\n", "                    # to raise the field error here.\n", "                    raise\n", "                else:\n", "                    last_field_exception = exc\n", "            else:\n", "                # The transforms are the remaining items that couldn't be\n", "                # resolved into fields.\n", "                transforms = names[pivot:]\n", "                break\n", "        for name in transforms:\n", "            def transform(field, alias, *, name, previous):\n", "                try:\n", "                    wrapped = previous(field, alias)\n", "                    return self.try_transform(wrapped, name)\n", "                except FieldError:\n", "                    # FieldError is raised if the transform doesn't exist.\n", "                    if isinstance(final_field, Field) and last_field_exception:\n", "                        raise last_field_exception\n", "                    else:\n", "                        raise\n", "            final_transformer = functools.partial(transform, name=name, previous=final_transformer)\n", "        # Then, add the path to the query's joins. Note that we can't trim\n", "        # joins at this stage - we will need the information about join type\n", "        # of the trimmed joins.\n", "        for join in path:\n", "            if join.filtered_relation:\n", "                filtered_relation = join.filtered_relation.clone()\n", "                table_alias = filtered_relation.alias\n", "            else:\n", "                filtered_relation = None\n", "                table_alias = None\n", "            opts = join.to_opts\n", "            if join.direct:\n", "                nullable = self.is_nullable(join.join_field)\n", "            else:\n", "                nullable = True\n", "            connection = Join(\n", "                opts.db_table, alias, table_alias, INNER, join.join_field,\n", "                nullable, filtered_relation=filtered_relation,\n", "            )\n", "            reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None\n", "            alias = self.join(\n", "                connection, reuse=reuse,\n", "                reuse_with_filtered_relation=reuse_with_filtered_relation,\n", "            )\n", "            joins.append(alias)\n", "            if filtered_relation:\n", "                filtered_relation.path = joins[:]\n", "        return JoinInfo(final_field, targets, opts, joins, path, final_transformer)\n"]}, {"span_id": "Query.add_ordering", "start_line": 1889, "end_line": 1933, "content": ["    def add_ordering(self, *ordering):\n", "        \"\"\"\n", "        Add items from the 'ordering' sequence to the query's \"order by\"\n", "        clause. These items are either field names (not column names) --\n", "        possibly with a direction prefix ('-' or '?') -- or OrderBy\n", "        expressions.\n", "\n", "        If 'ordering' is empty, clear all ordering from the query.\n", "        \"\"\"\n", "        errors = []\n", "        for item in ordering:\n", "            if isinstance(item, str):\n", "                if '.' in item:\n", "                    warnings.warn(\n", "                        'Passing column raw column aliases to order_by() is '\n", "                        'deprecated. Wrap %r in a RawSQL expression before '\n", "                        'passing it to order_by().' % item,\n", "                        category=RemovedInDjango40Warning,\n", "                        stacklevel=3,\n", "                    )\n", "                    continue\n", "                if item == '?':\n", "                    continue\n", "                if item.startswith('-'):\n", "                    item = item[1:]\n", "                if item in self.annotations:\n", "                    continue\n", "                if self.extra and item in self.extra:\n", "                    continue\n", "                # names_to_path() validates the lookup. A descriptive\n", "                # FieldError will be raise if it's not.\n", "                self.names_to_path(item.split(LOOKUP_SEP), self.model._meta)\n", "            elif not hasattr(item, 'resolve_expression'):\n", "                errors.append(item)\n", "            if getattr(item, 'contains_aggregate', False):\n", "                raise FieldError(\n", "                    'Using an aggregate in order_by() without also including '\n", "                    'it in annotate() is not allowed: %s' % item\n", "                )\n", "        if errors:\n", "            raise FieldError('Invalid order_by arguments: %s' % errors)\n", "        if ordering:\n", "            self.order_by += ordering\n", "        else:\n", "            self.default_ordering = False\n"]}]}]}