{"instance_id": "sympy__sympy-20212", "identified_spans": [{"file_path": "sympy/core/numbers.py", "span_ids": ["Zero", "Zero._eval_power"], "content": [{"span_id": "Zero", "start_line": 2584, "end_line": 2612, "content": ["class Zero(IntegerConstant, metaclass=Singleton):\n", "    \"\"\"The number zero.\n", "\n", "    Zero is a singleton, and can be accessed by ``S.Zero``\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import S, Integer\n", "    >>> Integer(0) is S.Zero\n", "    True\n", "    >>> 1/S.Zero\n", "    zoo\n", "\n", "    References\n", "    ==========\n", "\n", "    .. [1] https://en.wikipedia.org/wiki/Zero\n", "    \"\"\"\n", "\n", "    p = 0\n", "    q = 1\n", "    is_positive = False\n", "    is_negative = False\n", "    is_zero = True\n", "    is_number = True\n", "    is_comparable = True\n", "\n", "    __slots__ = ()\n"]}, {"span_id": "Zero._eval_power", "start_line": 2625, "end_line": 2639, "content": ["    def _eval_power(self, expt):\n", "        if expt.is_positive:\n", "            return self\n", "        if expt.is_negative:\n", "            return S.ComplexInfinity\n", "        if expt.is_extended_real is False:\n", "            return S.NaN\n", "        # infinities are already handled with pos and neg\n", "        # tests above; now throw away leading numbers on Mul\n", "        # exponent\n", "        coeff, terms = expt.as_coeff_Mul()\n", "        if coeff.is_negative:\n", "            return S.ComplexInfinity**terms\n", "        if coeff is not S.One:  # there is a Number to discard\n", "            return self**terms\n"]}]}, {"file_path": "sympy/core/power.py", "span_ids": ["Pow._eval_power", "Pow"], "content": [{"span_id": "Pow._eval_power", "start_line": 360, "end_line": 441, "content": ["    def _eval_power(self, other):\n", "        from sympy import arg, exp, floor, im, log, re, sign\n", "        b, e = self.as_base_exp()\n", "        if b is S.NaN:\n", "            return (b**e)**other  # let __new__ handle it\n", "\n", "        s = None\n", "        if other.is_integer:\n", "            s = 1\n", "        elif b.is_polar:  # e.g. exp_polar, besselj, var('p', polar=True)...\n", "            s = 1\n", "        elif e.is_extended_real is not None:\n", "            # helper functions ===========================\n", "            def _half(e):\n", "                \"\"\"Return True if the exponent has a literal 2 as the\n", "                denominator, else None.\"\"\"\n", "                if getattr(e, 'q', None) == 2:\n", "                    return True\n", "                n, d = e.as_numer_denom()\n", "                if n.is_integer and d == 2:\n", "                    return True\n", "            def _n2(e):\n", "                \"\"\"Return ``e`` evaluated to a Number with 2 significant\n", "                digits, else None.\"\"\"\n", "                try:\n", "                    rv = e.evalf(2, strict=True)\n", "                    if rv.is_Number:\n", "                        return rv\n", "                except PrecisionExhausted:\n", "                    pass\n", "            # ===================================================\n", "            if e.is_extended_real:\n", "                # we need _half(other) with constant floor or\n", "                # floor(S.Half - e*arg(b)/2/pi) == 0\n", "\n", "                # handle -1 as special case\n", "                if e == -1:\n", "                    # floor arg. is 1/2 + arg(b)/2/pi\n", "                    if _half(other):\n", "                        if b.is_negative is True:\n", "                            return S.NegativeOne**other*Pow(-b, e*other)\n", "                        elif b.is_negative is False:\n", "                            return Pow(b, -other)\n", "                elif e.is_even:\n", "                    if b.is_extended_real:\n", "                        b = abs(b)\n", "                    if b.is_imaginary:\n", "                        b = abs(im(b))*S.ImaginaryUnit\n", "\n", "                if (abs(e) < 1) == True or e == 1:\n", "                    s = 1  # floor = 0\n", "                elif b.is_extended_nonnegative:\n", "                    s = 1  # floor = 0\n", "                elif re(b).is_extended_nonnegative and (abs(e) < 2) == True:\n", "                    s = 1  # floor = 0\n", "                elif fuzzy_not(im(b).is_zero) and abs(e) == 2:\n", "                    s = 1  # floor = 0\n", "                elif _half(other):\n", "                    s = exp(2*S.Pi*S.ImaginaryUnit*other*floor(\n", "                        S.Half - e*arg(b)/(2*S.Pi)))\n", "                    if s.is_extended_real and _n2(sign(s) - s) == 0:\n", "                        s = sign(s)\n", "                    else:\n", "                        s = None\n", "            else:\n", "                # e.is_extended_real is False requires:\n", "                #     _half(other) with constant floor or\n", "                #     floor(S.Half - im(e*log(b))/2/pi) == 0\n", "                try:\n", "                    s = exp(2*S.ImaginaryUnit*S.Pi*other*\n", "                        floor(S.Half - im(e*log(b))/2/S.Pi))\n", "                    # be careful to test that s is -1 or 1 b/c sign(I) == I:\n", "                    # so check that s is real\n", "                    if s.is_extended_real and _n2(sign(s) - s) == 0:\n", "                        s = sign(s)\n", "                    else:\n", "                        s = None\n", "                except PrecisionExhausted:\n", "                    s = None\n", "\n", "        if s is not None:\n", "            return s*Pow(b, e*other)\n"]}, {"span_id": "Pow", "start_line": 182, "end_line": 267, "content": ["class Pow(Expr):\n", "    \"\"\"\n", "    Defines the expression x**y as \"x raised to a power y\"\n", "\n", "    Singleton definitions involving (0, 1, -1, oo, -oo, I, -I):\n", "\n", "    +--------------+---------+-----------------------------------------------+\n", "    | expr         | value   | reason                                        |\n", "    +==============+=========+===============================================+\n", "    | z**0         | 1       | Although arguments over 0**0 exist, see [2].  |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | z**1         | z       |                                               |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | (-oo)**(-1)  | 0       |                                               |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | (-1)**-1     | -1      |                                               |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | S.Zero**-1   | zoo     | This is not strictly true, as 0**-1 may be    |\n", "    |              |         | undefined, but is convenient in some contexts |\n", "    |              |         | where the base is assumed to be positive.     |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | 1**-1        | 1       |                                               |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | oo**-1       | 0       |                                               |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | 0**oo        | 0       | Because for all complex numbers z near        |\n", "    |              |         | 0, z**oo -> 0.                                |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | 0**-oo       | zoo     | This is not strictly true, as 0**oo may be    |\n", "    |              |         | oscillating between positive and negative     |\n", "    |              |         | values or rotating in the complex plane.      |\n", "    |              |         | It is convenient, however, when the base      |\n", "    |              |         | is positive.                                  |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | 1**oo        | nan     | Because there are various cases where         |\n", "    | 1**-oo       |         | lim(x(t),t)=1, lim(y(t),t)=oo (or -oo),       |\n", "    |              |         | but lim( x(t)**y(t), t) != 1.  See [3].       |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | b**zoo       | nan     | Because b**z has no limit as z -> zoo         |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | (-1)**oo     | nan     | Because of oscillations in the limit.         |\n", "    | (-1)**(-oo)  |         |                                               |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | oo**oo       | oo      |                                               |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | oo**-oo      | 0       |                                               |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | (-oo)**oo    | nan     |                                               |\n", "    | (-oo)**-oo   |         |                                               |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | oo**I        | nan     | oo**e could probably be best thought of as    |\n", "    | (-oo)**I     |         | the limit of x**e for real x as x tends to    |\n", "    |              |         | oo. If e is I, then the limit does not exist  |\n", "    |              |         | and nan is used to indicate that.             |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | oo**(1+I)    | zoo     | If the real part of e is positive, then the   |\n", "    | (-oo)**(1+I) |         | limit of abs(x**e) is oo. So the limit value  |\n", "    |              |         | is zoo.                                       |\n", "    +--------------+---------+-----------------------------------------------+\n", "    | oo**(-1+I)   | 0       | If the real part of e is negative, then the   |\n", "    | -oo**(-1+I)  |         | limit is 0.                                   |\n", "    +--------------+---------+-----------------------------------------------+\n", "\n", "    Because symbolic computations are more flexible that floating point\n", "    calculations and we prefer to never return an incorrect answer,\n", "    we choose not to conform to all IEEE 754 conventions.  This helps\n", "    us avoid extra test-case code in the calculation of limits.\n", "\n", "    See Also\n", "    ========\n", "\n", "    sympy.core.numbers.Infinity\n", "    sympy.core.numbers.NegativeInfinity\n", "    sympy.core.numbers.NaN\n", "\n", "    References\n", "    ==========\n", "\n", "    .. [1] https://en.wikipedia.org/wiki/Exponentiation\n", "    .. [2] https://en.wikipedia.org/wiki/Exponentiation#Zero_to_the_power_of_zero\n", "    .. [3] https://en.wikipedia.org/wiki/Indeterminate_forms\n", "\n", "    \"\"\"\n", "    is_Pow = True\n", "\n", "    __slots__ = ('is_commutative',)\n"]}]}]}