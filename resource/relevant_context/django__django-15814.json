{"instance_id": "django__django-15814", "identified_spans": [{"file_path": "django/db/models/base.py", "span_ids": ["ModelBase.__new__"], "content": [{"span_id": "ModelBase.__new__", "start_line": 93, "end_line": 365, "content": ["    def __new__(cls, name, bases, attrs, **kwargs):\n", "        super_new = super().__new__\n", "\n", "        # Also ensure initialization is only performed for subclasses of Model\n", "        # (excluding Model class itself).\n", "        parents = [b for b in bases if isinstance(b, ModelBase)]\n", "        if not parents:\n", "            return super_new(cls, name, bases, attrs)\n", "\n", "        # Create the class.\n", "        module = attrs.pop(\"__module__\")\n", "        new_attrs = {\"__module__\": module}\n", "        classcell = attrs.pop(\"__classcell__\", None)\n", "        if classcell is not None:\n", "            new_attrs[\"__classcell__\"] = classcell\n", "        attr_meta = attrs.pop(\"Meta\", None)\n", "        # Pass all attrs without a (Django-specific) contribute_to_class()\n", "        # method to type.__new__() so that they're properly initialized\n", "        # (i.e. __set_name__()).\n", "        contributable_attrs = {}\n", "        for obj_name, obj in attrs.items():\n", "            if _has_contribute_to_class(obj):\n", "                contributable_attrs[obj_name] = obj\n", "            else:\n", "                new_attrs[obj_name] = obj\n", "        new_class = super_new(cls, name, bases, new_attrs, **kwargs)\n", "\n", "        abstract = getattr(attr_meta, \"abstract\", False)\n", "        meta = attr_meta or getattr(new_class, \"Meta\", None)\n", "        base_meta = getattr(new_class, \"_meta\", None)\n", "\n", "        app_label = None\n", "\n", "        # Look for an application configuration to attach the model to.\n", "        app_config = apps.get_containing_app_config(module)\n", "\n", "        if getattr(meta, \"app_label\", None) is None:\n", "            if app_config is None:\n", "                if not abstract:\n", "                    raise RuntimeError(\n", "                        \"Model class %s.%s doesn't declare an explicit \"\n", "                        \"app_label and isn't in an application in \"\n", "                        \"INSTALLED_APPS.\" % (module, name)\n", "                    )\n", "\n", "            else:\n", "                app_label = app_config.label\n", "\n", "        new_class.add_to_class(\"_meta\", Options(meta, app_label))\n", "        if not abstract:\n", "            new_class.add_to_class(\n", "                \"DoesNotExist\",\n", "                subclass_exception(\n", "                    \"DoesNotExist\",\n", "                    tuple(\n", "                        x.DoesNotExist\n", "                        for x in parents\n", "                        if hasattr(x, \"_meta\") and not x._meta.abstract\n", "                    )\n", "                    or (ObjectDoesNotExist,),\n", "                    module,\n", "                    attached_to=new_class,\n", "                ),\n", "            )\n", "            new_class.add_to_class(\n", "                \"MultipleObjectsReturned\",\n", "                subclass_exception(\n", "                    \"MultipleObjectsReturned\",\n", "                    tuple(\n", "                        x.MultipleObjectsReturned\n", "                        for x in parents\n", "                        if hasattr(x, \"_meta\") and not x._meta.abstract\n", "                    )\n", "                    or (MultipleObjectsReturned,),\n", "                    module,\n", "                    attached_to=new_class,\n", "                ),\n", "            )\n", "            if base_meta and not base_meta.abstract:\n", "                # Non-abstract child classes inherit some attributes from their\n", "                # non-abstract parent (unless an ABC comes before it in the\n", "                # method resolution order).\n", "                if not hasattr(meta, \"ordering\"):\n", "                    new_class._meta.ordering = base_meta.ordering\n", "                if not hasattr(meta, \"get_latest_by\"):\n", "                    new_class._meta.get_latest_by = base_meta.get_latest_by\n", "\n", "        is_proxy = new_class._meta.proxy\n", "\n", "        # If the model is a proxy, ensure that the base class\n", "        # hasn't been swapped out.\n", "        if is_proxy and base_meta and base_meta.swapped:\n", "            raise TypeError(\n", "                \"%s cannot proxy the swapped model '%s'.\" % (name, base_meta.swapped)\n", "            )\n", "\n", "        # Add remaining attributes (those with a contribute_to_class() method)\n", "        # to the class.\n", "        for obj_name, obj in contributable_attrs.items():\n", "            new_class.add_to_class(obj_name, obj)\n", "\n", "        # All the fields of any type declared on this model\n", "        new_fields = chain(\n", "            new_class._meta.local_fields,\n", "            new_class._meta.local_many_to_many,\n", "            new_class._meta.private_fields,\n", "        )\n", "        field_names = {f.name for f in new_fields}\n", "\n", "        # Basic setup for proxy models.\n", "        if is_proxy:\n", "            base = None\n", "            for parent in [kls for kls in parents if hasattr(kls, \"_meta\")]:\n", "                if parent._meta.abstract:\n", "                    if parent._meta.fields:\n", "                        raise TypeError(\n", "                            \"Abstract base class containing model fields not \"\n", "                            \"permitted for proxy model '%s'.\" % name\n", "                        )\n", "                    else:\n", "                        continue\n", "                if base is None:\n", "                    base = parent\n", "                elif parent._meta.concrete_model is not base._meta.concrete_model:\n", "                    raise TypeError(\n", "                        \"Proxy model '%s' has more than one non-abstract model base \"\n", "                        \"class.\" % name\n", "                    )\n", "            if base is None:\n", "                raise TypeError(\n", "                    \"Proxy model '%s' has no non-abstract model base class.\" % name\n", "                )\n", "            new_class._meta.setup_proxy(base)\n", "            new_class._meta.concrete_model = base._meta.concrete_model\n", "        else:\n", "            new_class._meta.concrete_model = new_class\n", "\n", "        # Collect the parent links for multi-table inheritance.\n", "        parent_links = {}\n", "        for base in reversed([new_class] + parents):\n", "            # Conceptually equivalent to `if base is Model`.\n", "            if not hasattr(base, \"_meta\"):\n", "                continue\n", "            # Skip concrete parent classes.\n", "            if base != new_class and not base._meta.abstract:\n", "                continue\n", "            # Locate OneToOneField instances.\n", "            for field in base._meta.local_fields:\n", "                if isinstance(field, OneToOneField) and field.remote_field.parent_link:\n", "                    related = resolve_relation(new_class, field.remote_field.model)\n", "                    parent_links[make_model_tuple(related)] = field\n", "\n", "        # Track fields inherited from base models.\n", "        inherited_attributes = set()\n", "        # Do the appropriate setup for any model parents.\n", "        for base in new_class.mro():\n", "            if base not in parents or not hasattr(base, \"_meta\"):\n", "                # Things without _meta aren't functional models, so they're\n", "                # uninteresting parents.\n", "                inherited_attributes.update(base.__dict__)\n", "                continue\n", "\n", "            parent_fields = base._meta.local_fields + base._meta.local_many_to_many\n", "            if not base._meta.abstract:\n", "                # Check for clashes between locally declared fields and those\n", "                # on the base classes.\n", "                for field in parent_fields:\n", "                    if field.name in field_names:\n", "                        raise FieldError(\n", "                            \"Local field %r in class %r clashes with field of \"\n", "                            \"the same name from base class %r.\"\n", "                            % (\n", "                                field.name,\n", "                                name,\n", "                                base.__name__,\n", "                            )\n", "                        )\n", "                    else:\n", "                        inherited_attributes.add(field.name)\n", "\n", "                # Concrete classes...\n", "                base = base._meta.concrete_model\n", "                base_key = make_model_tuple(base)\n", "                if base_key in parent_links:\n", "                    field = parent_links[base_key]\n", "                elif not is_proxy:\n", "                    attr_name = \"%s_ptr\" % base._meta.model_name\n", "                    field = OneToOneField(\n", "                        base,\n", "                        on_delete=CASCADE,\n", "                        name=attr_name,\n", "                        auto_created=True,\n", "                        parent_link=True,\n", "                    )\n", "\n", "                    if attr_name in field_names:\n", "                        raise FieldError(\n", "                            \"Auto-generated field '%s' in class %r for \"\n", "                            \"parent_link to base class %r clashes with \"\n", "                            \"declared field of the same name.\"\n", "                            % (\n", "                                attr_name,\n", "                                name,\n", "                                base.__name__,\n", "                            )\n", "                        )\n", "\n", "                    # Only add the ptr field if it's not already present;\n", "                    # e.g. migrations will already have it specified\n", "                    if not hasattr(new_class, attr_name):\n", "                        new_class.add_to_class(attr_name, field)\n", "                else:\n", "                    field = None\n", "                new_class._meta.parents[base] = field\n", "            else:\n", "                base_parents = base._meta.parents.copy()\n", "\n", "                # Add fields from abstract base class if it wasn't overridden.\n", "                for field in parent_fields:\n", "                    if (\n", "                        field.name not in field_names\n", "                        and field.name not in new_class.__dict__\n", "                        and field.name not in inherited_attributes\n", "                    ):\n", "                        new_field = copy.deepcopy(field)\n", "                        new_class.add_to_class(field.name, new_field)\n", "                        # Replace parent links defined on this base by the new\n", "                        # field. It will be appropriately resolved if required.\n", "                        if field.one_to_one:\n", "                            for parent, parent_link in base_parents.items():\n", "                                if field == parent_link:\n", "                                    base_parents[parent] = new_field\n", "\n", "                # Pass any non-abstract parent classes onto child.\n", "                new_class._meta.parents.update(base_parents)\n", "\n", "            # Inherit private fields (like GenericForeignKey) from the parent\n", "            # class\n", "            for field in base._meta.private_fields:\n", "                if field.name in field_names:\n", "                    if not base._meta.abstract:\n", "                        raise FieldError(\n", "                            \"Local field %r in class %r clashes with field of \"\n", "                            \"the same name from base class %r.\"\n", "                            % (\n", "                                field.name,\n", "                                name,\n", "                                base.__name__,\n", "                            )\n", "                        )\n", "                else:\n", "                    field = copy.deepcopy(field)\n", "                    if not base._meta.abstract:\n", "                        field.mti_inherited = True\n", "                    new_class.add_to_class(field.name, field)\n", "\n", "        # Copy indexes so that index names are unique when models extend an\n", "        # abstract model.\n", "        new_class._meta.indexes = [\n", "            copy.deepcopy(idx) for idx in new_class._meta.indexes\n", "        ]\n", "\n", "        if abstract:\n", "            # Abstract base models can't be instantiated and don't appear in\n", "            # the list of models for an app. We do the final setup for them a\n", "            # little differently from normal models.\n", "            attr_meta.abstract = False\n", "            new_class.Meta = attr_meta\n", "            return new_class\n", "\n", "        new_class._prepare()\n", "        new_class._meta.apps.register_model(new_class._meta.app_label, new_class)\n", "        return new_class\n"]}]}, {"file_path": "django/db/models/query.py", "span_ids": ["QuerySet", "QuerySet.select_related", "RelatedPopulator.populate", "QuerySet.only", "RelatedPopulator"], "content": [{"span_id": "QuerySet", "start_line": 287, "end_line": 288, "content": ["class QuerySet:\n", "    \"\"\"Represent a lazy database lookup for a set of objects.\"\"\"\n"]}, {"span_id": "QuerySet.select_related", "start_line": 1529, "end_line": 1551, "content": ["    def select_related(self, *fields):\n", "        \"\"\"\n", "        Return a new QuerySet instance that will select related objects.\n", "\n", "        If fields are specified, they must be ForeignKey fields and only those\n", "        related objects are included in the selection.\n", "\n", "        If select_related(None) is called, clear the list.\n", "        \"\"\"\n", "        self._not_support_combined_queries(\"select_related\")\n", "        if self._fields is not None:\n", "            raise TypeError(\n", "                \"Cannot call select_related() after .values() or .values_list()\"\n", "            )\n", "\n", "        obj = self._chain()\n", "        if fields == (None,):\n", "            obj.query.select_related = False\n", "        elif fields:\n", "            obj.query.add_select_related(fields)\n", "        else:\n", "            obj.query.select_related = True\n", "        return obj\n"]}, {"span_id": "RelatedPopulator.populate", "start_line": 2604, "end_line": 2617, "content": ["    def populate(self, row, from_obj):\n", "        if self.reorder_for_init:\n", "            obj_data = self.reorder_for_init(row)\n", "        else:\n", "            obj_data = row[self.cols_start : self.cols_end]\n", "        if obj_data[self.pk_idx] is None:\n", "            obj = None\n", "        else:\n", "            obj = self.model_cls.from_db(self.db, self.init_list, obj_data)\n", "            for rel_iter in self.related_populators:\n", "                rel_iter.populate(row, obj)\n", "        self.local_setter(from_obj, obj)\n", "        if obj is not None:\n", "            self.remote_setter(obj, from_obj)\n"]}, {"span_id": "QuerySet.only", "start_line": 1712, "end_line": 1731, "content": ["    def only(self, *fields):\n", "        \"\"\"\n", "        Essentially, the opposite of defer(). Only the fields passed into this\n", "        method and that are not already specified as deferred are loaded\n", "        immediately when the queryset is evaluated.\n", "        \"\"\"\n", "        self._not_support_combined_queries(\"only\")\n", "        if self._fields is not None:\n", "            raise TypeError(\"Cannot call only() after .values() or .values_list()\")\n", "        if fields == (None,):\n", "            # Can only pass None to defer(), not only(), as the rest option.\n", "            # That won't stop people trying to do this, so let's be explicit.\n", "            raise TypeError(\"Cannot pass None as an argument to only().\")\n", "        for field in fields:\n", "            field = field.split(LOOKUP_SEP, 1)[0]\n", "            if field in self.query._filtered_relations:\n", "                raise ValueError(\"only() is not supported with FilteredRelation.\")\n", "        clone = self._chain()\n", "        clone.query.add_immediate_loading(fields)\n", "        return clone\n"]}, {"span_id": "RelatedPopulator", "start_line": 2534, "end_line": 2548, "content": ["class RelatedPopulator:\n", "    \"\"\"\n", "    RelatedPopulator is used for select_related() object instantiation.\n", "\n", "    The idea is that each select_related() model will be populated by a\n", "    different RelatedPopulator instance. The RelatedPopulator instances get\n", "    klass_info and select (computed in SQLCompiler) plus the used db as\n", "    input for initialization. That data is used to compute which columns\n", "    to use, how to instantiate the model, and how to populate the links\n", "    between the objects.\n", "\n", "    The actual creation of the objects is done in populate() method. This\n", "    method gets row and from_obj as input and populates the select_related()\n", "    model instance.\n", "    \"\"\"\n"]}]}, {"file_path": "django/db/models/sql/compiler.py", "span_ids": ["SQLCompiler", "SQLCompiler.get_related_selections"], "content": [{"span_id": "SQLCompiler", "start_line": 28, "end_line": 33, "content": ["class SQLCompiler:\n", "    # Multiline ordering SQL clause may appear from RawSQL.\n", "    ordering_parts = _lazy_re_compile(\n", "        r\"^(.*)\\s(?:ASC|DESC).*\",\n", "        re.MULTILINE | re.DOTALL,\n", "    )\n"]}, {"span_id": "SQLCompiler.get_related_selections", "start_line": 989, "end_line": 1198, "content": ["    def get_related_selections(\n", "        self,\n", "        select,\n", "        opts=None,\n", "        root_alias=None,\n", "        cur_depth=1,\n", "        requested=None,\n", "        restricted=None,\n", "    ):\n", "        \"\"\"\n", "        Fill in the information needed for a select_related query. The current\n", "        depth is measured as the number of connections away from the root model\n", "        (for example, cur_depth=1 means we are looking at models with direct\n", "        connections to the root model).\n", "        \"\"\"\n", "\n", "        def _get_field_choices():\n", "            direct_choices = (f.name for f in opts.fields if f.is_relation)\n", "            reverse_choices = (\n", "                f.field.related_query_name()\n", "                for f in opts.related_objects\n", "                if f.field.unique\n", "            )\n", "            return chain(\n", "                direct_choices, reverse_choices, self.query._filtered_relations\n", "            )\n", "\n", "        related_klass_infos = []\n", "        if not restricted and cur_depth > self.query.max_depth:\n", "            # We've recursed far enough; bail out.\n", "            return related_klass_infos\n", "\n", "        if not opts:\n", "            opts = self.query.get_meta()\n", "            root_alias = self.query.get_initial_alias()\n", "        only_load = self.deferred_to_columns()\n", "\n", "        # Setup for the case when only particular related fields should be\n", "        # included in the related selection.\n", "        fields_found = set()\n", "        if requested is None:\n", "            restricted = isinstance(self.query.select_related, dict)\n", "            if restricted:\n", "                requested = self.query.select_related\n", "\n", "        def get_related_klass_infos(klass_info, related_klass_infos):\n", "            klass_info[\"related_klass_infos\"] = related_klass_infos\n", "\n", "        for f in opts.fields:\n", "            field_model = f.model._meta.concrete_model\n", "            fields_found.add(f.name)\n", "\n", "            if restricted:\n", "                next = requested.get(f.name, {})\n", "                if not f.is_relation:\n", "                    # If a non-related field is used like a relation,\n", "                    # or if a single non-relational field is given.\n", "                    if next or f.name in requested:\n", "                        raise FieldError(\n", "                            \"Non-relational field given in select_related: '%s'. \"\n", "                            \"Choices are: %s\"\n", "                            % (\n", "                                f.name,\n", "                                \", \".join(_get_field_choices()) or \"(none)\",\n", "                            )\n", "                        )\n", "            else:\n", "                next = False\n", "\n", "            if not select_related_descend(\n", "                f, restricted, requested, only_load.get(field_model)\n", "            ):\n", "                continue\n", "            klass_info = {\n", "                \"model\": f.remote_field.model,\n", "                \"field\": f,\n", "                \"reverse\": False,\n", "                \"local_setter\": f.set_cached_value,\n", "                \"remote_setter\": f.remote_field.set_cached_value\n", "                if f.unique\n", "                else lambda x, y: None,\n", "                \"from_parent\": False,\n", "            }\n", "            related_klass_infos.append(klass_info)\n", "            select_fields = []\n", "            _, _, _, joins, _, _ = self.query.setup_joins([f.name], opts, root_alias)\n", "            alias = joins[-1]\n", "            columns = self.get_default_columns(\n", "                start_alias=alias, opts=f.remote_field.model._meta\n", "            )\n", "            for col in columns:\n", "                select_fields.append(len(select))\n", "                select.append((col, None))\n", "            klass_info[\"select_fields\"] = select_fields\n", "            next_klass_infos = self.get_related_selections(\n", "                select,\n", "                f.remote_field.model._meta,\n", "                alias,\n", "                cur_depth + 1,\n", "                next,\n", "                restricted,\n", "            )\n", "            get_related_klass_infos(klass_info, next_klass_infos)\n", "\n", "        if restricted:\n", "            related_fields = [\n", "                (o.field, o.related_model)\n", "                for o in opts.related_objects\n", "                if o.field.unique and not o.many_to_many\n", "            ]\n", "            for f, model in related_fields:\n", "                if not select_related_descend(\n", "                    f, restricted, requested, only_load.get(model), reverse=True\n", "                ):\n", "                    continue\n", "\n", "                related_field_name = f.related_query_name()\n", "                fields_found.add(related_field_name)\n", "\n", "                join_info = self.query.setup_joins(\n", "                    [related_field_name], opts, root_alias\n", "                )\n", "                alias = join_info.joins[-1]\n", "                from_parent = issubclass(model, opts.model) and model is not opts.model\n", "                klass_info = {\n", "                    \"model\": model,\n", "                    \"field\": f,\n", "                    \"reverse\": True,\n", "                    \"local_setter\": f.remote_field.set_cached_value,\n", "                    \"remote_setter\": f.set_cached_value,\n", "                    \"from_parent\": from_parent,\n", "                }\n", "                related_klass_infos.append(klass_info)\n", "                select_fields = []\n", "                columns = self.get_default_columns(\n", "                    start_alias=alias, opts=model._meta, from_parent=opts.model\n", "                )\n", "                for col in columns:\n", "                    select_fields.append(len(select))\n", "                    select.append((col, None))\n", "                klass_info[\"select_fields\"] = select_fields\n", "                next = requested.get(f.related_query_name(), {})\n", "                next_klass_infos = self.get_related_selections(\n", "                    select, model._meta, alias, cur_depth + 1, next, restricted\n", "                )\n", "                get_related_klass_infos(klass_info, next_klass_infos)\n", "\n", "            def local_setter(obj, from_obj):\n", "                # Set a reverse fk object when relation is non-empty.\n", "                if from_obj:\n", "                    f.remote_field.set_cached_value(from_obj, obj)\n", "\n", "            def remote_setter(name, obj, from_obj):\n", "                setattr(from_obj, name, obj)\n", "\n", "            for name in list(requested):\n", "                # Filtered relations work only on the topmost level.\n", "                if cur_depth > 1:\n", "                    break\n", "                if name in self.query._filtered_relations:\n", "                    fields_found.add(name)\n", "                    f, _, join_opts, joins, _, _ = self.query.setup_joins(\n", "                        [name], opts, root_alias\n", "                    )\n", "                    model = join_opts.model\n", "                    alias = joins[-1]\n", "                    from_parent = (\n", "                        issubclass(model, opts.model) and model is not opts.model\n", "                    )\n", "                    klass_info = {\n", "                        \"model\": model,\n", "                        \"field\": f,\n", "                        \"reverse\": True,\n", "                        \"local_setter\": local_setter,\n", "                        \"remote_setter\": partial(remote_setter, name),\n", "                        \"from_parent\": from_parent,\n", "                    }\n", "                    related_klass_infos.append(klass_info)\n", "                    select_fields = []\n", "                    columns = self.get_default_columns(\n", "                        start_alias=alias,\n", "                        opts=model._meta,\n", "                        from_parent=opts.model,\n", "                    )\n", "                    for col in columns:\n", "                        select_fields.append(len(select))\n", "                        select.append((col, None))\n", "                    klass_info[\"select_fields\"] = select_fields\n", "                    next_requested = requested.get(name, {})\n", "                    next_klass_infos = self.get_related_selections(\n", "                        select,\n", "                        opts=model._meta,\n", "                        root_alias=alias,\n", "                        cur_depth=cur_depth + 1,\n", "                        requested=next_requested,\n", "                        restricted=restricted,\n", "                    )\n", "                    get_related_klass_infos(klass_info, next_klass_infos)\n", "            fields_not_found = set(requested).difference(fields_found)\n", "            if fields_not_found:\n", "                invalid_fields = (\"'%s'\" % s for s in fields_not_found)\n", "                raise FieldError(\n", "                    \"Invalid field name(s) given in select_related: %s. \"\n", "                    \"Choices are: %s\"\n", "                    % (\n", "                        \", \".join(invalid_fields),\n", "                        \", \".join(_get_field_choices()) or \"(none)\",\n", "                    )\n", "                )\n", "        return related_klass_infos\n"]}]}, {"file_path": "django/db/models/sql/query.py", "span_ids": ["Query"], "content": [{"span_id": "Query", "start_line": 158, "end_line": 228, "content": ["class Query(BaseExpression):\n", "    \"\"\"A single SQL query.\"\"\"\n", "\n", "    alias_prefix = \"T\"\n", "    empty_result_set_value = None\n", "    subq_aliases = frozenset([alias_prefix])\n", "\n", "    compiler = \"SQLCompiler\"\n", "\n", "    base_table_class = BaseTable\n", "    join_class = Join\n", "\n", "    default_cols = True\n", "    default_ordering = True\n", "    standard_ordering = True\n", "\n", "    filter_is_sticky = False\n", "    subquery = False\n", "\n", "    # SQL-related attributes.\n", "    # Select and related select clauses are expressions to use in the SELECT\n", "    # clause of the query. The select is used for cases where we want to set up\n", "    # the select clause to contain other than default fields (values(),\n", "    # subqueries...). Note that annotations go to annotations dictionary.\n", "    select = ()\n", "    # The group_by attribute can have one of the following forms:\n", "    #  - None: no group by at all in the query\n", "    #  - A tuple of expressions: group by (at least) those expressions.\n", "    #    String refs are also allowed for now.\n", "    #  - True: group by all select fields of the model\n", "    # See compiler.get_group_by() for details.\n", "    group_by = None\n", "    order_by = ()\n", "    low_mark = 0  # Used for offset/limit.\n", "    high_mark = None  # Used for offset/limit.\n", "    distinct = False\n", "    distinct_fields = ()\n", "    select_for_update = False\n", "    select_for_update_nowait = False\n", "    select_for_update_skip_locked = False\n", "    select_for_update_of = ()\n", "    select_for_no_key_update = False\n", "    select_related = False\n", "    # Arbitrary limit for select_related to prevents infinite recursion.\n", "    max_depth = 5\n", "    # Holds the selects defined by a call to values() or values_list()\n", "    # excluding annotation_select and extra_select.\n", "    values_select = ()\n", "\n", "    # SQL annotation-related attributes.\n", "    annotation_select_mask = None\n", "    _annotation_select_cache = None\n", "\n", "    # Set combination attributes.\n", "    combinator = None\n", "    combinator_all = False\n", "    combined_queries = ()\n", "\n", "    # These are for extensions. The contents are more or less appended verbatim\n", "    # to the appropriate clause.\n", "    extra_select_mask = None\n", "    _extra_select_cache = None\n", "\n", "    extra_tables = ()\n", "    extra_order_by = ()\n", "\n", "    # A tuple that is a set of model field names and either True, if these are\n", "    # the fields to defer, or False if these are the only fields to load.\n", "    deferred_loading = (frozenset(), True)\n", "\n", "    explain_info = None\n"]}]}]}