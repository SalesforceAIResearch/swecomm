{"instance_id": "sympy__sympy-22840", "identified_spans": [{"file_path": "sympy/matrices/expressions/matexpr.py", "span_ids": ["MatrixSymbol"], "content": [{"span_id": "MatrixSymbol", "start_line": 646, "end_line": 665, "content": ["class MatrixSymbol(MatrixExpr):\n", "    \"\"\"Symbolic representation of a Matrix object\n", "\n", "    Creates a SymPy Symbol to represent a Matrix. This matrix has a shape and\n", "    can be included in Matrix Expressions\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import MatrixSymbol, Identity\n", "    >>> A = MatrixSymbol('A', 3, 4) # A 3 by 4 Matrix\n", "    >>> B = MatrixSymbol('B', 4, 3) # A 4 by 3 Matrix\n", "    >>> A.shape\n", "    (3, 4)\n", "    >>> 2*A*B + Identity(3)\n", "    I + 2*A*B\n", "    \"\"\"\n", "    is_commutative = False\n", "    is_symbol = True\n", "    _diff_wrt = True\n"]}]}, {"file_path": "sympy/simplify/cse_main.py", "span_ids": ["tree_cse", "cse"], "content": [{"span_id": "tree_cse", "start_line": 550, "end_line": 692, "content": ["def tree_cse(exprs, symbols, opt_subs=None, order='canonical', ignore=()):\n", "    \"\"\"Perform raw CSE on expression tree, taking opt_subs into account.\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    exprs : list of SymPy expressions\n", "        The expressions to reduce.\n", "    symbols : infinite iterator yielding unique Symbols\n", "        The symbols used to label the common subexpressions which are pulled\n", "        out.\n", "    opt_subs : dictionary of expression substitutions\n", "        The expressions to be substituted before any CSE action is performed.\n", "    order : string, 'none' or 'canonical'\n", "        The order by which Mul and Add arguments are processed. For large\n", "        expressions where speed is a concern, use the setting order='none'.\n", "    ignore : iterable of Symbols\n", "        Substitutions containing any Symbol from ``ignore`` will be ignored.\n", "    \"\"\"\n", "    from sympy.matrices.expressions import MatrixExpr, MatrixSymbol, MatMul, MatAdd\n", "    from sympy.polys.rootoftools import RootOf\n", "\n", "    if opt_subs is None:\n", "        opt_subs = dict()\n", "\n", "    ## Find repeated sub-expressions\n", "\n", "    to_eliminate = set()\n", "\n", "    seen_subexp = set()\n", "    excluded_symbols = set()\n", "\n", "    def _find_repeated(expr):\n", "        if not isinstance(expr, (Basic, Unevaluated)):\n", "            return\n", "\n", "        if isinstance(expr, RootOf):\n", "            return\n", "\n", "        if isinstance(expr, Basic) and (expr.is_Atom or expr.is_Order):\n", "            if expr.is_Symbol:\n", "                excluded_symbols.add(expr)\n", "            return\n", "\n", "        if iterable(expr):\n", "            args = expr\n", "\n", "        else:\n", "            if expr in seen_subexp:\n", "                for ign in ignore:\n", "                    if ign in expr.free_symbols:\n", "                        break\n", "                else:\n", "                    to_eliminate.add(expr)\n", "                    return\n", "\n", "            seen_subexp.add(expr)\n", "\n", "            if expr in opt_subs:\n", "                expr = opt_subs[expr]\n", "\n", "            args = expr.args\n", "\n", "        list(map(_find_repeated, args))\n", "\n", "    for e in exprs:\n", "        if isinstance(e, Basic):\n", "            _find_repeated(e)\n", "\n", "    ## Rebuild tree\n", "\n", "    # Remove symbols from the generator that conflict with names in the expressions.\n", "    symbols = (symbol for symbol in symbols if symbol not in excluded_symbols)\n", "\n", "    replacements = []\n", "\n", "    subs = dict()\n", "\n", "    def _rebuild(expr):\n", "        if not isinstance(expr, (Basic, Unevaluated)):\n", "            return expr\n", "\n", "        if not expr.args:\n", "            return expr\n", "\n", "        if iterable(expr):\n", "            new_args = [_rebuild(arg) for arg in expr]\n", "            return expr.func(*new_args)\n", "\n", "        if expr in subs:\n", "            return subs[expr]\n", "\n", "        orig_expr = expr\n", "        if expr in opt_subs:\n", "            expr = opt_subs[expr]\n", "\n", "        # If enabled, parse Muls and Adds arguments by order to ensure\n", "        # replacement order independent from hashes\n", "        if order != 'none':\n", "            if isinstance(expr, (Mul, MatMul)):\n", "                c, nc = expr.args_cnc()\n", "                if c == [1]:\n", "                    args = nc\n", "                else:\n", "                    args = list(ordered(c)) + nc\n", "            elif isinstance(expr, (Add, MatAdd)):\n", "                args = list(ordered(expr.args))\n", "            else:\n", "                args = expr.args\n", "        else:\n", "            args = expr.args\n", "\n", "        new_args = list(map(_rebuild, args))\n", "        if isinstance(expr, Unevaluated) or new_args != args:\n", "            new_expr = expr.func(*new_args)\n", "        else:\n", "            new_expr = expr\n", "\n", "        if orig_expr in to_eliminate:\n", "            try:\n", "                sym = next(symbols)\n", "            except StopIteration:\n", "                raise ValueError(\"Symbols iterator ran out of symbols.\")\n", "\n", "            if isinstance(orig_expr, MatrixExpr):\n", "                sym = MatrixSymbol(sym.name, orig_expr.rows,\n", "                    orig_expr.cols)\n", "\n", "            subs[orig_expr] = sym\n", "            replacements.append((sym, new_expr))\n", "            return sym\n", "\n", "        else:\n", "            return new_expr\n", "\n", "    reduced_exprs = []\n", "    for e in exprs:\n", "        if isinstance(e, Basic):\n", "            reduced_e = _rebuild(e)\n", "        else:\n", "            reduced_e = e\n", "        reduced_exprs.append(reduced_e)\n", "    return replacements, reduced_exprs\n"]}, {"span_id": "cse", "start_line": 695, "end_line": 849, "content": ["def cse(exprs, symbols=None, optimizations=None, postprocess=None,\n", "        order='canonical', ignore=(), list=True):\n", "    \"\"\" Perform common subexpression elimination on an expression.\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    exprs : list of SymPy expressions, or a single SymPy expression\n", "        The expressions to reduce.\n", "    symbols : infinite iterator yielding unique Symbols\n", "        The symbols used to label the common subexpressions which are pulled\n", "        out. The ``numbered_symbols`` generator is useful. The default is a\n", "        stream of symbols of the form \"x0\", \"x1\", etc. This must be an\n", "        infinite iterator.\n", "    optimizations : list of (callable, callable) pairs\n", "        The (preprocessor, postprocessor) pairs of external optimization\n", "        functions. Optionally 'basic' can be passed for a set of predefined\n", "        basic optimizations. Such 'basic' optimizations were used by default\n", "        in old implementation, however they can be really slow on larger\n", "        expressions. Now, no pre or post optimizations are made by default.\n", "    postprocess : a function which accepts the two return values of cse and\n", "        returns the desired form of output from cse, e.g. if you want the\n", "        replacements reversed the function might be the following lambda:\n", "        lambda r, e: return reversed(r), e\n", "    order : string, 'none' or 'canonical'\n", "        The order by which Mul and Add arguments are processed. If set to\n", "        'canonical', arguments will be canonically ordered. If set to 'none',\n", "        ordering will be faster but dependent on expressions hashes, thus\n", "        machine dependent and variable. For large expressions where speed is a\n", "        concern, use the setting order='none'.\n", "    ignore : iterable of Symbols\n", "        Substitutions containing any Symbol from ``ignore`` will be ignored.\n", "    list : bool, (default True)\n", "        Returns expression in list or else with same type as input (when False).\n", "\n", "    Returns\n", "    =======\n", "\n", "    replacements : list of (Symbol, expression) pairs\n", "        All of the common subexpressions that were replaced. Subexpressions\n", "        earlier in this list might show up in subexpressions later in this\n", "        list.\n", "    reduced_exprs : list of SymPy expressions\n", "        The reduced expressions with all of the replacements above.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import cse, SparseMatrix\n", "    >>> from sympy.abc import x, y, z, w\n", "    >>> cse(((w + x + y + z)*(w + y + z))/(w + x)**3)\n", "    ([(x0, y + z), (x1, w + x)], [(w + x0)*(x0 + x1)/x1**3])\n", "\n", "\n", "    List of expressions with recursive substitutions:\n", "\n", "    >>> m = SparseMatrix([x + y, x + y + z])\n", "    >>> cse([(x+y)**2, x + y + z, y + z, x + z + y, m])\n", "    ([(x0, x + y), (x1, x0 + z)], [x0**2, x1, y + z, x1, Matrix([\n", "    [x0],\n", "    [x1]])])\n", "\n", "    Note: the type and mutability of input matrices is retained.\n", "\n", "    >>> isinstance(_[1][-1], SparseMatrix)\n", "    True\n", "\n", "    The user may disallow substitutions containing certain symbols:\n", "\n", "    >>> cse([y**2*(x + 1), 3*y**2*(x + 1)], ignore=(y,))\n", "    ([(x0, x + 1)], [x0*y**2, 3*x0*y**2])\n", "\n", "    The default return value for the reduced expression(s) is a list, even if there is only\n", "    one expression. The `list` flag preserves the type of the input in the output:\n", "\n", "    >>> cse(x)\n", "    ([], [x])\n", "    >>> cse(x, list=False)\n", "    ([], x)\n", "    \"\"\"\n", "    from sympy.matrices import (MatrixBase, Matrix, ImmutableMatrix,\n", "                                SparseMatrix, ImmutableSparseMatrix)\n", "\n", "    if not list:\n", "        return _cse_homogeneous(exprs,\n", "            symbols=symbols, optimizations=optimizations,\n", "            postprocess=postprocess, order=order, ignore=ignore)\n", "\n", "    if isinstance(exprs, (int, float)):\n", "        exprs = sympify(exprs)\n", "\n", "    # Handle the case if just one expression was passed.\n", "    if isinstance(exprs, (Basic, MatrixBase)):\n", "        exprs = [exprs]\n", "\n", "    copy = exprs\n", "    temp = []\n", "    for e in exprs:\n", "        if isinstance(e, (Matrix, ImmutableMatrix)):\n", "            temp.append(Tuple(*e.flat()))\n", "        elif isinstance(e, (SparseMatrix, ImmutableSparseMatrix)):\n", "            temp.append(Tuple(*e.todok().items()))\n", "        else:\n", "            temp.append(e)\n", "    exprs = temp\n", "    del temp\n", "\n", "    if optimizations is None:\n", "        optimizations = []\n", "    elif optimizations == 'basic':\n", "        optimizations = basic_optimizations\n", "\n", "    # Preprocess the expressions to give us better optimization opportunities.\n", "    reduced_exprs = [preprocess_for_cse(e, optimizations) for e in exprs]\n", "\n", "    if symbols is None:\n", "        symbols = numbered_symbols(cls=Symbol)\n", "    else:\n", "        # In case we get passed an iterable with an __iter__ method instead of\n", "        # an actual iterator.\n", "        symbols = iter(symbols)\n", "\n", "    # Find other optimization opportunities.\n", "    opt_subs = opt_cse(reduced_exprs, order)\n", "\n", "    # Main CSE algorithm.\n", "    replacements, reduced_exprs = tree_cse(reduced_exprs, symbols, opt_subs,\n", "                                           order, ignore)\n", "\n", "    # Postprocess the expressions to return the expressions to canonical form.\n", "    exprs = copy\n", "    for i, (sym, subtree) in enumerate(replacements):\n", "        subtree = postprocess_for_cse(subtree, optimizations)\n", "        replacements[i] = (sym, subtree)\n", "    reduced_exprs = [postprocess_for_cse(e, optimizations)\n", "                     for e in reduced_exprs]\n", "\n", "    # Get the matrices back\n", "    for i, e in enumerate(exprs):\n", "        if isinstance(e, (Matrix, ImmutableMatrix)):\n", "            reduced_exprs[i] = Matrix(e.rows, e.cols, reduced_exprs[i])\n", "            if isinstance(e, ImmutableMatrix):\n", "                reduced_exprs[i] = reduced_exprs[i].as_immutable()\n", "        elif isinstance(e, (SparseMatrix, ImmutableSparseMatrix)):\n", "            m = SparseMatrix(e.rows, e.cols, {})\n", "            for k, v in reduced_exprs[i]:\n", "                m[k] = v\n", "            if isinstance(e, ImmutableSparseMatrix):\n", "                m = m.as_immutable()\n", "            reduced_exprs[i] = m\n", "\n", "    if postprocess is None:\n", "        return replacements, reduced_exprs\n", "\n", "    return postprocess(replacements, reduced_exprs)\n"]}]}]}