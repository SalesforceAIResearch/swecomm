{"instance_id": "matplotlib__matplotlib-23913", "identified_spans": [{"file_path": "lib/matplotlib/legend.py", "span_ids": ["Legend.set_draggable", "DraggableLegend", "Legend.__init__"], "content": [{"span_id": "Legend.set_draggable", "start_line": 1079, "end_line": 1111, "content": ["    def set_draggable(self, state, use_blit=False, update='loc'):\n", "        \"\"\"\n", "        Enable or disable mouse dragging support of the legend.\n", "\n", "        Parameters\n", "        ----------\n", "        state : bool\n", "            Whether mouse dragging is enabled.\n", "        use_blit : bool, optional\n", "            Use blitting for faster image composition. For details see\n", "            :ref:`func-animation`.\n", "        update : {'loc', 'bbox'}, optional\n", "            The legend parameter to be changed when dragged:\n", "\n", "            - 'loc': update the *loc* parameter of the legend\n", "            - 'bbox': update the *bbox_to_anchor* parameter of the legend\n", "\n", "        Returns\n", "        -------\n", "        `.DraggableLegend` or *None*\n", "            If *state* is ``True`` this returns the `.DraggableLegend` helper\n", "            instance. Otherwise this returns *None*.\n", "        \"\"\"\n", "        if state:\n", "            if self._draggable is None:\n", "                self._draggable = DraggableLegend(self,\n", "                                                  use_blit,\n", "                                                  update=update)\n", "        else:\n", "            if self._draggable is not None:\n", "                self._draggable.disconnect()\n", "            self._draggable = None\n", "        return self._draggable\n"]}, {"span_id": "DraggableLegend", "start_line": 53, "end_line": 53, "content": ["class DraggableLegend(DraggableOffsetBox):\n"]}, {"span_id": "Legend.__init__", "start_line": 304, "end_line": 575, "content": ["    @_api.make_keyword_only(\"3.6\", \"loc\")\n", "    @_docstring.dedent_interpd\n", "    def __init__(\n", "        self, parent, handles, labels,\n", "        loc=None,\n", "        numpoints=None,      # number of points in the legend line\n", "        markerscale=None,    # relative size of legend markers vs. original\n", "        markerfirst=True,    # left/right ordering of legend marker and label\n", "        scatterpoints=None,  # number of scatter points\n", "        scatteryoffsets=None,\n", "        prop=None,           # properties for the legend texts\n", "        fontsize=None,       # keyword to set font size directly\n", "        labelcolor=None,     # keyword to set the text color\n", "\n", "        # spacing & pad defined as a fraction of the font-size\n", "        borderpad=None,      # whitespace inside the legend border\n", "        labelspacing=None,   # vertical space between the legend entries\n", "        handlelength=None,   # length of the legend handles\n", "        handleheight=None,   # height of the legend handles\n", "        handletextpad=None,  # pad between the legend handle and text\n", "        borderaxespad=None,  # pad between the axes and legend border\n", "        columnspacing=None,  # spacing between columns\n", "\n", "        ncols=1,     # number of columns\n", "        mode=None,  # horizontal distribution of columns: None or \"expand\"\n", "\n", "        fancybox=None,  # True: fancy box, False: rounded box, None: rcParam\n", "        shadow=None,\n", "        title=None,           # legend title\n", "        title_fontsize=None,  # legend title font size\n", "        framealpha=None,      # set frame alpha\n", "        edgecolor=None,       # frame patch edgecolor\n", "        facecolor=None,       # frame patch facecolor\n", "\n", "        bbox_to_anchor=None,  # bbox to which the legend will be anchored\n", "        bbox_transform=None,  # transform for the bbox\n", "        frameon=None,         # draw frame\n", "        handler_map=None,\n", "        title_fontproperties=None,  # properties for the legend title\n", "        alignment=\"center\",       # control the alignment within the legend box\n", "        *,\n", "        ncol=1  # synonym for ncols (backward compatibility)\n", "    ):\n", "        \"\"\"\n", "        Parameters\n", "        ----------\n", "        parent : `~matplotlib.axes.Axes` or `.Figure`\n", "            The artist that contains the legend.\n", "\n", "        handles : list of `.Artist`\n", "            A list of Artists (lines, patches) to be added to the legend.\n", "\n", "        labels : list of str\n", "            A list of labels to show next to the artists. The length of handles\n", "            and labels should be the same. If they are not, they are truncated\n", "            to the smaller of both lengths.\n", "\n", "        Other Parameters\n", "        ----------------\n", "        %(_legend_kw_doc)s\n", "\n", "        Notes\n", "        -----\n", "        Users can specify any arbitrary location for the legend using the\n", "        *bbox_to_anchor* keyword argument. *bbox_to_anchor* can be a\n", "        `.BboxBase` (or derived there from) or a tuple of 2 or 4 floats.\n", "        See `set_bbox_to_anchor` for more detail.\n", "\n", "        The legend location can be specified by setting *loc* with a tuple of\n", "        2 floats, which is interpreted as the lower-left corner of the legend\n", "        in the normalized axes coordinate.\n", "        \"\"\"\n", "        # local import only to avoid circularity\n", "        from matplotlib.axes import Axes\n", "        from matplotlib.figure import FigureBase\n", "\n", "        super().__init__()\n", "\n", "        if prop is None:\n", "            if fontsize is not None:\n", "                self.prop = FontProperties(size=fontsize)\n", "            else:\n", "                self.prop = FontProperties(\n", "                    size=mpl.rcParams[\"legend.fontsize\"])\n", "        else:\n", "            self.prop = FontProperties._from_any(prop)\n", "            if isinstance(prop, dict) and \"size\" not in prop:\n", "                self.prop.set_size(mpl.rcParams[\"legend.fontsize\"])\n", "\n", "        self._fontsize = self.prop.get_size_in_points()\n", "\n", "        self.texts = []\n", "        self.legendHandles = []\n", "        self._legend_title_box = None\n", "\n", "        #: A dictionary with the extra handler mappings for this Legend\n", "        #: instance.\n", "        self._custom_handler_map = handler_map\n", "\n", "        def val_or_rc(val, rc_name):\n", "            return val if val is not None else mpl.rcParams[rc_name]\n", "\n", "        self.numpoints = val_or_rc(numpoints, 'legend.numpoints')\n", "        self.markerscale = val_or_rc(markerscale, 'legend.markerscale')\n", "        self.scatterpoints = val_or_rc(scatterpoints, 'legend.scatterpoints')\n", "        self.borderpad = val_or_rc(borderpad, 'legend.borderpad')\n", "        self.labelspacing = val_or_rc(labelspacing, 'legend.labelspacing')\n", "        self.handlelength = val_or_rc(handlelength, 'legend.handlelength')\n", "        self.handleheight = val_or_rc(handleheight, 'legend.handleheight')\n", "        self.handletextpad = val_or_rc(handletextpad, 'legend.handletextpad')\n", "        self.borderaxespad = val_or_rc(borderaxespad, 'legend.borderaxespad')\n", "        self.columnspacing = val_or_rc(columnspacing, 'legend.columnspacing')\n", "        self.shadow = val_or_rc(shadow, 'legend.shadow')\n", "        # trim handles and labels if illegal label...\n", "        _lab, _hand = [], []\n", "        for label, handle in zip(labels, handles):\n", "            if isinstance(label, str) and label.startswith('_'):\n", "                _api.warn_external(f\"The label {label!r} of {handle!r} starts \"\n", "                                   \"with '_'. It is thus excluded from the \"\n", "                                   \"legend.\")\n", "            else:\n", "                _lab.append(label)\n", "                _hand.append(handle)\n", "        labels, handles = _lab, _hand\n", "\n", "        handles = list(handles)\n", "        if len(handles) < 2:\n", "            ncols = 1\n", "        self._ncols = ncols if ncols != 1 else ncol\n", "\n", "        if self.numpoints <= 0:\n", "            raise ValueError(\"numpoints must be > 0; it was %d\" % numpoints)\n", "\n", "        # introduce y-offset for handles of the scatter plot\n", "        if scatteryoffsets is None:\n", "            self._scatteryoffsets = np.array([3. / 8., 4. / 8., 2.5 / 8.])\n", "        else:\n", "            self._scatteryoffsets = np.asarray(scatteryoffsets)\n", "        reps = self.scatterpoints // len(self._scatteryoffsets) + 1\n", "        self._scatteryoffsets = np.tile(self._scatteryoffsets,\n", "                                        reps)[:self.scatterpoints]\n", "\n", "        # _legend_box is a VPacker instance that contains all\n", "        # legend items and will be initialized from _init_legend_box()\n", "        # method.\n", "        self._legend_box = None\n", "\n", "        if isinstance(parent, Axes):\n", "            self.isaxes = True\n", "            self.axes = parent\n", "            self.set_figure(parent.figure)\n", "        elif isinstance(parent, FigureBase):\n", "            self.isaxes = False\n", "            self.set_figure(parent)\n", "        else:\n", "            raise TypeError(\n", "                \"Legend needs either Axes or FigureBase as parent\"\n", "            )\n", "        self.parent = parent\n", "\n", "        self._loc_used_default = loc is None\n", "        if loc is None:\n", "            loc = mpl.rcParams[\"legend.loc\"]\n", "            if not self.isaxes and loc in [0, 'best']:\n", "                loc = 'upper right'\n", "        if isinstance(loc, str):\n", "            loc = _api.check_getitem(self.codes, loc=loc)\n", "        if not self.isaxes and loc == 0:\n", "            raise ValueError(\n", "                \"Automatic legend placement (loc='best') not implemented for \"\n", "                \"figure legend\")\n", "\n", "        self._mode = mode\n", "        self.set_bbox_to_anchor(bbox_to_anchor, bbox_transform)\n", "\n", "        # We use FancyBboxPatch to draw a legend frame. The location\n", "        # and size of the box will be updated during the drawing time.\n", "\n", "        if facecolor is None:\n", "            facecolor = mpl.rcParams[\"legend.facecolor\"]\n", "        if facecolor == 'inherit':\n", "            facecolor = mpl.rcParams[\"axes.facecolor\"]\n", "\n", "        if edgecolor is None:\n", "            edgecolor = mpl.rcParams[\"legend.edgecolor\"]\n", "        if edgecolor == 'inherit':\n", "            edgecolor = mpl.rcParams[\"axes.edgecolor\"]\n", "\n", "        if fancybox is None:\n", "            fancybox = mpl.rcParams[\"legend.fancybox\"]\n", "\n", "        self.legendPatch = FancyBboxPatch(\n", "            xy=(0, 0), width=1, height=1,\n", "            facecolor=facecolor, edgecolor=edgecolor,\n", "            # If shadow is used, default to alpha=1 (#8943).\n", "            alpha=(framealpha if framealpha is not None\n", "                   else 1 if shadow\n", "                   else mpl.rcParams[\"legend.framealpha\"]),\n", "            # The width and height of the legendPatch will be set (in draw())\n", "            # to the length that includes the padding. Thus we set pad=0 here.\n", "            boxstyle=(\"round,pad=0,rounding_size=0.2\" if fancybox\n", "                      else \"square,pad=0\"),\n", "            mutation_scale=self._fontsize,\n", "            snap=True,\n", "            visible=(frameon if frameon is not None\n", "                     else mpl.rcParams[\"legend.frameon\"])\n", "        )\n", "        self._set_artist_props(self.legendPatch)\n", "\n", "        _api.check_in_list([\"center\", \"left\", \"right\"], alignment=alignment)\n", "        self._alignment = alignment\n", "\n", "        # init with null renderer\n", "        self._init_legend_box(handles, labels, markerfirst)\n", "\n", "        tmp = self._loc_used_default\n", "        self._set_loc(loc)\n", "        self._loc_used_default = tmp  # ignore changes done by _set_loc\n", "\n", "        # figure out title font properties:\n", "        if title_fontsize is not None and title_fontproperties is not None:\n", "            raise ValueError(\n", "                \"title_fontsize and title_fontproperties can't be specified \"\n", "                \"at the same time. Only use one of them. \")\n", "        title_prop_fp = FontProperties._from_any(title_fontproperties)\n", "        if isinstance(title_fontproperties, dict):\n", "            if \"size\" not in title_fontproperties:\n", "                title_fontsize = mpl.rcParams[\"legend.title_fontsize\"]\n", "                title_prop_fp.set_size(title_fontsize)\n", "        elif title_fontsize is not None:\n", "            title_prop_fp.set_size(title_fontsize)\n", "        elif not isinstance(title_fontproperties, FontProperties):\n", "            title_fontsize = mpl.rcParams[\"legend.title_fontsize\"]\n", "            title_prop_fp.set_size(title_fontsize)\n", "\n", "        self.set_title(title, prop=title_prop_fp)\n", "        self._draggable = None\n", "\n", "        # set the text color\n", "\n", "        color_getters = {  # getter function depends on line or patch\n", "            'linecolor':       ['get_color',           'get_facecolor'],\n", "            'markerfacecolor': ['get_markerfacecolor', 'get_facecolor'],\n", "            'mfc':             ['get_markerfacecolor', 'get_facecolor'],\n", "            'markeredgecolor': ['get_markeredgecolor', 'get_edgecolor'],\n", "            'mec':             ['get_markeredgecolor', 'get_edgecolor'],\n", "        }\n", "        if labelcolor is None:\n", "            if mpl.rcParams['legend.labelcolor'] is not None:\n", "                labelcolor = mpl.rcParams['legend.labelcolor']\n", "            else:\n", "                labelcolor = mpl.rcParams['text.color']\n", "        if isinstance(labelcolor, str) and labelcolor in color_getters:\n", "            getter_names = color_getters[labelcolor]\n", "            for handle, text in zip(self.legendHandles, self.texts):\n", "                for getter_name in getter_names:\n", "                    try:\n", "                        color = getattr(handle, getter_name)()\n", "                        text.set_color(color)\n", "                        break\n", "                    except AttributeError:\n", "                        pass\n", "        elif isinstance(labelcolor, str) and labelcolor == 'none':\n", "            for text in self.texts:\n", "                text.set_color(labelcolor)\n", "        elif np.iterable(labelcolor):\n", "            for text, color in zip(self.texts,\n", "                                   itertools.cycle(\n", "                                       colors.to_rgba_array(labelcolor))):\n", "                text.set_color(color)\n", "        else:\n", "            raise ValueError(f\"Invalid labelcolor: {labelcolor!r}\")\n"]}]}]}