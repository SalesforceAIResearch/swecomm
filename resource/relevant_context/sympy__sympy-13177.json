{"instance_id": "sympy__sympy-13177", "identified_spans": [{"file_path": "sympy/core/mod.py", "span_ids": ["Mod.eval"], "content": [{"span_id": "Mod.eval", "start_line": 26, "end_line": 141, "content": ["    @classmethod\n", "    def eval(cls, p, q):\n", "        from sympy.core.add import Add\n", "        from sympy.core.mul import Mul\n", "        from sympy.core.singleton import S\n", "        from sympy.core.exprtools import gcd_terms\n", "        from sympy.polys.polytools import gcd\n", "\n", "        def doit(p, q):\n", "            \"\"\"Try to return p % q if both are numbers or +/-p is known\n", "            to be less than or equal q.\n", "            \"\"\"\n", "\n", "            if p.is_infinite or q.is_infinite or p is nan or q is nan:\n", "                return nan\n", "            if (p == q or p == -q or\n", "                    p.is_Pow and p.exp.is_Integer and p.base == q or\n", "                    p.is_integer and q == 1):\n", "                return S.Zero\n", "\n", "            if q.is_Number:\n", "                if p.is_Number:\n", "                    return (p % q)\n", "                if q == 2:\n", "                    if p.is_even:\n", "                        return S.Zero\n", "                    elif p.is_odd:\n", "                        return S.One\n", "\n", "            # by ratio\n", "            r = p/q\n", "            try:\n", "                d = int(r)\n", "            except TypeError:\n", "                pass\n", "            else:\n", "                if type(d) is int:\n", "                    rv = p - d*q\n", "                    if (rv*q < 0) == True:\n", "                        rv += q\n", "                    return rv\n", "\n", "            # by difference\n", "            d = p - q\n", "            if d.is_negative:\n", "                if q.is_negative:\n", "                    return d\n", "                elif q.is_positive:\n", "                    return p\n", "\n", "        rv = doit(p, q)\n", "        if rv is not None:\n", "            return rv\n", "\n", "        # denest\n", "        if p.func is cls:\n", "            # easy\n", "            qinner = p.args[1]\n", "            if qinner == q:\n", "                return p\n", "            # XXX other possibilities?\n", "\n", "        # extract gcd; any further simplification should be done by the user\n", "        G = gcd(p, q)\n", "        if G != 1:\n", "            p, q = [\n", "                gcd_terms(i/G, clear=False, fraction=False) for i in (p, q)]\n", "        pwas, qwas = p, q\n", "\n", "        # simplify terms\n", "        # (x + y + 2) % x -> Mod(y + 2, x)\n", "        if p.is_Add:\n", "            args = []\n", "            for i in p.args:\n", "                a = cls(i, q)\n", "                if a.count(cls) > i.count(cls):\n", "                    args.append(i)\n", "                else:\n", "                    args.append(a)\n", "            if args != list(p.args):\n", "                p = Add(*args)\n", "\n", "        else:\n", "            # handle coefficients if they are not Rational\n", "            # since those are not handled by factor_terms\n", "            # e.g. Mod(.6*x, .3*y) -> 0.3*Mod(2*x, y)\n", "            cp, p = p.as_coeff_Mul()\n", "            cq, q = q.as_coeff_Mul()\n", "            ok = False\n", "            if not cp.is_Rational or not cq.is_Rational:\n", "                r = cp % cq\n", "                if r == 0:\n", "                    G *= cq\n", "                    p *= int(cp/cq)\n", "                    ok = True\n", "            if not ok:\n", "                p = cp*p\n", "                q = cq*q\n", "\n", "        # simple -1 extraction\n", "        if p.could_extract_minus_sign() and q.could_extract_minus_sign():\n", "            G, p, q = [-i for i in (G, p, q)]\n", "\n", "        # check again to see if p and q can now be handled as numbers\n", "        rv = doit(p, q)\n", "        if rv is not None:\n", "            return rv*G\n", "\n", "        # put 1.0 from G on inside\n", "        if G.is_Float and G == 1:\n", "            p *= G\n", "            return cls(p, q, evaluate=False)\n", "        elif G.is_Mul and G.args[0].is_Float and G.args[0] == 1:\n", "            p = G.args[0]*p\n", "            G = Mul._from_args(G.args[1:])\n", "        return G*cls(p, q, evaluate=(p, q) != (pwas, qwas))\n"]}]}]}