{"instance_id": "sympy__sympy-24066", "identified_spans": [{"file_path": "sympy/physics/units/systems/si.py", "span_ids": ["impl:7"], "content": [{"span_id": "impl:7", "start_line": 55, "end_line": 131, "content": ["all_units = []  # type: List[Quantity]\n", "for u in units:\n", "    all_units.extend(prefix_unit(u, PREFIXES))\n", "\n", "all_units.extend(units)\n", "all_units.extend([mol, cd, K, lux])\n", "\n", "\n", "dimsys_SI = dimsys_MKSA.extend(\n", "    [\n", "        # Dimensional dependencies for other base dimensions:\n", "        temperature,\n", "        amount_of_substance,\n", "        luminous_intensity,\n", "    ])\n", "\n", "dimsys_default = dimsys_SI.extend(\n", "    [information],\n", ")\n", "\n", "SI = MKSA.extend(base=(mol, cd, K), units=all_units, name='SI', dimension_system=dimsys_SI, derived_units={\n", "    power: watt,\n", "    magnetic_flux: weber,\n", "    time: second,\n", "    impedance: ohm,\n", "    pressure: pascal,\n", "    current: ampere,\n", "    voltage: volt,\n", "    length: meter,\n", "    frequency: hertz,\n", "    inductance: henry,\n", "    temperature: kelvin,\n", "    amount_of_substance: mole,\n", "    luminous_intensity: candela,\n", "    conductance: siemens,\n", "    mass: kilogram,\n", "    magnetic_density: tesla,\n", "    charge: coulomb,\n", "    force: newton,\n", "    capacitance: farad,\n", "    energy: joule,\n", "    velocity: meter/second,\n", "})\n", "\n", "One = S.One\n", "\n", "SI.set_quantity_dimension(radian, One)\n", "\n", "SI.set_quantity_scale_factor(ampere, One)\n", "\n", "SI.set_quantity_scale_factor(kelvin, One)\n", "\n", "SI.set_quantity_scale_factor(mole, One)\n", "\n", "SI.set_quantity_scale_factor(candela, One)\n", "\n", "# MKSA extension to MKS: derived units\n", "\n", "SI.set_quantity_scale_factor(coulomb, One)\n", "\n", "SI.set_quantity_scale_factor(volt, joule/coulomb)\n", "\n", "SI.set_quantity_scale_factor(ohm, volt/ampere)\n", "\n", "SI.set_quantity_scale_factor(siemens, ampere/volt)\n", "\n", "SI.set_quantity_scale_factor(farad, coulomb/volt)\n", "\n", "SI.set_quantity_scale_factor(henry, volt*second/ampere)\n", "\n", "SI.set_quantity_scale_factor(tesla, volt*second/meter**2)\n", "\n", "SI.set_quantity_scale_factor(weber, joule/ampere)\n", "\n", "\n", "SI.set_quantity_dimension(lux, luminous_intensity / length ** 2)\n", "SI.set_quantity_scale_factor(lux, steradian*candela/meter**2)\n"]}]}, {"file_path": "sympy/physics/units/unitsystem.py", "span_ids": ["UnitSystem._collect_factor_and_dimension"], "content": [{"span_id": "UnitSystem._collect_factor_and_dimension", "start_line": 152, "end_line": 200, "content": ["    def _collect_factor_and_dimension(self, expr):\n", "        \"\"\"\n", "        Return tuple with scale factor expression and dimension expression.\n", "        \"\"\"\n", "        from sympy.physics.units import Quantity\n", "        if isinstance(expr, Quantity):\n", "            return expr.scale_factor, expr.dimension\n", "        elif isinstance(expr, Mul):\n", "            factor = 1\n", "            dimension = Dimension(1)\n", "            for arg in expr.args:\n", "                arg_factor, arg_dim = self._collect_factor_and_dimension(arg)\n", "                factor *= arg_factor\n", "                dimension *= arg_dim\n", "            return factor, dimension\n", "        elif isinstance(expr, Pow):\n", "            factor, dim = self._collect_factor_and_dimension(expr.base)\n", "            exp_factor, exp_dim = self._collect_factor_and_dimension(expr.exp)\n", "            if self.get_dimension_system().is_dimensionless(exp_dim):\n", "                exp_dim = 1\n", "            return factor ** exp_factor, dim ** (exp_factor * exp_dim)\n", "        elif isinstance(expr, Add):\n", "            factor, dim = self._collect_factor_and_dimension(expr.args[0])\n", "            for addend in expr.args[1:]:\n", "                addend_factor, addend_dim = \\\n", "                    self._collect_factor_and_dimension(addend)\n", "                if dim != addend_dim:\n", "                    raise ValueError(\n", "                        'Dimension of \"{}\" is {}, '\n", "                        'but it should be {}'.format(\n", "                            addend, addend_dim, dim))\n", "                factor += addend_factor\n", "            return factor, dim\n", "        elif isinstance(expr, Derivative):\n", "            factor, dim = self._collect_factor_and_dimension(expr.args[0])\n", "            for independent, count in expr.variable_count:\n", "                ifactor, idim = self._collect_factor_and_dimension(independent)\n", "                factor /= ifactor**count\n", "                dim /= idim**count\n", "            return factor, dim\n", "        elif isinstance(expr, Function):\n", "            fds = [self._collect_factor_and_dimension(\n", "                arg) for arg in expr.args]\n", "            return (expr.func(*(f[0] for f in fds)),\n", "                    *(d[1] for d in fds))\n", "        elif isinstance(expr, Dimension):\n", "            return S.One, expr\n", "        else:\n", "            return expr, Dimension(1)\n"]}]}]}