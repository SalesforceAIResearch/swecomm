{"instance_id": "pytest-dev__pytest-5495", "identified_spans": [{"file_path": "src/_pytest/assertion/rewrite.py", "span_ids": ["AssertionRewriter", "AssertionRewriter.visit_Assert"], "content": [{"span_id": "AssertionRewriter", "start_line": 458, "end_line": 508, "content": ["class AssertionRewriter(ast.NodeVisitor):\n", "    \"\"\"Assertion rewriting implementation.\n", "\n", "    The main entrypoint is to call .run() with an ast.Module instance,\n", "    this will then find all the assert statements and rewrite them to\n", "    provide intermediate values and a detailed assertion error.  See\n", "    http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n", "    for an overview of how this works.\n", "\n", "    The entry point here is .run() which will iterate over all the\n", "    statements in an ast.Module and for each ast.Assert statement it\n", "    finds call .visit() with it.  Then .visit_Assert() takes over and\n", "    is responsible for creating new ast statements to replace the\n", "    original assert statement: it rewrites the test of an assertion\n", "    to provide intermediate values and replace it with an if statement\n", "    which raises an assertion error with a detailed explanation in\n", "    case the expression is false.\n", "\n", "    For this .visit_Assert() uses the visitor pattern to visit all the\n", "    AST nodes of the ast.Assert.test field, each visit call returning\n", "    an AST node and the corresponding explanation string.  During this\n", "    state is kept in several instance attributes:\n", "\n", "    :statements: All the AST statements which will replace the assert\n", "       statement.\n", "\n", "    :variables: This is populated by .variable() with each variable\n", "       used by the statements so that they can all be set to None at\n", "       the end of the statements.\n", "\n", "    :variable_counter: Counter to create new unique variables needed\n", "       by statements.  Variables are created using .variable() and\n", "       have the form of \"@py_assert0\".\n", "\n", "    :on_failure: The AST statements which will be executed if the\n", "       assertion test fails.  This is the code which will construct\n", "       the failure message and raises the AssertionError.\n", "\n", "    :explanation_specifiers: A dict filled by .explanation_param()\n", "       with %-formatting placeholders and their corresponding\n", "       expressions to use in the building of an assertion message.\n", "       This is used by .pop_format_context() to build a message.\n", "\n", "    :stack: A stack of the explanation_specifiers dicts maintained by\n", "       .push_format_context() and .pop_format_context() which allows\n", "       to build another %-formatted string while already building one.\n", "\n", "    This state is reset on every new assert statement visited and used\n", "    by the other visitors.\n", "\n", "    \"\"\"\n"]}, {"span_id": "AssertionRewriter.visit_Assert", "start_line": 663, "end_line": 726, "content": ["    def visit_Assert(self, assert_):\n", "        \"\"\"Return the AST statements to replace the ast.Assert instance.\n", "\n", "        This rewrites the test of an assertion to provide\n", "        intermediate values and replace it with an if statement which\n", "        raises an assertion error with a detailed explanation in case\n", "        the expression is false.\n", "\n", "        \"\"\"\n", "        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n", "            from _pytest.warning_types import PytestAssertRewriteWarning\n", "            import warnings\n", "\n", "            warnings.warn_explicit(\n", "                PytestAssertRewriteWarning(\n", "                    \"assertion is always true, perhaps remove parentheses?\"\n", "                ),\n", "                category=None,\n", "                filename=self.module_path,\n", "                lineno=assert_.lineno,\n", "            )\n", "\n", "        self.statements = []\n", "        self.variables = []\n", "        self.variable_counter = itertools.count()\n", "        self.stack = []\n", "        self.on_failure = []\n", "        self.push_format_context()\n", "        # Rewrite assert into a bunch of statements.\n", "        top_condition, explanation = self.visit(assert_.test)\n", "        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n", "        if self.module_path is not None:\n", "            self.statements.append(\n", "                self.warn_about_none_ast(\n", "                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n", "                )\n", "            )\n", "        # Create failure message.\n", "        body = self.on_failure\n", "        negation = ast.UnaryOp(ast.Not(), top_condition)\n", "        self.statements.append(ast.If(negation, body, []))\n", "        if assert_.msg:\n", "            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n", "            explanation = \"\\n>assert \" + explanation\n", "        else:\n", "            assertmsg = ast.Str(\"\")\n", "            explanation = \"assert \" + explanation\n", "        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n", "        msg = self.pop_format_context(template)\n", "        fmt = self.helper(\"_format_explanation\", msg)\n", "        err_name = ast.Name(\"AssertionError\", ast.Load())\n", "        exc = ast.Call(err_name, [fmt], [])\n", "        raise_ = ast.Raise(exc, None)\n", "\n", "        body.append(raise_)\n", "        # Clear temporary variables by setting them to None.\n", "        if self.variables:\n", "            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n", "            clear = ast.Assign(variables, _NameConstant(None))\n", "            self.statements.append(clear)\n", "        # Fix line numbers.\n", "        for stmt in self.statements:\n", "            set_location(stmt, assert_.lineno, assert_.col_offset)\n", "        return self.statements\n"]}]}, {"file_path": "src/_pytest/assertion/util.py", "span_ids": ["_compare_eq_sequence", "assertrepr_compare"], "content": [{"span_id": "_compare_eq_sequence", "start_line": 256, "end_line": 286, "content": ["def _compare_eq_sequence(left, right, verbose=0):\n", "    explanation = []\n", "    len_left = len(left)\n", "    len_right = len(right)\n", "    for i in range(min(len_left, len_right)):\n", "        if left[i] != right[i]:\n", "            explanation += [\n", "                \"At index {} diff: {!r} != {!r}\".format(i, left[i], right[i])\n", "            ]\n", "            break\n", "    len_diff = len_left - len_right\n", "\n", "    if len_diff:\n", "        if len_diff > 0:\n", "            dir_with_more = \"Left\"\n", "            extra = saferepr(left[len_right])\n", "        else:\n", "            len_diff = 0 - len_diff\n", "            dir_with_more = \"Right\"\n", "            extra = saferepr(right[len_left])\n", "\n", "        if len_diff == 1:\n", "            explanation += [\n", "                \"{} contains one more item: {}\".format(dir_with_more, extra)\n", "            ]\n", "        else:\n", "            explanation += [\n", "                \"%s contains %d more items, first extra item: %s\"\n", "                % (dir_with_more, len_diff, extra)\n", "            ]\n", "    return explanation\n"]}, {"span_id": "assertrepr_compare", "start_line": 116, "end_line": 163, "content": ["def assertrepr_compare(config, op, left, right):\n", "    \"\"\"Return specialised explanations for some operators/operands\"\"\"\n", "    width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op\n", "    left_repr = saferepr(left, maxsize=int(width // 2))\n", "    right_repr = saferepr(right, maxsize=width - len(left_repr))\n", "\n", "    summary = \"{} {} {}\".format(left_repr, op, right_repr)\n", "\n", "    verbose = config.getoption(\"verbose\")\n", "    explanation = None\n", "    try:\n", "        if op == \"==\":\n", "            if istext(left) and istext(right):\n", "                explanation = _diff_text(left, right, verbose)\n", "            else:\n", "                if issequence(left) and issequence(right):\n", "                    explanation = _compare_eq_sequence(left, right, verbose)\n", "                elif isset(left) and isset(right):\n", "                    explanation = _compare_eq_set(left, right, verbose)\n", "                elif isdict(left) and isdict(right):\n", "                    explanation = _compare_eq_dict(left, right, verbose)\n", "                elif type(left) == type(right) and (isdatacls(left) or isattrs(left)):\n", "                    type_fn = (isdatacls, isattrs)\n", "                    explanation = _compare_eq_cls(left, right, verbose, type_fn)\n", "                elif verbose > 0:\n", "                    explanation = _compare_eq_verbose(left, right)\n", "                if isiterable(left) and isiterable(right):\n", "                    expl = _compare_eq_iterable(left, right, verbose)\n", "                    if explanation is not None:\n", "                        explanation.extend(expl)\n", "                    else:\n", "                        explanation = expl\n", "        elif op == \"not in\":\n", "            if istext(left) and istext(right):\n", "                explanation = _notin_text(left, right, verbose)\n", "    except outcomes.Exit:\n", "        raise\n", "    except Exception:\n", "        explanation = [\n", "            \"(pytest_assertion plugin: representation of details failed.  \"\n", "            \"Probably an object has a faulty __repr__.)\",\n", "            str(_pytest._code.ExceptionInfo.from_current()),\n", "        ]\n", "\n", "    if not explanation:\n", "        return None\n", "\n", "    return [summary] + explanation\n"]}]}]}