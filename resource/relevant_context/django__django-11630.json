{"instance_id": "django__django-11630", "identified_spans": [{"file_path": "django/apps/registry.py", "span_ids": ["Apps.register_model", "Apps", "Apps.__init__", "Apps.populate"], "content": [{"span_id": "Apps.register_model", "start_line": 212, "end_line": 232, "content": ["    def register_model(self, app_label, model):\n", "        # Since this method is called when models are imported, it cannot\n", "        # perform imports because of the risk of import loops. It mustn't\n", "        # call get_app_config().\n", "        model_name = model._meta.model_name\n", "        app_models = self.all_models[app_label]\n", "        if model_name in app_models:\n", "            if (model.__name__ == app_models[model_name].__name__ and\n", "                    model.__module__ == app_models[model_name].__module__):\n", "                warnings.warn(\n", "                    \"Model '%s.%s' was already registered. \"\n", "                    \"Reloading models is not advised as it can lead to inconsistencies, \"\n", "                    \"most notably with related models.\" % (app_label, model_name),\n", "                    RuntimeWarning, stacklevel=2)\n", "            else:\n", "                raise RuntimeError(\n", "                    \"Conflicting '%s' models in application '%s': %s and %s.\" %\n", "                    (model_name, app_label, app_models[model_name], model))\n", "        app_models[model_name] = model\n", "        self.do_pending_operations(model)\n", "        self.clear_cache()\n"]}, {"span_id": "Apps", "start_line": 13, "end_line": 18, "content": ["class Apps:\n", "    \"\"\"\n", "    A registry that stores the configuration of installed applications.\n", "\n", "    It also keeps track of models, e.g. to provide reverse relations.\n", "    \"\"\"\n"]}, {"span_id": "Apps.__init__", "start_line": 20, "end_line": 59, "content": ["    def __init__(self, installed_apps=()):\n", "        # installed_apps is set to None when creating the master registry\n", "        # because it cannot be populated at that point. Other registries must\n", "        # provide a list of installed apps and are populated immediately.\n", "        if installed_apps is None and hasattr(sys.modules[__name__], 'apps'):\n", "            raise RuntimeError(\"You must supply an installed_apps argument.\")\n", "\n", "        # Mapping of app labels => model names => model classes. Every time a\n", "        # model is imported, ModelBase.__new__ calls apps.register_model which\n", "        # creates an entry in all_models. All imported models are registered,\n", "        # regardless of whether they're defined in an installed application\n", "        # and whether the registry has been populated. Since it isn't possible\n", "        # to reimport a module safely (it could reexecute initialization code)\n", "        # all_models is never overridden or reset.\n", "        self.all_models = defaultdict(dict)\n", "\n", "        # Mapping of labels to AppConfig instances for installed apps.\n", "        self.app_configs = {}\n", "\n", "        # Stack of app_configs. Used to store the current state in\n", "        # set_available_apps and set_installed_apps.\n", "        self.stored_app_configs = []\n", "\n", "        # Whether the registry is populated.\n", "        self.apps_ready = self.models_ready = self.ready = False\n", "        # For the autoreloader.\n", "        self.ready_event = threading.Event()\n", "\n", "        # Lock for thread-safe population.\n", "        self._lock = threading.RLock()\n", "        self.loading = False\n", "\n", "        # Maps (\"app_label\", \"modelname\") tuples to lists of functions to be\n", "        # called when the corresponding model is ready. Used by this class's\n", "        # `lazy_model_operation()` and `do_pending_operations()` methods.\n", "        self._pending_operations = defaultdict(list)\n", "\n", "        # Populate apps and models, unless it's the master registry.\n", "        if installed_apps is not None:\n", "            self.populate(installed_apps)\n"]}, {"span_id": "Apps.populate", "start_line": 61, "end_line": 125, "content": ["    def populate(self, installed_apps=None):\n", "        \"\"\"\n", "        Load application configurations and models.\n", "\n", "        Import each application module and then each model module.\n", "\n", "        It is thread-safe and idempotent, but not reentrant.\n", "        \"\"\"\n", "        if self.ready:\n", "            return\n", "\n", "        # populate() might be called by two threads in parallel on servers\n", "        # that create threads before initializing the WSGI callable.\n", "        with self._lock:\n", "            if self.ready:\n", "                return\n", "\n", "            # An RLock prevents other threads from entering this section. The\n", "            # compare and set operation below is atomic.\n", "            if self.loading:\n", "                # Prevent reentrant calls to avoid running AppConfig.ready()\n", "                # methods twice.\n", "                raise RuntimeError(\"populate() isn't reentrant\")\n", "            self.loading = True\n", "\n", "            # Phase 1: initialize app configs and import app modules.\n", "            for entry in installed_apps:\n", "                if isinstance(entry, AppConfig):\n", "                    app_config = entry\n", "                else:\n", "                    app_config = AppConfig.create(entry)\n", "                if app_config.label in self.app_configs:\n", "                    raise ImproperlyConfigured(\n", "                        \"Application labels aren't unique, \"\n", "                        \"duplicates: %s\" % app_config.label)\n", "\n", "                self.app_configs[app_config.label] = app_config\n", "                app_config.apps = self\n", "\n", "            # Check for duplicate app names.\n", "            counts = Counter(\n", "                app_config.name for app_config in self.app_configs.values())\n", "            duplicates = [\n", "                name for name, count in counts.most_common() if count > 1]\n", "            if duplicates:\n", "                raise ImproperlyConfigured(\n", "                    \"Application names aren't unique, \"\n", "                    \"duplicates: %s\" % \", \".join(duplicates))\n", "\n", "            self.apps_ready = True\n", "\n", "            # Phase 2: import models modules.\n", "            for app_config in self.app_configs.values():\n", "                app_config.import_models()\n", "\n", "            self.clear_cache()\n", "\n", "            self.models_ready = True\n", "\n", "            # Phase 3: run ready() methods of app configs.\n", "            for app_config in self.get_app_configs():\n", "                app_config.ready()\n", "\n", "            self.ready = True\n", "            self.ready_event.set()\n"]}]}, {"file_path": "django/core/checks/model_checks.py", "span_ids": ["check_all_models"], "content": [{"span_id": "check_all_models", "start_line": 10, "end_line": 74, "content": ["@register(Tags.models)\n", "def check_all_models(app_configs=None, **kwargs):\n", "    db_table_models = defaultdict(list)\n", "    indexes = defaultdict(list)\n", "    constraints = defaultdict(list)\n", "    errors = []\n", "    if app_configs is None:\n", "        models = apps.get_models()\n", "    else:\n", "        models = chain.from_iterable(app_config.get_models() for app_config in app_configs)\n", "    for model in models:\n", "        if model._meta.managed and not model._meta.proxy:\n", "            db_table_models[model._meta.db_table].append(model._meta.label)\n", "        if not inspect.ismethod(model.check):\n", "            errors.append(\n", "                Error(\n", "                    \"The '%s.check()' class method is currently overridden by %r.\"\n", "                    % (model.__name__, model.check),\n", "                    obj=model,\n", "                    id='models.E020'\n", "                )\n", "            )\n", "        else:\n", "            errors.extend(model.check(**kwargs))\n", "        for model_index in model._meta.indexes:\n", "            indexes[model_index.name].append(model._meta.label)\n", "        for model_constraint in model._meta.constraints:\n", "            constraints[model_constraint.name].append(model._meta.label)\n", "    for db_table, model_labels in db_table_models.items():\n", "        if len(model_labels) != 1:\n", "            errors.append(\n", "                Error(\n", "                    \"db_table '%s' is used by multiple models: %s.\"\n", "                    % (db_table, ', '.join(db_table_models[db_table])),\n", "                    obj=db_table,\n", "                    id='models.E028',\n", "                )\n", "            )\n", "    for index_name, model_labels in indexes.items():\n", "        if len(model_labels) > 1:\n", "            model_labels = set(model_labels)\n", "            errors.append(\n", "                Error(\n", "                    \"index name '%s' is not unique %s %s.\" % (\n", "                        index_name,\n", "                        'for model' if len(model_labels) == 1 else 'amongst models:',\n", "                        ', '.join(sorted(model_labels)),\n", "                    ),\n", "                    id='models.E029' if len(model_labels) == 1 else 'models.E030',\n", "                ),\n", "            )\n", "    for constraint_name, model_labels in constraints.items():\n", "        if len(model_labels) > 1:\n", "            model_labels = set(model_labels)\n", "            errors.append(\n", "                Error(\n", "                    \"constraint name '%s' is not unique %s %s.\" % (\n", "                        constraint_name,\n", "                        'for model' if len(model_labels) == 1 else 'amongst models:',\n", "                        ', '.join(sorted(model_labels)),\n", "                    ),\n", "                    id='models.E031' if len(model_labels) == 1 else 'models.E032',\n", "                ),\n", "            )\n", "    return errors\n"]}]}]}