{"instance_id": "django__django-11905", "identified_spans": [{"file_path": "django/db/models/lookups.py", "span_ids": ["IsNull", "IsNull.as_sql"], "content": [{"span_id": "IsNull", "start_line": 460, "end_line": 463, "content": ["@Field.register_lookup\n", "class IsNull(BuiltinLookup):\n", "    lookup_name = 'isnull'\n", "    prepare_rhs = False\n"]}, {"span_id": "IsNull.as_sql", "start_line": 465, "end_line": 470, "content": ["    def as_sql(self, compiler, connection):\n", "        sql, params = compiler.compile(self.lhs)\n", "        if self.rhs:\n", "            return \"%s IS NULL\" % sql, params\n", "        else:\n", "            return \"%s IS NOT NULL\" % sql, params\n"]}]}, {"file_path": "django/db/models/sql/query.py", "span_ids": ["Query.build_filter"], "content": [{"span_id": "Query.build_filter", "start_line": 1204, "end_line": 1331, "content": ["    def build_filter(self, filter_expr, branch_negated=False, current_negated=False,\n", "                     can_reuse=None, allow_joins=True, split_subq=True,\n", "                     reuse_with_filtered_relation=False, simple_col=False):\n", "        \"\"\"\n", "        Build a WhereNode for a single filter clause but don't add it\n", "        to this Query. Query.add_q() will then add this filter to the where\n", "        Node.\n", "\n", "        The 'branch_negated' tells us if the current branch contains any\n", "        negations. This will be used to determine if subqueries are needed.\n", "\n", "        The 'current_negated' is used to determine if the current filter is\n", "        negated or not and this will be used to determine if IS NULL filtering\n", "        is needed.\n", "\n", "        The difference between current_negated and branch_negated is that\n", "        branch_negated is set on first negation, but current_negated is\n", "        flipped for each negation.\n", "\n", "        Note that add_filter will not do any negating itself, that is done\n", "        upper in the code by add_q().\n", "\n", "        The 'can_reuse' is a set of reusable joins for multijoins.\n", "\n", "        If 'reuse_with_filtered_relation' is True, then only joins in can_reuse\n", "        will be reused.\n", "\n", "        The method will create a filter clause that can be added to the current\n", "        query. However, if the filter isn't added to the query then the caller\n", "        is responsible for unreffing the joins used.\n", "        \"\"\"\n", "        if isinstance(filter_expr, dict):\n", "            raise FieldError(\"Cannot parse keyword query as dict\")\n", "        if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):\n", "            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):\n", "                condition = filter_expr.resolve_expression(self)\n", "            else:\n", "                # Expression is not supported in the WHERE clause, add\n", "                # comparison with True.\n", "                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)\n", "            clause = self.where_class()\n", "            clause.add(condition, AND)\n", "            return clause, []\n", "        arg, value = filter_expr\n", "        if not arg:\n", "            raise FieldError(\"Cannot parse keyword query %r\" % arg)\n", "        lookups, parts, reffed_expression = self.solve_lookup_type(arg)\n", "\n", "        self.check_filterable(reffed_expression)\n", "\n", "        if not allow_joins and len(parts) > 1:\n", "            raise FieldError(\"Joined field references are not permitted in this query\")\n", "\n", "        pre_joins = self.alias_refcount.copy()\n", "        value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)\n", "        used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n", "\n", "        self.check_filterable(value)\n", "\n", "        clause = self.where_class()\n", "        if reffed_expression:\n", "            condition = self.build_lookup(lookups, reffed_expression, value)\n", "            clause.add(condition, AND)\n", "            return clause, []\n", "\n", "        opts = self.get_meta()\n", "        alias = self.get_initial_alias()\n", "        allow_many = not branch_negated or not split_subq\n", "\n", "        try:\n", "            join_info = self.setup_joins(\n", "                parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,\n", "                reuse_with_filtered_relation=reuse_with_filtered_relation,\n", "            )\n", "\n", "            # Prevent iterator from being consumed by check_related_objects()\n", "            if isinstance(value, Iterator):\n", "                value = list(value)\n", "            self.check_related_objects(join_info.final_field, value, join_info.opts)\n", "\n", "            # split_exclude() needs to know which joins were generated for the\n", "            # lookup parts\n", "            self._lookup_joins = join_info.joins\n", "        except MultiJoin as e:\n", "            return self.split_exclude(filter_expr, can_reuse, e.names_with_path)\n", "\n", "        # Update used_joins before trimming since they are reused to determine\n", "        # which joins could be later promoted to INNER.\n", "        used_joins.update(join_info.joins)\n", "        targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)\n", "        if can_reuse is not None:\n", "            can_reuse.update(join_list)\n", "\n", "        if join_info.final_field.is_relation:\n", "            # No support for transforms for relational fields\n", "            num_lookups = len(lookups)\n", "            if num_lookups > 1:\n", "                raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))\n", "            if len(targets) == 1:\n", "                col = _get_col(targets[0], join_info.final_field, alias, simple_col)\n", "            else:\n", "                col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)\n", "        else:\n", "            col = _get_col(targets[0], join_info.final_field, alias, simple_col)\n", "\n", "        condition = self.build_lookup(lookups, col, value)\n", "        lookup_type = condition.lookup_name\n", "        clause.add(condition, AND)\n", "\n", "        require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated\n", "        if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:\n", "            require_outer = True\n", "            if (lookup_type != 'isnull' and (\n", "                    self.is_nullable(targets[0]) or\n", "                    self.alias_map[join_list[-1]].join_type == LOUTER)):\n", "                # The condition added here will be SQL like this:\n", "                # NOT (col IS NOT NULL), where the first NOT is added in\n", "                # upper layers of code. The reason for addition is that if col\n", "                # is null, then col != someval will result in SQL \"unknown\"\n", "                # which isn't the same as in Python. The Python None handling\n", "                # is wanted, and it can be gotten by\n", "                # (col IS NULL OR col != someval)\n", "                #   <=>\n", "                # NOT (col IS NOT NULL AND col = someval).\n", "                lookup_class = targets[0].get_lookup('isnull')\n", "                col = _get_col(targets[0], join_info.targets[0], alias, simple_col)\n", "                clause.add(lookup_class(col, False), AND)\n", "        return clause, used_joins if not require_outer else ()\n"]}]}]}