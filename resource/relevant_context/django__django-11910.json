{"instance_id": "django__django-11910", "identified_spans": [{"file_path": "django/db/migrations/operations/fields.py", "span_ids": ["RenameField.__init__", "RenameField", "RenameField.state_forwards"], "content": [{"span_id": "RenameField.__init__", "start_line": 277, "end_line": 280, "content": ["    def __init__(self, model_name, old_name, new_name):\n", "        self.old_name = old_name\n", "        self.new_name = new_name\n", "        super().__init__(model_name, old_name)\n"]}, {"span_id": "RenameField", "start_line": 274, "end_line": 275, "content": ["class RenameField(FieldOperation):\n", "    \"\"\"Rename a field on the model. Might affect db_column too.\"\"\"\n"]}, {"span_id": "RenameField.state_forwards", "start_line": 302, "end_line": 355, "content": ["    def state_forwards(self, app_label, state):\n", "        model_state = state.models[app_label, self.model_name_lower]\n", "        # Rename the field\n", "        fields = model_state.fields\n", "        found = False\n", "        delay = True\n", "        for index, (name, field) in enumerate(fields):\n", "            if not found and name == self.old_name:\n", "                fields[index] = (self.new_name, field)\n", "                found = True\n", "            # Fix from_fields to refer to the new field.\n", "            from_fields = getattr(field, 'from_fields', None)\n", "            if from_fields:\n", "                field.from_fields = tuple([\n", "                    self.new_name if from_field_name == self.old_name else from_field_name\n", "                    for from_field_name in from_fields\n", "                ])\n", "            # Delay rendering of relationships if it's not a relational\n", "            # field and not referenced by a foreign key.\n", "            delay = delay and (\n", "                not field.is_relation and\n", "                not is_referenced_by_foreign_key(state, self.model_name_lower, field, self.name)\n", "            )\n", "        if not found:\n", "            raise FieldDoesNotExist(\n", "                \"%s.%s has no field named '%s'\" % (app_label, self.model_name, self.old_name)\n", "            )\n", "        # Fix index/unique_together to refer to the new field\n", "        options = model_state.options\n", "        for option in ('index_together', 'unique_together'):\n", "            if option in options:\n", "                options[option] = [\n", "                    [self.new_name if n == self.old_name else n for n in together]\n", "                    for together in options[option]\n", "                ]\n", "        # Fix to_fields to refer to the new field.\n", "        model_tuple = app_label, self.model_name_lower\n", "        for (model_app_label, model_name), model_state in state.models.items():\n", "            for index, (name, field) in enumerate(model_state.fields):\n", "                remote_field = field.remote_field\n", "                if remote_field:\n", "                    remote_model_tuple = self._get_model_tuple(\n", "                        remote_field.model, model_app_label, model_name\n", "                    )\n", "                    if remote_model_tuple == model_tuple:\n", "                        if getattr(remote_field, 'field_name', None) == self.old_name:\n", "                            remote_field.field_name = self.new_name\n", "                        to_fields = getattr(field, 'to_fields', None)\n", "                        if to_fields:\n", "                            field.to_fields = tuple([\n", "                                self.new_name if to_field_name == self.old_name else to_field_name\n", "                                for to_field_name in to_fields\n", "                            ])\n", "        state.reload_model(app_label, self.model_name_lower, delay=delay)\n"]}]}, {"file_path": "django/db/models/fields/related.py", "span_ids": ["ForeignKey", "ForeignKey.__init__"], "content": [{"span_id": "ForeignKey", "start_line": 759, "end_line": 780, "content": ["class ForeignKey(ForeignObject):\n", "    \"\"\"\n", "    Provide a many-to-one relation by adding a column to the local model\n", "    to hold the remote value.\n", "\n", "    By default ForeignKey will target the pk of the remote model but this\n", "    behavior can be changed by using the ``to_field`` argument.\n", "    \"\"\"\n", "    descriptor_class = ForeignKeyDeferredAttribute\n", "    # Field flags\n", "    many_to_many = False\n", "    many_to_one = True\n", "    one_to_many = False\n", "    one_to_one = False\n", "\n", "    rel_class = ManyToOneRel\n", "\n", "    empty_strings_allowed = False\n", "    default_error_messages = {\n", "        'invalid': _('%(model)s instance with %(field)s %(value)r does not exist.')\n", "    }\n", "    description = _(\"Foreign Key (type determined by related field)\")\n"]}, {"span_id": "ForeignKey.__init__", "start_line": 782, "end_line": 815, "content": ["    def __init__(self, to, on_delete, related_name=None, related_query_name=None,\n", "                 limit_choices_to=None, parent_link=False, to_field=None,\n", "                 db_constraint=True, **kwargs):\n", "        try:\n", "            to._meta.model_name\n", "        except AttributeError:\n", "            assert isinstance(to, str), (\n", "                \"%s(%r) is invalid. First parameter to ForeignKey must be \"\n", "                \"either a model, a model name, or the string %r\" % (\n", "                    self.__class__.__name__, to,\n", "                    RECURSIVE_RELATIONSHIP_CONSTANT,\n", "                )\n", "            )\n", "        else:\n", "            # For backwards compatibility purposes, we need to *try* and set\n", "            # the to_field during FK construction. It won't be guaranteed to\n", "            # be correct until contribute_to_class is called. Refs #12190.\n", "            to_field = to_field or (to._meta.pk and to._meta.pk.name)\n", "        if not callable(on_delete):\n", "            raise TypeError('on_delete must be callable.')\n", "\n", "        kwargs['rel'] = self.rel_class(\n", "            self, to, to_field,\n", "            related_name=related_name,\n", "            related_query_name=related_query_name,\n", "            limit_choices_to=limit_choices_to,\n", "            parent_link=parent_link,\n", "            on_delete=on_delete,\n", "        )\n", "        kwargs.setdefault('db_index', True)\n", "\n", "        super().__init__(to, on_delete, from_fields=['self'], to_fields=[to_field], **kwargs)\n", "\n", "        self.db_constraint = db_constraint\n"]}]}, {"file_path": "django/db/models/fields/reverse_related.py", "span_ids": ["ManyToOneRel.set_field_name", "ManyToOneRel.__init__", "ManyToOneRel"], "content": [{"span_id": "ManyToOneRel.set_field_name", "start_line": 222, "end_line": 223, "content": ["    def set_field_name(self):\n", "        self.field_name = self.field_name or self.model._meta.pk.name\n"]}, {"span_id": "ManyToOneRel.__init__", "start_line": 195, "end_line": 206, "content": ["    def __init__(self, field, to, field_name, related_name=None, related_query_name=None,\n", "                 limit_choices_to=None, parent_link=False, on_delete=None):\n", "        super().__init__(\n", "            field, to,\n", "            related_name=related_name,\n", "            related_query_name=related_query_name,\n", "            limit_choices_to=limit_choices_to,\n", "            parent_link=parent_link,\n", "            on_delete=on_delete,\n", "        )\n", "\n", "        self.field_name = field_name\n"]}, {"span_id": "ManyToOneRel", "start_line": 180, "end_line": 193, "content": ["class ManyToOneRel(ForeignObjectRel):\n", "    \"\"\"\n", "    Used by the ForeignKey field to store information about the relation.\n", "\n", "    ``_meta.get_fields()`` returns this class to provide access to the field\n", "    flags for the reverse relation.\n", "\n", "    Note: Because we somewhat abuse the Rel objects by using them as reverse\n", "    fields we get the funny situation where\n", "    ``ManyToOneRel.many_to_one == False`` and\n", "    ``ManyToOneRel.one_to_many == True``. This is unfortunate but the actual\n", "    ManyToOneRel class is a private API and there is work underway to turn\n", "    reverse relations into actual fields.\n", "    \"\"\"\n"]}]}]}