{"instance_id": "sphinx-doc__sphinx-7686", "identified_spans": [{"file_path": "sphinx/config.py", "span_ids": ["Config"], "content": [{"span_id": "Config", "start_line": 81, "end_line": 155, "content": ["class Config:\n", "    \"\"\"Configuration file abstraction.\n", "\n", "    The config object makes the values of all config values available as\n", "    attributes.\n", "\n", "    It is exposed via the :py:attr:`sphinx.application.Application.config` and\n", "    :py:attr:`sphinx.environment.Environment.config` attributes. For example,\n", "    to get the value of :confval:`language`, use either ``app.config.language``\n", "    or ``env.config.language``.\n", "    \"\"\"\n", "\n", "    # the values are: (default, what needs to be rebuilt if changed)\n", "\n", "    # If you add a value here, don't forget to include it in the\n", "    # quickstart.py file template as well as in the docs!\n", "\n", "    config_values = {\n", "        # general options\n", "        'project': ('Python', 'env', []),\n", "        'author': ('unknown', 'env', []),\n", "        'copyright': ('', 'html', []),\n", "        'version': ('', 'env', []),\n", "        'release': ('', 'env', []),\n", "        'today': ('', 'env', []),\n", "        # the real default is locale-dependent\n", "        'today_fmt': (None, 'env', [str]),\n", "\n", "        'language': (None, 'env', [str]),\n", "        'locale_dirs': (['locales'], 'env', []),\n", "        'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),\n", "\n", "        'master_doc': ('index', 'env', []),\n", "        'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),\n", "        'source_encoding': ('utf-8-sig', 'env', []),\n", "        'source_parsers': ({}, 'env', []),\n", "        'exclude_patterns': ([], 'env', []),\n", "        'default_role': (None, 'env', [str]),\n", "        'add_function_parentheses': (True, 'env', []),\n", "        'add_module_names': (True, 'env', []),\n", "        'trim_footnote_reference_space': (False, 'env', []),\n", "        'show_authors': (False, 'env', []),\n", "        'pygments_style': (None, 'html', [str]),\n", "        'highlight_language': ('default', 'env', []),\n", "        'highlight_options': ({}, 'env', []),\n", "        'templates_path': ([], 'html', []),\n", "        'template_bridge': (None, 'html', [str]),\n", "        'keep_warnings': (False, 'env', []),\n", "        'suppress_warnings': ([], 'env', []),\n", "        'modindex_common_prefix': ([], 'html', []),\n", "        'rst_epilog': (None, 'env', [str]),\n", "        'rst_prolog': (None, 'env', [str]),\n", "        'trim_doctest_flags': (True, 'env', []),\n", "        'primary_domain': ('py', 'env', [NoneType]),   # type: ignore\n", "        'needs_sphinx': (None, None, [str]),\n", "        'needs_extensions': ({}, None, []),\n", "        'manpages_url': (None, 'env', []),\n", "        'nitpicky': (False, None, []),\n", "        'nitpick_ignore': ([], None, []),\n", "        'numfig': (False, 'env', []),\n", "        'numfig_secnum_depth': (1, 'env', []),\n", "        'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()\n", "\n", "        'math_number_all': (False, 'env', []),\n", "        'math_eqref_format': (None, 'env', [str]),\n", "        'math_numfig': (True, 'env', []),\n", "        'tls_verify': (True, 'env', []),\n", "        'tls_cacerts': (None, 'env', []),\n", "        'user_agent': (None, 'env', [str]),\n", "        'smartquotes': (True, 'env', []),\n", "        'smartquotes_action': ('qDe', 'env', []),\n", "        'smartquotes_excludes': ({'languages': ['ja'],\n", "                                  'builders': ['man', 'text']},\n", "                                 'env', []),\n", "    }  # type: Dict[str, Tuple]\n"]}]}, {"file_path": "sphinx/ext/autodoc/__init__.py", "span_ids": ["ModuleDocumenter", "setup", "ModuleDocumenter.get_object_members", "Documenter.filter_members"], "content": [{"span_id": "ModuleDocumenter", "start_line": 807, "end_line": 823, "content": ["class ModuleDocumenter(Documenter):\n", "    \"\"\"\n", "    Specialized Documenter subclass for modules.\n", "    \"\"\"\n", "    objtype = 'module'\n", "    content_indent = ''\n", "    titles_allowed = True\n", "\n", "    option_spec = {\n", "        'members': members_option, 'undoc-members': bool_option,\n", "        'noindex': bool_option, 'inherited-members': inherited_members_option,\n", "        'show-inheritance': bool_option, 'synopsis': identity,\n", "        'platform': identity, 'deprecated': bool_option,\n", "        'member-order': identity, 'exclude-members': members_set_option,\n", "        'private-members': bool_option, 'special-members': members_option,\n", "        'imported-members': bool_option, 'ignore-module-all': bool_option\n", "    }  # type: Dict[str, Callable]\n"]}, {"span_id": "setup", "start_line": 1765, "end_line": 1799, "content": ["def setup(app: Sphinx) -> Dict[str, Any]:\n", "    app.add_autodocumenter(ModuleDocumenter)\n", "    app.add_autodocumenter(ClassDocumenter)\n", "    app.add_autodocumenter(ExceptionDocumenter)\n", "    app.add_autodocumenter(DataDocumenter)\n", "    app.add_autodocumenter(DataDeclarationDocumenter)\n", "    app.add_autodocumenter(FunctionDocumenter)\n", "    app.add_autodocumenter(DecoratorDocumenter)\n", "    app.add_autodocumenter(MethodDocumenter)\n", "    app.add_autodocumenter(AttributeDocumenter)\n", "    app.add_autodocumenter(PropertyDocumenter)\n", "    app.add_autodocumenter(InstanceAttributeDocumenter)\n", "    app.add_autodocumenter(SlotsAttributeDocumenter)\n", "\n", "    app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))\n", "    app.add_config_value('autodoc_member_order', 'alphabetical', True,\n", "                         ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))\n", "    app.add_config_value('autodoc_default_options', {}, True)\n", "    app.add_config_value('autodoc_docstring_signature', True, True)\n", "    app.add_config_value('autodoc_mock_imports', [], True)\n", "    app.add_config_value('autodoc_typehints', \"signature\", True,\n", "                         ENUM(\"signature\", \"description\", \"none\"))\n", "    app.add_config_value('autodoc_warningiserror', True, True)\n", "    app.add_config_value('autodoc_inherit_docstrings', True, True)\n", "    app.add_event('autodoc-before-process-signature')\n", "    app.add_event('autodoc-process-docstring')\n", "    app.add_event('autodoc-process-signature')\n", "    app.add_event('autodoc-skip-member')\n", "\n", "    app.connect('config-inited', migrate_autodoc_member_order)\n", "\n", "    app.setup_extension('sphinx.ext.autodoc.type_comment')\n", "    app.setup_extension('sphinx.ext.autodoc.typehints')\n", "\n", "    return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n"]}, {"span_id": "ModuleDocumenter.get_object_members", "start_line": 863, "end_line": 896, "content": ["    def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:\n", "        if want_all:\n", "            if (self.options.ignore_module_all or not\n", "                    hasattr(self.object, '__all__')):\n", "                # for implicit module members, check __module__ to avoid\n", "                # documenting imported objects\n", "                return True, get_module_members(self.object)\n", "            else:\n", "                memberlist = self.object.__all__\n", "                # Sometimes __all__ is broken...\n", "                if not isinstance(memberlist, (list, tuple)) or not \\\n", "                   all(isinstance(entry, str) for entry in memberlist):\n", "                    logger.warning(\n", "                        __('__all__ should be a list of strings, not %r '\n", "                           '(in module %s) -- ignoring __all__') %\n", "                        (memberlist, self.fullname),\n", "                        type='autodoc'\n", "                    )\n", "                    # fall back to all members\n", "                    return True, get_module_members(self.object)\n", "        else:\n", "            memberlist = self.options.members or []\n", "        ret = []\n", "        for mname in memberlist:\n", "            try:\n", "                ret.append((mname, safe_getattr(self.object, mname)))\n", "            except AttributeError:\n", "                logger.warning(\n", "                    __('missing attribute mentioned in :members: or __all__: '\n", "                       'module %s, attribute %s') %\n", "                    (safe_getattr(self.object, '__name__', '???'), mname),\n", "                    type='autodoc'\n", "                )\n", "        return False, ret\n"]}, {"span_id": "Documenter.filter_members", "start_line": 531, "end_line": 655, "content": ["    def filter_members(self, members: List[Tuple[str, Any]], want_all: bool\n", "                       ) -> List[Tuple[str, Any, bool]]:\n", "        \"\"\"Filter the given member list.\n", "\n", "        Members are skipped if\n", "\n", "        - they are private (except if given explicitly or the private-members\n", "          option is set)\n", "        - they are special methods (except if given explicitly or the\n", "          special-members option is set)\n", "        - they are undocumented (except if the undoc-members option is set)\n", "\n", "        The user can override the skipping decision by connecting to the\n", "        ``autodoc-skip-member`` event.\n", "        \"\"\"\n", "        def is_filtered_inherited_member(name: str) -> bool:\n", "            if inspect.isclass(self.object):\n", "                for cls in self.object.__mro__:\n", "                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n", "                        # given member is a member of specified *super class*\n", "                        return True\n", "                    elif name in cls.__dict__:\n", "                        return False\n", "\n", "            return False\n", "\n", "        ret = []\n", "\n", "        # search for members in source code too\n", "        namespace = '.'.join(self.objpath)  # will be empty for modules\n", "\n", "        if self.analyzer:\n", "            attr_docs = self.analyzer.find_attr_docs()\n", "        else:\n", "            attr_docs = {}\n", "\n", "        # process members and determine which to skip\n", "        for (membername, member) in members:\n", "            # if isattr is True, the member is documented as an attribute\n", "            if member is INSTANCEATTR:\n", "                isattr = True\n", "            else:\n", "                isattr = False\n", "\n", "            doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,\n", "                         self.parent, self.object_name)\n", "            if not isinstance(doc, str):\n", "                # Ignore non-string __doc__\n", "                doc = None\n", "\n", "            # if the member __doc__ is the same as self's __doc__, it's just\n", "            # inherited and therefore not the member's doc\n", "            cls = self.get_attr(member, '__class__', None)\n", "            if cls:\n", "                cls_doc = self.get_attr(cls, '__doc__', None)\n", "                if cls_doc == doc:\n", "                    doc = None\n", "            has_doc = bool(doc)\n", "\n", "            metadata = extract_metadata(doc)\n", "            if 'private' in metadata:\n", "                # consider a member private if docstring has \"private\" metadata\n", "                isprivate = True\n", "            elif 'public' in metadata:\n", "                # consider a member public if docstring has \"public\" metadata\n", "                isprivate = False\n", "            else:\n", "                isprivate = membername.startswith('_')\n", "\n", "            keep = False\n", "            if safe_getattr(member, '__sphinx_mock__', False):\n", "                # mocked module or object\n", "                pass\n", "            elif want_all and membername.startswith('__') and \\\n", "                    membername.endswith('__') and len(membername) > 4:\n", "                # special __methods__\n", "                if self.options.special_members is ALL:\n", "                    if membername == '__doc__':\n", "                        keep = False\n", "                    elif is_filtered_inherited_member(membername):\n", "                        keep = False\n", "                    else:\n", "                        keep = has_doc or self.options.undoc_members\n", "                elif self.options.special_members:\n", "                    if membername in self.options.special_members:\n", "                        keep = has_doc or self.options.undoc_members\n", "            elif (namespace, membername) in attr_docs:\n", "                if want_all and isprivate:\n", "                    # ignore members whose name starts with _ by default\n", "                    keep = self.options.private_members\n", "                else:\n", "                    # keep documented attributes\n", "                    keep = True\n", "                isattr = True\n", "            elif want_all and isprivate:\n", "                # ignore members whose name starts with _ by default\n", "                keep = self.options.private_members and \\\n", "                    (has_doc or self.options.undoc_members)\n", "            else:\n", "                if self.options.members is ALL and is_filtered_inherited_member(membername):\n", "                    keep = False\n", "                else:\n", "                    # ignore undocumented members if :undoc-members: is not given\n", "                    keep = has_doc or self.options.undoc_members\n", "\n", "            # give the user a chance to decide whether this member\n", "            # should be skipped\n", "            if self.env.app:\n", "                # let extensions preprocess docstrings\n", "                try:\n", "                    skip_user = self.env.app.emit_firstresult(\n", "                        'autodoc-skip-member', self.objtype, membername, member,\n", "                        not keep, self.options)\n", "                    if skip_user is not None:\n", "                        keep = not skip_user\n", "                except Exception as exc:\n", "                    logger.warning(__('autodoc: failed to determine %r to be documented, '\n", "                                      'the following exception was raised:\\n%s'),\n", "                                   member, exc, type='autodoc')\n", "                    keep = False\n", "\n", "            if keep:\n", "                ret.append((membername, member, isattr))\n", "\n", "        return ret\n"]}]}]}