{"instance_id": "astropy__astropy-7746", "identified_spans": [{"file_path": "astropy/wcs/wcs.py", "span_ids": ["WCS.wcs_pix2world", "WCS._array_converter"], "content": [{"span_id": "WCS.wcs_pix2world", "start_line": 1349, "end_line": 1354, "content": ["    def wcs_pix2world(self, *args, **kwargs):\n", "        if self.wcs is None:\n", "            raise ValueError(\"No basic WCS settings were created.\")\n", "        return self._array_converter(\n", "            lambda xy, o: self.wcs.p2s(xy, o)['world'],\n", "            'output', *args, **kwargs)\n"]}, {"span_id": "WCS._array_converter", "start_line": 1208, "end_line": 1276, "content": ["    def _array_converter(self, func, sky, *args, ra_dec_order=False):\n", "        \"\"\"\n", "        A helper function to support reading either a pair of arrays\n", "        or a single Nx2 array.\n", "        \"\"\"\n", "\n", "        def _return_list_of_arrays(axes, origin):\n", "            try:\n", "                axes = np.broadcast_arrays(*axes)\n", "            except ValueError:\n", "                raise ValueError(\n", "                    \"Coordinate arrays are not broadcastable to each other\")\n", "\n", "            xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n", "\n", "            if ra_dec_order and sky == 'input':\n", "                xy = self._denormalize_sky(xy)\n", "            output = func(xy, origin)\n", "            if ra_dec_order and sky == 'output':\n", "                output = self._normalize_sky(output)\n", "                return (output[:, 0].reshape(axes[0].shape),\n", "                        output[:, 1].reshape(axes[0].shape))\n", "            return [output[:, i].reshape(axes[0].shape)\n", "                    for i in range(output.shape[1])]\n", "\n", "        def _return_single_array(xy, origin):\n", "            if xy.shape[-1] != self.naxis:\n", "                raise ValueError(\n", "                    \"When providing two arguments, the array must be \"\n", "                    \"of shape (N, {0})\".format(self.naxis))\n", "            if ra_dec_order and sky == 'input':\n", "                xy = self._denormalize_sky(xy)\n", "            result = func(xy, origin)\n", "            if ra_dec_order and sky == 'output':\n", "                result = self._normalize_sky(result)\n", "            return result\n", "\n", "        if len(args) == 2:\n", "            try:\n", "                xy, origin = args\n", "                xy = np.asarray(xy)\n", "                origin = int(origin)\n", "            except Exception:\n", "                raise TypeError(\n", "                    \"When providing two arguments, they must be \"\n", "                    \"(coords[N][{0}], origin)\".format(self.naxis))\n", "            if self.naxis == 1 and len(xy.shape) == 1:\n", "                return _return_list_of_arrays([xy], origin)\n", "            return _return_single_array(xy, origin)\n", "\n", "        elif len(args) == self.naxis + 1:\n", "            axes = args[:-1]\n", "            origin = args[-1]\n", "            try:\n", "                axes = [np.asarray(x) for x in axes]\n", "                origin = int(origin)\n", "            except Exception:\n", "                raise TypeError(\n", "                    \"When providing more than two arguments, they must be \" +\n", "                    \"a 1-D array for each axis, followed by an origin.\")\n", "\n", "            return _return_list_of_arrays(axes, origin)\n", "\n", "        raise TypeError(\n", "            \"WCS projection has {0} dimensions, so expected 2 (an Nx{0} array \"\n", "            \"and the origin argument) or {1} arguments (the position in each \"\n", "            \"dimension, and the origin argument). Instead, {2} arguments were \"\n", "            \"given.\".format(\n", "                self.naxis, self.naxis + 1, len(args)))\n"]}]}]}