{"instance_id": "pytest-dev__pytest-8906", "identified_spans": [{"file_path": "src/_pytest/outcomes.py", "span_ids": ["skip"], "content": [{"span_id": "skip", "start_line": 123, "end_line": 144, "content": ["@_with_exception(Skipped)\n", "def skip(msg: str = \"\", *, allow_module_level: bool = False) -> \"NoReturn\":\n", "    \"\"\"Skip an executing test with the given message.\n", "\n", "    This function should be called only during testing (setup, call or teardown) or\n", "    during collection by using the ``allow_module_level`` flag.  This function can\n", "    be called in doctests as well.\n", "\n", "    :param bool allow_module_level:\n", "        Allows this function to be called at module level, skipping the rest\n", "        of the module. Defaults to False.\n", "\n", "    .. note::\n", "        It is better to use the :ref:`pytest.mark.skipif ref` marker when\n", "        possible to declare a test to be skipped under certain conditions\n", "        like mismatching platforms or dependencies.\n", "        Similarly, use the ``# doctest: +SKIP`` directive (see `doctest.SKIP\n", "        <https://docs.python.org/3/library/how-to/doctest.html#doctest.SKIP>`_)\n", "        to skip a doctest statically.\n", "    \"\"\"\n", "    __tracebackhide__ = True\n", "    raise Skipped(msg=msg, allow_module_level=allow_module_level)\n"]}]}, {"file_path": "src/_pytest/python.py", "span_ids": ["Module._importtestmodule"], "content": [{"span_id": "Module._importtestmodule", "start_line": 572, "end_line": 617, "content": ["    def _importtestmodule(self):\n", "        # We assume we are only called once per module.\n", "        importmode = self.config.getoption(\"--import-mode\")\n", "        try:\n", "            mod = import_path(self.path, mode=importmode, root=self.config.rootpath)\n", "        except SyntaxError as e:\n", "            raise self.CollectError(\n", "                ExceptionInfo.from_current().getrepr(style=\"short\")\n", "            ) from e\n", "        except ImportPathMismatchError as e:\n", "            raise self.CollectError(\n", "                \"import file mismatch:\\n\"\n", "                \"imported module %r has this __file__ attribute:\\n\"\n", "                \"  %s\\n\"\n", "                \"which is not the same as the test file we want to collect:\\n\"\n", "                \"  %s\\n\"\n", "                \"HINT: remove __pycache__ / .pyc files and/or use a \"\n", "                \"unique basename for your test file modules\" % e.args\n", "            ) from e\n", "        except ImportError as e:\n", "            exc_info = ExceptionInfo.from_current()\n", "            if self.config.getoption(\"verbose\") < 2:\n", "                exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n", "            exc_repr = (\n", "                exc_info.getrepr(style=\"short\")\n", "                if exc_info.traceback\n", "                else exc_info.exconly()\n", "            )\n", "            formatted_tb = str(exc_repr)\n", "            raise self.CollectError(\n", "                \"ImportError while importing test module '{path}'.\\n\"\n", "                \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n", "                \"Traceback:\\n\"\n", "                \"{traceback}\".format(path=self.path, traceback=formatted_tb)\n", "            ) from e\n", "        except skip.Exception as e:\n", "            if e.allow_module_level:\n", "                raise\n", "            raise self.CollectError(\n", "                \"Using pytest.skip outside of a test is not allowed. \"\n", "                \"To decorate a test function, use the @pytest.mark.skip \"\n", "                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n", "                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n", "            ) from e\n", "        self.config.pluginmanager.consider_module(mod)\n", "        return mod\n"]}]}, {"file_path": "src/_pytest/skipping.py", "span_ids": ["evaluate_skip_marks"], "content": [{"span_id": "evaluate_skip_marks", "start_line": 167, "end_line": 192, "content": ["def evaluate_skip_marks(item: Item) -> Optional[Skip]:\n", "    \"\"\"Evaluate skip and skipif marks on item, returning Skip if triggered.\"\"\"\n", "    for mark in item.iter_markers(name=\"skipif\"):\n", "        if \"condition\" not in mark.kwargs:\n", "            conditions = mark.args\n", "        else:\n", "            conditions = (mark.kwargs[\"condition\"],)\n", "\n", "        # Unconditional.\n", "        if not conditions:\n", "            reason = mark.kwargs.get(\"reason\", \"\")\n", "            return Skip(reason)\n", "\n", "        # If any of the conditions are true.\n", "        for condition in conditions:\n", "            result, reason = evaluate_condition(item, mark, condition)\n", "            if result:\n", "                return Skip(reason)\n", "\n", "    for mark in item.iter_markers(name=\"skip\"):\n", "        try:\n", "            return Skip(*mark.args, **mark.kwargs)\n", "        except TypeError as e:\n", "            raise TypeError(str(e) + \" - maybe you meant pytest.mark.skipif?\") from None\n", "\n", "    return None\n"]}]}]}