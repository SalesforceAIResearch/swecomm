{"instance_id": "sympy__sympy-18199", "identified_spans": [{"file_path": "sympy/ntheory/residue_ntheory.py", "span_ids": ["sqrt_mod_iter", "sqrt_mod", "_nthroot_mod1", "nthroot_mod"], "content": [{"span_id": "sqrt_mod_iter", "start_line": 302, "end_line": 359, "content": ["def sqrt_mod_iter(a, p, domain=int):\n", "    \"\"\"\n", "    Iterate over solutions to ``x**2 = a mod p``\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    a : integer\n", "    p : positive integer\n", "    domain : integer domain, ``int``, ``ZZ`` or ``Integer``\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.ntheory.residue_ntheory import sqrt_mod_iter\n", "    >>> list(sqrt_mod_iter(11, 43))\n", "    [21, 22]\n", "    \"\"\"\n", "    from sympy.polys.galoistools import gf_crt1, gf_crt2\n", "    from sympy.polys.domains import ZZ\n", "    a, p = as_int(a), abs(as_int(p))\n", "    if isprime(p):\n", "        a = a % p\n", "        if a == 0:\n", "            res = _sqrt_mod1(a, p, 1)\n", "        else:\n", "            res = _sqrt_mod_prime_power(a, p, 1)\n", "        if res:\n", "            if domain is ZZ:\n", "                for x in res:\n", "                    yield x\n", "            else:\n", "                for x in res:\n", "                    yield domain(x)\n", "    else:\n", "        f = factorint(p)\n", "        v = []\n", "        pv = []\n", "        for px, ex in f.items():\n", "            if a % px == 0:\n", "                rx = _sqrt_mod1(a, px, ex)\n", "                if not rx:\n", "                    return\n", "            else:\n", "                rx = _sqrt_mod_prime_power(a, px, ex)\n", "                if not rx:\n", "                    return\n", "            v.append(rx)\n", "            pv.append(px**ex)\n", "        mm, e, s = gf_crt1(pv, ZZ)\n", "        if domain is ZZ:\n", "            for vx in _product(*v):\n", "                r = gf_crt2(vx, pv, mm, e, s, ZZ)\n", "                yield r\n", "        else:\n", "            for vx in _product(*v):\n", "                r = gf_crt2(vx, pv, mm, e, s, ZZ)\n", "                yield domain(r)\n"]}, {"span_id": "sqrt_mod", "start_line": 216, "end_line": 265, "content": ["def sqrt_mod(a, p, all_roots=False):\n", "    \"\"\"\n", "    Find a root of ``x**2 = a mod p``\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    a : integer\n", "    p : positive integer\n", "    all_roots : if True the list of roots is returned or None\n", "\n", "    Notes\n", "    =====\n", "\n", "    If there is no root it is returned None; else the returned root\n", "    is less or equal to ``p // 2``; in general is not the smallest one.\n", "    It is returned ``p // 2`` only if it is the only root.\n", "\n", "    Use ``all_roots`` only when it is expected that all the roots fit\n", "    in memory; otherwise use ``sqrt_mod_iter``.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.ntheory import sqrt_mod\n", "    >>> sqrt_mod(11, 43)\n", "    21\n", "    >>> sqrt_mod(17, 32, True)\n", "    [7, 9, 23, 25]\n", "    \"\"\"\n", "    if all_roots:\n", "        return sorted(list(sqrt_mod_iter(a, p)))\n", "    try:\n", "        p = abs(as_int(p))\n", "        it = sqrt_mod_iter(a, p)\n", "        r = next(it)\n", "        if r > p // 2:\n", "            return p - r\n", "        elif r < p // 2:\n", "            return r\n", "        else:\n", "            try:\n", "                r = next(it)\n", "                if r > p // 2:\n", "                    return p - r\n", "            except StopIteration:\n", "                pass\n", "            return r\n", "    except StopIteration:\n", "        return None\n"]}, {"span_id": "_nthroot_mod1", "start_line": 700, "end_line": 743, "content": ["def _nthroot_mod1(s, q, p, all_roots):\n", "    \"\"\"\n", "    Root of ``x**q = s mod p``, ``p`` prime and ``q`` divides ``p - 1``\n", "\n", "    References\n", "    ==========\n", "\n", "    .. [1] A. M. Johnston \"A Generalized qth Root Algorithm\"\n", "\n", "    \"\"\"\n", "    g = primitive_root(p)\n", "    if not isprime(q):\n", "        r = _nthroot_mod2(s, q, p)\n", "    else:\n", "        f = p - 1\n", "        assert (p - 1) % q == 0\n", "        # determine k\n", "        k = 0\n", "        while f % q == 0:\n", "            k += 1\n", "            f = f // q\n", "        # find z, x, r1\n", "        f1 = igcdex(-f, q)[0] % q\n", "        z = f*f1\n", "        x = (1 + z) // q\n", "        r1 = pow(s, x, p)\n", "        s1 = pow(s, f, p)\n", "        h = pow(g, f*q, p)\n", "        t = discrete_log(p, s1, h)\n", "        g2 = pow(g, z*t, p)\n", "        g3 = igcdex(g2, p)[0]\n", "        r = r1*g3 % p\n", "        #assert pow(r, q, p) == s\n", "    res = [r]\n", "    h = pow(g, (p - 1) // q, p)\n", "    #assert pow(h, q, p) == 1\n", "    hx = r\n", "    for i in range(q - 1):\n", "        hx = (hx*h) % p\n", "        res.append(hx)\n", "    if all_roots:\n", "        res.sort()\n", "        return res\n", "    return min(res)\n"]}, {"span_id": "nthroot_mod", "start_line": 746, "end_line": 807, "content": ["def nthroot_mod(a, n, p, all_roots=False):\n", "    \"\"\"\n", "    Find the solutions to ``x**n = a mod p``\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    a : integer\n", "    n : positive integer\n", "    p : positive integer\n", "    all_roots : if False returns the smallest root, else the list of roots\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.ntheory.residue_ntheory import nthroot_mod\n", "    >>> nthroot_mod(11, 4, 19)\n", "    8\n", "    >>> nthroot_mod(11, 4, 19, True)\n", "    [8, 11]\n", "    >>> nthroot_mod(68, 3, 109)\n", "    23\n", "    \"\"\"\n", "    from sympy.core.numbers import igcdex\n", "    a, n, p = as_int(a), as_int(n), as_int(p)\n", "    if n == 2:\n", "        return sqrt_mod(a, p, all_roots)\n", "    # see Hackman \"Elementary Number Theory\" (2009), page 76\n", "    if not is_nthpow_residue(a, n, p):\n", "        return None\n", "    if not isprime(p):\n", "        raise NotImplementedError(\"Not implemented for composite p\")\n", "\n", "    if (p - 1) % n == 0:\n", "        return _nthroot_mod1(a, n, p, all_roots)\n", "    # The roots of ``x**n - a = 0 (mod p)`` are roots of\n", "    # ``gcd(x**n - a, x**(p - 1) - 1) = 0 (mod p)``\n", "    pa = n\n", "    pb = p - 1\n", "    b = 1\n", "    if pa < pb:\n", "        a, pa, b, pb = b, pb, a, pa\n", "    while pb:\n", "        # x**pa - a = 0; x**pb - b = 0\n", "        # x**pa - a = x**(q*pb + r) - a = (x**pb)**q * x**r - a =\n", "        #             b**q * x**r - a; x**r - c = 0; c = b**-q * a mod p\n", "        q, r = divmod(pa, pb)\n", "        c = pow(b, q, p)\n", "        c = igcdex(c, p)[0]\n", "        c = (c * a) % p\n", "        pa, pb = pb, r\n", "        a, b = b, c\n", "    if pa == 1:\n", "        if all_roots:\n", "            res = [a]\n", "        else:\n", "            res = a\n", "    elif pa == 2:\n", "        return sqrt_mod(a, p , all_roots)\n", "    else:\n", "        res = _nthroot_mod1(a, pa, p, all_roots)\n", "    return res\n"]}]}]}