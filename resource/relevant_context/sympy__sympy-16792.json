{"instance_id": "sympy__sympy-16792", "identified_spans": [{"file_path": "sympy/utilities/autowrap.py", "span_ids": ["autowrap"], "content": [{"span_id": "autowrap", "start_line": 533, "end_line": 648, "content": ["@cacheit\n", "@doctest_depends_on(exe=('f2py', 'gfortran'), modules=('numpy',))\n", "def autowrap(expr, language=None, backend='f2py', tempdir=None, args=None,\n", "             flags=None, verbose=False, helpers=None, code_gen=None, **kwargs):\n", "    \"\"\"Generates python callable binaries based on the math expression.\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    expr\n", "        The SymPy expression that should be wrapped as a binary routine.\n", "    language : string, optional\n", "        If supplied, (options: 'C' or 'F95'), specifies the language of the\n", "        generated code. If ``None`` [default], the language is inferred based\n", "        upon the specified backend.\n", "    backend : string, optional\n", "        Backend used to wrap the generated code. Either 'f2py' [default],\n", "        or 'cython'.\n", "    tempdir : string, optional\n", "        Path to directory for temporary files. If this argument is supplied,\n", "        the generated code and the wrapper input files are left intact in the\n", "        specified path.\n", "    args : iterable, optional\n", "        An ordered iterable of symbols. Specifies the argument sequence for the\n", "        function.\n", "    flags : iterable, optional\n", "        Additional option flags that will be passed to the backend.\n", "    verbose : bool, optional\n", "        If True, autowrap will not mute the command line backends. This can be\n", "        helpful for debugging.\n", "    helpers : 3-tuple or iterable of 3-tuples, optional\n", "        Used to define auxiliary expressions needed for the main expr. If the\n", "        main expression needs to call a specialized function it should be\n", "        passed in via ``helpers``. Autowrap will then make sure that the\n", "        compiled main expression can link to the helper routine. Items should\n", "        be 3-tuples with (<function_name>, <sympy_expression>,\n", "        <argument_tuple>). It is mandatory to supply an argument sequence to\n", "        helper routines.\n", "    code_gen : CodeGen instance\n", "        An instance of a CodeGen subclass. Overrides ``language``.\n", "    include_dirs : [string]\n", "        A list of directories to search for C/C++ header files (in Unix form\n", "        for portability).\n", "    library_dirs : [string]\n", "        A list of directories to search for C/C++ libraries at link time.\n", "    libraries : [string]\n", "        A list of library names (not filenames or paths) to link against.\n", "    extra_compile_args : [string]\n", "        Any extra platform- and compiler-specific information to use when\n", "        compiling the source files in 'sources'.  For platforms and compilers\n", "        where \"command line\" makes sense, this is typically a list of\n", "        command-line arguments, but for other platforms it could be anything.\n", "    extra_link_args : [string]\n", "        Any extra platform- and compiler-specific information to use when\n", "        linking object files together to create the extension (or to create a\n", "        new static Python interpreter).  Similar interpretation as for\n", "        'extra_compile_args'.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.abc import x, y, z\n", "    >>> from sympy.utilities.autowrap import autowrap\n", "    >>> expr = ((x - y + z)**(13)).expand()\n", "    >>> binary_func = autowrap(expr)\n", "    >>> binary_func(1, 4, 2)\n", "    -1.0\n", "\n", "    \"\"\"\n", "    if language:\n", "        if not isinstance(language, type):\n", "            _validate_backend_language(backend, language)\n", "    else:\n", "        language = _infer_language(backend)\n", "\n", "    # two cases 1) helpers is an iterable of 3-tuples and 2) helpers is a\n", "    # 3-tuple\n", "    if iterable(helpers) and len(helpers) != 0 and iterable(helpers[0]):\n", "        helpers = helpers if helpers else ()\n", "    else:\n", "        helpers = [helpers] if helpers else ()\n", "    args = list(args) if iterable(args, exclude=set) else args\n", "\n", "    if code_gen is None:\n", "        code_gen = get_code_generator(language, \"autowrap\")\n", "\n", "    CodeWrapperClass = {\n", "        'F2PY': F2PyCodeWrapper,\n", "        'CYTHON': CythonCodeWrapper,\n", "        'DUMMY': DummyWrapper\n", "    }[backend.upper()]\n", "    code_wrapper = CodeWrapperClass(code_gen, tempdir, flags if flags else (),\n", "                                    verbose, **kwargs)\n", "\n", "    helps = []\n", "    for name_h, expr_h, args_h in helpers:\n", "        helps.append(code_gen.routine(name_h, expr_h, args_h))\n", "\n", "    for name_h, expr_h, args_h in helpers:\n", "        if expr.has(expr_h):\n", "            name_h = binary_function(name_h, expr_h, backend='dummy')\n", "            expr = expr.subs(expr_h, name_h(*args_h))\n", "    try:\n", "        routine = code_gen.routine('autofunc', expr, args)\n", "    except CodeGenArgumentListError as e:\n", "        # if all missing arguments are for pure output, we simply attach them\n", "        # at the end and try again, because the wrappers will silently convert\n", "        # them to return values anyway.\n", "        new_args = []\n", "        for missing in e.missing_args:\n", "            if not isinstance(missing, OutputArgument):\n", "                raise\n", "            new_args.append(missing.name)\n", "        routine = code_gen.routine('autofunc', expr, args + new_args)\n", "\n", "    return code_wrapper.wrap_code(routine, helpers=helps)\n"]}]}]}