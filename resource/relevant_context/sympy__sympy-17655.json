{"instance_id": "sympy__sympy-17655", "identified_spans": [{"file_path": "sympy/geometry/entity.py", "span_ids": ["GeometryEntity.__rmul__"], "content": [{"span_id": "GeometryEntity.__rmul__", "start_line": 140, "end_line": 142, "content": ["    def __rmul__(self, a):\n", "        \"\"\"Implementation of reverse multiplication method.\"\"\"\n", "        return a.__mul__(self)\n"]}]}, {"file_path": "sympy/geometry/point.py", "span_ids": ["Point.__mul__", "Point.__add__"], "content": [{"span_id": "Point.__mul__", "start_line": 250, "end_line": 279, "content": ["    def __mul__(self, factor):\n", "        \"\"\"Multiply point's coordinates by a factor.\n", "\n", "        Notes\n", "        =====\n", "\n", "        >>> from sympy.geometry.point import Point\n", "\n", "        When multiplying a Point by a floating point number,\n", "        the coordinates of the Point will be changed to Floats:\n", "\n", "        >>> Point(1, 2)*0.1\n", "        Point2D(0.1, 0.2)\n", "\n", "        If this is not desired, the `scale` method can be used or\n", "        else only multiply or divide by integers:\n", "\n", "        >>> Point(1, 2).scale(1.1, 1.1)\n", "        Point2D(11/10, 11/5)\n", "        >>> Point(1, 2)*11/10\n", "        Point2D(11/10, 11/5)\n", "\n", "        See Also\n", "        ========\n", "\n", "        sympy.geometry.point.Point.scale\n", "        \"\"\"\n", "        factor = sympify(factor)\n", "        coords = [simplify(x*factor) for x in self.args]\n", "        return Point(coords, evaluate=False)\n"]}, {"span_id": "Point.__add__", "start_line": 185, "end_line": 222, "content": ["    def __add__(self, other):\n", "        \"\"\"Add other to self by incrementing self's coordinates by\n", "        those of other.\n", "\n", "        Notes\n", "        =====\n", "\n", "        >>> from sympy.geometry.point import Point\n", "\n", "        When sequences of coordinates are passed to Point methods, they\n", "        are converted to a Point internally. This __add__ method does\n", "        not do that so if floating point values are used, a floating\n", "        point result (in terms of SymPy Floats) will be returned.\n", "\n", "        >>> Point(1, 2) + (.1, .2)\n", "        Point2D(1.1, 2.2)\n", "\n", "        If this is not desired, the `translate` method can be used or\n", "        another Point can be added:\n", "\n", "        >>> Point(1, 2).translate(.1, .2)\n", "        Point2D(11/10, 11/5)\n", "        >>> Point(1, 2) + Point(.1, .2)\n", "        Point2D(11/10, 11/5)\n", "\n", "        See Also\n", "        ========\n", "\n", "        sympy.geometry.point.Point.translate\n", "\n", "        \"\"\"\n", "        try:\n", "            s, o = Point._normalize_dimension(self, Point(other, evaluate=False))\n", "        except TypeError:\n", "            raise GeometryError(\"Don't know how to add {} and a Point object\".format(other))\n", "\n", "        coords = [simplify(a + b) for a, b in zip(s, o)]\n", "        return Point(coords, evaluate=False)\n"]}]}]}