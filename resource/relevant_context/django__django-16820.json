{"instance_id": "django__django-16820", "identified_spans": [{"file_path": "django/core/management/commands/squashmigrations.py", "span_ids": ["Command.handle"], "content": [{"span_id": "Command.handle", "start_line": 62, "end_line": 253, "content": ["    def handle(self, **options):\n", "        self.verbosity = options[\"verbosity\"]\n", "        self.interactive = options[\"interactive\"]\n", "        app_label = options[\"app_label\"]\n", "        start_migration_name = options[\"start_migration_name\"]\n", "        migration_name = options[\"migration_name\"]\n", "        no_optimize = options[\"no_optimize\"]\n", "        squashed_name = options[\"squashed_name\"]\n", "        include_header = options[\"include_header\"]\n", "        # Validate app_label.\n", "        try:\n", "            apps.get_app_config(app_label)\n", "        except LookupError as err:\n", "            raise CommandError(str(err))\n", "        # Load the current graph state, check the app and migration they asked\n", "        # for exists.\n", "        loader = MigrationLoader(connections[DEFAULT_DB_ALIAS])\n", "        if app_label not in loader.migrated_apps:\n", "            raise CommandError(\n", "                \"App '%s' does not have migrations (so squashmigrations on \"\n", "                \"it makes no sense)\" % app_label\n", "            )\n", "\n", "        migration = self.find_migration(loader, app_label, migration_name)\n", "\n", "        # Work out the list of predecessor migrations\n", "        migrations_to_squash = [\n", "            loader.get_migration(al, mn)\n", "            for al, mn in loader.graph.forwards_plan(\n", "                (migration.app_label, migration.name)\n", "            )\n", "            if al == migration.app_label\n", "        ]\n", "\n", "        if start_migration_name:\n", "            start_migration = self.find_migration(\n", "                loader, app_label, start_migration_name\n", "            )\n", "            start = loader.get_migration(\n", "                start_migration.app_label, start_migration.name\n", "            )\n", "            try:\n", "                start_index = migrations_to_squash.index(start)\n", "                migrations_to_squash = migrations_to_squash[start_index:]\n", "            except ValueError:\n", "                raise CommandError(\n", "                    \"The migration '%s' cannot be found. Maybe it comes after \"\n", "                    \"the migration '%s'?\\n\"\n", "                    \"Have a look at:\\n\"\n", "                    \"  python manage.py showmigrations %s\\n\"\n", "                    \"to debug this issue.\" % (start_migration, migration, app_label)\n", "                )\n", "\n", "        # Tell them what we're doing and optionally ask if we should proceed\n", "        if self.verbosity > 0 or self.interactive:\n", "            self.stdout.write(\n", "                self.style.MIGRATE_HEADING(\"Will squash the following migrations:\")\n", "            )\n", "            for migration in migrations_to_squash:\n", "                self.stdout.write(\" - %s\" % migration.name)\n", "\n", "            if self.interactive:\n", "                answer = None\n", "                while not answer or answer not in \"yn\":\n", "                    answer = input(\"Do you wish to proceed? [yN] \")\n", "                    if not answer:\n", "                        answer = \"n\"\n", "                        break\n", "                    else:\n", "                        answer = answer[0].lower()\n", "                if answer != \"y\":\n", "                    return\n", "\n", "        # Load the operations from all those migrations and concat together,\n", "        # along with collecting external dependencies and detecting\n", "        # double-squashing\n", "        operations = []\n", "        dependencies = set()\n", "        # We need to take all dependencies from the first migration in the list\n", "        # as it may be 0002 depending on 0001\n", "        first_migration = True\n", "        for smigration in migrations_to_squash:\n", "            if smigration.replaces:\n", "                raise CommandError(\n", "                    \"You cannot squash squashed migrations! Please transition it to a \"\n", "                    \"normal migration first: https://docs.djangoproject.com/en/%s/\"\n", "                    \"topics/migrations/#squashing-migrations\" % get_docs_version()\n", "                )\n", "            operations.extend(smigration.operations)\n", "            for dependency in smigration.dependencies:\n", "                if isinstance(dependency, SwappableTuple):\n", "                    if settings.AUTH_USER_MODEL == dependency.setting:\n", "                        dependencies.add((\"__setting__\", \"AUTH_USER_MODEL\"))\n", "                    else:\n", "                        dependencies.add(dependency)\n", "                elif dependency[0] != smigration.app_label or first_migration:\n", "                    dependencies.add(dependency)\n", "            first_migration = False\n", "\n", "        if no_optimize:\n", "            if self.verbosity > 0:\n", "                self.stdout.write(\n", "                    self.style.MIGRATE_HEADING(\"(Skipping optimization.)\")\n", "                )\n", "            new_operations = operations\n", "        else:\n", "            if self.verbosity > 0:\n", "                self.stdout.write(self.style.MIGRATE_HEADING(\"Optimizing...\"))\n", "\n", "            optimizer = MigrationOptimizer()\n", "            new_operations = optimizer.optimize(operations, migration.app_label)\n", "\n", "            if self.verbosity > 0:\n", "                if len(new_operations) == len(operations):\n", "                    self.stdout.write(\"  No optimizations possible.\")\n", "                else:\n", "                    self.stdout.write(\n", "                        \"  Optimized from %s operations to %s operations.\"\n", "                        % (len(operations), len(new_operations))\n", "                    )\n", "\n", "        # Work out the value of replaces (any squashed ones we're re-squashing)\n", "        # need to feed their replaces into ours\n", "        replaces = []\n", "        for migration in migrations_to_squash:\n", "            if migration.replaces:\n", "                replaces.extend(migration.replaces)\n", "            else:\n", "                replaces.append((migration.app_label, migration.name))\n", "\n", "        # Make a new migration with those operations\n", "        subclass = type(\n", "            \"Migration\",\n", "            (migrations.Migration,),\n", "            {\n", "                \"dependencies\": dependencies,\n", "                \"operations\": new_operations,\n", "                \"replaces\": replaces,\n", "            },\n", "        )\n", "        if start_migration_name:\n", "            if squashed_name:\n", "                # Use the name from --squashed-name.\n", "                prefix, _ = start_migration.name.split(\"_\", 1)\n", "                name = \"%s_%s\" % (prefix, squashed_name)\n", "            else:\n", "                # Generate a name.\n", "                name = \"%s_squashed_%s\" % (start_migration.name, migration.name)\n", "            new_migration = subclass(name, app_label)\n", "        else:\n", "            name = \"0001_%s\" % (squashed_name or \"squashed_%s\" % migration.name)\n", "            new_migration = subclass(name, app_label)\n", "            new_migration.initial = True\n", "\n", "        # Write out the new migration file\n", "        writer = MigrationWriter(new_migration, include_header)\n", "        if os.path.exists(writer.path):\n", "            raise CommandError(\n", "                f\"Migration {new_migration.name} already exists. Use a different name.\"\n", "            )\n", "        with open(writer.path, \"w\", encoding=\"utf-8\") as fh:\n", "            fh.write(writer.as_string())\n", "        run_formatters([writer.path])\n", "\n", "        if self.verbosity > 0:\n", "            self.stdout.write(\n", "                self.style.MIGRATE_HEADING(\n", "                    \"Created new squashed migration %s\" % writer.path\n", "                )\n", "                + \"\\n\"\n", "                \"  You should commit this migration but leave the old ones in place;\\n\"\n", "                \"  the new migration will be used for new installs. Once you are sure\\n\"\n", "                \"  all instances of the codebase have applied the migrations you \"\n", "                \"squashed,\\n\"\n", "                \"  you can delete them.\"\n", "            )\n", "            if writer.needs_manual_porting:\n", "                self.stdout.write(\n", "                    self.style.MIGRATE_HEADING(\"Manual porting required\") + \"\\n\"\n", "                    \"  Your migrations contained functions that must be manually \"\n", "                    \"copied over,\\n\"\n", "                    \"  as we could not safely copy their implementation.\\n\"\n", "                    \"  See the comment at the top of the squashed migration for \"\n", "                    \"details.\"\n", "                )\n", "                if shutil.which(\"black\"):\n", "                    self.stdout.write(\n", "                        self.style.WARNING(\n", "                            \"Squashed migration couldn't be formatted using the \"\n", "                            '\"black\" command. You can call it manually.'\n", "                        )\n", "                    )\n"]}]}, {"file_path": "django/db/migrations/autodetector.py", "span_ids": ["MigrationAutodetector.generate_altered_index_together", "MigrationAutodetector.generate_removed_altered_index_together"], "content": [{"span_id": "MigrationAutodetector.generate_altered_index_together", "start_line": 1547, "end_line": 1548, "content": ["    def generate_altered_index_together(self):\n", "        self._generate_altered_foo_together(operations.AlterIndexTogether)\n"]}, {"span_id": "MigrationAutodetector.generate_removed_altered_index_together", "start_line": 1524, "end_line": 1525, "content": ["    def generate_removed_altered_index_together(self):\n", "        self._generate_removed_altered_foo_together(operations.AlterIndexTogether)\n"]}]}, {"file_path": "django/db/migrations/optimizer.py", "span_ids": ["MigrationOptimizer.optimize_inner", "MigrationOptimizer.optimize"], "content": [{"span_id": "MigrationOptimizer.optimize_inner", "start_line": 40, "end_line": 69, "content": ["    def optimize_inner(self, operations, app_label):\n", "        \"\"\"Inner optimization loop.\"\"\"\n", "        new_operations = []\n", "        for i, operation in enumerate(operations):\n", "            right = True  # Should we reduce on the right or on the left.\n", "            # Compare it to each operation after it\n", "            for j, other in enumerate(operations[i + 1 :]):\n", "                result = operation.reduce(other, app_label)\n", "                if isinstance(result, list):\n", "                    in_between = operations[i + 1 : i + j + 1]\n", "                    if right:\n", "                        new_operations.extend(in_between)\n", "                        new_operations.extend(result)\n", "                    elif all(op.reduce(other, app_label) is True for op in in_between):\n", "                        # Perform a left reduction if all of the in-between\n", "                        # operations can optimize through other.\n", "                        new_operations.extend(result)\n", "                        new_operations.extend(in_between)\n", "                    else:\n", "                        # Otherwise keep trying.\n", "                        new_operations.append(operation)\n", "                        break\n", "                    new_operations.extend(operations[i + j + 2 :])\n", "                    return new_operations\n", "                elif not result:\n", "                    # Can't perform a right reduction.\n", "                    right = False\n", "            else:\n", "                new_operations.append(operation)\n", "        return new_operations\n"]}, {"span_id": "MigrationOptimizer.optimize", "start_line": 12, "end_line": 38, "content": ["    def optimize(self, operations, app_label):\n", "        \"\"\"\n", "        Main optimization entry point. Pass in a list of Operation instances,\n", "        get out a new list of Operation instances.\n", "\n", "        Unfortunately, due to the scope of the optimization (two combinable\n", "        operations might be separated by several hundred others), this can't be\n", "        done as a peephole optimization with checks/output implemented on\n", "        the Operations themselves; instead, the optimizer looks at each\n", "        individual operation and scans forwards in the list to see if there\n", "        are any matches, stopping at boundaries - operations which can't\n", "        be optimized over (RunSQL, operations on the same field/model, etc.)\n", "\n", "        The inner loop is run until the starting list is the same as the result\n", "        list, and then the result is returned. This means that operation\n", "        optimization must be stable and always return an equal or shorter list.\n", "        \"\"\"\n", "        # Internal tracking variable for test assertions about # of loops\n", "        if app_label is None:\n", "            raise TypeError(\"app_label must be a str.\")\n", "        self._iterations = 0\n", "        while True:\n", "            result = self.optimize_inner(operations, app_label)\n", "            self._iterations += 1\n", "            if result == operations:\n", "                return result\n", "            operations = result\n"]}]}]}