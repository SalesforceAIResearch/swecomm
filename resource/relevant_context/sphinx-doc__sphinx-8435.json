{"instance_id": "sphinx-doc__sphinx-8435", "identified_spans": [{"file_path": "sphinx/ext/autodoc/__init__.py", "span_ids": ["FunctionDocumenter.format_args", "setup", "FunctionDocumenter", "AttributeDocumenter", "AttributeDocumenter.add_directive_header"], "content": [{"span_id": "FunctionDocumenter.format_args", "start_line": 1255, "end_line": 1273, "content": ["    def format_args(self, **kwargs: Any) -> str:\n", "        if self.config.autodoc_typehints in ('none', 'description'):\n", "            kwargs.setdefault('show_annotation', False)\n", "\n", "        try:\n", "            self.env.app.emit('autodoc-before-process-signature', self.object, False)\n", "            sig = inspect.signature(self.object, type_aliases=self.config.autodoc_type_aliases)\n", "            args = stringify_signature(sig, **kwargs)\n", "        except TypeError as exc:\n", "            logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n", "                           self.fullname, exc)\n", "            return None\n", "        except ValueError:\n", "            args = ''\n", "\n", "        if self.config.strip_signature_backslash:\n", "            # escape backslashes for reST\n", "            args = args.replace('\\\\', '\\\\\\\\')\n", "        return args\n"]}, {"span_id": "setup", "start_line": 2304, "end_line": 2341, "content": ["def setup(app: Sphinx) -> Dict[str, Any]:\n", "    app.add_autodocumenter(ModuleDocumenter)\n", "    app.add_autodocumenter(ClassDocumenter)\n", "    app.add_autodocumenter(ExceptionDocumenter)\n", "    app.add_autodocumenter(DataDocumenter)\n", "    app.add_autodocumenter(DataDeclarationDocumenter)\n", "    app.add_autodocumenter(GenericAliasDocumenter)\n", "    app.add_autodocumenter(TypeVarDocumenter)\n", "    app.add_autodocumenter(FunctionDocumenter)\n", "    app.add_autodocumenter(DecoratorDocumenter)\n", "    app.add_autodocumenter(MethodDocumenter)\n", "    app.add_autodocumenter(AttributeDocumenter)\n", "    app.add_autodocumenter(PropertyDocumenter)\n", "    app.add_autodocumenter(InstanceAttributeDocumenter)\n", "    app.add_autodocumenter(SlotsAttributeDocumenter)\n", "\n", "    app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))\n", "    app.add_config_value('autodoc_member_order', 'alphabetical', True,\n", "                         ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))\n", "    app.add_config_value('autodoc_default_options', {}, True)\n", "    app.add_config_value('autodoc_docstring_signature', True, True)\n", "    app.add_config_value('autodoc_mock_imports', [], True)\n", "    app.add_config_value('autodoc_typehints', \"signature\", True,\n", "                         ENUM(\"signature\", \"description\", \"none\"))\n", "    app.add_config_value('autodoc_type_aliases', {}, True)\n", "    app.add_config_value('autodoc_warningiserror', True, True)\n", "    app.add_config_value('autodoc_inherit_docstrings', True, True)\n", "    app.add_event('autodoc-before-process-signature')\n", "    app.add_event('autodoc-process-docstring')\n", "    app.add_event('autodoc-process-signature')\n", "    app.add_event('autodoc-skip-member')\n", "\n", "    app.connect('config-inited', migrate_autodoc_member_order, priority=800)\n", "\n", "    app.setup_extension('sphinx.ext.autodoc.type_comment')\n", "    app.setup_extension('sphinx.ext.autodoc.typehints')\n", "\n", "    return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n"]}, {"span_id": "FunctionDocumenter", "start_line": 1241, "end_line": 1246, "content": ["class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n", "    \"\"\"\n", "    Specialized Documenter subclass for functions.\n", "    \"\"\"\n", "    objtype = 'function'\n", "    member_order = 30\n"]}, {"span_id": "AttributeDocumenter", "start_line": 2016, "end_line": 2027, "content": ["class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n", "    \"\"\"\n", "    Specialized Documenter subclass for attributes.\n", "    \"\"\"\n", "    objtype = 'attribute'\n", "    member_order = 60\n", "    option_spec = dict(ModuleLevelDocumenter.option_spec)\n", "    option_spec[\"annotation\"] = annotation_option\n", "\n", "    # must be higher than the MethodDocumenter, else it will recognize\n", "    # some non-data descriptors as methods\n", "    priority = 10\n"]}, {"span_id": "AttributeDocumenter.add_directive_header", "start_line": 2090, "end_line": 2131, "content": ["    def add_directive_header(self, sig: str) -> None:\n", "        super().add_directive_header(sig)\n", "        sourcename = self.get_sourcename()\n", "        if not self.options.annotation:\n", "            # obtain type annotation for this attribute\n", "            try:\n", "                annotations = get_type_hints(self.parent)\n", "            except NameError:\n", "                # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)\n", "                annotations = safe_getattr(self.parent, '__annotations__', {})\n", "            except TypeError:\n", "                annotations = {}\n", "            except KeyError:\n", "                # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)\n", "                annotations = {}\n", "            except AttributeError:\n", "                # AttributeError is raised on 3.5.2 (fixed by 3.5.3)\n", "                annotations = {}\n", "\n", "            if self.objpath[-1] in annotations:\n", "                objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n", "                self.add_line('   :type: ' + objrepr, sourcename)\n", "            else:\n", "                key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n", "                if self.analyzer and key in self.analyzer.annotations:\n", "                    self.add_line('   :type: ' + self.analyzer.annotations[key],\n", "                                  sourcename)\n", "\n", "            # data descriptors do not have useful values\n", "            if not self._datadescriptor:\n", "                try:\n", "                    if self.object is INSTANCEATTR:\n", "                        pass\n", "                    else:\n", "                        objrepr = object_description(self.object)\n", "                        self.add_line('   :value: ' + objrepr, sourcename)\n", "                except ValueError:\n", "                    pass\n", "        elif self.options.annotation is SUPPRESS:\n", "            pass\n", "        else:\n", "            self.add_line('   :annotation: %s' % self.options.annotation, sourcename)\n"]}]}]}