{"instance_id": "django__django-15202", "identified_spans": [{"file_path": "django/core/validators.py", "span_ids": ["URLValidator.__call__", "URLValidator"], "content": [{"span_id": "URLValidator.__call__", "start_line": 100, "end_line": 143, "content": ["    def __call__(self, value):\n", "        if not isinstance(value, str):\n", "            raise ValidationError(self.message, code=self.code, params={'value': value})\n", "        if self.unsafe_chars.intersection(value):\n", "            raise ValidationError(self.message, code=self.code, params={'value': value})\n", "        # Check if the scheme is valid.\n", "        scheme = value.split('://')[0].lower()\n", "        if scheme not in self.schemes:\n", "            raise ValidationError(self.message, code=self.code, params={'value': value})\n", "\n", "        # Then check full URL\n", "        try:\n", "            super().__call__(value)\n", "        except ValidationError as e:\n", "            # Trivial case failed. Try for possible IDN domain\n", "            if value:\n", "                try:\n", "                    scheme, netloc, path, query, fragment = urlsplit(value)\n", "                except ValueError:  # for example, \"Invalid IPv6 URL\"\n", "                    raise ValidationError(self.message, code=self.code, params={'value': value})\n", "                try:\n", "                    netloc = punycode(netloc)  # IDN -> ACE\n", "                except UnicodeError:  # invalid domain part\n", "                    raise e\n", "                url = urlunsplit((scheme, netloc, path, query, fragment))\n", "                super().__call__(url)\n", "            else:\n", "                raise\n", "        else:\n", "            # Now verify IPv6 in the netloc part\n", "            host_match = re.search(r'^\\[(.+)\\](?::\\d{1,5})?$', urlsplit(value).netloc)\n", "            if host_match:\n", "                potential_ip = host_match[1]\n", "                try:\n", "                    validate_ipv6_address(potential_ip)\n", "                except ValidationError:\n", "                    raise ValidationError(self.message, code=self.code, params={'value': value})\n", "\n", "        # The maximum length of a full host name is 253 characters per RFC 1034\n", "        # section 3.1. It's defined to be 255 bytes or less, but this includes\n", "        # one byte for the length of the name and one byte for the trailing dot\n", "        # that's used to indicate absolute names in DNS.\n", "        if len(urlsplit(value).hostname) > 253:\n", "            raise ValidationError(self.message, code=self.code, params={'value': value})\n"]}, {"span_id": "URLValidator", "start_line": 62, "end_line": 93, "content": ["@deconstructible\n", "class URLValidator(RegexValidator):\n", "    ul = '\\u00a1-\\uffff'  # Unicode letters range (must not be a raw string).\n", "\n", "    # IP patterns\n", "    ipv4_re = r'(?:0|25[0-5]|2[0-4]\\d|1\\d?\\d?|[1-9]\\d?)(?:\\.(?:0|25[0-5]|2[0-4]\\d|1\\d?\\d?|[1-9]\\d?)){3}'\n", "    ipv6_re = r'\\[[0-9a-f:.]+\\]'  # (simple regex, validated later)\n", "\n", "    # Host patterns\n", "    hostname_re = r'[a-z' + ul + r'0-9](?:[a-z' + ul + r'0-9-]{0,61}[a-z' + ul + r'0-9])?'\n", "    # Max length for domain name labels is 63 characters per RFC 1034 sec. 3.1\n", "    domain_re = r'(?:\\.(?!-)[a-z' + ul + r'0-9-]{1,63}(?<!-))*'\n", "    tld_re = (\n", "        r'\\.'                                # dot\n", "        r'(?!-)'                             # can't start with a dash\n", "        r'(?:[a-z' + ul + '-]{2,63}'         # domain label\n", "        r'|xn--[a-z0-9]{1,59})'              # or punycode label\n", "        r'(?<!-)'                            # can't end with a dash\n", "        r'\\.?'                               # may have a trailing dot\n", "    )\n", "    host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)'\n", "\n", "    regex = _lazy_re_compile(\n", "        r'^(?:[a-z0-9.+-]*)://'  # scheme is validated separately\n", "        r'(?:[^\\s:@/]+(?::[^\\s:@/]*)?@)?'  # user:pass authentication\n", "        r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'\n", "        r'(?::\\d{1,5})?'  # port\n", "        r'(?:[/?#][^\\s]*)?'  # resource path\n", "        r'\\Z', re.IGNORECASE)\n", "    message = _('Enter a valid URL.')\n", "    schemes = ['http', 'https', 'ftp', 'ftps']\n", "    unsafe_chars = frozenset('\\t\\r\\n')\n"]}]}, {"file_path": "django/forms/fields.py", "span_ids": ["Field.clean", "URLField.to_python", "URLField"], "content": [{"span_id": "Field.clean", "start_line": 144, "end_line": 152, "content": ["    def clean(self, value):\n", "        \"\"\"\n", "        Validate the given value and return its \"cleaned\" value as an\n", "        appropriate Python object. Raise ValidationError for any errors.\n", "        \"\"\"\n", "        value = self.to_python(value)\n", "        self.validate(value)\n", "        self.run_validators(value)\n", "        return value\n"]}, {"span_id": "URLField.to_python", "start_line": 681, "end_line": 710, "content": ["    def to_python(self, value):\n", "\n", "        def split_url(url):\n", "            \"\"\"\n", "            Return a list of url parts via urlparse.urlsplit(), or raise\n", "            ValidationError for some malformed URLs.\n", "            \"\"\"\n", "            try:\n", "                return list(urlsplit(url))\n", "            except ValueError:\n", "                # urlparse.urlsplit can raise a ValueError with some\n", "                # misformatted URLs.\n", "                raise ValidationError(self.error_messages['invalid'], code='invalid')\n", "\n", "        value = super().to_python(value)\n", "        if value:\n", "            url_fields = split_url(value)\n", "            if not url_fields[0]:\n", "                # If no URL scheme given, assume http://\n", "                url_fields[0] = 'http'\n", "            if not url_fields[1]:\n", "                # Assume that if no domain is provided, that the path segment\n", "                # contains the domain.\n", "                url_fields[1] = url_fields[2]\n", "                url_fields[2] = ''\n", "                # Rebuild the url_fields list, since the domain segment may now\n", "                # contain the path too.\n", "                url_fields = split_url(urlunsplit(url_fields))\n", "            value = urlunsplit(url_fields)\n", "        return value\n"]}, {"span_id": "URLField", "start_line": 671, "end_line": 676, "content": ["class URLField(CharField):\n", "    widget = URLInput\n", "    default_error_messages = {\n", "        'invalid': _('Enter a valid URL.'),\n", "    }\n", "    default_validators = [validators.URLValidator()]\n"]}]}]}