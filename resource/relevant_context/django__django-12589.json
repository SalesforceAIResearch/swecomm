{"instance_id": "django__django-12589", "identified_spans": [{"file_path": "django/db/models/query.py", "span_ids": ["QuerySet.annotate"], "content": [{"span_id": "QuerySet.annotate", "start_line": 1067, "end_line": 1112, "content": ["    def annotate(self, *args, **kwargs):\n", "        \"\"\"\n", "        Return a query set in which the returned objects have been annotated\n", "        with extra data or aggregations.\n", "        \"\"\"\n", "        self._not_support_combined_queries('annotate')\n", "        self._validate_values_are_expressions(args + tuple(kwargs.values()), method_name='annotate')\n", "        annotations = {}\n", "        for arg in args:\n", "            # The default_alias property may raise a TypeError.\n", "            try:\n", "                if arg.default_alias in kwargs:\n", "                    raise ValueError(\"The named annotation '%s' conflicts with the \"\n", "                                     \"default name for another annotation.\"\n", "                                     % arg.default_alias)\n", "            except TypeError:\n", "                raise TypeError(\"Complex annotations require an alias\")\n", "            annotations[arg.default_alias] = arg\n", "        annotations.update(kwargs)\n", "\n", "        clone = self._chain()\n", "        names = self._fields\n", "        if names is None:\n", "            names = set(chain.from_iterable(\n", "                (field.name, field.attname) if hasattr(field, 'attname') else (field.name,)\n", "                for field in self.model._meta.get_fields()\n", "            ))\n", "\n", "        for alias, annotation in annotations.items():\n", "            if alias in names:\n", "                raise ValueError(\"The annotation '%s' conflicts with a field on \"\n", "                                 \"the model.\" % alias)\n", "            if isinstance(annotation, FilteredRelation):\n", "                clone.query.add_filtered_relation(annotation, alias)\n", "            else:\n", "                clone.query.add_annotation(annotation, alias, is_summary=False)\n", "\n", "        for alias, annotation in clone.query.annotations.items():\n", "            if alias in annotations and annotation.contains_aggregate:\n", "                if clone._fields is None:\n", "                    clone.query.group_by = True\n", "                else:\n", "                    clone.query.set_group_by()\n", "                break\n", "\n", "        return clone\n"]}]}, {"file_path": "django/db/models/sql/compiler.py", "span_ids": ["SQLCompiler", "SQLCompiler.__init__", "SQLCompiler.get_group_by", "SQLCompiler.setup_query", "SQLCompiler.as_sql"], "content": [{"span_id": "SQLCompiler", "start_line": 21, "end_line": 21, "content": ["class SQLCompiler:\n"]}, {"span_id": "SQLCompiler.__init__", "start_line": 22, "end_line": 36, "content": ["    def __init__(self, query, connection, using):\n", "        self.query = query\n", "        self.connection = connection\n", "        self.using = using\n", "        self.quote_cache = {'*': '*'}\n", "        # The select, klass_info, and annotations are needed by QuerySet.iterator()\n", "        # these are set as a side-effect of executing the query. Note that we calculate\n", "        # separately a list of extra select columns needed for grammatical correctness\n", "        # of the query, but these columns are not included in self.select.\n", "        self.select = None\n", "        self.annotation_col_map = None\n", "        self.klass_info = None\n", "        # Multiline ordering SQL clause may appear from RawSQL.\n", "        self.ordering_parts = re.compile(r'^(.*)\\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)\n", "        self._meta_ordering = None\n"]}, {"span_id": "SQLCompiler.get_group_by", "start_line": 58, "end_line": 141, "content": ["    def get_group_by(self, select, order_by):\n", "        \"\"\"\n", "        Return a list of 2-tuples of form (sql, params).\n", "\n", "        The logic of what exactly the GROUP BY clause contains is hard\n", "        to describe in other words than \"if it passes the test suite,\n", "        then it is correct\".\n", "        \"\"\"\n", "        # Some examples:\n", "        #     SomeModel.objects.annotate(Count('somecol'))\n", "        #     GROUP BY: all fields of the model\n", "        #\n", "        #    SomeModel.objects.values('name').annotate(Count('somecol'))\n", "        #    GROUP BY: name\n", "        #\n", "        #    SomeModel.objects.annotate(Count('somecol')).values('name')\n", "        #    GROUP BY: all cols of the model\n", "        #\n", "        #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n", "        #    GROUP BY: name, pk\n", "        #\n", "        #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n", "        #    GROUP BY: name, pk\n", "        #\n", "        # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n", "        # can't be ever restricted to a smaller set, but additional columns in\n", "        # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n", "        # the end result is that it is impossible to force the query to have\n", "        # a chosen GROUP BY clause - you can almost do this by using the form:\n", "        #     .values(*wanted_cols).annotate(AnAggregate())\n", "        # but any later annotations, extra selects, values calls that\n", "        # refer some column outside of the wanted_cols, order_by, or even\n", "        # filter calls can alter the GROUP BY clause.\n", "\n", "        # The query.group_by is either None (no GROUP BY at all), True\n", "        # (group by select fields), or a list of expressions to be added\n", "        # to the group by.\n", "        if self.query.group_by is None:\n", "            return []\n", "        expressions = []\n", "        if self.query.group_by is not True:\n", "            # If the group by is set to a list (by .values() call most likely),\n", "            # then we need to add everything in it to the GROUP BY clause.\n", "            # Backwards compatibility hack for setting query.group_by. Remove\n", "            # when  we have public API way of forcing the GROUP BY clause.\n", "            # Converts string references to expressions.\n", "            for expr in self.query.group_by:\n", "                if not hasattr(expr, 'as_sql'):\n", "                    expressions.append(self.query.resolve_ref(expr))\n", "                else:\n", "                    expressions.append(expr)\n", "        # Note that even if the group_by is set, it is only the minimal\n", "        # set to group by. So, we need to add cols in select, order_by, and\n", "        # having into the select in any case.\n", "        ref_sources = {\n", "            expr.source for expr in expressions if isinstance(expr, Ref)\n", "        }\n", "        for expr, _, _ in select:\n", "            # Skip members of the select clause that are already included\n", "            # by reference.\n", "            if expr in ref_sources:\n", "                continue\n", "            cols = expr.get_group_by_cols()\n", "            for col in cols:\n", "                expressions.append(col)\n", "        for expr, (sql, params, is_ref) in order_by:\n", "            # Skip References to the select clause, as all expressions in the\n", "            # select clause are already part of the group by.\n", "            if not is_ref:\n", "                expressions.extend(expr.get_group_by_cols())\n", "        having_group_by = self.having.get_group_by_cols() if self.having else ()\n", "        for expr in having_group_by:\n", "            expressions.append(expr)\n", "        result = []\n", "        seen = set()\n", "        expressions = self.collapse_group_by(expressions, having_group_by)\n", "\n", "        for expr in expressions:\n", "            sql, params = self.compile(expr)\n", "            params_hash = make_hashable(params)\n", "            if (sql, params_hash) not in seen:\n", "                result.append((sql, params))\n", "                seen.add((sql, params_hash))\n", "        return result\n"]}, {"span_id": "SQLCompiler.setup_query", "start_line": 38, "end_line": 42, "content": ["    def setup_query(self):\n", "        if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):\n", "            self.query.get_initial_alias()\n", "        self.select, self.klass_info, self.annotation_col_map = self.get_select()\n", "        self.col_count = len(self.select)\n"]}, {"span_id": "SQLCompiler.as_sql", "start_line": 479, "end_line": 629, "content": ["    def as_sql(self, with_limits=True, with_col_aliases=False):\n", "        \"\"\"\n", "        Create the SQL for this query. Return the SQL string and list of\n", "        parameters.\n", "\n", "        If 'with_limits' is False, any limit/offset information is not included\n", "        in the query.\n", "        \"\"\"\n", "        refcounts_before = self.query.alias_refcount.copy()\n", "        try:\n", "            extra_select, order_by, group_by = self.pre_sql_setup()\n", "            for_update_part = None\n", "            # Is a LIMIT/OFFSET clause needed?\n", "            with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n", "            combinator = self.query.combinator\n", "            features = self.connection.features\n", "            if combinator:\n", "                if not getattr(features, 'supports_select_{}'.format(combinator)):\n", "                    raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n", "                result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n", "            else:\n", "                distinct_fields, distinct_params = self.get_distinct()\n", "                # This must come after 'select', 'ordering', and 'distinct'\n", "                # (see docstring of get_from_clause() for details).\n", "                from_, f_params = self.get_from_clause()\n", "                where, w_params = self.compile(self.where) if self.where is not None else (\"\", [])\n", "                having, h_params = self.compile(self.having) if self.having is not None else (\"\", [])\n", "                result = ['SELECT']\n", "                params = []\n", "\n", "                if self.query.distinct:\n", "                    distinct_result, distinct_params = self.connection.ops.distinct_sql(\n", "                        distinct_fields,\n", "                        distinct_params,\n", "                    )\n", "                    result += distinct_result\n", "                    params += distinct_params\n", "\n", "                out_cols = []\n", "                col_idx = 1\n", "                for _, (s_sql, s_params), alias in self.select + extra_select:\n", "                    if alias:\n", "                        s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n", "                    elif with_col_aliases:\n", "                        s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)\n", "                        col_idx += 1\n", "                    params.extend(s_params)\n", "                    out_cols.append(s_sql)\n", "\n", "                result += [', '.join(out_cols), 'FROM', *from_]\n", "                params.extend(f_params)\n", "\n", "                if self.query.select_for_update and self.connection.features.has_select_for_update:\n", "                    if self.connection.get_autocommit():\n", "                        raise TransactionManagementError('select_for_update cannot be used outside of a transaction.')\n", "\n", "                    if with_limit_offset and not self.connection.features.supports_select_for_update_with_limit:\n", "                        raise NotSupportedError(\n", "                            'LIMIT/OFFSET is not supported with '\n", "                            'select_for_update on this database backend.'\n", "                        )\n", "                    nowait = self.query.select_for_update_nowait\n", "                    skip_locked = self.query.select_for_update_skip_locked\n", "                    of = self.query.select_for_update_of\n", "                    # If it's a NOWAIT/SKIP LOCKED/OF query but the backend\n", "                    # doesn't support it, raise NotSupportedError to prevent a\n", "                    # possible deadlock.\n", "                    if nowait and not self.connection.features.has_select_for_update_nowait:\n", "                        raise NotSupportedError('NOWAIT is not supported on this database backend.')\n", "                    elif skip_locked and not self.connection.features.has_select_for_update_skip_locked:\n", "                        raise NotSupportedError('SKIP LOCKED is not supported on this database backend.')\n", "                    elif of and not self.connection.features.has_select_for_update_of:\n", "                        raise NotSupportedError('FOR UPDATE OF is not supported on this database backend.')\n", "                    for_update_part = self.connection.ops.for_update_sql(\n", "                        nowait=nowait,\n", "                        skip_locked=skip_locked,\n", "                        of=self.get_select_for_update_of_arguments(),\n", "                    )\n", "\n", "                if for_update_part and self.connection.features.for_update_after_from:\n", "                    result.append(for_update_part)\n", "\n", "                if where:\n", "                    result.append('WHERE %s' % where)\n", "                    params.extend(w_params)\n", "\n", "                grouping = []\n", "                for g_sql, g_params in group_by:\n", "                    grouping.append(g_sql)\n", "                    params.extend(g_params)\n", "                if grouping:\n", "                    if distinct_fields:\n", "                        raise NotImplementedError('annotate() + distinct(fields) is not implemented.')\n", "                    order_by = order_by or self.connection.ops.force_no_ordering()\n", "                    result.append('GROUP BY %s' % ', '.join(grouping))\n", "                    if self._meta_ordering:\n", "                        order_by = None\n", "                if having:\n", "                    result.append('HAVING %s' % having)\n", "                    params.extend(h_params)\n", "\n", "            if self.query.explain_query:\n", "                result.insert(0, self.connection.ops.explain_query_prefix(\n", "                    self.query.explain_format,\n", "                    **self.query.explain_options\n", "                ))\n", "\n", "            if order_by:\n", "                ordering = []\n", "                for _, (o_sql, o_params, _) in order_by:\n", "                    ordering.append(o_sql)\n", "                    params.extend(o_params)\n", "                result.append('ORDER BY %s' % ', '.join(ordering))\n", "\n", "            if with_limit_offset:\n", "                result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))\n", "\n", "            if for_update_part and not self.connection.features.for_update_after_from:\n", "                result.append(for_update_part)\n", "\n", "            if self.query.subquery and extra_select:\n", "                # If the query is used as a subquery, the extra selects would\n", "                # result in more columns than the left-hand side expression is\n", "                # expecting. This can happen when a subquery uses a combination\n", "                # of order_by() and distinct(), forcing the ordering expressions\n", "                # to be selected as well. Wrap the query in another subquery\n", "                # to exclude extraneous selects.\n", "                sub_selects = []\n", "                sub_params = []\n", "                for index, (select, _, alias) in enumerate(self.select, start=1):\n", "                    if not alias and with_col_aliases:\n", "                        alias = 'col%d' % index\n", "                    if alias:\n", "                        sub_selects.append(\"%s.%s\" % (\n", "                            self.connection.ops.quote_name('subquery'),\n", "                            self.connection.ops.quote_name(alias),\n", "                        ))\n", "                    else:\n", "                        select_clone = select.relabeled_clone({select.alias: 'subquery'})\n", "                        subselect, subparams = select_clone.as_sql(self, self.connection)\n", "                        sub_selects.append(subselect)\n", "                        sub_params.extend(subparams)\n", "                return 'SELECT %s FROM (%s) subquery' % (\n", "                    ', '.join(sub_selects),\n", "                    ' '.join(result),\n", "                ), tuple(sub_params + params)\n", "\n", "            return ' '.join(result), tuple(params)\n", "        finally:\n", "            # Finally do cleanup - get rid of the joins we created above.\n", "            self.query.reset_refcounts(refcounts_before)\n"]}]}, {"file_path": "django/db/models/sql/query.py", "span_ids": ["Query.solve_lookup_type", "Query.add_annotation", "Query", "Query.__init__"], "content": [{"span_id": "Query.solve_lookup_type", "start_line": 1076, "end_line": 1092, "content": ["    def solve_lookup_type(self, lookup):\n", "        \"\"\"\n", "        Solve the lookup type from the lookup (e.g.: 'foobar__id__icontains').\n", "        \"\"\"\n", "        lookup_splitted = lookup.split(LOOKUP_SEP)\n", "        if self.annotations:\n", "            expression, expression_lookups = refs_expression(lookup_splitted, self.annotations)\n", "            if expression:\n", "                return expression_lookups, (), expression\n", "        _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())\n", "        field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]\n", "        if len(lookup_parts) > 1 and not field_parts:\n", "            raise FieldError(\n", "                'Invalid lookup \"%s\" for model %s\".' %\n", "                (lookup, self.get_meta().model.__name__)\n", "            )\n", "        return lookup_parts, field_parts, False\n"]}, {"span_id": "Query.add_annotation", "start_line": 1017, "end_line": 1022, "content": ["    def add_annotation(self, annotation, alias, is_summary=False):\n", "        \"\"\"Add a single annotation expression to the Query.\"\"\"\n", "        annotation = annotation.resolve_expression(self, allow_joins=True, reuse=None,\n", "                                                   summarize=is_summary)\n", "        self.append_annotation_mask([alias])\n", "        self.annotations[alias] = annotation\n"]}, {"span_id": "Query", "start_line": 138, "end_line": 144, "content": ["class Query(BaseExpression):\n", "    \"\"\"A single SQL query.\"\"\"\n", "\n", "    alias_prefix = 'T'\n", "    subq_aliases = frozenset([alias_prefix])\n", "\n", "    compiler = 'SQLCompiler'\n"]}, {"span_id": "Query.__init__", "start_line": 146, "end_line": 231, "content": ["    def __init__(self, model, where=WhereNode, alias_cols=True):\n", "        self.model = model\n", "        self.alias_refcount = {}\n", "        # alias_map is the most important data structure regarding joins.\n", "        # It's used for recording which joins exist in the query and what\n", "        # types they are. The key is the alias of the joined table (possibly\n", "        # the table name) and the value is a Join-like object (see\n", "        # sql.datastructures.Join for more information).\n", "        self.alias_map = {}\n", "        # Whether to provide alias to columns during reference resolving.\n", "        self.alias_cols = alias_cols\n", "        # Sometimes the query contains references to aliases in outer queries (as\n", "        # a result of split_exclude). Correct alias quoting needs to know these\n", "        # aliases too.\n", "        # Map external tables to whether they are aliased.\n", "        self.external_aliases = {}\n", "        self.table_map = {}     # Maps table names to list of aliases.\n", "        self.default_cols = True\n", "        self.default_ordering = True\n", "        self.standard_ordering = True\n", "        self.used_aliases = set()\n", "        self.filter_is_sticky = False\n", "        self.subquery = False\n", "\n", "        # SQL-related attributes\n", "        # Select and related select clauses are expressions to use in the\n", "        # SELECT clause of the query.\n", "        # The select is used for cases where we want to set up the select\n", "        # clause to contain other than default fields (values(), subqueries...)\n", "        # Note that annotations go to annotations dictionary.\n", "        self.select = ()\n", "        self.where = where()\n", "        self.where_class = where\n", "        # The group_by attribute can have one of the following forms:\n", "        #  - None: no group by at all in the query\n", "        #  - A tuple of expressions: group by (at least) those expressions.\n", "        #    String refs are also allowed for now.\n", "        #  - True: group by all select fields of the model\n", "        # See compiler.get_group_by() for details.\n", "        self.group_by = None\n", "        self.order_by = ()\n", "        self.low_mark, self.high_mark = 0, None  # Used for offset/limit\n", "        self.distinct = False\n", "        self.distinct_fields = ()\n", "        self.select_for_update = False\n", "        self.select_for_update_nowait = False\n", "        self.select_for_update_skip_locked = False\n", "        self.select_for_update_of = ()\n", "\n", "        self.select_related = False\n", "        # Arbitrary limit for select_related to prevents infinite recursion.\n", "        self.max_depth = 5\n", "\n", "        # Holds the selects defined by a call to values() or values_list()\n", "        # excluding annotation_select and extra_select.\n", "        self.values_select = ()\n", "\n", "        # SQL annotation-related attributes\n", "        self.annotations = {}  # Maps alias -> Annotation Expression\n", "        self.annotation_select_mask = None\n", "        self._annotation_select_cache = None\n", "\n", "        # Set combination attributes\n", "        self.combinator = None\n", "        self.combinator_all = False\n", "        self.combined_queries = ()\n", "\n", "        # These are for extensions. The contents are more or less appended\n", "        # verbatim to the appropriate clause.\n", "        self.extra = {}  # Maps col_alias -> (col_sql, params).\n", "        self.extra_select_mask = None\n", "        self._extra_select_cache = None\n", "\n", "        self.extra_tables = ()\n", "        self.extra_order_by = ()\n", "\n", "        # A tuple that is a set of model field names and either True, if these\n", "        # are the fields to defer, or False if these are the only fields to\n", "        # load.\n", "        self.deferred_loading = (frozenset(), True)\n", "\n", "        self._filtered_relations = {}\n", "\n", "        self.explain_query = False\n", "        self.explain_format = None\n", "        self.explain_options = {}\n"]}]}]}