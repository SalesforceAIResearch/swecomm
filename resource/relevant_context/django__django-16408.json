{"instance_id": "django__django-16408", "identified_spans": [{"file_path": "django/db/models/query.py", "span_ids": ["Query.add_select_related", "QuerySet.select_related", "Query.get_select_mask"], "content": [{"span_id": "QuerySet.select_related", "start_line": 1522, "end_line": 1544, "content": ["    def select_related(self, *fields):\n", "        \"\"\"\n", "        Return a new QuerySet instance that will select related objects.\n", "\n", "        If fields are specified, they must be ForeignKey fields and only those\n", "        related objects are included in the selection.\n", "\n", "        If select_related(None) is called, clear the list.\n", "        \"\"\"\n", "        self._not_support_combined_queries(\"select_related\")\n", "        if self._fields is not None:\n", "            raise TypeError(\n", "                \"Cannot call select_related() after .values() or .values_list()\"\n", "            )\n", "\n", "        obj = self._chain()\n", "        if fields == (None,):\n", "            obj.query.select_related = False\n", "        elif fields:\n", "            obj.query.add_select_related(fields)\n", "        else:\n", "            obj.query.select_related = True\n", "        return obj\n"]}]}, {"file_path": "django/db/models/query_utils.py", "span_ids": ["FilteredRelation"], "content": [{"span_id": "FilteredRelation", "start_line": 396, "end_line": 397, "content": ["class FilteredRelation:\n", "    \"\"\"Specify custom filtering in the ON clause of SQL joins.\"\"\"\n"]}]}, {"file_path": "django/db/models/sql/compiler.py", "span_ids": ["SQLCompiler.get_related_selections"], "content": [{"span_id": "SQLCompiler.get_related_selections", "start_line": 1112, "end_line": 1337, "content": ["    def get_related_selections(\n", "        self,\n", "        select,\n", "        select_mask,\n", "        opts=None,\n", "        root_alias=None,\n", "        cur_depth=1,\n", "        requested=None,\n", "        restricted=None,\n", "    ):\n", "        \"\"\"\n", "        Fill in the information needed for a select_related query. The current\n", "        depth is measured as the number of connections away from the root model\n", "        (for example, cur_depth=1 means we are looking at models with direct\n", "        connections to the root model).\n", "        \"\"\"\n", "\n", "        def _get_field_choices():\n", "            direct_choices = (f.name for f in opts.fields if f.is_relation)\n", "            reverse_choices = (\n", "                f.field.related_query_name()\n", "                for f in opts.related_objects\n", "                if f.field.unique\n", "            )\n", "            return chain(\n", "                direct_choices, reverse_choices, self.query._filtered_relations\n", "            )\n", "\n", "        related_klass_infos = []\n", "        if not restricted and cur_depth > self.query.max_depth:\n", "            # We've recursed far enough; bail out.\n", "            return related_klass_infos\n", "\n", "        if not opts:\n", "            opts = self.query.get_meta()\n", "            root_alias = self.query.get_initial_alias()\n", "\n", "        # Setup for the case when only particular related fields should be\n", "        # included in the related selection.\n", "        fields_found = set()\n", "        if requested is None:\n", "            restricted = isinstance(self.query.select_related, dict)\n", "            if restricted:\n", "                requested = self.query.select_related\n", "\n", "        def get_related_klass_infos(klass_info, related_klass_infos):\n", "            klass_info[\"related_klass_infos\"] = related_klass_infos\n", "\n", "        for f in opts.fields:\n", "            fields_found.add(f.name)\n", "\n", "            if restricted:\n", "                next = requested.get(f.name, {})\n", "                if not f.is_relation:\n", "                    # If a non-related field is used like a relation,\n", "                    # or if a single non-relational field is given.\n", "                    if next or f.name in requested:\n", "                        raise FieldError(\n", "                            \"Non-relational field given in select_related: '%s'. \"\n", "                            \"Choices are: %s\"\n", "                            % (\n", "                                f.name,\n", "                                \", \".join(_get_field_choices()) or \"(none)\",\n", "                            )\n", "                        )\n", "            else:\n", "                next = False\n", "\n", "            if not select_related_descend(f, restricted, requested, select_mask):\n", "                continue\n", "            related_select_mask = select_mask.get(f) or {}\n", "            klass_info = {\n", "                \"model\": f.remote_field.model,\n", "                \"field\": f,\n", "                \"reverse\": False,\n", "                \"local_setter\": f.set_cached_value,\n", "                \"remote_setter\": f.remote_field.set_cached_value\n", "                if f.unique\n", "                else lambda x, y: None,\n", "                \"from_parent\": False,\n", "            }\n", "            related_klass_infos.append(klass_info)\n", "            select_fields = []\n", "            _, _, _, joins, _, _ = self.query.setup_joins([f.name], opts, root_alias)\n", "            alias = joins[-1]\n", "            columns = self.get_default_columns(\n", "                related_select_mask, start_alias=alias, opts=f.remote_field.model._meta\n", "            )\n", "            for col in columns:\n", "                select_fields.append(len(select))\n", "                select.append((col, None))\n", "            klass_info[\"select_fields\"] = select_fields\n", "            next_klass_infos = self.get_related_selections(\n", "                select,\n", "                related_select_mask,\n", "                f.remote_field.model._meta,\n", "                alias,\n", "                cur_depth + 1,\n", "                next,\n", "                restricted,\n", "            )\n", "            get_related_klass_infos(klass_info, next_klass_infos)\n", "\n", "        if restricted:\n", "            related_fields = [\n", "                (o.field, o.related_model)\n", "                for o in opts.related_objects\n", "                if o.field.unique and not o.many_to_many\n", "            ]\n", "            for related_field, model in related_fields:\n", "                related_select_mask = select_mask.get(related_field) or {}\n", "                if not select_related_descend(\n", "                    related_field,\n", "                    restricted,\n", "                    requested,\n", "                    related_select_mask,\n", "                    reverse=True,\n", "                ):\n", "                    continue\n", "\n", "                related_field_name = related_field.related_query_name()\n", "                fields_found.add(related_field_name)\n", "\n", "                join_info = self.query.setup_joins(\n", "                    [related_field_name], opts, root_alias\n", "                )\n", "                alias = join_info.joins[-1]\n", "                from_parent = issubclass(model, opts.model) and model is not opts.model\n", "                klass_info = {\n", "                    \"model\": model,\n", "                    \"field\": related_field,\n", "                    \"reverse\": True,\n", "                    \"local_setter\": related_field.remote_field.set_cached_value,\n", "                    \"remote_setter\": related_field.set_cached_value,\n", "                    \"from_parent\": from_parent,\n", "                }\n", "                related_klass_infos.append(klass_info)\n", "                select_fields = []\n", "                columns = self.get_default_columns(\n", "                    related_select_mask,\n", "                    start_alias=alias,\n", "                    opts=model._meta,\n", "                    from_parent=opts.model,\n", "                )\n", "                for col in columns:\n", "                    select_fields.append(len(select))\n", "                    select.append((col, None))\n", "                klass_info[\"select_fields\"] = select_fields\n", "                next = requested.get(related_field.related_query_name(), {})\n", "                next_klass_infos = self.get_related_selections(\n", "                    select,\n", "                    related_select_mask,\n", "                    model._meta,\n", "                    alias,\n", "                    cur_depth + 1,\n", "                    next,\n", "                    restricted,\n", "                )\n", "                get_related_klass_infos(klass_info, next_klass_infos)\n", "\n", "            def local_setter(final_field, obj, from_obj):\n", "                # Set a reverse fk object when relation is non-empty.\n", "                if from_obj:\n", "                    final_field.remote_field.set_cached_value(from_obj, obj)\n", "\n", "            def remote_setter(name, obj, from_obj):\n", "                setattr(from_obj, name, obj)\n", "\n", "            for name in list(requested):\n", "                # Filtered relations work only on the topmost level.\n", "                if cur_depth > 1:\n", "                    break\n", "                if name in self.query._filtered_relations:\n", "                    fields_found.add(name)\n", "                    final_field, _, join_opts, joins, _, _ = self.query.setup_joins(\n", "                        [name], opts, root_alias\n", "                    )\n", "                    model = join_opts.model\n", "                    alias = joins[-1]\n", "                    from_parent = (\n", "                        issubclass(model, opts.model) and model is not opts.model\n", "                    )\n", "                    klass_info = {\n", "                        \"model\": model,\n", "                        \"field\": final_field,\n", "                        \"reverse\": True,\n", "                        \"local_setter\": partial(local_setter, final_field),\n", "                        \"remote_setter\": partial(remote_setter, name),\n", "                        \"from_parent\": from_parent,\n", "                    }\n", "                    related_klass_infos.append(klass_info)\n", "                    select_fields = []\n", "                    field_select_mask = select_mask.get((name, final_field)) or {}\n", "                    columns = self.get_default_columns(\n", "                        field_select_mask,\n", "                        start_alias=alias,\n", "                        opts=model._meta,\n", "                        from_parent=opts.model,\n", "                    )\n", "                    for col in columns:\n", "                        select_fields.append(len(select))\n", "                        select.append((col, None))\n", "                    klass_info[\"select_fields\"] = select_fields\n", "                    next_requested = requested.get(name, {})\n", "                    next_klass_infos = self.get_related_selections(\n", "                        select,\n", "                        field_select_mask,\n", "                        opts=model._meta,\n", "                        root_alias=alias,\n", "                        cur_depth=cur_depth + 1,\n", "                        requested=next_requested,\n", "                        restricted=restricted,\n", "                    )\n", "                    get_related_klass_infos(klass_info, next_klass_infos)\n", "            fields_not_found = set(requested).difference(fields_found)\n", "            if fields_not_found:\n", "                invalid_fields = (\"'%s'\" % s for s in fields_not_found)\n", "                raise FieldError(\n", "                    \"Invalid field name(s) given in select_related: %s. \"\n", "                    \"Choices are: %s\"\n", "                    % (\n", "                        \", \".join(invalid_fields),\n", "                        \", \".join(_get_field_choices()) or \"(none)\",\n", "                    )\n", "                )\n", "        return related_klass_infos\n"]}]}]}