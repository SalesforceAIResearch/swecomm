{"instance_id": "sphinx-doc__sphinx-10451", "identified_spans": [{"file_path": "sphinx/ext/autodoc/__init__.py", "span_ids": ["FunctionDocumenter", "MethodDocumenter.format_signature", "MethodDocumenter.format_args", "MethodDocumenter", "FunctionDocumenter.format_signature", "FunctionDocumenter.format_args"], "content": [{"span_id": "FunctionDocumenter", "start_line": 1253, "end_line": 1258, "content": ["class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n", "    \"\"\"\n", "    Specialized Documenter subclass for functions.\n", "    \"\"\"\n", "    objtype = 'function'\n", "    member_order = 30\n"]}, {"span_id": "MethodDocumenter.format_signature", "start_line": 2184, "end_line": 2234, "content": ["    def format_signature(self, **kwargs: Any) -> str:\n", "        if self.config.autodoc_typehints_format == \"short\":\n", "            kwargs.setdefault('unqualified_typehints', True)\n", "\n", "        sigs = []\n", "        if (self.analyzer and\n", "                '.'.join(self.objpath) in self.analyzer.overloads and\n", "                self.config.autodoc_typehints != 'none'):\n", "            # Use signatures for overloaded methods instead of the implementation method.\n", "            overloaded = True\n", "        else:\n", "            overloaded = False\n", "            sig = super().format_signature(**kwargs)\n", "            sigs.append(sig)\n", "\n", "        meth = self.parent.__dict__.get(self.objpath[-1])\n", "        if inspect.is_singledispatch_method(meth):\n", "            # append signature of singledispatch'ed functions\n", "            for typ, func in meth.dispatcher.registry.items():\n", "                if typ is object:\n", "                    pass  # default implementation. skipped.\n", "                else:\n", "                    dispatchmeth = self.annotate_to_first_argument(func, typ)\n", "                    if dispatchmeth:\n", "                        documenter = MethodDocumenter(self.directive, '')\n", "                        documenter.parent = self.parent\n", "                        documenter.object = dispatchmeth\n", "                        documenter.objpath = [None]\n", "                        sigs.append(documenter.format_signature())\n", "        if overloaded:\n", "            if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n", "                actual = inspect.signature(self.object, bound_method=False,\n", "                                           type_aliases=self.config.autodoc_type_aliases)\n", "            else:\n", "                actual = inspect.signature(self.object, bound_method=True,\n", "                                           type_aliases=self.config.autodoc_type_aliases)\n", "\n", "            __globals__ = safe_getattr(self.object, '__globals__', {})\n", "            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n", "                overload = self.merge_default_value(actual, overload)\n", "                overload = evaluate_signature(overload, __globals__,\n", "                                              self.config.autodoc_type_aliases)\n", "\n", "                if not inspect.isstaticmethod(self.object, cls=self.parent,\n", "                                              name=self.object_name):\n", "                    parameters = list(overload.parameters.values())\n", "                    overload = overload.replace(parameters=parameters[1:])\n", "                sig = stringify_signature(overload, **kwargs)\n", "                sigs.append(sig)\n", "\n", "        return \"\\n\".join(sigs)\n"]}, {"span_id": "MethodDocumenter.format_args", "start_line": 2130, "end_line": 2163, "content": ["    def format_args(self, **kwargs: Any) -> str:\n", "        if self.config.autodoc_typehints in ('none', 'description'):\n", "            kwargs.setdefault('show_annotation', False)\n", "        if self.config.autodoc_typehints_format == \"short\":\n", "            kwargs.setdefault('unqualified_typehints', True)\n", "\n", "        try:\n", "            if self.object == object.__init__ and self.parent != object:\n", "                # Classes not having own __init__() method are shown as no arguments.\n", "                #\n", "                # Note: The signature of object.__init__() is (self, /, *args, **kwargs).\n", "                #       But it makes users confused.\n", "                args = '()'\n", "            else:\n", "                if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n", "                    self.env.app.emit('autodoc-before-process-signature', self.object, False)\n", "                    sig = inspect.signature(self.object, bound_method=False,\n", "                                            type_aliases=self.config.autodoc_type_aliases)\n", "                else:\n", "                    self.env.app.emit('autodoc-before-process-signature', self.object, True)\n", "                    sig = inspect.signature(self.object, bound_method=True,\n", "                                            type_aliases=self.config.autodoc_type_aliases)\n", "                args = stringify_signature(sig, **kwargs)\n", "        except TypeError as exc:\n", "            logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n", "                           self.fullname, exc)\n", "            return None\n", "        except ValueError:\n", "            args = ''\n", "\n", "        if self.config.strip_signature_backslash:\n", "            # escape backslashes for reST\n", "            args = args.replace('\\\\', '\\\\\\\\')\n", "        return args\n"]}, {"span_id": "MethodDocumenter", "start_line": 2099, "end_line": 2106, "content": ["class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore\n", "    \"\"\"\n", "    Specialized Documenter subclass for methods (normal, static and class).\n", "    \"\"\"\n", "    objtype = 'method'\n", "    directivetype = 'method'\n", "    member_order = 50\n", "    priority = 1  # must be more than FunctionDocumenter\n"]}, {"span_id": "FunctionDocumenter.format_signature", "start_line": 1299, "end_line": 1338, "content": ["    def format_signature(self, **kwargs: Any) -> str:\n", "        if self.config.autodoc_typehints_format == \"short\":\n", "            kwargs.setdefault('unqualified_typehints', True)\n", "\n", "        sigs = []\n", "        if (self.analyzer and\n", "                '.'.join(self.objpath) in self.analyzer.overloads and\n", "                self.config.autodoc_typehints != 'none'):\n", "            # Use signatures for overloaded functions instead of the implementation function.\n", "            overloaded = True\n", "        else:\n", "            overloaded = False\n", "            sig = super().format_signature(**kwargs)\n", "            sigs.append(sig)\n", "\n", "        if inspect.is_singledispatch_function(self.object):\n", "            # append signature of singledispatch'ed functions\n", "            for typ, func in self.object.registry.items():\n", "                if typ is object:\n", "                    pass  # default implementation. skipped.\n", "                else:\n", "                    dispatchfunc = self.annotate_to_first_argument(func, typ)\n", "                    if dispatchfunc:\n", "                        documenter = FunctionDocumenter(self.directive, '')\n", "                        documenter.object = dispatchfunc\n", "                        documenter.objpath = [None]\n", "                        sigs.append(documenter.format_signature())\n", "        if overloaded:\n", "            actual = inspect.signature(self.object,\n", "                                       type_aliases=self.config.autodoc_type_aliases)\n", "            __globals__ = safe_getattr(self.object, '__globals__', {})\n", "            for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n", "                overload = self.merge_default_value(actual, overload)\n", "                overload = evaluate_signature(overload, __globals__,\n", "                                              self.config.autodoc_type_aliases)\n", "\n", "                sig = stringify_signature(overload, **kwargs)\n", "                sigs.append(sig)\n", "\n", "        return \"\\n\".join(sigs)\n"]}, {"span_id": "FunctionDocumenter.format_args", "start_line": 1267, "end_line": 1287, "content": ["    def format_args(self, **kwargs: Any) -> str:\n", "        if self.config.autodoc_typehints in ('none', 'description'):\n", "            kwargs.setdefault('show_annotation', False)\n", "        if self.config.autodoc_typehints_format == \"short\":\n", "            kwargs.setdefault('unqualified_typehints', True)\n", "\n", "        try:\n", "            self.env.app.emit('autodoc-before-process-signature', self.object, False)\n", "            sig = inspect.signature(self.object, type_aliases=self.config.autodoc_type_aliases)\n", "            args = stringify_signature(sig, **kwargs)\n", "        except TypeError as exc:\n", "            logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n", "                           self.fullname, exc)\n", "            return None\n", "        except ValueError:\n", "            args = ''\n", "\n", "        if self.config.strip_signature_backslash:\n", "            # escape backslashes for reST\n", "            args = args.replace('\\\\', '\\\\\\\\')\n", "        return args\n"]}]}, {"file_path": "sphinx/ext/autodoc/typehints.py", "span_ids": ["merge_typehints", "record_typehints"], "content": [{"span_id": "merge_typehints", "start_line": 37, "end_line": 73, "content": ["def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n", "    if domain != 'py':\n", "        return\n", "    if app.config.autodoc_typehints not in ('both', 'description'):\n", "        return\n", "\n", "    try:\n", "        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n", "        if signature['module']:\n", "            fullname = '.'.join([signature['module'], signature['fullname']])\n", "        else:\n", "            fullname = signature['fullname']\n", "    except KeyError:\n", "        # signature node does not have valid context info for the target object\n", "        return\n", "\n", "    annotations = app.env.temp_data.get('annotations', {})\n", "    if annotations.get(fullname, {}):\n", "        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n", "        if field_lists == []:\n", "            field_list = insert_field_list(contentnode)\n", "            field_lists.append(field_list)\n", "\n", "        for field_list in field_lists:\n", "            if app.config.autodoc_typehints_description_target == \"all\":\n", "                if objtype == 'class':\n", "                    modify_field_list(field_list, annotations[fullname], suppress_rtype=True)\n", "                else:\n", "                    modify_field_list(field_list, annotations[fullname])\n", "            elif app.config.autodoc_typehints_description_target == \"documented_params\":\n", "                augment_descriptions_with_types(\n", "                    field_list, annotations[fullname], force_rtype=True\n", "                )\n", "            else:\n", "                augment_descriptions_with_types(\n", "                    field_list, annotations[fullname], force_rtype=False\n", "                )\n"]}, {"span_id": "record_typehints", "start_line": 15, "end_line": 34, "content": ["def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n", "                     options: Dict, args: str, retann: str) -> None:\n", "    \"\"\"Record type hints to env object.\"\"\"\n", "    if app.config.autodoc_typehints_format == 'short':\n", "        mode = 'smart'\n", "    else:\n", "        mode = 'fully-qualified'\n", "\n", "    try:\n", "        if callable(obj):\n", "            annotations = app.env.temp_data.setdefault('annotations', {})\n", "            annotation = annotations.setdefault(name, OrderedDict())\n", "            sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)\n", "            for param in sig.parameters.values():\n", "                if param.annotation is not param.empty:\n", "                    annotation[param.name] = typing.stringify(param.annotation, mode)\n", "            if sig.return_annotation is not sig.empty:\n", "                annotation['return'] = typing.stringify(sig.return_annotation, mode)\n", "    except (TypeError, ValueError):\n", "        pass\n"]}]}]}