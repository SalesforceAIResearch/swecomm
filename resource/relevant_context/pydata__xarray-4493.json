{"instance_id": "pydata__xarray-4493", "identified_spans": [{"file_path": "xarray/core/alignment.py", "span_ids": ["deep_align"], "content": [{"span_id": "deep_align", "start_line": 366, "end_line": 446, "content": ["def deep_align(\n", "    objects,\n", "    join=\"inner\",\n", "    copy=True,\n", "    indexes=None,\n", "    exclude=frozenset(),\n", "    raise_on_invalid=True,\n", "    fill_value=dtypes.NA,\n", "):\n", "    \"\"\"Align objects for merging, recursing into dictionary values.\n", "\n", "    This function is not public API.\n", "    \"\"\"\n", "    from .dataarray import DataArray\n", "    from .dataset import Dataset\n", "\n", "    if indexes is None:\n", "        indexes = {}\n", "\n", "    def is_alignable(obj):\n", "        return isinstance(obj, (DataArray, Dataset))\n", "\n", "    positions = []\n", "    keys = []\n", "    out = []\n", "    targets = []\n", "    no_key = object()\n", "    not_replaced = object()\n", "    for position, variables in enumerate(objects):\n", "        if is_alignable(variables):\n", "            positions.append(position)\n", "            keys.append(no_key)\n", "            targets.append(variables)\n", "            out.append(not_replaced)\n", "        elif is_dict_like(variables):\n", "            current_out = {}\n", "            for k, v in variables.items():\n", "                if is_alignable(v) and k not in indexes:\n", "                    # Skip variables in indexes for alignment, because these\n", "                    # should to be overwritten instead:\n", "                    # https://github.com/pydata/xarray/issues/725\n", "                    # https://github.com/pydata/xarray/issues/3377\n", "                    # TODO(shoyer): doing this here feels super-hacky -- can we\n", "                    # move it explicitly into merge instead?\n", "                    positions.append(position)\n", "                    keys.append(k)\n", "                    targets.append(v)\n", "                    current_out[k] = not_replaced\n", "                else:\n", "                    current_out[k] = v\n", "            out.append(current_out)\n", "        elif raise_on_invalid:\n", "            raise ValueError(\n", "                \"object to align is neither an xarray.Dataset, \"\n", "                \"an xarray.DataArray nor a dictionary: {!r}\".format(variables)\n", "            )\n", "        else:\n", "            out.append(variables)\n", "\n", "    aligned = align(\n", "        *targets,\n", "        join=join,\n", "        copy=copy,\n", "        indexes=indexes,\n", "        exclude=exclude,\n", "        fill_value=fill_value,\n", "    )\n", "\n", "    for position, key, aligned_obj in zip(positions, keys, aligned):\n", "        if key is no_key:\n", "            out[position] = aligned_obj\n", "        else:\n", "            out[position][key] = aligned_obj\n", "\n", "    # something went wrong: we should have replaced all sentinel values\n", "    for arg in out:\n", "        assert arg is not not_replaced\n", "        if is_dict_like(arg):\n", "            assert all(value is not not_replaced for value in arg.values())\n", "\n", "    return out\n"]}]}, {"file_path": "xarray/core/dataset.py", "span_ids": ["Dataset.update"], "content": [{"span_id": "Dataset.update", "start_line": 3883, "end_line": 3910, "content": ["    def update(self, other: \"CoercibleMapping\") -> \"Dataset\":\n", "        \"\"\"Update this dataset's variables with those from another dataset.\n", "\n", "        Parameters\n", "        ----------\n", "        other : Dataset or mapping\n", "            Variables with which to update this dataset. One of:\n", "\n", "            - Dataset\n", "            - mapping {var name: DataArray}\n", "            - mapping {var name: Variable}\n", "            - mapping {var name: (dimension name, array-like)}\n", "            - mapping {var name: (tuple of dimension names, array-like)}\n", "\n", "\n", "        Returns\n", "        -------\n", "        updated : Dataset\n", "            Updated dataset.\n", "\n", "        Raises\n", "        ------\n", "        ValueError\n", "            If any dimensions would have inconsistent sizes in the updated\n", "            dataset.\n", "        \"\"\"\n", "        merge_result = dataset_update_method(self, other)\n", "        return self._replace(inplace=True, **merge_result._asdict())\n"]}]}, {"file_path": "xarray/core/merge.py", "span_ids": ["merge_core", "dataset_update_method", "coerce_pandas_values"], "content": [{"span_id": "merge_core", "start_line": 537, "end_line": 625, "content": ["def merge_core(\n", "    objects: Iterable[\"CoercibleMapping\"],\n", "    compat: str = \"broadcast_equals\",\n", "    join: str = \"outer\",\n", "    combine_attrs: Optional[str] = \"override\",\n", "    priority_arg: Optional[int] = None,\n", "    explicit_coords: Optional[Sequence] = None,\n", "    indexes: Optional[Mapping[Hashable, pd.Index]] = None,\n", "    fill_value: object = dtypes.NA,\n", ") -> _MergeResult:\n", "    \"\"\"Core logic for merging labeled objects.\n", "\n", "    This is not public API.\n", "\n", "    Parameters\n", "    ----------\n", "    objects : list of mapping\n", "        All values must be convertable to labeled arrays.\n", "    compat : {\"identical\", \"equals\", \"broadcast_equals\", \"no_conflicts\", \"override\"}, optional\n", "        Compatibility checks to use when merging variables.\n", "    join : {\"outer\", \"inner\", \"left\", \"right\"}, optional\n", "        How to combine objects with different indexes.\n", "    combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"override\"}, optional\n", "        How to combine attributes of objects\n", "    priority_arg : int, optional\n", "        Optional argument in `objects` that takes precedence over the others.\n", "    explicit_coords : set, optional\n", "        An explicit list of variables from `objects` that are coordinates.\n", "    indexes : dict, optional\n", "        Dictionary with values given by pandas.Index objects.\n", "    fill_value : scalar, optional\n", "        Value to use for newly missing values\n", "\n", "    Returns\n", "    -------\n", "    variables : dict\n", "        Dictionary of Variable objects.\n", "    coord_names : set\n", "        Set of coordinate names.\n", "    dims : dict\n", "        Dictionary mapping from dimension names to sizes.\n", "    attrs : dict\n", "        Dictionary of attributes\n", "\n", "    Raises\n", "    ------\n", "    MergeError if the merge cannot be done successfully.\n", "    \"\"\"\n", "    from .dataarray import DataArray\n", "    from .dataset import Dataset, calculate_dimensions\n", "\n", "    _assert_compat_valid(compat)\n", "\n", "    coerced = coerce_pandas_values(objects)\n", "    aligned = deep_align(\n", "        coerced, join=join, copy=False, indexes=indexes, fill_value=fill_value\n", "    )\n", "    collected = collect_variables_and_indexes(aligned)\n", "\n", "    prioritized = _get_priority_vars_and_indexes(aligned, priority_arg, compat=compat)\n", "    variables, out_indexes = merge_collected(collected, prioritized, compat=compat)\n", "    assert_unique_multiindex_level_names(variables)\n", "\n", "    dims = calculate_dimensions(variables)\n", "\n", "    coord_names, noncoord_names = determine_coords(coerced)\n", "    if explicit_coords is not None:\n", "        assert_valid_explicit_coords(variables, dims, explicit_coords)\n", "        coord_names.update(explicit_coords)\n", "    for dim, size in dims.items():\n", "        if dim in variables:\n", "            coord_names.add(dim)\n", "    ambiguous_coords = coord_names.intersection(noncoord_names)\n", "    if ambiguous_coords:\n", "        raise MergeError(\n", "            \"unable to determine if these variables should be \"\n", "            \"coordinates or not in the merged result: %s\" % ambiguous_coords\n", "        )\n", "\n", "    attrs = merge_attrs(\n", "        [\n", "            var.attrs\n", "            for var in coerced\n", "            if isinstance(var, Dataset) or isinstance(var, DataArray)\n", "        ],\n", "        combine_attrs,\n", "    )\n", "\n", "    return _MergeResult(variables, coord_names, dims, out_indexes, attrs)\n"]}, {"span_id": "dataset_update_method", "start_line": 908, "end_line": 940, "content": ["def dataset_update_method(\n", "    dataset: \"Dataset\", other: \"CoercibleMapping\"\n", ") -> _MergeResult:\n", "    \"\"\"Guts of the Dataset.update method.\n", "\n", "    This drops a duplicated coordinates from `other` if `other` is not an\n", "    `xarray.Dataset`, e.g., if it's a dict with DataArray values (GH2068,\n", "    GH2180).\n", "    \"\"\"\n", "    from .dataarray import DataArray\n", "    from .dataset import Dataset\n", "\n", "    if not isinstance(other, Dataset):\n", "        other = dict(other)\n", "        for key, value in other.items():\n", "            if isinstance(value, DataArray):\n", "                # drop conflicting coordinates\n", "                coord_names = [\n", "                    c\n", "                    for c in value.coords\n", "                    if c not in value.dims and c in dataset.coords\n", "                ]\n", "                if coord_names:\n", "                    other[key] = value.drop_vars(coord_names)\n", "\n", "    # use ds.coords and not ds.indexes, else str coords are cast to object\n", "    indexes = {key: dataset.coords[key] for key in dataset.indexes.keys()}\n", "    return merge_core(\n", "        [dataset, other],\n", "        priority_arg=1,\n", "        indexes=indexes,\n", "        combine_attrs=\"override\",\n", "    )\n"]}, {"span_id": "coerce_pandas_values", "start_line": 370, "end_line": 400, "content": ["def coerce_pandas_values(objects: Iterable[\"CoercibleMapping\"]) -> List[\"DatasetLike\"]:\n", "    \"\"\"Convert pandas values found in a list of labeled objects.\n", "\n", "    Parameters\n", "    ----------\n", "    objects : list of Dataset or mapping\n", "        The mappings may contain any sort of objects coercible to\n", "        xarray.Variables as keys, including pandas objects.\n", "\n", "    Returns\n", "    -------\n", "    List of Dataset or dictionary objects. Any inputs or values in the inputs\n", "    that were pandas objects have been converted into native xarray objects.\n", "    \"\"\"\n", "    from .dataarray import DataArray\n", "    from .dataset import Dataset\n", "\n", "    out = []\n", "    for obj in objects:\n", "        if isinstance(obj, Dataset):\n", "            variables: \"DatasetLike\" = obj\n", "        else:\n", "            variables = {}\n", "            if isinstance(obj, PANDAS_TYPES):\n", "                obj = dict(obj.iteritems())\n", "            for k, v in obj.items():\n", "                if isinstance(v, PANDAS_TYPES):\n", "                    v = DataArray(v)\n", "                variables[k] = v\n", "        out.append(variables)\n", "    return out\n"]}]}]}