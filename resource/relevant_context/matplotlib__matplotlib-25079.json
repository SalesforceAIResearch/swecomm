{"instance_id": "matplotlib__matplotlib-25079", "identified_spans": [{"file_path": "lib/matplotlib/cm.py", "span_ids": ["ScalarMappable.to_rgba", "ScalarMappable", "ScalarMappable.norm_10", "ScalarMappable.set_norm"], "content": [{"span_id": "ScalarMappable.to_rgba", "start_line": 427, "end_line": 495, "content": ["    def to_rgba(self, x, alpha=None, bytes=False, norm=True):\n", "        \"\"\"\n", "        Return a normalized rgba array corresponding to *x*.\n", "\n", "        In the normal case, *x* is a 1D or 2D sequence of scalars, and\n", "        the corresponding `~numpy.ndarray` of rgba values will be returned,\n", "        based on the norm and colormap set for this ScalarMappable.\n", "\n", "        There is one special case, for handling images that are already\n", "        rgb or rgba, such as might have been read from an image file.\n", "        If *x* is an `~numpy.ndarray` with 3 dimensions,\n", "        and the last dimension is either 3 or 4, then it will be\n", "        treated as an rgb or rgba array, and no mapping will be done.\n", "        The array can be uint8, or it can be floating point with\n", "        values in the 0-1 range; otherwise a ValueError will be raised.\n", "        If it is a masked array, the mask will be ignored.\n", "        If the last dimension is 3, the *alpha* kwarg (defaulting to 1)\n", "        will be used to fill in the transparency.  If the last dimension\n", "        is 4, the *alpha* kwarg is ignored; it does not\n", "        replace the preexisting alpha.  A ValueError will be raised\n", "        if the third dimension is other than 3 or 4.\n", "\n", "        In either case, if *bytes* is *False* (default), the rgba\n", "        array will be floats in the 0-1 range; if it is *True*,\n", "        the returned rgba array will be uint8 in the 0 to 255 range.\n", "\n", "        If norm is False, no normalization of the input data is\n", "        performed, and it is assumed to be in the range (0-1).\n", "\n", "        \"\"\"\n", "        # First check for special case, image input:\n", "        try:\n", "            if x.ndim == 3:\n", "                if x.shape[2] == 3:\n", "                    if alpha is None:\n", "                        alpha = 1\n", "                    if x.dtype == np.uint8:\n", "                        alpha = np.uint8(alpha * 255)\n", "                    m, n = x.shape[:2]\n", "                    xx = np.empty(shape=(m, n, 4), dtype=x.dtype)\n", "                    xx[:, :, :3] = x\n", "                    xx[:, :, 3] = alpha\n", "                elif x.shape[2] == 4:\n", "                    xx = x\n", "                else:\n", "                    raise ValueError(\"Third dimension must be 3 or 4\")\n", "                if xx.dtype.kind == 'f':\n", "                    if norm and (xx.max() > 1 or xx.min() < 0):\n", "                        raise ValueError(\"Floating point image RGB values \"\n", "                                         \"must be in the 0..1 range.\")\n", "                    if bytes:\n", "                        xx = (xx * 255).astype(np.uint8)\n", "                elif xx.dtype == np.uint8:\n", "                    if not bytes:\n", "                        xx = xx.astype(np.float32) / 255\n", "                else:\n", "                    raise ValueError(\"Image RGB array must be uint8 or \"\n", "                                     \"floating point; found %s\" % xx.dtype)\n", "                return xx\n", "        except AttributeError:\n", "            # e.g., x is not an ndarray; so try mapping it\n", "            pass\n", "\n", "        # This is the normal case, mapping a scalar array:\n", "        x = ma.asarray(x)\n", "        if norm:\n", "            x = self.norm(x)\n", "        rgba = self.cmap(x, alpha=alpha, bytes=bytes)\n", "        return rgba\n"]}, {"span_id": "ScalarMappable", "start_line": 374, "end_line": 380, "content": ["class ScalarMappable:\n", "    \"\"\"\n", "    A mixin class to map scalar data to RGBA.\n", "\n", "    The ScalarMappable applies data normalization before returning RGBA colors\n", "    from the given colormap.\n", "    \"\"\"\n"]}, {"span_id": "ScalarMappable.norm_10", "start_line": 593, "end_line": 620, "content": ["    @norm.setter\n", "    def norm(self, norm):\n", "        _api.check_isinstance((colors.Normalize, str, None), norm=norm)\n", "        if norm is None:\n", "            norm = colors.Normalize()\n", "        elif isinstance(norm, str):\n", "            try:\n", "                scale_cls = scale._scale_mapping[norm]\n", "            except KeyError:\n", "                raise ValueError(\n", "                    \"Invalid norm str name; the following values are \"\n", "                    f\"supported: {', '.join(scale._scale_mapping)}\"\n", "                ) from None\n", "            norm = _auto_norm_from_scale(scale_cls)()\n", "\n", "        if norm is self.norm:\n", "            # We aren't updating anything\n", "            return\n", "\n", "        in_init = self.norm is None\n", "        # Remove the current callback and connect to the new one\n", "        if not in_init:\n", "            self.norm.callbacks.disconnect(self._id_norm)\n", "        self._norm = norm\n", "        self._id_norm = self.norm.callbacks.connect('changed',\n", "                                                    self.changed)\n", "        if not in_init:\n", "            self.changed()\n"]}, {"span_id": "ScalarMappable.set_norm", "start_line": 622, "end_line": 636, "content": ["    def set_norm(self, norm):\n", "        \"\"\"\n", "        Set the normalization instance.\n", "\n", "        Parameters\n", "        ----------\n", "        norm : `.Normalize` or str or None\n", "\n", "        Notes\n", "        -----\n", "        If there are any colorbars using the mappable for this norm, setting\n", "        the norm of the mappable will reset the norm, locator, and formatters\n", "        on the colorbar to default.\n", "        \"\"\"\n", "        self.norm = norm\n"]}]}, {"file_path": "lib/matplotlib/colorbar.py", "span_ids": ["Colorbar._draw_all", "Colorbar.update_normal"], "content": [{"span_id": "Colorbar._draw_all", "start_line": 529, "end_line": 579, "content": ["    def _draw_all(self):\n", "        \"\"\"\n", "        Calculate any free parameters based on the current cmap and norm,\n", "        and do all the drawing.\n", "        \"\"\"\n", "        if self.orientation == 'vertical':\n", "            if mpl.rcParams['ytick.minor.visible']:\n", "                self.minorticks_on()\n", "        else:\n", "            if mpl.rcParams['xtick.minor.visible']:\n", "                self.minorticks_on()\n", "        self._long_axis().set(label_position=self.ticklocation,\n", "                              ticks_position=self.ticklocation)\n", "        self._short_axis().set_ticks([])\n", "        self._short_axis().set_ticks([], minor=True)\n", "\n", "        # Set self._boundaries and self._values, including extensions.\n", "        # self._boundaries are the edges of each square of color, and\n", "        # self._values are the value to map into the norm to get the\n", "        # color:\n", "        self._process_values()\n", "        # Set self.vmin and self.vmax to first and last boundary, excluding\n", "        # extensions:\n", "        self.vmin, self.vmax = self._boundaries[self._inside][[0, -1]]\n", "        # Compute the X/Y mesh.\n", "        X, Y = self._mesh()\n", "        # draw the extend triangles, and shrink the inner axes to accommodate.\n", "        # also adds the outline path to self.outline spine:\n", "        self._do_extends()\n", "        lower, upper = self.vmin, self.vmax\n", "        if self._long_axis().get_inverted():\n", "            # If the axis is inverted, we need to swap the vmin/vmax\n", "            lower, upper = upper, lower\n", "        if self.orientation == 'vertical':\n", "            self.ax.set_xlim(0, 1)\n", "            self.ax.set_ylim(lower, upper)\n", "        else:\n", "            self.ax.set_ylim(0, 1)\n", "            self.ax.set_xlim(lower, upper)\n", "\n", "        # set up the tick locators and formatters.  A bit complicated because\n", "        # boundary norms + uniform spacing requires a manual locator.\n", "        self.update_ticks()\n", "\n", "        if self._filled:\n", "            ind = np.arange(len(self._values))\n", "            if self._extend_lower():\n", "                ind = ind[1:]\n", "            if self._extend_upper():\n", "                ind = ind[:-1]\n", "            self._add_solids(X, Y, self._values[ind, np.newaxis])\n"]}, {"span_id": "Colorbar.update_normal", "start_line": 493, "end_line": 519, "content": ["    def update_normal(self, mappable):\n", "        \"\"\"\n", "        Update solid patches, lines, etc.\n", "\n", "        This is meant to be called when the norm of the image or contour plot\n", "        to which this colorbar belongs changes.\n", "\n", "        If the norm on the mappable is different than before, this resets the\n", "        locator and formatter for the axis, so if these have been customized,\n", "        they will need to be customized again.  However, if the norm only\n", "        changes values of *vmin*, *vmax* or *cmap* then the old formatter\n", "        and locator will be preserved.\n", "        \"\"\"\n", "        _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n", "        self.mappable = mappable\n", "        self.set_alpha(mappable.get_alpha())\n", "        self.cmap = mappable.cmap\n", "        if mappable.norm != self.norm:\n", "            self.norm = mappable.norm\n", "            self._reset_locator_formatter_scale()\n", "\n", "        self._draw_all()\n", "        if isinstance(self.mappable, contour.ContourSet):\n", "            CS = self.mappable\n", "            if not CS.filled:\n", "                self.add_lines(CS)\n", "        self.stale = True\n"]}]}, {"file_path": "lib/matplotlib/colors.py", "span_ids": ["Normalize.__call__", "impl:25"], "content": [{"span_id": "Normalize.__call__", "start_line": 1305, "end_line": 1349, "content": ["    def __call__(self, value, clip=None):\n", "        \"\"\"\n", "        Normalize *value* data in the ``[vmin, vmax]`` interval into the\n", "        ``[0.0, 1.0]`` interval and return it.\n", "\n", "        Parameters\n", "        ----------\n", "        value\n", "            Data to normalize.\n", "        clip : bool\n", "            If ``None``, defaults to ``self.clip`` (which defaults to\n", "            ``False``).\n", "\n", "        Notes\n", "        -----\n", "        If not already initialized, ``self.vmin`` and ``self.vmax`` are\n", "        initialized using ``self.autoscale_None(value)``.\n", "        \"\"\"\n", "        if clip is None:\n", "            clip = self.clip\n", "\n", "        result, is_scalar = self.process_value(value)\n", "\n", "        if self.vmin is None or self.vmax is None:\n", "            self.autoscale_None(result)\n", "        # Convert at least to float, without losing precision.\n", "        (vmin,), _ = self.process_value(self.vmin)\n", "        (vmax,), _ = self.process_value(self.vmax)\n", "        if vmin == vmax:\n", "            result.fill(0)  # Or should it be all masked?  Or 0.5?\n", "        elif vmin > vmax:\n", "            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n", "        else:\n", "            if clip:\n", "                mask = np.ma.getmask(result)\n", "                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n", "                                     mask=mask)\n", "            # ma division is very slow; we can take a shortcut\n", "            resdat = result.data\n", "            resdat -= vmin\n", "            resdat /= (vmax - vmin)\n", "            result = np.ma.array(resdat, mask=result.mask, copy=False)\n", "        if is_scalar:\n", "            result = result[0]\n", "        return result\n"]}, {"span_id": "impl:25", "start_line": 1780, "end_line": 1783, "content": ["LogNorm = make_norm_from_scale(\n", "    functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\n", "LogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\n", "LogNorm.__doc__ = \"Normalize a given value to the 0-1 range on a log scale.\"\n"]}]}]}