{"instance_id": "sympy__sympy-16988", "identified_spans": [{"file_path": "sympy/sets/sets.py", "span_ids": ["Intersection.__new__", "Intersection", "Intersection._handle_finite_sets", "simplify_intersection"], "content": [{"span_id": "Intersection.__new__", "start_line": 1259, "end_line": 1274, "content": ["    def __new__(cls, *args, **kwargs):\n", "        evaluate = kwargs.get('evaluate', global_evaluate[0])\n", "\n", "        # flatten inputs to merge intersections and iterables\n", "        args = _sympify(args)\n", "\n", "        # Reduce sets using known rules\n", "        if evaluate:\n", "            args = list(cls._new_args_filter(args))\n", "            return simplify_intersection(args)\n", "\n", "        args = list(ordered(args, Set._infimum_key))\n", "\n", "        obj = Basic.__new__(cls, *args)\n", "        obj._argset = frozenset(args)\n", "        return obj\n"]}, {"span_id": "Intersection", "start_line": 1223, "end_line": 1249, "content": ["class Intersection(Set, LatticeOp):\n", "    \"\"\"\n", "    Represents an intersection of sets as a :class:`Set`.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import Intersection, Interval\n", "    >>> Intersection(Interval(1, 3), Interval(2, 4))\n", "    Interval(2, 3)\n", "\n", "    We often use the .intersect method\n", "\n", "    >>> Interval(1,3).intersect(Interval(2,4))\n", "    Interval(2, 3)\n", "\n", "    See Also\n", "    ========\n", "\n", "    Union\n", "\n", "    References\n", "    ==========\n", "\n", "    .. [1] https://en.wikipedia.org/wiki/Intersection_%28set_theory%29\n", "    \"\"\"\n", "    is_Intersection = True\n"]}, {"span_id": "Intersection._handle_finite_sets", "start_line": 1315, "end_line": 1380, "content": ["    @staticmethod\n", "    def _handle_finite_sets(args):\n", "        from sympy.core.logic import fuzzy_and, fuzzy_bool\n", "        from sympy.core.compatibility import zip_longest\n", "\n", "        fs_args, other = sift(args, lambda x: x.is_FiniteSet,\n", "            binary=True)\n", "        if not fs_args:\n", "            return\n", "        fs_args.sort(key=len)\n", "        s = fs_args[0]\n", "        fs_args = fs_args[1:]\n", "\n", "        res = []\n", "        unk = []\n", "        for x in s:\n", "            c = fuzzy_and(fuzzy_bool(o.contains(x))\n", "                for o in fs_args + other)\n", "            if c:\n", "                res.append(x)\n", "            elif c is None:\n", "                unk.append(x)\n", "            else:\n", "                pass  # drop arg\n", "\n", "        res = FiniteSet(\n", "            *res, evaluate=False) if res else S.EmptySet\n", "        if unk:\n", "            symbolic_s_list = [x for x in s if x.has(Symbol)]\n", "            non_symbolic_s = s - FiniteSet(\n", "                *symbolic_s_list, evaluate=False)\n", "            while fs_args:\n", "                v = fs_args.pop()\n", "                if all(i == j for i, j in zip_longest(\n", "                        symbolic_s_list,\n", "                        (x for x in v if x.has(Symbol)))):\n", "                    # all the symbolic elements of `v` are the same\n", "                    # as in `s` so remove the non-symbol containing\n", "                    # expressions from `unk`, since they cannot be\n", "                    # contained\n", "                    for x in non_symbolic_s:\n", "                        if x in unk:\n", "                            unk.remove(x)\n", "                else:\n", "                    # if only a subset of elements in `s` are\n", "                    # contained in `v` then remove them from `v`\n", "                    # and add this as a new arg\n", "                    contained = [x for x in symbolic_s_list\n", "                        if sympify(v.contains(x)) is S.true]\n", "                    if contained != symbolic_s_list:\n", "                        other.append(\n", "                            v - FiniteSet(\n", "                            *contained, evaluate=False))\n", "                    else:\n", "                        pass  # for coverage\n", "\n", "            other_sets = Intersection(*other)\n", "            if not other_sets:\n", "                return S.EmptySet  # b/c we use evaluate=False below\n", "            elif other_sets == S.UniversalSet:\n", "                res += FiniteSet(*unk)\n", "            else:\n", "                res += Intersection(\n", "                    FiniteSet(*unk),\n", "                    other_sets, evaluate=False)\n", "        return res\n"]}, {"span_id": "simplify_intersection", "start_line": 1971, "end_line": 2044, "content": ["def simplify_intersection(args):\n", "    \"\"\"\n", "    Simplify an intersection using known rules\n", "\n", "    We first start with global rules like\n", "    'if any empty sets return empty set' and 'distribute any unions'\n", "\n", "    Then we iterate through all pairs and ask the constituent sets if they\n", "    can simplify themselves with any other constituent\n", "    \"\"\"\n", "\n", "    # ===== Global Rules =====\n", "    if not args:\n", "        return S.UniversalSet\n", "\n", "    for arg in args:\n", "        if not isinstance(arg, Set):\n", "            raise TypeError(\"Input args to Union must be Sets\")\n", "\n", "    # If any EmptySets return EmptySet\n", "    if S.EmptySet in args:\n", "        return S.EmptySet\n", "\n", "    # Handle Finite sets\n", "    rv = Intersection._handle_finite_sets(args)\n", "\n", "    if rv is not None:\n", "        return rv\n", "\n", "    # If any of the sets are unions, return a Union of Intersections\n", "    for s in args:\n", "        if s.is_Union:\n", "            other_sets = set(args) - set((s,))\n", "            if len(other_sets) > 0:\n", "                other = Intersection(*other_sets)\n", "                return Union(*(Intersection(arg, other) for arg in s.args))\n", "            else:\n", "                return Union(*[arg for arg in s.args])\n", "\n", "    for s in args:\n", "        if s.is_Complement:\n", "            args.remove(s)\n", "            other_sets = args + [s.args[0]]\n", "            return Complement(Intersection(*other_sets), s.args[1])\n", "\n", "\n", "    from sympy.sets.handlers.intersection import intersection_sets\n", "\n", "    # At this stage we are guaranteed not to have any\n", "    # EmptySets, FiniteSets, or Unions in the intersection\n", "\n", "    # ===== Pair-wise Rules =====\n", "    # Here we depend on rules built into the constituent sets\n", "    args = set(args)\n", "    new_args = True\n", "    while new_args:\n", "        for s in args:\n", "            new_args = False\n", "            for t in args - set((s,)):\n", "                new_set = intersection_sets(s, t)\n", "                # This returns None if s does not know how to intersect\n", "                # with t. Returns the newly intersected set otherwise\n", "\n", "                if new_set is not None:\n", "                    new_args = (args - set((s, t))).union(set((new_set, )))\n", "                    break\n", "            if new_args:\n", "                args = new_args\n", "                break\n", "\n", "    if len(args) == 1:\n", "        return args.pop()\n", "    else:\n", "        return Intersection(*args, evaluate=False)\n"]}]}]}