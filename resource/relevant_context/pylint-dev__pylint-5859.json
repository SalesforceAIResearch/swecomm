{"instance_id": "pylint-dev__pylint-5859", "identified_spans": [{"file_path": "pylint/checkers/misc.py", "span_ids": ["EncodingChecker.process_tokens", "EncodingChecker", "EncodingChecker.open"], "content": [{"span_id": "EncodingChecker.process_tokens", "start_line": 155, "end_line": 198, "content": ["    def process_tokens(self, tokens):\n", "        \"\"\"Inspect the source to find fixme problems.\"\"\"\n", "        if not self.config.notes:\n", "            return\n", "        comments = (\n", "            token_info for token_info in tokens if token_info.type == tokenize.COMMENT\n", "        )\n", "        for comment in comments:\n", "            comment_text = comment.string[1:].lstrip()  # trim '#' and whitespaces\n", "\n", "            # handle pylint disable clauses\n", "            disable_option_match = OPTION_PO.search(comment_text)\n", "            if disable_option_match:\n", "                try:\n", "                    values = []\n", "                    try:\n", "                        for pragma_repr in (\n", "                            p_rep\n", "                            for p_rep in parse_pragma(disable_option_match.group(2))\n", "                            if p_rep.action == \"disable\"\n", "                        ):\n", "                            values.extend(pragma_repr.messages)\n", "                    except PragmaParserError:\n", "                        # Printing useful information dealing with this error is done in the lint package\n", "                        pass\n", "                    if set(values) & set(self.config.notes):\n", "                        continue\n", "                except ValueError:\n", "                    self.add_message(\n", "                        \"bad-inline-option\",\n", "                        args=disable_option_match.group(1).strip(),\n", "                        line=comment.start[0],\n", "                    )\n", "                    continue\n", "\n", "            # emit warnings if necessary\n", "            match = self._fixme_pattern.search(\"#\" + comment_text.lower())\n", "            if match:\n", "                self.add_message(\n", "                    \"fixme\",\n", "                    col_offset=comment.start[1] + 1,\n", "                    args=comment_text,\n", "                    line=comment.start[0],\n", "                )\n"]}, {"span_id": "EncodingChecker", "start_line": 77, "end_line": 117, "content": ["class EncodingChecker(BaseChecker):\n", "\n", "    \"\"\"Checks for:\n", "    * warning notes in the code like FIXME, XXX\n", "    * encoding issues.\n", "    \"\"\"\n", "\n", "    __implements__ = (IRawChecker, ITokenChecker)\n", "\n", "    # configuration section name\n", "    name = \"miscellaneous\"\n", "    msgs = {\n", "        \"W0511\": (\n", "            \"%s\",\n", "            \"fixme\",\n", "            \"Used when a warning note as FIXME or XXX is detected.\",\n", "        )\n", "    }\n", "\n", "    options = (\n", "        (\n", "            \"notes\",\n", "            {\n", "                \"type\": \"csv\",\n", "                \"metavar\": \"<comma separated values>\",\n", "                \"default\": (\"FIXME\", \"XXX\", \"TODO\"),\n", "                \"help\": (\n", "                    \"List of note tags to take in consideration, \"\n", "                    \"separated by a comma.\"\n", "                ),\n", "            },\n", "        ),\n", "        (\n", "            \"notes-rgx\",\n", "            {\n", "                \"type\": \"string\",\n", "                \"metavar\": \"<regexp>\",\n", "                \"help\": \"Regular expression of note tags to take in consideration.\",\n", "            },\n", "        ),\n", "    )\n"]}, {"span_id": "EncodingChecker.open", "start_line": 119, "end_line": 128, "content": ["    def open(self):\n", "        super().open()\n", "\n", "        notes = \"|\".join(re.escape(note) for note in self.config.notes)\n", "        if self.config.notes_rgx:\n", "            regex_string = rf\"#\\s*({notes}|{self.config.notes_rgx})\\b\"\n", "        else:\n", "            regex_string = rf\"#\\s*({notes})\\b\"\n", "\n", "        self._fixme_pattern = re.compile(regex_string, re.I)\n"]}]}]}