{"instance_id": "pytest-dev__pytest-9359", "identified_spans": [{"file_path": "src/_pytest/assertion/rewrite.py", "span_ids": ["AssertionRewritingHook", "AssertionRewriter.visit_Assert"], "content": [{"span_id": "AssertionRewritingHook", "start_line": 57, "end_line": 58, "content": ["class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n", "    \"\"\"PEP302/PEP451 import hook which rewrites asserts.\"\"\"\n"]}, {"span_id": "AssertionRewriter.visit_Assert", "start_line": 846, "end_line": 961, "content": ["    def visit_Assert(self, assert_: ast.Assert) -> List[ast.stmt]:\n", "        \"\"\"Return the AST statements to replace the ast.Assert instance.\n", "\n", "        This rewrites the test of an assertion to provide\n", "        intermediate values and replace it with an if statement which\n", "        raises an assertion error with a detailed explanation in case\n", "        the expression is false.\n", "        \"\"\"\n", "        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n", "            from _pytest.warning_types import PytestAssertRewriteWarning\n", "            import warnings\n", "\n", "            # TODO: This assert should not be needed.\n", "            assert self.module_path is not None\n", "            warnings.warn_explicit(\n", "                PytestAssertRewriteWarning(\n", "                    \"assertion is always true, perhaps remove parentheses?\"\n", "                ),\n", "                category=None,\n", "                filename=self.module_path,\n", "                lineno=assert_.lineno,\n", "            )\n", "\n", "        self.statements: List[ast.stmt] = []\n", "        self.variables: List[str] = []\n", "        self.variable_counter = itertools.count()\n", "\n", "        if self.enable_assertion_pass_hook:\n", "            self.format_variables: List[str] = []\n", "\n", "        self.stack: List[Dict[str, ast.expr]] = []\n", "        self.expl_stmts: List[ast.stmt] = []\n", "        self.push_format_context()\n", "        # Rewrite assert into a bunch of statements.\n", "        top_condition, explanation = self.visit(assert_.test)\n", "\n", "        negation = ast.UnaryOp(ast.Not(), top_condition)\n", "\n", "        if self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook\n", "            msg = self.pop_format_context(ast.Str(explanation))\n", "\n", "            # Failed\n", "            if assert_.msg:\n", "                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n", "                gluestr = \"\\n>assert \"\n", "            else:\n", "                assertmsg = ast.Str(\"\")\n", "                gluestr = \"assert \"\n", "            err_explanation = ast.BinOp(ast.Str(gluestr), ast.Add(), msg)\n", "            err_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)\n", "            err_name = ast.Name(\"AssertionError\", ast.Load())\n", "            fmt = self.helper(\"_format_explanation\", err_msg)\n", "            exc = ast.Call(err_name, [fmt], [])\n", "            raise_ = ast.Raise(exc, None)\n", "            statements_fail = []\n", "            statements_fail.extend(self.expl_stmts)\n", "            statements_fail.append(raise_)\n", "\n", "            # Passed\n", "            fmt_pass = self.helper(\"_format_explanation\", msg)\n", "            orig = _get_assertion_exprs(self.source)[assert_.lineno]\n", "            hook_call_pass = ast.Expr(\n", "                self.helper(\n", "                    \"_call_assertion_pass\",\n", "                    ast.Num(assert_.lineno),\n", "                    ast.Str(orig),\n", "                    fmt_pass,\n", "                )\n", "            )\n", "            # If any hooks implement assert_pass hook\n", "            hook_impl_test = ast.If(\n", "                self.helper(\"_check_if_assertion_pass_impl\"),\n", "                self.expl_stmts + [hook_call_pass],\n", "                [],\n", "            )\n", "            statements_pass = [hook_impl_test]\n", "\n", "            # Test for assertion condition\n", "            main_test = ast.If(negation, statements_fail, statements_pass)\n", "            self.statements.append(main_test)\n", "            if self.format_variables:\n", "                variables = [\n", "                    ast.Name(name, ast.Store()) for name in self.format_variables\n", "                ]\n", "                clear_format = ast.Assign(variables, ast.NameConstant(None))\n", "                self.statements.append(clear_format)\n", "\n", "        else:  # Original assertion rewriting\n", "            # Create failure message.\n", "            body = self.expl_stmts\n", "            self.statements.append(ast.If(negation, body, []))\n", "            if assert_.msg:\n", "                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n", "                explanation = \"\\n>assert \" + explanation\n", "            else:\n", "                assertmsg = ast.Str(\"\")\n", "                explanation = \"assert \" + explanation\n", "            template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n", "            msg = self.pop_format_context(template)\n", "            fmt = self.helper(\"_format_explanation\", msg)\n", "            err_name = ast.Name(\"AssertionError\", ast.Load())\n", "            exc = ast.Call(err_name, [fmt], [])\n", "            raise_ = ast.Raise(exc, None)\n", "\n", "            body.append(raise_)\n", "\n", "        # Clear temporary variables by setting them to None.\n", "        if self.variables:\n", "            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n", "            clear = ast.Assign(variables, ast.NameConstant(None))\n", "            self.statements.append(clear)\n", "        # Fix locations (line numbers/column offsets).\n", "        for stmt in self.statements:\n", "            for node in traverse_node(stmt):\n", "                ast.copy_location(node, assert_)\n", "        return self.statements\n"]}]}]}