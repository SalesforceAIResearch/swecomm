{"instance_id": "sympy__sympy-17022", "identified_spans": [{"file_path": "sympy/matrices/expressions/matexpr.py", "span_ids": ["Identity"], "content": [{"span_id": "Identity", "start_line": 808, "end_line": 821, "content": ["class Identity(MatrixExpr):\n", "    \"\"\"The Matrix Identity I - multiplicative identity\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.matrices import Identity, MatrixSymbol\n", "    >>> A = MatrixSymbol('A', 3, 5)\n", "    >>> I = Identity(3)\n", "    >>> I*A\n", "    A\n", "    \"\"\"\n", "\n", "    is_Identity = True\n"]}]}, {"file_path": "sympy/printing/julia.py", "span_ids": ["JuliaCodePrinter._print_Identity"], "content": [{"span_id": "JuliaCodePrinter._print_Identity", "start_line": 402, "end_line": 403, "content": ["    def _print_Identity(self, expr):\n", "        return \"eye(%s)\" % self._print(expr.shape[0])\n"]}]}, {"file_path": "sympy/printing/latex.py", "span_ids": ["LatexPrinter._print_Identity"], "content": [{"span_id": "LatexPrinter._print_Identity", "start_line": 1605, "end_line": 1607, "content": ["    def _print_Identity(self, I):\n", "        return r\"\\mathbb{I}\" if self._settings[\n", "            'mat_symbol_style'] == 'plain' else r\"\\mathbf{I}\"\n"]}]}, {"file_path": "sympy/printing/str.py", "span_ids": ["StrPrinter._print_Identity"], "content": [{"span_id": "StrPrinter._print_Identity", "start_line": 723, "end_line": 724, "content": ["    def _print_Identity(self, expr):\n", "        return \"I\"\n"]}]}, {"file_path": "sympy/printing/theanocode.py", "span_ids": ["imports"], "content": [{"span_id": "imports", "start_line": 1, "end_line": 65, "content": ["from __future__ import print_function, division\n", "\n", "from sympy.core.compatibility import range, is_sequence\n", "from sympy.external import import_module\n", "from sympy.printing.printer import Printer\n", "import sympy\n", "from functools import partial\n", "\n", "\n", "theano = import_module('theano')\n", "\n", "if theano:\n", "    ts = theano.scalar\n", "    tt = theano.tensor\n", "    from theano.sandbox import linalg as tlinalg\n", "\n", "    mapping = {\n", "            sympy.Add: tt.add,\n", "            sympy.Mul: tt.mul,\n", "            sympy.Abs: tt.abs_,\n", "            sympy.sign: tt.sgn,\n", "            sympy.ceiling: tt.ceil,\n", "            sympy.floor: tt.floor,\n", "            sympy.log: tt.log,\n", "            sympy.exp: tt.exp,\n", "            sympy.sqrt: tt.sqrt,\n", "            sympy.cos: tt.cos,\n", "            sympy.acos: tt.arccos,\n", "            sympy.sin: tt.sin,\n", "            sympy.asin: tt.arcsin,\n", "            sympy.tan: tt.tan,\n", "            sympy.atan: tt.arctan,\n", "            sympy.atan2: tt.arctan2,\n", "            sympy.cosh: tt.cosh,\n", "            sympy.acosh: tt.arccosh,\n", "            sympy.sinh: tt.sinh,\n", "            sympy.asinh: tt.arcsinh,\n", "            sympy.tanh: tt.tanh,\n", "            sympy.atanh: tt.arctanh,\n", "            sympy.re: tt.real,\n", "            sympy.im: tt.imag,\n", "            sympy.arg: tt.angle,\n", "            sympy.erf: tt.erf,\n", "            sympy.gamma: tt.gamma,\n", "            sympy.loggamma: tt.gammaln,\n", "            sympy.Pow: tt.pow,\n", "            sympy.Eq: tt.eq,\n", "            sympy.StrictGreaterThan: tt.gt,\n", "            sympy.StrictLessThan: tt.lt,\n", "            sympy.LessThan: tt.le,\n", "            sympy.GreaterThan: tt.ge,\n", "            sympy.And: tt.and_,\n", "            sympy.Or: tt.or_,\n", "            sympy.Max: tt.maximum,  # Sympy accept >2 inputs, Theano only 2\n", "            sympy.Min: tt.minimum,  # Sympy accept >2 inputs, Theano only 2\n", "            sympy.conjugate: tt.conj,\n", "            sympy.numbers.ImaginaryUnit: lambda:tt.complex(0,1),\n", "            # Matrices\n", "            sympy.MatAdd: tt.Elemwise(ts.add),\n", "            sympy.HadamardProduct: tt.Elemwise(ts.mul),\n", "            sympy.Trace: tlinalg.trace,\n", "            sympy.Determinant : tlinalg.det,\n", "            sympy.Inverse: tlinalg.matrix_inverse,\n", "            sympy.Transpose: tt.DimShuffle((False, False), [1, 0]),\n", "    }\n"]}]}, {"file_path": "sympy/utilities/lambdify.py", "span_ids": ["lambdify"], "content": [{"span_id": "lambdify", "start_line": 176, "end_line": 795, "content": ["@doctest_depends_on(modules=('numpy', 'tensorflow', ), python_version=(3,))\n", "def lambdify(args, expr, modules=None, printer=None, use_imps=True,\n", "             dummify=False):\n", "    \"\"\"\n", "    Translates a SymPy expression into an equivalent numeric function\n", "\n", "    For example, to convert the SymPy expression ``sin(x) + cos(x)`` to an\n", "    equivalent NumPy function that numerically evaluates it:\n", "\n", "    >>> from sympy import sin, cos, symbols, lambdify\n", "    >>> import numpy as np\n", "    >>> x = symbols('x')\n", "    >>> expr = sin(x) + cos(x)\n", "    >>> expr\n", "    sin(x) + cos(x)\n", "    >>> f = lambdify(x, expr, 'numpy')\n", "    >>> a = np.array([1, 2])\n", "    >>> f(a)\n", "    [1.38177329 0.49315059]\n", "\n", "    The primary purpose of this function is to provide a bridge from SymPy\n", "    expressions to numerical libraries such as NumPy, SciPy, NumExpr, mpmath,\n", "    and tensorflow. In general, SymPy functions do not work with objects from\n", "    other libraries, such as NumPy arrays, and functions from numeric\n", "    libraries like NumPy or mpmath do not work on SymPy expressions.\n", "    ``lambdify`` bridges the two by converting a SymPy expression to an\n", "    equivalent numeric function.\n", "\n", "    The basic workflow with ``lambdify`` is to first create a SymPy expression\n", "    representing whatever mathematical function you wish to evaluate. This\n", "    should be done using only SymPy functions and expressions. Then, use\n", "    ``lambdify`` to convert this to an equivalent function for numerical\n", "    evaluation. For instance, above we created ``expr`` using the SymPy symbol\n", "    ``x`` and SymPy functions ``sin`` and ``cos``, then converted it to an\n", "    equivalent NumPy function ``f``, and called it on a NumPy array ``a``.\n", "\n", "    .. warning::\n", "       This function uses ``exec``, and thus shouldn't be used on unsanitized\n", "       input.\n", "\n", "    Arguments\n", "    =========\n", "\n", "    The first argument of ``lambdify`` is a variable or list of variables in\n", "    the expression. Variable lists may be nested. Variables can be Symbols,\n", "    undefined functions, or matrix symbols. The order and nesting of the\n", "    variables corresponds to the order and nesting of the parameters passed to\n", "    the lambdified function. For instance,\n", "\n", "    >>> from sympy.abc import x, y, z\n", "    >>> f = lambdify([x, (y, z)], x + y + z)\n", "    >>> f(1, (2, 3))\n", "    6\n", "\n", "    The second argument of ``lambdify`` is the expression, list of\n", "    expressions, or matrix to be evaluated. Lists may be nested. If the\n", "    expression is a list, the output will also be a list.\n", "\n", "    >>> f = lambdify(x, [x, [x + 1, x + 2]])\n", "    >>> f(1)\n", "    [1, [2, 3]]\n", "\n", "    If it is a matrix, an array will be returned (for the NumPy module).\n", "\n", "    >>> from sympy import Matrix\n", "    >>> f = lambdify(x, Matrix([x, x + 1]))\n", "    >>> f(1)\n", "    [[1]\n", "     [2]]\n", "\n", "    Note that the argument order here, variables then expression, is used to\n", "    emulate the Python ``lambda`` keyword. ``lambdify(x, expr)`` works\n", "    (roughly) like ``lambda x: expr`` (see :ref:`lambdify-how-it-works` below).\n", "\n", "    The third argument, ``modules`` is optional. If not specified, ``modules``\n", "    defaults to ``[\"scipy\", \"numpy\"]`` if SciPy is installed, ``[\"numpy\"]`` if\n", "    only NumPy is installed, and ``[\"math\", \"mpmath\", \"sympy\"]`` if neither is\n", "    installed. That is, SymPy functions are replaced as far as possible by\n", "    either ``scipy`` or ``numpy`` functions if available, and Python's\n", "    standard library ``math``, or ``mpmath`` functions otherwise.\n", "\n", "    ``modules`` can be one of the following types\n", "\n", "     - the strings ``\"math\"``, ``\"mpmath\"``, ``\"numpy\"``, ``\"numexpr\"``,\n", "       ``\"scipy\"``, ``\"sympy\"``, or ``\"tensorflow\"``. This uses the\n", "       corresponding printer and namespace mapping for that module.\n", "     - a module (e.g., ``math``). This uses the global namespace of the\n", "       module. If the module is one of the above known modules, it will also\n", "       use the corresponding printer and namespace mapping (i.e.,\n", "       ``modules=numpy`` is equivalent to ``modules=\"numpy\"``).\n", "     - a dictionary that maps names of SymPy functions to arbitrary functions\n", "       (e.g., ``{'sin': custom_sin}``).\n", "     - a list that contains a mix of the arguments above, with higher priority\n", "       given to entries appearing first (e.g., to use the NumPy module but\n", "       override the ``sin`` function with a custom version, you can use\n", "       ``[{'sin': custom_sin}, 'numpy']``).\n", "\n", "    The ``dummify`` keyword argument controls whether or not the variables in\n", "    the provided expression that are not valid Python identifiers are\n", "    substituted with dummy symbols. This allows for undefined functions like\n", "    ``Function('f')(t)`` to be supplied as arguments. By default, the\n", "    variables are only dummified if they are not valid Python identifiers. Set\n", "    ``dummify=True`` to replace all arguments with dummy symbols (if ``args``\n", "    is not a string) - for example, to ensure that the arguments do not\n", "    redefine any built-in names.\n", "\n", "    .. _lambdify-how-it-works:\n", "\n", "    How it works\n", "    ============\n", "\n", "    When using this function, it helps a great deal to have an idea of what it\n", "    is doing. At its core, lambdify is nothing more than a namespace\n", "    translation, on top of a special printer that makes some corner cases work\n", "    properly.\n", "\n", "    To understand lambdify, first we must properly understand how Python\n", "    namespaces work. Say we had two files. One called ``sin_cos_sympy.py``,\n", "    with\n", "\n", "    .. code:: python\n", "\n", "        # sin_cos_sympy.py\n", "\n", "        from sympy import sin, cos\n", "\n", "        def sin_cos(x):\n", "            return sin(x) + cos(x)\n", "\n", "\n", "    and one called ``sin_cos_numpy.py`` with\n", "\n", "    .. code:: python\n", "\n", "        # sin_cos_numpy.py\n", "\n", "        from numpy import sin, cos\n", "\n", "        def sin_cos(x):\n", "            return sin(x) + cos(x)\n", "\n", "    The two files define an identical function ``sin_cos``. However, in the\n", "    first file, ``sin`` and ``cos`` are defined as the SymPy ``sin`` and\n", "    ``cos``. In the second, they are defined as the NumPy versions.\n", "\n", "    If we were to import the first file and use the ``sin_cos`` function, we\n", "    would get something like\n", "\n", "    >>> from sin_cos_sympy import sin_cos # doctest: +SKIP\n", "    >>> sin_cos(1) # doctest: +SKIP\n", "    cos(1) + sin(1)\n", "\n", "    On the other hand, if we imported ``sin_cos`` from the second file, we\n", "    would get\n", "\n", "    >>> from sin_cos_numpy import sin_cos # doctest: +SKIP\n", "    >>> sin_cos(1) # doctest: +SKIP\n", "    1.38177329068\n", "\n", "    In the first case we got a symbolic output, because it used the symbolic\n", "    ``sin`` and ``cos`` functions from SymPy. In the second, we got a numeric\n", "    result, because ``sin_cos`` used the numeric ``sin`` and ``cos`` functions\n", "    from NumPy. But notice that the versions of ``sin`` and ``cos`` that were\n", "    used was not inherent to the ``sin_cos`` function definition. Both\n", "    ``sin_cos`` definitions are exactly the same. Rather, it was based on the\n", "    names defined at the module where the ``sin_cos`` function was defined.\n", "\n", "    The key point here is that when function in Python references a name that\n", "    is not defined in the function, that name is looked up in the \"global\"\n", "    namespace of the module where that function is defined.\n", "\n", "    Now, in Python, we can emulate this behavior without actually writing a\n", "    file to disk using the ``exec`` function. ``exec`` takes a string\n", "    containing a block of Python code, and a dictionary that should contain\n", "    the global variables of the module. It then executes the code \"in\" that\n", "    dictionary, as if it were the module globals. The following is equivalent\n", "    to the ``sin_cos`` defined in ``sin_cos_sympy.py``:\n", "\n", "    >>> import sympy\n", "    >>> module_dictionary = {'sin': sympy.sin, 'cos': sympy.cos}\n", "    >>> exec('''\n", "    ... def sin_cos(x):\n", "    ...     return sin(x) + cos(x)\n", "    ... ''', module_dictionary)\n", "    >>> sin_cos = module_dictionary['sin_cos']\n", "    >>> sin_cos(1)\n", "    cos(1) + sin(1)\n", "\n", "    and similarly with ``sin_cos_numpy``:\n", "\n", "    >>> import numpy\n", "    >>> module_dictionary = {'sin': numpy.sin, 'cos': numpy.cos}\n", "    >>> exec('''\n", "    ... def sin_cos(x):\n", "    ...     return sin(x) + cos(x)\n", "    ... ''', module_dictionary)\n", "    >>> sin_cos = module_dictionary['sin_cos']\n", "    >>> sin_cos(1)\n", "    1.38177329068\n", "\n", "    So now we can get an idea of how ``lambdify`` works. The name \"lambdify\"\n", "    comes from the fact that we can think of something like ``lambdify(x,\n", "    sin(x) + cos(x), 'numpy')`` as ``lambda x: sin(x) + cos(x)``, where\n", "    ``sin`` and ``cos`` come from the ``numpy`` namespace. This is also why\n", "    the symbols argument is first in ``lambdify``, as opposed to most SymPy\n", "    functions where it comes after the expression: to better mimic the\n", "    ``lambda`` keyword.\n", "\n", "    ``lambdify`` takes the input expression (like ``sin(x) + cos(x)``) and\n", "\n", "    1. Converts it to a string\n", "    2. Creates a module globals dictionary based on the modules that are\n", "       passed in (by default, it uses the NumPy module)\n", "    3. Creates the string ``\"def func({vars}): return {expr}\"``, where ``{vars}`` is the\n", "       list of variables separated by commas, and ``{expr}`` is the string\n", "       created in step 1., then ``exec``s that string with the module globals\n", "       namespace and returns ``func``.\n", "\n", "    In fact, functions returned by ``lambdify`` support inspection. So you can\n", "    see exactly how they are defined by using ``inspect.getsource``, or ``??`` if you\n", "    are using IPython or the Jupyter notebook.\n", "\n", "    >>> f = lambdify(x, sin(x) + cos(x))\n", "    >>> import inspect\n", "    >>> print(inspect.getsource(f))\n", "    def _lambdifygenerated(x):\n", "        return (sin(x) + cos(x))\n", "\n", "    This shows us the source code of the function, but not the namespace it\n", "    was defined in. We can inspect that by looking at the ``__globals__``\n", "    attribute of ``f``:\n", "\n", "    >>> f.__globals__['sin']\n", "    <ufunc 'sin'>\n", "    >>> f.__globals__['cos']\n", "    <ufunc 'cos'>\n", "    >>> f.__globals__['sin'] is numpy.sin\n", "    True\n", "\n", "    This shows us that ``sin`` and ``cos`` in the namespace of ``f`` will be\n", "    ``numpy.sin`` and ``numpy.cos``.\n", "\n", "    Note that there are some convenience layers in each of these steps, but at\n", "    the core, this is how ``lambdify`` works. Step 1 is done using the\n", "    ``LambdaPrinter`` printers defined in the printing module (see\n", "    :mod:`sympy.printing.lambdarepr`). This allows different SymPy expressions\n", "    to define how they should be converted to a string for different modules.\n", "    You can change which printer ``lambdify`` uses by passing a custom printer\n", "    in to the ``printer`` argument.\n", "\n", "    Step 2 is augmented by certain translations. There are default\n", "    translations for each module, but you can provide your own by passing a\n", "    list to the ``modules`` argument. For instance,\n", "\n", "    >>> def mysin(x):\n", "    ...     print('taking the sin of', x)\n", "    ...     return numpy.sin(x)\n", "    ...\n", "    >>> f = lambdify(x, sin(x), [{'sin': mysin}, 'numpy'])\n", "    >>> f(1)\n", "    taking the sin of 1\n", "    0.8414709848078965\n", "\n", "    The globals dictionary is generated from the list by merging the\n", "    dictionary ``{'sin': mysin}`` and the module dictionary for NumPy. The\n", "    merging is done so that earlier items take precedence, which is why\n", "    ``mysin`` is used above instead of ``numpy.sin``.\n", "\n", "    If you want to modify the way ``lambdify`` works for a given function, it\n", "    is usually easiest to do so by modifying the globals dictionary as such.\n", "    In more complicated cases, it may be necessary to create and pass in a\n", "    custom printer.\n", "\n", "    Finally, step 3 is augmented with certain convenience operations, such as\n", "    the addition of a docstring.\n", "\n", "    Understanding how ``lambdify`` works can make it easier to avoid certain\n", "    gotchas when using it. For instance, a common mistake is to create a\n", "    lambdified function for one module (say, NumPy), and pass it objects from\n", "    another (say, a SymPy expression).\n", "\n", "    For instance, say we create\n", "\n", "    >>> from sympy.abc import x\n", "    >>> f = lambdify(x, x + 1, 'numpy')\n", "\n", "    Now if we pass in a NumPy array, we get that array plus 1\n", "\n", "    >>> import numpy\n", "    >>> a = numpy.array([1, 2])\n", "    >>> f(a)\n", "    [2 3]\n", "\n", "    But what happens if you make the mistake of passing in a SymPy expression\n", "    instead of a NumPy array:\n", "\n", "    >>> f(x + 1)\n", "    x + 2\n", "\n", "    This worked, but it was only by accident. Now take a different lambdified\n", "    function:\n", "\n", "    >>> from sympy import sin\n", "    >>> g = lambdify(x, x + sin(x), 'numpy')\n", "\n", "    This works as expected on NumPy arrays:\n", "\n", "    >>> g(a)\n", "    [1.84147098 2.90929743]\n", "\n", "    But if we try to pass in a SymPy expression, it fails\n", "\n", "    >>> g(x + 1)\n", "    Traceback (most recent call last):\n", "    ...\n", "    AttributeError: 'Add' object has no attribute 'sin'\n", "\n", "    Now, let's look at what happened. The reason this fails is that ``g``\n", "    calls ``numpy.sin`` on the input expression, and ``numpy.sin`` does not\n", "    know how to operate on a SymPy object. **As a general rule, NumPy\n", "    functions do not know how to operate on SymPy expressions, and SymPy\n", "    functions do not know how to operate on NumPy arrays. This is why lambdify\n", "    exists: to provide a bridge between SymPy and NumPy.**\n", "\n", "    However, why is it that ``f`` did work? That's because ``f`` doesn't call\n", "    any functions, it only adds 1. So the resulting function that is created,\n", "    ``def _lambdifygenerated(x): return x + 1`` does not depend on the globals\n", "    namespace it is defined in. Thus it works, but only by accident. A future\n", "    version of ``lambdify`` may remove this behavior.\n", "\n", "    Be aware that certain implementation details described here may change in\n", "    future versions of SymPy. The API of passing in custom modules and\n", "    printers will not change, but the details of how a lambda function is\n", "    created may change. However, the basic idea will remain the same, and\n", "    understanding it will be helpful to understanding the behavior of\n", "    lambdify.\n", "\n", "    **In general: you should create lambdified functions for one module (say,\n", "    NumPy), and only pass it input types that are compatible with that module\n", "    (say, NumPy arrays).** Remember that by default, if the ``module``\n", "    argument is not provided, ``lambdify`` creates functions using the NumPy\n", "    and SciPy namespaces.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.utilities.lambdify import implemented_function\n", "    >>> from sympy import sqrt, sin, Matrix\n", "    >>> from sympy import Function\n", "    >>> from sympy.abc import w, x, y, z\n", "\n", "    >>> f = lambdify(x, x**2)\n", "    >>> f(2)\n", "    4\n", "    >>> f = lambdify((x, y, z), [z, y, x])\n", "    >>> f(1,2,3)\n", "    [3, 2, 1]\n", "    >>> f = lambdify(x, sqrt(x))\n", "    >>> f(4)\n", "    2.0\n", "    >>> f = lambdify((x, y), sin(x*y)**2)\n", "    >>> f(0, 5)\n", "    0.0\n", "    >>> row = lambdify((x, y), Matrix((x, x + y)).T, modules='sympy')\n", "    >>> row(1, 2)\n", "    Matrix([[1, 3]])\n", "\n", "    ``lambdify`` can be used to translate SymPy expressions into mpmath\n", "    functions. This may be preferable to using ``evalf`` (which uses mpmath on\n", "    the backend) in some cases.\n", "\n", "    >>> import mpmath\n", "    >>> f = lambdify(x, sin(x), 'mpmath')\n", "    >>> f(1)\n", "    0.8414709848078965\n", "\n", "    Tuple arguments are handled and the lambdified function should\n", "    be called with the same type of arguments as were used to create\n", "    the function:\n", "\n", "    >>> f = lambdify((x, (y, z)), x + y)\n", "    >>> f(1, (2, 4))\n", "    3\n", "\n", "    The ``flatten`` function can be used to always work with flattened\n", "    arguments:\n", "\n", "    >>> from sympy.utilities.iterables import flatten\n", "    >>> args = w, (x, (y, z))\n", "    >>> vals = 1, (2, (3, 4))\n", "    >>> f = lambdify(flatten(args), w + x + y + z)\n", "    >>> f(*flatten(vals))\n", "    10\n", "\n", "    Functions present in ``expr`` can also carry their own numerical\n", "    implementations, in a callable attached to the ``_imp_`` attribute. This\n", "    can be used with undefined functions using the ``implemented_function``\n", "    factory:\n", "\n", "    >>> f = implemented_function(Function('f'), lambda x: x+1)\n", "    >>> func = lambdify(x, f(x))\n", "    >>> func(4)\n", "    5\n", "\n", "    ``lambdify`` always prefers ``_imp_`` implementations to implementations\n", "    in other namespaces, unless the ``use_imps`` input parameter is False.\n", "\n", "    Usage with Tensorflow:\n", "\n", "    >>> import tensorflow as tf\n", "    >>> from sympy import Max, sin\n", "    >>> f = Max(x, sin(x))\n", "    >>> func = lambdify(x, f, 'tensorflow')\n", "    >>> result = func(tf.constant(1.0))\n", "    >>> print(result) # a tf.Tensor representing the result of the calculation\n", "    Tensor(\"Maximum:0\", shape=(), dtype=float32)\n", "    >>> sess = tf.Session()\n", "    >>> sess.run(result) # compute result\n", "    1.0\n", "    >>> var = tf.Variable(1.0)\n", "    >>> sess.run(tf.global_variables_initializer())\n", "    >>> sess.run(func(var)) # also works for tf.Variable and tf.Placeholder\n", "    1.0\n", "    >>> tensor = tf.constant([[1.0, 2.0], [3.0, 4.0]]) # works with any shape tensor\n", "    >>> sess.run(func(tensor))\n", "    [[1. 2.]\n", "     [3. 4.]]\n", "\n", "    Notes\n", "    =====\n", "\n", "    - For functions involving large array calculations, numexpr can provide a\n", "      significant speedup over numpy. Please note that the available functions\n", "      for numexpr are more limited than numpy but can be expanded with\n", "      ``implemented_function`` and user defined subclasses of Function. If\n", "      specified, numexpr may be the only option in modules. The official list\n", "      of numexpr functions can be found at:\n", "      https://numexpr.readthedocs.io/en/latest/user_guide.html#supported-functions\n", "\n", "    - In previous versions of SymPy, ``lambdify`` replaced ``Matrix`` with\n", "      ``numpy.matrix`` by default. As of SymPy 1.0 ``numpy.array`` is the\n", "      default. To get the old default behavior you must pass in\n", "      ``[{'ImmutableDenseMatrix':  numpy.matrix}, 'numpy']`` to the\n", "      ``modules`` kwarg.\n", "\n", "      >>> from sympy import lambdify, Matrix\n", "      >>> from sympy.abc import x, y\n", "      >>> import numpy\n", "      >>> array2mat = [{'ImmutableDenseMatrix': numpy.matrix}, 'numpy']\n", "      >>> f = lambdify((x, y), Matrix([x, y]), modules=array2mat)\n", "      >>> f(1, 2)\n", "      [[1]\n", "       [2]]\n", "\n", "    - In the above examples, the generated functions can accept scalar\n", "      values or numpy arrays as arguments.  However, in some cases\n", "      the generated function relies on the input being a numpy array:\n", "\n", "      >>> from sympy import Piecewise\n", "      >>> from sympy.utilities.pytest import ignore_warnings\n", "      >>> f = lambdify(x, Piecewise((x, x <= 1), (1/x, x > 1)), \"numpy\")\n", "\n", "      >>> with ignore_warnings(RuntimeWarning):\n", "      ...     f(numpy.array([-1, 0, 1, 2]))\n", "      [-1.   0.   1.   0.5]\n", "\n", "      >>> f(0)\n", "      Traceback (most recent call last):\n", "          ...\n", "      ZeroDivisionError: division by zero\n", "\n", "      In such cases, the input should be wrapped in a numpy array:\n", "\n", "      >>> with ignore_warnings(RuntimeWarning):\n", "      ...     float(f(numpy.array([0])))\n", "      0.0\n", "\n", "      Or if numpy functionality is not required another module can be used:\n", "\n", "      >>> f = lambdify(x, Piecewise((x, x <= 1), (1/x, x > 1)), \"math\")\n", "      >>> f(0)\n", "      0\n", "\n", "    \"\"\"\n", "    from sympy.core.symbol import Symbol\n", "\n", "    # If the user hasn't specified any modules, use what is available.\n", "    if modules is None:\n", "        try:\n", "            _import(\"scipy\")\n", "        except ImportError:\n", "            try:\n", "                _import(\"numpy\")\n", "            except ImportError:\n", "                # Use either numpy (if available) or python.math where possible.\n", "                # XXX: This leads to different behaviour on different systems and\n", "                #      might be the reason for irreproducible errors.\n", "                modules = [\"math\", \"mpmath\", \"sympy\"]\n", "            else:\n", "                modules = [\"numpy\"]\n", "        else:\n", "            modules = [\"scipy\", \"numpy\"]\n", "\n", "    # Get the needed namespaces.\n", "    namespaces = []\n", "    # First find any function implementations\n", "    if use_imps:\n", "        namespaces.append(_imp_namespace(expr))\n", "    # Check for dict before iterating\n", "    if isinstance(modules, (dict, string_types)) or not hasattr(modules, '__iter__'):\n", "        namespaces.append(modules)\n", "    else:\n", "        # consistency check\n", "        if _module_present('numexpr', modules) and len(modules) > 1:\n", "            raise TypeError(\"numexpr must be the only item in 'modules'\")\n", "        namespaces += list(modules)\n", "    # fill namespace with first having highest priority\n", "    namespace = {}\n", "    for m in namespaces[::-1]:\n", "        buf = _get_namespace(m)\n", "        namespace.update(buf)\n", "\n", "    if hasattr(expr, \"atoms\"):\n", "        #Try if you can extract symbols from the expression.\n", "        #Move on if expr.atoms in not implemented.\n", "        syms = expr.atoms(Symbol)\n", "        for term in syms:\n", "            namespace.update({str(term): term})\n", "\n", "    if printer is None:\n", "        if _module_present('mpmath', namespaces):\n", "            from sympy.printing.pycode import MpmathPrinter as Printer\n", "        elif _module_present('scipy', namespaces):\n", "            from sympy.printing.pycode import SciPyPrinter as Printer\n", "        elif _module_present('numpy', namespaces):\n", "            from sympy.printing.pycode import NumPyPrinter as Printer\n", "        elif _module_present('numexpr', namespaces):\n", "            from sympy.printing.lambdarepr import NumExprPrinter as Printer\n", "        elif _module_present('tensorflow', namespaces):\n", "            from sympy.printing.tensorflow import TensorflowPrinter as Printer\n", "        elif _module_present('sympy', namespaces):\n", "            from sympy.printing.pycode import SymPyPrinter as Printer\n", "        else:\n", "            from sympy.printing.pycode import PythonCodePrinter as Printer\n", "        user_functions = {}\n", "        for m in namespaces[::-1]:\n", "            if isinstance(m, dict):\n", "                for k in m:\n", "                    user_functions[k] = k\n", "        printer = Printer({'fully_qualified_modules': False, 'inline': True,\n", "                           'allow_unknown_functions': True,\n", "                           'user_functions': user_functions})\n", "\n", "    # Get the names of the args, for creating a docstring\n", "    if not iterable(args):\n", "        args = (args,)\n", "    names = []\n", "    # Grab the callers frame, for getting the names by inspection (if needed)\n", "    callers_local_vars = inspect.currentframe().f_back.f_locals.items()\n", "    for n, var in enumerate(args):\n", "        if hasattr(var, 'name'):\n", "            names.append(var.name)\n", "        else:\n", "            # It's an iterable. Try to get name by inspection of calling frame.\n", "            name_list = [var_name for var_name, var_val in callers_local_vars\n", "                    if var_val is var]\n", "            if len(name_list) == 1:\n", "                names.append(name_list[0])\n", "            else:\n", "                # Cannot infer name with certainty. arg_# will have to do.\n", "                names.append('arg_' + str(n))\n", "\n", "    # Create the function definition code and execute it\n", "    funcname = '_lambdifygenerated'\n", "    if _module_present('tensorflow', namespaces):\n", "        funcprinter = _TensorflowEvaluatorPrinter(printer, dummify)\n", "    else:\n", "        funcprinter = _EvaluatorPrinter(printer, dummify)\n", "    funcstr = funcprinter.doprint(funcname, args, expr)\n", "\n", "    # Collect the module imports from the code printers.\n", "    imp_mod_lines = []\n", "    for mod, keys in (getattr(printer, 'module_imports', None) or {}).items():\n", "        for k in keys:\n", "            if k not in namespace:\n", "                imp_mod_lines.append(\"from %s import %s\" % (mod, k))\n", "    for ln in imp_mod_lines:\n", "        exec_(ln, {}, namespace)\n", "\n", "    # Provide lambda expression with builtins, and compatible implementation of range\n", "    namespace.update({'builtins':builtins, 'range':range})\n", "\n", "    funclocals = {}\n", "    global _lambdify_generated_counter\n", "    filename = '<lambdifygenerated-%s>' % _lambdify_generated_counter\n", "    _lambdify_generated_counter += 1\n", "    c = compile(funcstr, filename, 'exec')\n", "    exec_(c, namespace, funclocals)\n", "    # mtime has to be None or else linecache.checkcache will remove it\n", "    linecache.cache[filename] = (len(funcstr), None, funcstr.splitlines(True), filename)\n", "\n", "    func = funclocals[funcname]\n", "\n", "    # Apply the docstring\n", "    sig = \"func({0})\".format(\", \".join(str(i) for i in names))\n", "    sig = textwrap.fill(sig, subsequent_indent=' '*8)\n", "    expr_str = str(expr)\n", "    if len(expr_str) > 78:\n", "        expr_str = textwrap.wrap(expr_str, 75)[0] + '...'\n", "    func.__doc__ = (\n", "        \"Created with lambdify. Signature:\\n\\n\"\n", "        \"{sig}\\n\\n\"\n", "        \"Expression:\\n\\n\"\n", "        \"{expr}\\n\\n\"\n", "        \"Source code:\\n\\n\"\n", "        \"{src}\\n\\n\"\n", "        \"Imported modules:\\n\\n\"\n", "        \"{imp_mods}\"\n", "        ).format(sig=sig, expr=expr_str, src=funcstr, imp_mods='\\n'.join(imp_mod_lines))\n", "    return func\n"]}]}]}