{"instance_id": "sympy__sympy-11897", "identified_spans": [{"file_path": "sympy/printing/latex.py", "span_ids": ["LatexPrinter._print_Mul", "LatexPrinter._print_Pow", "LatexPrinter._print_Float"], "content": [{"span_id": "LatexPrinter._print_Mul", "start_line": 348, "end_line": 438, "content": ["    def _print_Mul(self, expr):\n", "        include_parens = False\n", "        if _coeff_isneg(expr):\n", "            expr = -expr\n", "            tex = \"- \"\n", "            if expr.is_Add:\n", "                tex += \"(\"\n", "                include_parens = True\n", "        else:\n", "            tex = \"\"\n", "\n", "        from sympy.simplify import fraction\n", "        numer, denom = fraction(expr, exact=True)\n", "        separator = self._settings['mul_symbol_latex']\n", "        numbersep = self._settings['mul_symbol_latex_numbers']\n", "\n", "        def convert(expr):\n", "            if not expr.is_Mul:\n", "                return str(self._print(expr))\n", "            else:\n", "                _tex = last_term_tex = \"\"\n", "\n", "                if self.order not in ('old', 'none'):\n", "                    args = expr.as_ordered_factors()\n", "                else:\n", "                    args = expr.args\n", "\n", "                for i, term in enumerate(args):\n", "                    term_tex = self._print(term)\n", "\n", "                    if self._needs_mul_brackets(term, first=(i == 0),\n", "                                                last=(i == len(args) - 1)):\n", "                        term_tex = r\"\\left(%s\\right)\" % term_tex\n", "\n", "                    if _between_two_numbers_p[0].search(last_term_tex) and \\\n", "                            _between_two_numbers_p[1].match(term_tex):\n", "                        # between two numbers\n", "                        _tex += numbersep\n", "                    elif _tex:\n", "                        _tex += separator\n", "\n", "                    _tex += term_tex\n", "                    last_term_tex = term_tex\n", "                return _tex\n", "\n", "        if denom is S.One:\n", "            # use the original expression here, since fraction() may have\n", "            # altered it when producing numer and denom\n", "            tex += convert(expr)\n", "        else:\n", "            snumer = convert(numer)\n", "            sdenom = convert(denom)\n", "            ldenom = len(sdenom.split())\n", "            ratio = self._settings['long_frac_ratio']\n", "            if self._settings['fold_short_frac'] \\\n", "                    and ldenom <= 2 and not \"^\" in sdenom:\n", "                # handle short fractions\n", "                if self._needs_mul_brackets(numer, last=False):\n", "                    tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n", "                else:\n", "                    tex += r\"%s / %s\" % (snumer, sdenom)\n", "            elif len(snumer.split()) > ratio*ldenom:\n", "                # handle long fractions\n", "                if self._needs_mul_brackets(numer, last=True):\n", "                    tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n", "                        % (sdenom, separator, snumer)\n", "                elif numer.is_Mul:\n", "                    # split a long numerator\n", "                    a = S.One\n", "                    b = S.One\n", "                    for x in numer.args:\n", "                        if self._needs_mul_brackets(x, last=False) or \\\n", "                                len(convert(a*x).split()) > ratio*ldenom or \\\n", "                                (b.is_commutative is x.is_commutative is False):\n", "                            b *= x\n", "                        else:\n", "                            a *= x\n", "                    if self._needs_mul_brackets(b, last=True):\n", "                        tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n", "                            % (convert(a), sdenom, separator, convert(b))\n", "                    else:\n", "                        tex += r\"\\frac{%s}{%s}%s%s\" \\\n", "                            % (convert(a), sdenom, separator, convert(b))\n", "                else:\n", "                    tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n", "            else:\n", "                tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n", "\n", "        if include_parens:\n", "            tex += \")\"\n", "        return tex\n"]}, {"span_id": "LatexPrinter._print_Pow", "start_line": 440, "end_line": 484, "content": ["    def _print_Pow(self, expr):\n", "        # Treat x**Rational(1,n) as special case\n", "        if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1:\n", "            base = self._print(expr.base)\n", "            expq = expr.exp.q\n", "\n", "            if expq == 2:\n", "                tex = r\"\\sqrt{%s}\" % base\n", "            elif self._settings['itex']:\n", "                tex = r\"\\root{%d}{%s}\" % (expq, base)\n", "            else:\n", "                tex = r\"\\sqrt[%d]{%s}\" % (expq, base)\n", "\n", "            if expr.exp.is_negative:\n", "                return r\"\\frac{1}{%s}\" % tex\n", "            else:\n", "                return tex\n", "        elif self._settings['fold_frac_powers'] \\\n", "            and expr.exp.is_Rational \\\n", "                and expr.exp.q != 1:\n", "            base, p, q = self.parenthesize(expr.base, PRECEDENCE['Pow']), expr.exp.p, expr.exp.q\n", "            if expr.base.is_Function:\n", "                return self._print(expr.base, \"%s/%s\" % (p, q))\n", "            return r\"%s^{%s/%s}\" % (base, p, q)\n", "        elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n", "            # Things like 1/x\n", "            return self._print_Mul(expr)\n", "        else:\n", "            if expr.base.is_Function:\n", "                return self._print(expr.base, self._print(expr.exp))\n", "            else:\n", "                if expr.is_commutative and expr.exp == -1:\n", "                    #solves issue 4129\n", "                    #As Mul always simplify 1/x to x**-1\n", "                    #The objective is achieved with this hack\n", "                    #first we get the latex for -1 * expr,\n", "                    #which is a Mul expression\n", "                    tex = self._print(S.NegativeOne * expr).strip()\n", "                    #the result comes with a minus and a space, so we remove\n", "                    if tex[:1] == \"-\":\n", "                        return tex[1:].strip()\n", "                tex = r\"%s^{%s}\"\n", "\n", "                return tex % (self.parenthesize(expr.base, PRECEDENCE['Pow']),\n", "                              self._print(expr.exp))\n"]}, {"span_id": "LatexPrinter._print_Float", "start_line": 325, "end_line": 346, "content": ["    def _print_Float(self, expr):\n", "        # Based off of that in StrPrinter\n", "        dps = prec_to_dps(expr._prec)\n", "        str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)\n", "\n", "        # Must always have a mul symbol (as 2.5 10^{20} just looks odd)\n", "        # thus we use the number separator\n", "        separator = self._settings['mul_symbol_latex_numbers']\n", "\n", "        if 'e' in str_real:\n", "            (mant, exp) = str_real.split('e')\n", "\n", "            if exp[0] == '+':\n", "                exp = exp[1:]\n", "\n", "            return r\"%s%s10^{%s}\" % (mant, separator, exp)\n", "        elif str_real == \"+inf\":\n", "            return r\"\\infty\"\n", "        elif str_real == \"-inf\":\n", "            return r\"- \\infty\"\n", "        else:\n", "            return str_real\n"]}]}, {"file_path": "sympy/printing/pretty/pretty.py", "span_ids": ["PrettyPrinter._print_Float", "PrettyPrinter._print_Pow", "PrettyPrinter._print_Mul"], "content": [{"span_id": "PrettyPrinter._print_Float", "start_line": 81, "end_line": 87, "content": ["    def _print_Float(self, e):\n", "        # we will use StrPrinter's Float printer, but we need to handle the\n", "        # full_prec ourselves, according to the self._print_level\n", "        full_prec = self._settings[\"full_prec\"]\n", "        if full_prec == \"auto\":\n", "            full_prec = self._print_level == 1\n", "        return prettyForm(sstr(e, full_prec=full_prec))\n"]}, {"span_id": "PrettyPrinter._print_Pow", "start_line": 1491, "end_line": 1506, "content": ["    def _print_Pow(self, power):\n", "        from sympy.simplify.simplify import fraction\n", "        b, e = power.as_base_exp()\n", "        if power.is_commutative:\n", "            if e is S.NegativeOne:\n", "                return prettyForm(\"1\")/self._print(b)\n", "            n, d = fraction(e)\n", "            if n is S.One and d.is_Atom and not e.is_Integer:\n", "                return self._print_nth_root(b, e)\n", "            if e.is_Rational and e < 0:\n", "                return prettyForm(\"1\")/self._print(Pow(b, -e, evaluate=False))\n", "\n", "        if b.is_Relational:\n", "            return prettyForm(*self._print(b).parens()).__pow__(self._print(e))\n", "\n", "        return self._print(b)**self._print(e)\n"]}, {"span_id": "PrettyPrinter._print_Mul", "start_line": 1393, "end_line": 1443, "content": ["    def _print_Mul(self, product):\n", "        a = []  # items in the numerator\n", "        b = []  # items that are in the denominator (if any)\n", "\n", "        if self.order not in ('old', 'none'):\n", "            args = product.as_ordered_factors()\n", "        else:\n", "            args = product.args\n", "\n", "        # Gather terms for numerator/denominator\n", "        for item in args:\n", "            if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n", "                if item.exp != -1:\n", "                    b.append(Pow(item.base, -item.exp, evaluate=False))\n", "                else:\n", "                    b.append(Pow(item.base, -item.exp))\n", "            elif item.is_Rational and item is not S.Infinity:\n", "                if item.p != 1:\n", "                    a.append( Rational(item.p) )\n", "                if item.q != 1:\n", "                    b.append( Rational(item.q) )\n", "            else:\n", "                a.append(item)\n", "\n", "        from sympy import Integral, Piecewise, Product, Sum\n", "\n", "        # Convert to pretty forms. Add parens to Add instances if there\n", "        # is more than one term in the numer/denom\n", "        for i in range(0, len(a)):\n", "            if (a[i].is_Add and len(a) > 1) or (i != len(a) - 1 and\n", "                    isinstance(a[i], (Integral, Piecewise, Product, Sum))):\n", "                a[i] = prettyForm(*self._print(a[i]).parens())\n", "            elif a[i].is_Relational:\n", "                a[i] = prettyForm(*self._print(a[i]).parens())\n", "            else:\n", "                a[i] = self._print(a[i])\n", "\n", "        for i in range(0, len(b)):\n", "            if (b[i].is_Add and len(b) > 1) or (i != len(b) - 1 and\n", "                    isinstance(b[i], (Integral, Piecewise, Product, Sum))):\n", "                b[i] = prettyForm(*self._print(b[i]).parens())\n", "            else:\n", "                b[i] = self._print(b[i])\n", "\n", "        # Construct a pretty form\n", "        if len(b) == 0:\n", "            return prettyForm.__mul__(*a)\n", "        else:\n", "            if len(a) == 0:\n", "                a.append( self._print(S.One) )\n", "            return prettyForm.__mul__(*a)/prettyForm.__mul__(*b)\n"]}]}]}