{"instance_id": "django__django-15252", "identified_spans": [{"file_path": "django/db/migrations/executor.py", "span_ids": ["MigrationExecutor", "MigrationExecutor.apply_migration", "MigrationExecutor.record_migration"], "content": [{"span_id": "MigrationExecutor", "start_line": 10, "end_line": 14, "content": ["class MigrationExecutor:\n", "    \"\"\"\n", "    End-to-end migration execution - load migrations and run them up or down\n", "    to a specified set of targets.\n", "    \"\"\"\n"]}, {"span_id": "MigrationExecutor.apply_migration", "start_line": 222, "end_line": 245, "content": ["    def apply_migration(self, state, migration, fake=False, fake_initial=False):\n", "        \"\"\"Run a migration forwards.\"\"\"\n", "        migration_recorded = False\n", "        if self.progress_callback:\n", "            self.progress_callback(\"apply_start\", migration, fake)\n", "        if not fake:\n", "            if fake_initial:\n", "                # Test to see if this is an already-applied initial migration\n", "                applied, state = self.detect_soft_applied(state, migration)\n", "                if applied:\n", "                    fake = True\n", "            if not fake:\n", "                # Alright, do it normally\n", "                with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:\n", "                    state = migration.apply(state, schema_editor)\n", "                    if not schema_editor.deferred_sql:\n", "                        self.record_migration(migration)\n", "                        migration_recorded = True\n", "        if not migration_recorded:\n", "            self.record_migration(migration)\n", "        # Report progress\n", "        if self.progress_callback:\n", "            self.progress_callback(\"apply_success\", migration, fake)\n", "        return state\n"]}, {"span_id": "MigrationExecutor.record_migration", "start_line": 247, "end_line": 253, "content": ["    def record_migration(self, migration):\n", "        # For replacement migrations, record individual statuses\n", "        if migration.replaces:\n", "            for app_label, name in migration.replaces:\n", "                self.recorder.record_applied(app_label, name)\n", "        else:\n", "            self.recorder.record_applied(migration.app_label, migration.name)\n"]}]}, {"file_path": "django/db/migrations/recorder.py", "span_ids": ["MigrationRecorder.ensure_schema", "MigrationRecorder", "MigrationRecorder.record_applied"], "content": [{"span_id": "MigrationRecorder.ensure_schema", "start_line": 59, "end_line": 70, "content": ["    def ensure_schema(self):\n", "        \"\"\"Ensure the table exists and has the correct schema.\"\"\"\n", "        # If the table's there, that's fine - we've never changed its schema\n", "        # in the codebase.\n", "        if self.has_table():\n", "            return\n", "        # Make the table\n", "        try:\n", "            with self.connection.schema_editor() as editor:\n", "                editor.create_model(self.Migration)\n", "        except DatabaseError as exc:\n", "            raise MigrationSchemaMissing(\"Unable to create the django_migrations table (%s)\" % exc)\n"]}, {"span_id": "MigrationRecorder", "start_line": 9, "end_line": 21, "content": ["class MigrationRecorder:\n", "    \"\"\"\n", "    Deal with storing migration records in the database.\n", "\n", "    Because this table is actually itself used for dealing with model\n", "    creation, it's the one thing we can't do normally via migrations.\n", "    We manually handle table creation/schema updating (using schema backend)\n", "    and then have a floating model to do queries with.\n", "\n", "    If a migration is unapplied its row is removed from the table. Having\n", "    a row in the table always means a migration is applied.\n", "    \"\"\"\n", "    _migration_class = None\n"]}, {"span_id": "MigrationRecorder.record_applied", "start_line": 84, "end_line": 87, "content": ["    def record_applied(self, app, name):\n", "        \"\"\"Record that a migration was applied.\"\"\"\n", "        self.ensure_schema()\n", "        self.migration_qs.create(app=app, name=name)\n"]}]}, {"file_path": "django/db/utils.py", "span_ids": ["ConnectionRouter", "ConnectionRouter.allow_migrate"], "content": [{"span_id": "ConnectionRouter", "start_line": 217, "end_line": 217, "content": ["class ConnectionRouter:\n"]}, {"span_id": "ConnectionRouter.allow_migrate", "start_line": 272, "end_line": 284, "content": ["    def allow_migrate(self, db, app_label, **hints):\n", "        for router in self.routers:\n", "            try:\n", "                method = router.allow_migrate\n", "            except AttributeError:\n", "                # If the router doesn't have a method, skip to the next one.\n", "                continue\n", "\n", "            allow = method(db, app_label, **hints)\n", "\n", "            if allow is not None:\n", "                return allow\n", "        return True\n"]}]}]}