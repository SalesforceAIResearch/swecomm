{"instance_id": "astropy__astropy-6938", "identified_spans": [{"file_path": "astropy/io/fits/fitsrec.py", "span_ids": ["FITS_rec._scale_back_ascii"], "content": [{"span_id": "FITS_rec._scale_back_ascii", "start_line": 1196, "end_line": 1264, "content": ["    def _scale_back_ascii(self, col_idx, input_field, output_field):\n", "        \"\"\"\n", "        Convert internal array values back to ASCII table representation.\n", "\n", "        The ``input_field`` is the internal representation of the values, and\n", "        the ``output_field`` is the character array representing the ASCII\n", "        output that will be written.\n", "        \"\"\"\n", "\n", "        starts = self._coldefs.starts[:]\n", "        spans = self._coldefs.spans\n", "        format = self._coldefs[col_idx].format\n", "\n", "        # The the index of the \"end\" column of the record, beyond\n", "        # which we can't write\n", "        end = super().field(-1).itemsize\n", "        starts.append(end + starts[-1])\n", "\n", "        if col_idx > 0:\n", "            lead = starts[col_idx] - starts[col_idx - 1] - spans[col_idx - 1]\n", "        else:\n", "            lead = 0\n", "\n", "        if lead < 0:\n", "            warnings.warn('Column {!r} starting point overlaps the previous '\n", "                          'column.'.format(col_idx + 1))\n", "\n", "        trail = starts[col_idx + 1] - starts[col_idx] - spans[col_idx]\n", "\n", "        if trail < 0:\n", "            warnings.warn('Column {!r} ending point overlaps the next '\n", "                          'column.'.format(col_idx + 1))\n", "\n", "        # TODO: It would be nice if these string column formatting\n", "        # details were left to a specialized class, as is the case\n", "        # with FormatX and FormatP\n", "        if 'A' in format:\n", "            _pc = '{:'\n", "        else:\n", "            _pc = '{:>'\n", "\n", "        fmt = ''.join([_pc, format[1:], ASCII2STR[format[0]], '}',\n", "                       (' ' * trail)])\n", "\n", "        # Even if the format precision is 0, we should output a decimal point\n", "        # as long as there is space to do so--not including a decimal point in\n", "        # a float value is discouraged by the FITS Standard\n", "        trailing_decimal = (format.precision == 0 and\n", "                            format.format in ('F', 'E', 'D'))\n", "\n", "        # not using numarray.strings's num2char because the\n", "        # result is not allowed to expand (as C/Python does).\n", "        for jdx, value in enumerate(input_field):\n", "            value = fmt.format(value)\n", "            if len(value) > starts[col_idx + 1] - starts[col_idx]:\n", "                raise ValueError(\n", "                    \"Value {!r} does not fit into the output's itemsize of \"\n", "                    \"{}.\".format(value, spans[col_idx]))\n", "\n", "            if trailing_decimal and value[0] == ' ':\n", "                # We have some extra space in the field for the trailing\n", "                # decimal point\n", "                value = value[1:] + '.'\n", "\n", "            output_field[jdx] = value\n", "\n", "        # Replace exponent separator in floating point numbers\n", "        if 'D' in format:\n", "            output_field.replace(encode_ascii('E'), encode_ascii('D'))\n"]}]}]}