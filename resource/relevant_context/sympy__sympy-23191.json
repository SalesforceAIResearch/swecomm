{"instance_id": "sympy__sympy-23191", "identified_spans": [{"file_path": "sympy/physics/vector/printing.py", "span_ids": ["VectorPrettyPrinter._print_Function", "vpprint", "VectorPrettyPrinter"], "content": [{"span_id": "VectorPrettyPrinter._print_Function", "start_line": 157, "end_line": 170, "content": ["    def _print_Function(self, e):\n", "        from sympy.physics.vector.functions import dynamicsymbols\n", "        t = dynamicsymbols._t\n", "        # XXX works only for applied functions\n", "        func = e.func\n", "        args = e.args\n", "        func_name = func.__name__\n", "        pform = self._print_Symbol(Symbol(func_name))\n", "        # If this function is an Undefined function of t, it is probably a\n", "        # dynamic symbol, so we'll skip the (t). The rest of the code is\n", "        # identical to the normal PrettyPrinter code\n", "        if not (isinstance(func, UndefinedFunction) and (args == (t,))):\n", "            return super()._print_Function(e)\n", "        return pform\n"]}, {"span_id": "vpprint", "start_line": 256, "end_line": 287, "content": ["def vpprint(expr, **settings):\n", "    r\"\"\"Function for pretty printing of expressions generated in the\n", "    sympy.physics vector package.\n", "\n", "    Mainly used for expressions not inside a vector; the output of running\n", "    scripts and generating equations of motion. Takes the same options as\n", "    SymPy's :func:`~.pretty_print`; see that function for more information.\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    expr : valid SymPy object\n", "        SymPy expression to pretty print\n", "    settings : args\n", "        Same as those accepted by SymPy's pretty_print.\n", "\n", "\n", "    \"\"\"\n", "\n", "    pp = VectorPrettyPrinter(settings)\n", "\n", "    # Note that this is copied from sympy.printing.pretty.pretty_print:\n", "\n", "    # XXX: this is an ugly hack, but at least it works\n", "    use_unicode = pp._settings['use_unicode']\n", "    from sympy.printing.pretty.pretty_symbology import pretty_use_unicode\n", "    uflag = pretty_use_unicode(use_unicode)\n", "\n", "    try:\n", "        return pp.doprint(expr)\n", "    finally:\n", "        pretty_use_unicode(uflag)\n"]}, {"span_id": "VectorPrettyPrinter", "start_line": 106, "end_line": 107, "content": ["class VectorPrettyPrinter(PrettyPrinter):\n", "    \"\"\"Pretty Printer for vectorialexpressions. \"\"\"\n"]}]}, {"file_path": "sympy/printing/pretty/pretty.py", "span_ids": ["PrettyPrinter", "PrettyPrinter._print_Integral"], "content": [{"span_id": "PrettyPrinter", "start_line": 30, "end_line": 45, "content": ["class PrettyPrinter(Printer):\n", "    \"\"\"Printer, which converts an expression into 2D ASCII-art figure.\"\"\"\n", "    printmethod = \"_pretty\"\n", "\n", "    _default_settings = {\n", "        \"order\": None,\n", "        \"full_prec\": \"auto\",\n", "        \"use_unicode\": None,\n", "        \"wrap_line\": True,\n", "        \"num_columns\": None,\n", "        \"use_unicode_sqrt_char\": True,\n", "        \"root_notation\": True,\n", "        \"mat_symbol_style\": \"plain\",\n", "        \"imaginary_unit\": \"i\",\n", "        \"perm_cyclic\": True\n", "    }\n"]}, {"span_id": "PrettyPrinter._print_Integral", "start_line": 429, "end_line": 502, "content": ["    def _print_Integral(self, integral):\n", "        f = integral.function\n", "\n", "        # Add parentheses if arg involves addition of terms and\n", "        # create a pretty form for the argument\n", "        prettyF = self._print(f)\n", "        # XXX generalize parens\n", "        if f.is_Add:\n", "            prettyF = prettyForm(*prettyF.parens())\n", "\n", "        # dx dy dz ...\n", "        arg = prettyF\n", "        for x in integral.limits:\n", "            prettyArg = self._print(x[0])\n", "            # XXX qparens (parens if needs-parens)\n", "            if prettyArg.width() > 1:\n", "                prettyArg = prettyForm(*prettyArg.parens())\n", "\n", "            arg = prettyForm(*arg.right(' d', prettyArg))\n", "\n", "        # \\int \\int \\int ...\n", "        firstterm = True\n", "        s = None\n", "        for lim in integral.limits:\n", "            # Create bar based on the height of the argument\n", "            h = arg.height()\n", "            H = h + 2\n", "\n", "            # XXX hack!\n", "            ascii_mode = not self._use_unicode\n", "            if ascii_mode:\n", "                H += 2\n", "\n", "            vint = vobj('int', H)\n", "\n", "            # Construct the pretty form with the integral sign and the argument\n", "            pform = prettyForm(vint)\n", "            pform.baseline = arg.baseline + (\n", "                H - h)//2    # covering the whole argument\n", "\n", "            if len(lim) > 1:\n", "                # Create pretty forms for endpoints, if definite integral.\n", "                # Do not print empty endpoints.\n", "                if len(lim) == 2:\n", "                    prettyA = prettyForm(\"\")\n", "                    prettyB = self._print(lim[1])\n", "                if len(lim) == 3:\n", "                    prettyA = self._print(lim[1])\n", "                    prettyB = self._print(lim[2])\n", "\n", "                if ascii_mode:  # XXX hack\n", "                    # Add spacing so that endpoint can more easily be\n", "                    # identified with the correct integral sign\n", "                    spc = max(1, 3 - prettyB.width())\n", "                    prettyB = prettyForm(*prettyB.left(' ' * spc))\n", "\n", "                    spc = max(1, 4 - prettyA.width())\n", "                    prettyA = prettyForm(*prettyA.right(' ' * spc))\n", "\n", "                pform = prettyForm(*pform.above(prettyB))\n", "                pform = prettyForm(*pform.below(prettyA))\n", "\n", "            if not ascii_mode:  # XXX hack\n", "                pform = prettyForm(*pform.right(' '))\n", "\n", "            if firstterm:\n", "                s = pform   # first term\n", "                firstterm = False\n", "            else:\n", "                s = prettyForm(*s.left(pform))\n", "\n", "        pform = prettyForm(*arg.left(s))\n", "        pform.binding = prettyForm.MUL\n", "        return pform\n"]}]}, {"file_path": "sympy/vector/coordsysrect.py", "span_ids": ["CoordSys3D"], "content": [{"span_id": "CoordSys3D", "start_line": 25, "end_line": 28, "content": ["class CoordSys3D(Basic):\n", "    \"\"\"\n", "    Represents a coordinate system in 3-D space.\n", "    \"\"\"\n"]}]}, {"file_path": "sympy/vector/deloperator.py", "span_ids": ["Del"], "content": [{"span_id": "Del", "start_line": 5, "end_line": 9, "content": ["class Del(Basic):\n", "    \"\"\"\n", "    Represents the vector differential operator, usually represented in\n", "    mathematical expressions as the 'nabla' symbol.\n", "    \"\"\"\n"]}]}, {"file_path": "sympy/vector/vector.py", "span_ids": ["Vector._pretty", "Vector"], "content": [{"span_id": "Vector", "start_line": 18, "end_line": 34, "content": ["class Vector(BasisDependent):\n", "    \"\"\"\n", "    Super class for all Vector classes.\n", "    Ideally, neither this class nor any of its subclasses should be\n", "    instantiated by the user.\n", "    \"\"\"\n", "\n", "    is_scalar = False\n", "    is_Vector = True\n", "    _op_priority = 12.0\n", "\n", "    _expr_type = None  # type: Type[Vector]\n", "    _mul_func = None  # type: Type[Vector]\n", "    _add_func = None  # type: Type[Vector]\n", "    _zero_func = None  # type: Type[Vector]\n", "    _base_func = None  # type: Type[Vector]\n", "    zero = None  # type: VectorZero\n"]}]}]}