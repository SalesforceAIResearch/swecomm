{"instance_id": "matplotlib__matplotlib-24334", "identified_spans": [{"file_path": "lib/matplotlib/axis.py", "span_ids": ["Axis.set_ticks", "Axis.set_ticklabels"], "content": [{"span_id": "Axis.set_ticks", "start_line": 1990, "end_line": 2027, "content": ["    def set_ticks(self, ticks, labels=None, *, minor=False, **kwargs):\n", "        \"\"\"\n", "        Set this Axis' tick locations and optionally labels.\n", "\n", "        If necessary, the view limits of the Axis are expanded so that all\n", "        given ticks are visible.\n", "\n", "        Parameters\n", "        ----------\n", "        ticks : list of floats\n", "            List of tick locations.  The axis `.Locator` is replaced by a\n", "            `~.ticker.FixedLocator`.\n", "\n", "            Some tick formatters will not label arbitrary tick positions;\n", "            e.g. log formatters only label decade ticks by default. In\n", "            such a case you can set a formatter explicitly on the axis\n", "            using `.Axis.set_major_formatter` or provide formatted\n", "            *labels* yourself.\n", "        labels : list of str, optional\n", "            List of tick labels. If not set, the labels are generated with\n", "            the axis tick `.Formatter`.\n", "        minor : bool, default: False\n", "            If ``False``, set the major ticks; if ``True``, the minor ticks.\n", "        **kwargs\n", "            `.Text` properties for the labels. These take effect only if you\n", "            pass *labels*. In other cases, please use `~.Axes.tick_params`.\n", "\n", "        Notes\n", "        -----\n", "        The mandatory expansion of the view limits is an intentional design\n", "        choice to prevent the surprise of a non-visible tick. If you need\n", "        other limits, you should set the limits explicitly after setting the\n", "        ticks.\n", "        \"\"\"\n", "        result = self._set_tick_locations(ticks, minor=minor)\n", "        if labels is not None:\n", "            self.set_ticklabels(labels, minor=minor, **kwargs)\n", "        return result\n"]}, {"span_id": "Axis.set_ticklabels", "start_line": 1841, "end_line": 1921, "content": ["    def set_ticklabels(self, ticklabels, *, minor=False, **kwargs):\n", "        r\"\"\"\n", "        [*Discouraged*] Set the text values of the tick labels.\n", "\n", "        .. admonition:: Discouraged\n", "\n", "            The use of this method is discouraged, because of the dependency\n", "            on tick positions. In most cases, you'll want to use\n", "            ``set_[x/y]ticks(positions, labels)`` instead.\n", "\n", "            If you are using this method, you should always fix the tick\n", "            positions before, e.g. by using `.Axis.set_ticks` or by explicitly\n", "            setting a `~.ticker.FixedLocator`. Otherwise, ticks are free to\n", "            move and the labels may end up in unexpected positions.\n", "\n", "        Parameters\n", "        ----------\n", "        ticklabels : sequence of str or of `.Text`\\s\n", "            Texts for labeling each tick location in the sequence set by\n", "            `.Axis.set_ticks`; the number of labels must match the number of\n", "            locations.\n", "        minor : bool\n", "            If True, set minor ticks instead of major ticks.\n", "        **kwargs\n", "            Text properties.\n", "\n", "        Returns\n", "        -------\n", "        list of `.Text`\\s\n", "            For each tick, includes ``tick.label1`` if it is visible, then\n", "            ``tick.label2`` if it is visible, in that order.\n", "        \"\"\"\n", "        try:\n", "            ticklabels = [t.get_text() if hasattr(t, 'get_text') else t\n", "                          for t in ticklabels]\n", "        except TypeError:\n", "            raise TypeError(f\"{ticklabels:=} must be a sequence\") from None\n", "        locator = (self.get_minor_locator() if minor\n", "                   else self.get_major_locator())\n", "        if isinstance(locator, mticker.FixedLocator):\n", "            # Passing [] as a list of ticklabels is often used as a way to\n", "            # remove all tick labels, so only error for > 0 ticklabels\n", "            if len(locator.locs) != len(ticklabels) and len(ticklabels) != 0:\n", "                raise ValueError(\n", "                    \"The number of FixedLocator locations\"\n", "                    f\" ({len(locator.locs)}), usually from a call to\"\n", "                    \" set_ticks, does not match\"\n", "                    f\" the number of ticklabels ({len(ticklabels)}).\")\n", "            tickd = {loc: lab for loc, lab in zip(locator.locs, ticklabels)}\n", "            func = functools.partial(self._format_with_dict, tickd)\n", "            formatter = mticker.FuncFormatter(func)\n", "        else:\n", "            formatter = mticker.FixedFormatter(ticklabels)\n", "\n", "        if minor:\n", "            self.set_minor_formatter(formatter)\n", "            locs = self.get_minorticklocs()\n", "            ticks = self.get_minor_ticks(len(locs))\n", "        else:\n", "            self.set_major_formatter(formatter)\n", "            locs = self.get_majorticklocs()\n", "            ticks = self.get_major_ticks(len(locs))\n", "\n", "        ret = []\n", "        for pos, (loc, tick) in enumerate(zip(locs, ticks)):\n", "            tick.update_position(loc)\n", "            tick_label = formatter(loc, pos)\n", "            # deal with label1\n", "            tick.label1.set_text(tick_label)\n", "            tick.label1._internal_update(kwargs)\n", "            # deal with label2\n", "            tick.label2.set_text(tick_label)\n", "            tick.label2._internal_update(kwargs)\n", "            # only return visible tick labels\n", "            if tick.label1.get_visible():\n", "                ret.append(tick.label1)\n", "            if tick.label2.get_visible():\n", "                ret.append(tick.label2)\n", "\n", "        self.stale = True\n", "        return ret\n"]}]}]}