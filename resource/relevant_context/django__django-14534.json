{"instance_id": "django__django-14534", "identified_spans": [{"file_path": "django/forms/boundfield.py", "span_ids": ["BoundWidget", "BoundField.subwidgets", "BoundWidget.id_for_label"], "content": [{"span_id": "BoundWidget", "start_line": 246, "end_line": 259, "content": ["@html_safe\n", "class BoundWidget:\n", "    \"\"\"\n", "    A container class used for iterating over widgets. This is useful for\n", "    widgets that have choices. For example, the following can be used in a\n", "    template:\n", "\n", "    {% for radio in myform.beatles %}\n", "      <label for=\"{{ radio.id_for_label }}\">\n", "        {{ radio.choice_label }}\n", "        <span class=\"radio\">{{ radio.tag }}</span>\n", "      </label>\n", "    {% endfor %}\n", "    \"\"\"\n"]}, {"span_id": "BoundField.subwidgets", "start_line": 36, "end_line": 51, "content": ["    @cached_property\n", "    def subwidgets(self):\n", "        \"\"\"\n", "        Most widgets yield a single subwidget, but others like RadioSelect and\n", "        CheckboxSelectMultiple produce one subwidget for each choice.\n", "\n", "        This property is cached so that only one database query occurs when\n", "        rendering ModelChoiceFields.\n", "        \"\"\"\n", "        id_ = self.field.widget.attrs.get('id') or self.auto_id\n", "        attrs = {'id': id_} if id_ else {}\n", "        attrs = self.build_widget_attrs(attrs)\n", "        return [\n", "            BoundWidget(self.field.widget, widget, self.form.renderer)\n", "            for widget in self.field.widget.subwidgets(self.html_name, self.value(), attrs=attrs)\n", "        ]\n"]}, {"span_id": "BoundWidget.id_for_label", "start_line": 278, "end_line": 280, "content": ["    @property\n", "    def id_for_label(self):\n", "        return 'id_%s_%s' % (self.data['name'], self.data['index'])\n"]}]}]}