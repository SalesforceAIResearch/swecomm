{"instance_id": "sympy__sympy-19487", "identified_spans": [{"file_path": "sympy/functions/elementary/complexes.py", "span_ids": ["sign.eval", "Abs", "sign", "Abs.eval"], "content": [{"span_id": "sign.eval", "start_line": 295, "end_line": 340, "content": ["    @classmethod\n", "    def eval(cls, arg):\n", "        # handle what we can\n", "        if arg.is_Mul:\n", "            c, args = arg.as_coeff_mul()\n", "            unk = []\n", "            s = sign(c)\n", "            for a in args:\n", "                if a.is_extended_negative:\n", "                    s = -s\n", "                elif a.is_extended_positive:\n", "                    pass\n", "                else:\n", "                    ai = im(a)\n", "                    if a.is_imaginary and ai.is_comparable:  # i.e. a = I*real\n", "                        s *= S.ImaginaryUnit\n", "                        if ai.is_extended_negative:\n", "                            # can't use sign(ai) here since ai might not be\n", "                            # a Number\n", "                            s = -s\n", "                    else:\n", "                        unk.append(a)\n", "            if c is S.One and len(unk) == len(args):\n", "                return None\n", "            return s * cls(arg._new_rawargs(*unk))\n", "        if arg is S.NaN:\n", "            return S.NaN\n", "        if arg.is_zero:  # it may be an Expr that is zero\n", "            return S.Zero\n", "        if arg.is_extended_positive:\n", "            return S.One\n", "        if arg.is_extended_negative:\n", "            return S.NegativeOne\n", "        if arg.is_Function:\n", "            if isinstance(arg, sign):\n", "                return arg\n", "        if arg.is_imaginary:\n", "            if arg.is_Pow and arg.exp is S.Half:\n", "                # we catch this because non-trivial sqrt args are not expanded\n", "                # e.g. sqrt(1-sqrt(2)) --x-->  to I*sqrt(sqrt(2) - 1)\n", "                return S.ImaginaryUnit\n", "            arg2 = -S.ImaginaryUnit * arg\n", "            if arg2.is_extended_positive:\n", "                return S.ImaginaryUnit\n", "            if arg2.is_extended_negative:\n", "                return -S.ImaginaryUnit\n"]}, {"span_id": "Abs", "start_line": 401, "end_line": 443, "content": ["class Abs(Function):\n", "    \"\"\"\n", "    Return the absolute value of the argument.\n", "\n", "    This is an extension of the built-in function abs() to accept symbolic\n", "    values.  If you pass a SymPy expression to the built-in abs(), it will\n", "    pass it automatically to Abs().\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import Abs, Symbol, S\n", "    >>> Abs(-1)\n", "    1\n", "    >>> x = Symbol('x', real=True)\n", "    >>> Abs(-x)\n", "    Abs(x)\n", "    >>> Abs(x**2)\n", "    x**2\n", "    >>> abs(-x) # The Python built-in\n", "    Abs(x)\n", "\n", "    Note that the Python built-in will return either an Expr or int depending on\n", "    the argument::\n", "\n", "        >>> type(abs(-1))\n", "        <... 'int'>\n", "        >>> type(abs(S.NegativeOne))\n", "        <class 'sympy.core.numbers.One'>\n", "\n", "    Abs will always return a sympy object.\n", "\n", "    See Also\n", "    ========\n", "\n", "    sign, conjugate\n", "    \"\"\"\n", "\n", "    is_extended_real = True\n", "    is_extended_negative = False\n", "    is_extended_nonnegative = True\n", "    unbranched = True\n", "    _singularities = True  # non-holomorphic\n"]}, {"span_id": "sign", "start_line": 246, "end_line": 288, "content": ["class sign(Function):\n", "    \"\"\"\n", "    Returns the complex sign of an expression:\n", "\n", "    If the expression is real the sign will be:\n", "\n", "        * 1 if expression is positive\n", "        * 0 if expression is equal to zero\n", "        * -1 if expression is negative\n", "\n", "    If the expression is imaginary the sign will be:\n", "\n", "        * I if im(expression) is positive\n", "        * -I if im(expression) is negative\n", "\n", "    Otherwise an unevaluated expression will be returned. When evaluated, the\n", "    result (in general) will be ``cos(arg(expr)) + I*sin(arg(expr))``.\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy.functions import sign\n", "    >>> from sympy.core.numbers import I\n", "\n", "    >>> sign(-1)\n", "    -1\n", "    >>> sign(0)\n", "    0\n", "    >>> sign(-3*I)\n", "    -I\n", "    >>> sign(1 + I)\n", "    sign(1 + I)\n", "    >>> _.evalf()\n", "    0.707106781186548 + 0.707106781186548*I\n", "\n", "    See Also\n", "    ========\n", "\n", "    Abs, conjugate\n", "    \"\"\"\n", "\n", "    is_complex = True\n", "    _singularities = True\n"]}, {"span_id": "Abs.eval", "start_line": 462, "end_line": 550, "content": ["    @classmethod\n", "    def eval(cls, arg):\n", "        from sympy.simplify.simplify import signsimp\n", "        from sympy.core.function import expand_mul\n", "        from sympy.core.power import Pow\n", "\n", "        if hasattr(arg, '_eval_Abs'):\n", "            obj = arg._eval_Abs()\n", "            if obj is not None:\n", "                return obj\n", "        if not isinstance(arg, Expr):\n", "            raise TypeError(\"Bad argument type for Abs(): %s\" % type(arg))\n", "        # handle what we can\n", "        arg = signsimp(arg, evaluate=False)\n", "        n, d = arg.as_numer_denom()\n", "        if d.free_symbols and not n.free_symbols:\n", "            return cls(n)/cls(d)\n", "\n", "        if arg.is_Mul:\n", "            known = []\n", "            unk = []\n", "            for t in arg.args:\n", "                if t.is_Pow and t.exp.is_integer and t.exp.is_negative:\n", "                    bnew = cls(t.base)\n", "                    if isinstance(bnew, cls):\n", "                        unk.append(t)\n", "                    else:\n", "                        known.append(Pow(bnew, t.exp))\n", "                else:\n", "                    tnew = cls(t)\n", "                    if isinstance(tnew, cls):\n", "                        unk.append(t)\n", "                    else:\n", "                        known.append(tnew)\n", "            known = Mul(*known)\n", "            unk = cls(Mul(*unk), evaluate=False) if unk else S.One\n", "            return known*unk\n", "        if arg is S.NaN:\n", "            return S.NaN\n", "        if arg is S.ComplexInfinity:\n", "            return S.Infinity\n", "        if arg.is_Pow:\n", "            base, exponent = arg.as_base_exp()\n", "            if base.is_extended_real:\n", "                if exponent.is_integer:\n", "                    if exponent.is_even:\n", "                        return arg\n", "                    if base is S.NegativeOne:\n", "                        return S.One\n", "                    return Abs(base)**exponent\n", "                if base.is_extended_nonnegative:\n", "                    return base**re(exponent)\n", "                if base.is_extended_negative:\n", "                    return (-base)**re(exponent)*exp(-S.Pi*im(exponent))\n", "                return\n", "            elif not base.has(Symbol): # complex base\n", "                # express base**exponent as exp(exponent*log(base))\n", "                a, b = log(base).as_real_imag()\n", "                z = a + I*b\n", "                return exp(re(exponent*z))\n", "        if isinstance(arg, exp):\n", "            return exp(re(arg.args[0]))\n", "        if isinstance(arg, AppliedUndef):\n", "            return\n", "        if arg.is_Add and arg.has(S.Infinity, S.NegativeInfinity):\n", "            if any(a.is_infinite for a in arg.as_real_imag()):\n", "                return S.Infinity\n", "        if arg.is_zero:\n", "            return S.Zero\n", "        if arg.is_extended_nonnegative:\n", "            return arg\n", "        if arg.is_extended_nonpositive:\n", "            return -arg\n", "        if arg.is_imaginary:\n", "            arg2 = -S.ImaginaryUnit * arg\n", "            if arg2.is_extended_nonnegative:\n", "                return arg2\n", "        # reject result if all new conjugates are just wrappers around\n", "        # an expression that was already in the arg\n", "        conj = signsimp(arg.conjugate(), evaluate=False)\n", "        new_conj = conj.atoms(conjugate) - arg.atoms(conjugate)\n", "        if new_conj and all(arg.has(i.args[0]) for i in new_conj):\n", "            return\n", "        if arg != conj and arg != -conj:\n", "            ignore = arg.atoms(Abs)\n", "            abs_free_arg = arg.xreplace({i: Dummy(real=True) for i in ignore})\n", "            unk = [a for a in abs_free_arg.free_symbols if a.is_extended_real is None]\n", "            if not unk or not all(conj.has(conjugate(u)) for u in unk):\n", "                return sqrt(expand_mul(arg*conj))\n"]}]}]}