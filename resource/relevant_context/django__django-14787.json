{"instance_id": "django__django-14787", "identified_spans": [{"file_path": "django/utils/decorators.py", "span_ids": ["_multi_decorate", "_update_method_wrapper", "method_decorator"], "content": [{"span_id": "_multi_decorate", "start_line": 22, "end_line": 50, "content": ["def _multi_decorate(decorators, method):\n", "    \"\"\"\n", "    Decorate `method` with one or more function decorators. `decorators` can be\n", "    a single decorator or an iterable of decorators.\n", "    \"\"\"\n", "    if hasattr(decorators, '__iter__'):\n", "        # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n", "        # functions are applied so that the call order is the same as the\n", "        # order in which they appear in the iterable.\n", "        decorators = decorators[::-1]\n", "    else:\n", "        decorators = [decorators]\n", "\n", "    def _wrapper(self, *args, **kwargs):\n", "        # bound_method has the signature that 'decorator' expects i.e. no\n", "        # 'self' argument, but it's a closure over self so it can call\n", "        # 'func'. Also, wrap method.__get__() in a function because new\n", "        # attributes can't be set on bound method objects, only on functions.\n", "        bound_method = partial(method.__get__(self, type(self)))\n", "        for dec in decorators:\n", "            bound_method = dec(bound_method)\n", "        return bound_method(*args, **kwargs)\n", "\n", "    # Copy any attributes that a decorator adds to the function it decorates.\n", "    for dec in decorators:\n", "        _update_method_wrapper(_wrapper, dec)\n", "    # Preserve any existing attributes of 'method', including the name.\n", "    update_wrapper(_wrapper, method)\n", "    return _wrapper\n"]}, {"span_id": "_update_method_wrapper", "start_line": 13, "end_line": 19, "content": ["def _update_method_wrapper(_wrapper, decorator):\n", "    # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n", "    # using it on a dummy function.\n", "    @decorator\n", "    def dummy(*args, **kwargs):\n", "        pass\n", "    update_wrapper(_wrapper, dummy)\n"]}, {"span_id": "method_decorator", "start_line": 53, "end_line": 86, "content": ["def method_decorator(decorator, name=''):\n", "    \"\"\"\n", "    Convert a function decorator into a method decorator\n", "    \"\"\"\n", "    # 'obj' can be a class or a function. If 'obj' is a function at the time it\n", "    # is passed to _dec,  it will eventually be a method of the class it is\n", "    # defined on. If 'obj' is a class, the 'name' is required to be the name\n", "    # of the method that will be decorated.\n", "    def _dec(obj):\n", "        if not isinstance(obj, type):\n", "            return _multi_decorate(decorator, obj)\n", "        if not (name and hasattr(obj, name)):\n", "            raise ValueError(\n", "                \"The keyword argument `name` must be the name of a method \"\n", "                \"of the decorated class: %s. Got '%s' instead.\" % (obj, name)\n", "            )\n", "        method = getattr(obj, name)\n", "        if not callable(method):\n", "            raise TypeError(\n", "                \"Cannot decorate '%s' as it isn't a callable attribute of \"\n", "                \"%s (%s).\" % (name, obj, method)\n", "            )\n", "        _wrapper = _multi_decorate(decorator, method)\n", "        setattr(obj, name, _wrapper)\n", "        return obj\n", "\n", "    # Don't worry about making _dec look similar to a list/tuple as it's rather\n", "    # meaningless.\n", "    if not hasattr(decorator, '__iter__'):\n", "        update_wrapper(_dec, decorator)\n", "    # Change the name to aid debugging.\n", "    obj = decorator if hasattr(decorator, '__name__') else decorator.__class__\n", "    _dec.__name__ = 'method_decorator(%s)' % obj.__name__\n", "    return _dec\n"]}]}]}