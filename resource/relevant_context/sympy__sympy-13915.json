{"instance_id": "sympy__sympy-13915", "identified_spans": [{"file_path": "sympy/core/add.py", "span_ids": ["Add._eval_subs"], "content": [{"span_id": "Add._eval_subs", "start_line": 721, "end_line": 756, "content": ["    def _eval_subs(self, old, new):\n", "        if not old.is_Add:\n", "            if old is S.Infinity and -old in self.args:\n", "                # foo - oo is foo + (-oo) internally\n", "                return self.xreplace({-old: -new})\n", "            return None\n", "\n", "        coeff_self, terms_self = self.as_coeff_Add()\n", "        coeff_old, terms_old = old.as_coeff_Add()\n", "\n", "        if coeff_self.is_Rational and coeff_old.is_Rational:\n", "            if terms_self == terms_old:   # (2 + a).subs( 3 + a, y) -> -1 + y\n", "                return self.func(new, coeff_self, -coeff_old)\n", "            if terms_self == -terms_old:  # (2 + a).subs(-3 - a, y) -> -1 - y\n", "                return self.func(-new, coeff_self, coeff_old)\n", "\n", "        if coeff_self.is_Rational and coeff_old.is_Rational \\\n", "                or coeff_self == coeff_old:\n", "            args_old, args_self = self.func.make_args(\n", "                terms_old), self.func.make_args(terms_self)\n", "            if len(args_old) < len(args_self):  # (a+b+c).subs(b+c,x) -> a+x\n", "                self_set = set(args_self)\n", "                old_set = set(args_old)\n", "\n", "                if old_set < self_set:\n", "                    ret_set = self_set - old_set\n", "                    return self.func(new, coeff_self, -coeff_old,\n", "                               *[s._subs(old, new) for s in ret_set])\n", "\n", "                args_old = self.func.make_args(\n", "                    -terms_old)     # (a+b+c+d).subs(-b-c,x) -> a-x+d\n", "                old_set = set(args_old)\n", "                if old_set < self_set:\n", "                    ret_set = self_set - old_set\n", "                    return self.func(-new, coeff_self, coeff_old,\n", "                               *[s._subs(old, new) for s in ret_set])\n"]}]}, {"file_path": "sympy/core/basic.py", "span_ids": ["Basic._subs", "Basic.subs"], "content": [{"span_id": "Basic._subs", "start_line": 925, "end_line": 1035, "content": ["    @cacheit\n", "    def _subs(self, old, new, **hints):\n", "        \"\"\"Substitutes an expression old -> new.\n", "\n", "        If self is not equal to old then _eval_subs is called.\n", "        If _eval_subs doesn't want to make any special replacement\n", "        then a None is received which indicates that the fallback\n", "        should be applied wherein a search for replacements is made\n", "        amongst the arguments of self.\n", "\n", "        >>> from sympy import Add\n", "        >>> from sympy.abc import x, y, z\n", "\n", "        Examples\n", "        ========\n", "\n", "        Add's _eval_subs knows how to target x + y in the following\n", "        so it makes the change:\n", "\n", "            >>> (x + y + z).subs(x + y, 1)\n", "            z + 1\n", "\n", "        Add's _eval_subs doesn't need to know how to find x + y in\n", "        the following:\n", "\n", "            >>> Add._eval_subs(z*(x + y) + 3, x + y, 1) is None\n", "            True\n", "\n", "        The returned None will cause the fallback routine to traverse the args and\n", "        pass the z*(x + y) arg to Mul where the change will take place and the\n", "        substitution will succeed:\n", "\n", "            >>> (z*(x + y) + 3).subs(x + y, 1)\n", "            z + 3\n", "\n", "        ** Developers Notes **\n", "\n", "        An _eval_subs routine for a class should be written if:\n", "\n", "            1) any arguments are not instances of Basic (e.g. bool, tuple);\n", "\n", "            2) some arguments should not be targeted (as in integration\n", "               variables);\n", "\n", "            3) if there is something other than a literal replacement\n", "               that should be attempted (as in Piecewise where the condition\n", "               may be updated without doing a replacement).\n", "\n", "        If it is overridden, here are some special cases that might arise:\n", "\n", "            1) If it turns out that no special change was made and all\n", "               the original sub-arguments should be checked for\n", "               replacements then None should be returned.\n", "\n", "            2) If it is necessary to do substitutions on a portion of\n", "               the expression then _subs should be called. _subs will\n", "               handle the case of any sub-expression being equal to old\n", "               (which usually would not be the case) while its fallback\n", "               will handle the recursion into the sub-arguments. For\n", "               example, after Add's _eval_subs removes some matching terms\n", "               it must process the remaining terms so it calls _subs\n", "               on each of the un-matched terms and then adds them\n", "               onto the terms previously obtained.\n", "\n", "           3) If the initial expression should remain unchanged then\n", "              the original expression should be returned. (Whenever an\n", "              expression is returned, modified or not, no further\n", "              substitution of old -> new is attempted.) Sum's _eval_subs\n", "              routine uses this strategy when a substitution is attempted\n", "              on any of its summation variables.\n", "        \"\"\"\n", "\n", "        def fallback(self, old, new):\n", "            \"\"\"\n", "            Try to replace old with new in any of self's arguments.\n", "            \"\"\"\n", "            hit = False\n", "            args = list(self.args)\n", "            for i, arg in enumerate(args):\n", "                if not hasattr(arg, '_eval_subs'):\n", "                    continue\n", "                arg = arg._subs(old, new, **hints)\n", "                if not _aresame(arg, args[i]):\n", "                    hit = True\n", "                    args[i] = arg\n", "            if hit:\n", "                rv = self.func(*args)\n", "                hack2 = hints.get('hack2', False)\n", "                if hack2 and self.is_Mul and not rv.is_Mul:  # 2-arg hack\n", "                    coeff = S.One\n", "                    nonnumber = []\n", "                    for i in args:\n", "                        if i.is_Number:\n", "                            coeff *= i\n", "                        else:\n", "                            nonnumber.append(i)\n", "                    nonnumber = self.func(*nonnumber)\n", "                    if coeff is S.One:\n", "                        return nonnumber\n", "                    else:\n", "                        return self.func(coeff, nonnumber, evaluate=False)\n", "                return rv\n", "            return self\n", "\n", "        if _aresame(self, old):\n", "            return new\n", "\n", "        rv = self._eval_subs(old, new)\n", "        if rv is None:\n", "            rv = fallback(self, old, new)\n", "        return rv\n"]}, {"span_id": "Basic.subs", "start_line": 727, "end_line": 923, "content": ["    def subs(self, *args, **kwargs):\n", "        \"\"\"\n", "        Substitutes old for new in an expression after sympifying args.\n", "\n", "        `args` is either:\n", "          - two arguments, e.g. foo.subs(old, new)\n", "          - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n", "             o an iterable container with (old, new) pairs. In this case the\n", "               replacements are processed in the order given with successive\n", "               patterns possibly affecting replacements already made.\n", "             o a dict or set whose key/value items correspond to old/new pairs.\n", "               In this case the old/new pairs will be sorted by op count and in\n", "               case of a tie, by number of args and the default_sort_key. The\n", "               resulting sorted list is then processed as an iterable container\n", "               (see previous).\n", "\n", "        If the keyword ``simultaneous`` is True, the subexpressions will not be\n", "        evaluated until all the substitutions have been made.\n", "\n", "        Examples\n", "        ========\n", "\n", "        >>> from sympy import pi, exp, limit, oo\n", "        >>> from sympy.abc import x, y\n", "        >>> (1 + x*y).subs(x, pi)\n", "        pi*y + 1\n", "        >>> (1 + x*y).subs({x:pi, y:2})\n", "        1 + 2*pi\n", "        >>> (1 + x*y).subs([(x, pi), (y, 2)])\n", "        1 + 2*pi\n", "        >>> reps = [(y, x**2), (x, 2)]\n", "        >>> (x + y).subs(reps)\n", "        6\n", "        >>> (x + y).subs(reversed(reps))\n", "        x**2 + 2\n", "\n", "        >>> (x**2 + x**4).subs(x**2, y)\n", "        y**2 + y\n", "\n", "        To replace only the x**2 but not the x**4, use xreplace:\n", "\n", "        >>> (x**2 + x**4).xreplace({x**2: y})\n", "        x**4 + y\n", "\n", "        To delay evaluation until all substitutions have been made,\n", "        set the keyword ``simultaneous`` to True:\n", "\n", "        >>> (x/y).subs([(x, 0), (y, 0)])\n", "        0\n", "        >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n", "        nan\n", "\n", "        This has the added feature of not allowing subsequent substitutions\n", "        to affect those already made:\n", "\n", "        >>> ((x + y)/y).subs({x + y: y, y: x + y})\n", "        1\n", "        >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n", "        y/(x + y)\n", "\n", "        In order to obtain a canonical result, unordered iterables are\n", "        sorted by count_op length, number of arguments and by the\n", "        default_sort_key to break any ties. All other iterables are left\n", "        unsorted.\n", "\n", "        >>> from sympy import sqrt, sin, cos\n", "        >>> from sympy.abc import a, b, c, d, e\n", "\n", "        >>> A = (sqrt(sin(2*x)), a)\n", "        >>> B = (sin(2*x), b)\n", "        >>> C = (cos(2*x), c)\n", "        >>> D = (x, d)\n", "        >>> E = (exp(x), e)\n", "\n", "        >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n", "\n", "        >>> expr.subs(dict([A, B, C, D, E]))\n", "        a*c*sin(d*e) + b\n", "\n", "        The resulting expression represents a literal replacement of the\n", "        old arguments with the new arguments. This may not reflect the\n", "        limiting behavior of the expression:\n", "\n", "        >>> (x**3 - 3*x).subs({x: oo})\n", "        nan\n", "\n", "        >>> limit(x**3 - 3*x, x, oo)\n", "        oo\n", "\n", "        If the substitution will be followed by numerical\n", "        evaluation, it is better to pass the substitution to\n", "        evalf as\n", "\n", "        >>> (1/x).evalf(subs={x: 3.0}, n=21)\n", "        0.333333333333333333333\n", "\n", "        rather than\n", "\n", "        >>> (1/x).subs({x: 3.0}).evalf(21)\n", "        0.333333333333333314830\n", "\n", "        as the former will ensure that the desired level of precision is\n", "        obtained.\n", "\n", "        See Also\n", "        ========\n", "        replace: replacement capable of doing wildcard-like matching,\n", "                 parsing of match, and conditional replacements\n", "        xreplace: exact node replacement in expr tree; also capable of\n", "                  using matching rules\n", "        evalf: calculates the given formula to a desired level of precision\n", "\n", "        \"\"\"\n", "        from sympy.core.containers import Dict\n", "        from sympy.utilities import default_sort_key\n", "        from sympy import Dummy, Symbol\n", "\n", "        unordered = False\n", "        if len(args) == 1:\n", "            sequence = args[0]\n", "            if isinstance(sequence, set):\n", "                unordered = True\n", "            elif isinstance(sequence, (Dict, Mapping)):\n", "                unordered = True\n", "                sequence = sequence.items()\n", "            elif not iterable(sequence):\n", "                from sympy.utilities.misc import filldedent\n", "                raise ValueError(filldedent(\"\"\"\n", "                   When a single argument is passed to subs\n", "                   it should be a dictionary of old: new pairs or an iterable\n", "                   of (old, new) tuples.\"\"\"))\n", "        elif len(args) == 2:\n", "            sequence = [args]\n", "        else:\n", "            raise ValueError(\"subs accepts either 1 or 2 arguments\")\n", "\n", "        sequence = list(sequence)\n", "        for i in range(len(sequence)):\n", "            s = list(sequence[i])\n", "            for j, si in enumerate(s):\n", "                try:\n", "                    si = sympify(si, strict=True)\n", "                except SympifyError:\n", "                    if type(si) is str:\n", "                        si = Symbol(si)\n", "                    else:\n", "                        # if it can't be sympified, skip it\n", "                        sequence[i] = None\n", "                        break\n", "                s[j] = si\n", "            else:\n", "                sequence[i] = None if _aresame(*s) else tuple(s)\n", "        sequence = list(filter(None, sequence))\n", "\n", "        if unordered:\n", "            sequence = dict(sequence)\n", "            if not all(k.is_Atom for k in sequence):\n", "                d = {}\n", "                for o, n in sequence.items():\n", "                    try:\n", "                        ops = o.count_ops(), len(o.args)\n", "                    except TypeError:\n", "                        ops = (0, 0)\n", "                    d.setdefault(ops, []).append((o, n))\n", "                newseq = []\n", "                for k in sorted(d.keys(), reverse=True):\n", "                    newseq.extend(\n", "                        sorted([v[0] for v in d[k]], key=default_sort_key))\n", "                sequence = [(k, sequence[k]) for k in newseq]\n", "                del newseq, d\n", "            else:\n", "                sequence = sorted([(k, v) for (k, v) in sequence.items()],\n", "                                  key=default_sort_key)\n", "\n", "        if kwargs.pop('simultaneous', False):  # XXX should this be the default for dict subs?\n", "            reps = {}\n", "            rv = self\n", "            kwargs['hack2'] = True\n", "            m = Dummy()\n", "            for old, new in sequence:\n", "                d = Dummy(commutative=new.is_commutative)\n", "                # using d*m so Subs will be used on dummy variables\n", "                # in things like Derivative(f(x, y), x) in which x\n", "                # is both free and bound\n", "                rv = rv._subs(old, d*m, **kwargs)\n", "                if not isinstance(rv, Basic):\n", "                    break\n", "                reps[d] = new\n", "            reps[m] = S.One  # get rid of m\n", "            return rv.xreplace(reps)\n", "        else:\n", "            rv = self\n", "            for old, new in sequence:\n", "                rv = rv._subs(old, new, **kwargs)\n", "                if not isinstance(rv, Basic):\n", "                    break\n", "            return rv\n"]}]}, {"file_path": "sympy/core/function.py", "span_ids": ["Subs"], "content": [{"span_id": "Subs", "start_line": 1712, "end_line": 1754, "content": ["class Subs(Expr):\n", "    \"\"\"\n", "    Represents unevaluated substitutions of an expression.\n", "\n", "    ``Subs(expr, x, x0)`` receives 3 arguments: an expression, a variable or\n", "    list of distinct variables and a point or list of evaluation points\n", "    corresponding to those variables.\n", "\n", "    ``Subs`` objects are generally useful to represent unevaluated derivatives\n", "    calculated at a point.\n", "\n", "    The variables may be expressions, but they are subjected to the limitations\n", "    of subs(), so it is usually a good practice to use only symbols for\n", "    variables, since in that case there can be no ambiguity.\n", "\n", "    There's no automatic expansion - use the method .doit() to effect all\n", "    possible substitutions of the object and also of objects inside the\n", "    expression.\n", "\n", "    When evaluating derivatives at a point that is not a symbol, a Subs object\n", "    is returned. One is also able to calculate derivatives of Subs objects - in\n", "    this case the expression is always expanded (for the unevaluated form, use\n", "    Derivative()).\n", "\n", "    A simple example:\n", "\n", "    >>> from sympy import Subs, Function, sin\n", "    >>> from sympy.abc import x, y, z\n", "    >>> f = Function('f')\n", "    >>> e = Subs(f(x).diff(x), x, y)\n", "    >>> e.subs(y, 0)\n", "    Subs(Derivative(f(x), x), (x,), (0,))\n", "    >>> e.subs(f, sin).doit()\n", "    cos(y)\n", "\n", "    An example with several variables:\n", "\n", "    >>> Subs(f(x)*sin(y) + z, (x, y), (0, 1))\n", "    Subs(z + f(x)*sin(y), (x, y), (0, 1))\n", "    >>> _.doit()\n", "    z + f(0)*sin(1)\n", "\n", "    \"\"\"\n"]}]}, {"file_path": "sympy/core/mul.py", "span_ids": ["Mul._eval_subs"], "content": [{"span_id": "Mul._eval_subs", "start_line": 1340, "end_line": 1602, "content": ["    def _eval_subs(self, old, new):\n", "        from sympy.functions.elementary.complexes import sign\n", "        from sympy.ntheory.factor_ import multiplicity\n", "        from sympy.simplify.powsimp import powdenest\n", "        from sympy.simplify.radsimp import fraction\n", "\n", "        if not old.is_Mul:\n", "            return None\n", "\n", "        # try keep replacement literal so -2*x doesn't replace 4*x\n", "        if old.args[0].is_Number and old.args[0] < 0:\n", "            if self.args[0].is_Number:\n", "                if self.args[0] < 0:\n", "                    return self._subs(-old, -new)\n", "                return None\n", "\n", "        def base_exp(a):\n", "            # if I and -1 are in a Mul, they get both end up with\n", "            # a -1 base (see issue 6421); all we want here are the\n", "            # true Pow or exp separated into base and exponent\n", "            from sympy import exp\n", "            if a.is_Pow or isinstance(a, exp):\n", "                return a.as_base_exp()\n", "            return a, S.One\n", "\n", "        def breakup(eq):\n", "            \"\"\"break up powers of eq when treated as a Mul:\n", "                   b**(Rational*e) -> b**e, Rational\n", "                commutatives come back as a dictionary {b**e: Rational}\n", "                noncommutatives come back as a list [(b**e, Rational)]\n", "            \"\"\"\n", "\n", "            (c, nc) = (defaultdict(int), list())\n", "            for a in Mul.make_args(eq):\n", "                a = powdenest(a)\n", "                (b, e) = base_exp(a)\n", "                if e is not S.One:\n", "                    (co, _) = e.as_coeff_mul()\n", "                    b = Pow(b, e/co)\n", "                    e = co\n", "                if a.is_commutative:\n", "                    c[b] += e\n", "                else:\n", "                    nc.append([b, e])\n", "            return (c, nc)\n", "\n", "        def rejoin(b, co):\n", "            \"\"\"\n", "            Put rational back with exponent; in general this is not ok, but\n", "            since we took it from the exponent for analysis, it's ok to put\n", "            it back.\n", "            \"\"\"\n", "\n", "            (b, e) = base_exp(b)\n", "            return Pow(b, e*co)\n", "\n", "        def ndiv(a, b):\n", "            \"\"\"if b divides a in an extractive way (like 1/4 divides 1/2\n", "            but not vice versa, and 2/5 does not divide 1/3) then return\n", "            the integer number of times it divides, else return 0.\n", "            \"\"\"\n", "            if not b.q % a.q or not a.q % b.q:\n", "                return int(a/b)\n", "            return 0\n", "\n", "        # give Muls in the denominator a chance to be changed (see issue 5651)\n", "        # rv will be the default return value\n", "        rv = None\n", "        n, d = fraction(self)\n", "        self2 = self\n", "        if d is not S.One:\n", "            self2 = n._subs(old, new)/d._subs(old, new)\n", "            if not self2.is_Mul:\n", "                return self2._subs(old, new)\n", "            if self2 != self:\n", "                rv = self2\n", "\n", "        # Now continue with regular substitution.\n", "\n", "        # handle the leading coefficient and use it to decide if anything\n", "        # should even be started; we always know where to find the Rational\n", "        # so it's a quick test\n", "\n", "        co_self = self2.args[0]\n", "        co_old = old.args[0]\n", "        co_xmul = None\n", "        if co_old.is_Rational and co_self.is_Rational:\n", "            # if coeffs are the same there will be no updating to do\n", "            # below after breakup() step; so skip (and keep co_xmul=None)\n", "            if co_old != co_self:\n", "                co_xmul = co_self.extract_multiplicatively(co_old)\n", "        elif co_old.is_Rational:\n", "            return rv\n", "\n", "        # break self and old into factors\n", "\n", "        (c, nc) = breakup(self2)\n", "        (old_c, old_nc) = breakup(old)\n", "\n", "        # update the coefficients if we had an extraction\n", "        # e.g. if co_self were 2*(3/35*x)**2 and co_old = 3/5\n", "        # then co_self in c is replaced by (3/5)**2 and co_residual\n", "        # is 2*(1/7)**2\n", "\n", "        if co_xmul and co_xmul.is_Rational and abs(co_old) != 1:\n", "            mult = S(multiplicity(abs(co_old), co_self))\n", "            c.pop(co_self)\n", "            if co_old in c:\n", "                c[co_old] += mult\n", "            else:\n", "                c[co_old] = mult\n", "            co_residual = co_self/co_old**mult\n", "        else:\n", "            co_residual = 1\n", "\n", "        # do quick tests to see if we can't succeed\n", "\n", "        ok = True\n", "        if len(old_nc) > len(nc):\n", "            # more non-commutative terms\n", "            ok = False\n", "        elif len(old_c) > len(c):\n", "            # more commutative terms\n", "            ok = False\n", "        elif set(i[0] for i in old_nc).difference(set(i[0] for i in nc)):\n", "            # unmatched non-commutative bases\n", "            ok = False\n", "        elif set(old_c).difference(set(c)):\n", "            # unmatched commutative terms\n", "            ok = False\n", "        elif any(sign(c[b]) != sign(old_c[b]) for b in old_c):\n", "            # differences in sign\n", "            ok = False\n", "        if not ok:\n", "            return rv\n", "\n", "        if not old_c:\n", "            cdid = None\n", "        else:\n", "            rat = []\n", "            for (b, old_e) in old_c.items():\n", "                c_e = c[b]\n", "                rat.append(ndiv(c_e, old_e))\n", "                if not rat[-1]:\n", "                    return rv\n", "            cdid = min(rat)\n", "\n", "        if not old_nc:\n", "            ncdid = None\n", "            for i in range(len(nc)):\n", "                nc[i] = rejoin(*nc[i])\n", "        else:\n", "            ncdid = 0  # number of nc replacements we did\n", "            take = len(old_nc)  # how much to look at each time\n", "            limit = cdid or S.Infinity  # max number that we can take\n", "            failed = []  # failed terms will need subs if other terms pass\n", "            i = 0\n", "            while limit and i + take <= len(nc):\n", "                hit = False\n", "\n", "                # the bases must be equivalent in succession, and\n", "                # the powers must be extractively compatible on the\n", "                # first and last factor but equal in between.\n", "\n", "                rat = []\n", "                for j in range(take):\n", "                    if nc[i + j][0] != old_nc[j][0]:\n", "                        break\n", "                    elif j == 0:\n", "                        rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n", "                    elif j == take - 1:\n", "                        rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n", "                    elif nc[i + j][1] != old_nc[j][1]:\n", "                        break\n", "                    else:\n", "                        rat.append(1)\n", "                    j += 1\n", "                else:\n", "                    ndo = min(rat)\n", "                    if ndo:\n", "                        if take == 1:\n", "                            if cdid:\n", "                                ndo = min(cdid, ndo)\n", "                            nc[i] = Pow(new, ndo)*rejoin(nc[i][0],\n", "                                    nc[i][1] - ndo*old_nc[0][1])\n", "                        else:\n", "                            ndo = 1\n", "\n", "                            # the left residual\n", "\n", "                            l = rejoin(nc[i][0], nc[i][1] - ndo*\n", "                                    old_nc[0][1])\n", "\n", "                            # eliminate all middle terms\n", "\n", "                            mid = new\n", "\n", "                            # the right residual (which may be the same as the middle if take == 2)\n", "\n", "                            ir = i + take - 1\n", "                            r = (nc[ir][0], nc[ir][1] - ndo*\n", "                                 old_nc[-1][1])\n", "                            if r[1]:\n", "                                if i + take < len(nc):\n", "                                    nc[i:i + take] = [l*mid, r]\n", "                                else:\n", "                                    r = rejoin(*r)\n", "                                    nc[i:i + take] = [l*mid*r]\n", "                            else:\n", "\n", "                                # there was nothing left on the right\n", "\n", "                                nc[i:i + take] = [l*mid]\n", "\n", "                        limit -= ndo\n", "                        ncdid += ndo\n", "                        hit = True\n", "                if not hit:\n", "\n", "                    # do the subs on this failing factor\n", "\n", "                    failed.append(i)\n", "                i += 1\n", "            else:\n", "\n", "                if not ncdid:\n", "                    return rv\n", "\n", "                # although we didn't fail, certain nc terms may have\n", "                # failed so we rebuild them after attempting a partial\n", "                # subs on them\n", "\n", "                failed.extend(range(i, len(nc)))\n", "                for i in failed:\n", "                    nc[i] = rejoin(*nc[i]).subs(old, new)\n", "\n", "        # rebuild the expression\n", "\n", "        if cdid is None:\n", "            do = ncdid\n", "        elif ncdid is None:\n", "            do = cdid\n", "        else:\n", "            do = min(ncdid, cdid)\n", "\n", "        margs = []\n", "        for b in c:\n", "            if b in old_c:\n", "\n", "                # calculate the new exponent\n", "\n", "                e = c[b] - old_c[b]*do\n", "                margs.append(rejoin(b, e))\n", "            else:\n", "                margs.append(rejoin(b.subs(old, new), c[b]))\n", "        if cdid and not ncdid:\n", "\n", "            # in case we are replacing commutative with non-commutative,\n", "            # we want the new term to come at the front just like the\n", "            # rest of this routine\n", "\n", "            margs = [Pow(new, cdid)] + margs\n", "        return co_residual*self2.func(*margs)*self2.func(*nc)\n"]}]}, {"file_path": "sympy/core/numbers.py", "span_ids": ["Infinity._eval_subs", "NegativeInfinity._eval_subs"], "content": [{"span_id": "Infinity._eval_subs", "start_line": 2719, "end_line": 2721, "content": ["    def _eval_subs(self, old, new):\n", "        if self == old:\n", "            return new\n"]}, {"span_id": "NegativeInfinity._eval_subs", "start_line": 2942, "end_line": 2944, "content": ["    def _eval_subs(self, old, new):\n", "        if self == old:\n", "            return new\n"]}]}, {"file_path": "sympy/core/power.py", "span_ids": ["Pow._eval_subs"], "content": [{"span_id": "Pow._eval_subs", "start_line": 578, "end_line": 691, "content": ["    def _eval_subs(self, old, new):\n", "        from sympy import exp, log, Symbol\n", "        def _check(ct1, ct2, old):\n", "            \"\"\"Return (bool, pow, remainder_pow) where, if bool is True, then the\n", "            exponent of Pow `old` will combine with `pow` so the substitution\n", "            is valid, otherwise bool will be False.\n", "\n", "            For noncommutative objects, `pow` will be an integer, and a factor\n", "            `Pow(old.base, remainder_pow)` needs to be included. If there is\n", "            no such factor, None is returned. For commutative objects,\n", "            remainder_pow is always None.\n", "\n", "            cti are the coefficient and terms of an exponent of self or old\n", "            In this _eval_subs routine a change like (b**(2*x)).subs(b**x, y)\n", "            will give y**2 since (b**x)**2 == b**(2*x); if that equality does\n", "            not hold then the substitution should not occur so `bool` will be\n", "            False.\n", "\n", "            \"\"\"\n", "            coeff1, terms1 = ct1\n", "            coeff2, terms2 = ct2\n", "            if terms1 == terms2:\n", "                if old.is_commutative:\n", "                    # Allow fractional powers for commutative objects\n", "                    pow = coeff1/coeff2\n", "                    try:\n", "                        pow = as_int(pow)\n", "                        combines = True\n", "                    except ValueError:\n", "                        combines = Pow._eval_power(\n", "                            Pow(*old.as_base_exp(), evaluate=False),\n", "                            pow) is not None\n", "                    return combines, pow, None\n", "                else:\n", "                    # With noncommutative symbols, substitute only integer powers\n", "                    if not isinstance(terms1, tuple):\n", "                        terms1 = (terms1,)\n", "                    if not all(term.is_integer for term in terms1):\n", "                        return False, None, None\n", "\n", "                    try:\n", "                        # Round pow toward zero\n", "                        pow, remainder = divmod(as_int(coeff1), as_int(coeff2))\n", "                        if pow < 0 and remainder != 0:\n", "                            pow += 1\n", "                            remainder -= as_int(coeff2)\n", "\n", "                        if remainder == 0:\n", "                            remainder_pow = None\n", "                        else:\n", "                            remainder_pow = Mul(remainder, *terms1)\n", "\n", "                        return True, pow, remainder_pow\n", "                    except ValueError:\n", "                        # Can't substitute\n", "                        pass\n", "\n", "            return False, None, None\n", "\n", "        if old == self.base:\n", "            return new**self.exp._subs(old, new)\n", "\n", "        # issue 10829: (4**x - 3*y + 2).subs(2**x, y) -> y**2 - 3*y + 2\n", "        if isinstance(old, self.func) and self.exp == old.exp:\n", "            l = log(self.base, old.base)\n", "            if l.is_Number:\n", "                return Pow(new, l)\n", "\n", "        if isinstance(old, self.func) and self.base == old.base:\n", "            if self.exp.is_Add is False:\n", "                ct1 = self.exp.as_independent(Symbol, as_Add=False)\n", "                ct2 = old.exp.as_independent(Symbol, as_Add=False)\n", "                ok, pow, remainder_pow = _check(ct1, ct2, old)\n", "                if ok:\n", "                    # issue 5180: (x**(6*y)).subs(x**(3*y),z)->z**2\n", "                    result = self.func(new, pow)\n", "                    if remainder_pow is not None:\n", "                        result = Mul(result, Pow(old.base, remainder_pow))\n", "                    return result\n", "            else:  # b**(6*x+a).subs(b**(3*x), y) -> y**2 * b**a\n", "                # exp(exp(x) + exp(x**2)).subs(exp(exp(x)), w) -> w * exp(exp(x**2))\n", "                oarg = old.exp\n", "                new_l = []\n", "                o_al = []\n", "                ct2 = oarg.as_coeff_mul()\n", "                for a in self.exp.args:\n", "                    newa = a._subs(old, new)\n", "                    ct1 = newa.as_coeff_mul()\n", "                    ok, pow, remainder_pow = _check(ct1, ct2, old)\n", "                    if ok:\n", "                        new_l.append(new**pow)\n", "                        if remainder_pow is not None:\n", "                            o_al.append(remainder_pow)\n", "                        continue\n", "                    elif not old.is_commutative and not newa.is_integer:\n", "                        # If any term in the exponent is non-integer,\n", "                        # we do not do any substitutions in the noncommutative case\n", "                        return\n", "                    o_al.append(newa)\n", "                if new_l:\n", "                    expo = Add(*o_al)\n", "                    new_l.append(Pow(self.base, expo, evaluate=False) if expo != 1 else self.base)\n", "                    return Mul(*new_l)\n", "\n", "        if isinstance(old, exp) and self.exp.is_real and self.base.is_positive:\n", "            ct1 = old.args[0].as_independent(Symbol, as_Add=False)\n", "            ct2 = (self.exp*log(self.base)).as_independent(\n", "                Symbol, as_Add=False)\n", "            ok, pow, remainder_pow = _check(ct1, ct2, old)\n", "            if ok:\n", "                result = self.func(new, pow)  # (2**x).subs(exp(x*log(2)), z) -> z\n", "                if remainder_pow is not None:\n", "                    result = Mul(result, Pow(old.base, remainder_pow))\n", "                return result\n"]}]}]}