{"instance_id": "django__django-11848", "identified_spans": [{"file_path": "django/utils/http.py", "span_ids": ["parse_http_date", "parse_http_date_safe"], "content": [{"span_id": "parse_http_date", "start_line": 158, "end_line": 191, "content": ["def parse_http_date(date):\n", "    \"\"\"\n", "    Parse a date format as specified by HTTP RFC7231 section 7.1.1.1.\n", "\n", "    The three formats allowed by the RFC are accepted, even if only the first\n", "    one is still in widespread use.\n", "\n", "    Return an integer expressed in seconds since the epoch, in UTC.\n", "    \"\"\"\n", "    # email.utils.parsedate() does the job for RFC1123 dates; unfortunately\n", "    # RFC7231 makes it mandatory to support RFC850 dates too. So we roll\n", "    # our own RFC-compliant parsing.\n", "    for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:\n", "        m = regex.match(date)\n", "        if m is not None:\n", "            break\n", "    else:\n", "        raise ValueError(\"%r is not in a valid HTTP date format\" % date)\n", "    try:\n", "        year = int(m.group('year'))\n", "        if year < 100:\n", "            if year < 70:\n", "                year += 2000\n", "            else:\n", "                year += 1900\n", "        month = MONTHS.index(m.group('mon').lower()) + 1\n", "        day = int(m.group('day'))\n", "        hour = int(m.group('hour'))\n", "        min = int(m.group('min'))\n", "        sec = int(m.group('sec'))\n", "        result = datetime.datetime(year, month, day, hour, min, sec)\n", "        return calendar.timegm(result.utctimetuple())\n", "    except Exception as exc:\n", "        raise ValueError(\"%r is not a valid date\" % date) from exc\n"]}, {"span_id": "parse_http_date_safe", "start_line": 194, "end_line": 201, "content": ["def parse_http_date_safe(date):\n", "    \"\"\"\n", "    Same as parse_http_date, but return None if the input is invalid.\n", "    \"\"\"\n", "    try:\n", "        return parse_http_date(date)\n", "    except Exception:\n", "        pass\n"]}]}]}