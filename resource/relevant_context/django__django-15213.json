{"instance_id": "django__django-15213", "identified_spans": [{"file_path": "django/db/models/expressions.py", "span_ids": ["ExpressionWrapper.as_sql", "ExpressionWrapper"], "content": [{"span_id": "ExpressionWrapper.as_sql", "start_line": 981, "end_line": 982, "content": ["    def as_sql(self, compiler, connection):\n", "        return compiler.compile(self.expression)\n"]}, {"span_id": "ExpressionWrapper", "start_line": 956, "end_line": 960, "content": ["class ExpressionWrapper(SQLiteNumericMixin, Expression):\n", "    \"\"\"\n", "    An expression that can wrap another expression so that it can provide\n", "    extra context to the inner expression, such as the output_field.\n", "    \"\"\"\n"]}]}, {"file_path": "django/db/models/query_utils.py", "span_ids": ["Q", "Q.__invert__"], "content": [{"span_id": "Q", "start_line": 29, "end_line": 38, "content": ["class Q(tree.Node):\n", "    \"\"\"\n", "    Encapsulate filters as objects that can then be combined logically (using\n", "    `&` and `|`).\n", "    \"\"\"\n", "    # Connection types\n", "    AND = 'AND'\n", "    OR = 'OR'\n", "    default = AND\n", "    conditional = True\n"]}, {"span_id": "Q.__invert__", "start_line": 65, "end_line": 69, "content": ["    def __invert__(self):\n", "        obj = type(self)()\n", "        obj.add(self, self.AND)\n", "        obj.negate()\n", "        return obj\n"]}]}, {"file_path": "django/db/models/sql/compiler.py", "span_ids": ["SQLCompiler.compile"], "content": [{"span_id": "SQLCompiler.compile", "start_line": 465, "end_line": 471, "content": ["    def compile(self, node):\n", "        vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)\n", "        if vendor_impl:\n", "            sql, params = vendor_impl(self, self.connection)\n", "        else:\n", "            sql, params = node.as_sql(self, self.connection)\n", "        return sql, params\n"]}]}]}