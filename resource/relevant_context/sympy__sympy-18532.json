{"instance_id": "sympy__sympy-18532", "identified_spans": [{"file_path": "sympy/core/basic.py", "span_ids": ["Basic.atoms", "Basic", "Atom"], "content": [{"span_id": "Basic.atoms", "start_line": 434, "end_line": 512, "content": ["    def atoms(self, *types):\n", "        \"\"\"Returns the atoms that form the current object.\n", "\n", "        By default, only objects that are truly atomic and can't\n", "        be divided into smaller pieces are returned: symbols, numbers,\n", "        and number symbols like I and pi. It is possible to request\n", "        atoms of any type, however, as demonstrated below.\n", "\n", "        Examples\n", "        ========\n", "\n", "        >>> from sympy import I, pi, sin\n", "        >>> from sympy.abc import x, y\n", "        >>> (1 + x + 2*sin(y + I*pi)).atoms()\n", "        {1, 2, I, pi, x, y}\n", "\n", "        If one or more types are given, the results will contain only\n", "        those types of atoms.\n", "\n", "        >>> from sympy import Number, NumberSymbol, Symbol\n", "        >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n", "        {x, y}\n", "\n", "        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n", "        {1, 2}\n", "\n", "        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n", "        {1, 2, pi}\n", "\n", "        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n", "        {1, 2, I, pi}\n", "\n", "        Note that I (imaginary unit) and zoo (complex infinity) are special\n", "        types of number symbols and are not part of the NumberSymbol class.\n", "\n", "        The type can be given implicitly, too:\n", "\n", "        >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n", "        {x, y}\n", "\n", "        Be careful to check your assumptions when using the implicit option\n", "        since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\n", "        of sympy atom, while ``type(S(2))`` is type ``Integer`` and will find all\n", "        integers in an expression:\n", "\n", "        >>> from sympy import S\n", "        >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n", "        {1}\n", "\n", "        >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n", "        {1, 2}\n", "\n", "        Finally, arguments to atoms() can select more than atomic atoms: any\n", "        sympy type (loaded in core/__init__.py) can be listed as an argument\n", "        and those types of \"atoms\" as found in scanning the arguments of the\n", "        expression recursively:\n", "\n", "        >>> from sympy import Function, Mul\n", "        >>> from sympy.core.function import AppliedUndef\n", "        >>> f = Function('f')\n", "        >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n", "        {f(x), sin(y + I*pi)}\n", "        >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n", "        {f(x)}\n", "\n", "        >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n", "        {I*pi, 2*sin(y + I*pi)}\n", "\n", "        \"\"\"\n", "        if types:\n", "            types = tuple(\n", "                [t if isinstance(t, type) else type(t) for t in types])\n", "        else:\n", "            types = (Atom,)\n", "        result = set()\n", "        for expr in preorder_traversal(self):\n", "            if isinstance(expr, types):\n", "                result.add(expr)\n", "        return result\n"]}, {"span_id": "Basic", "start_line": 28, "end_line": 93, "content": ["class Basic(metaclass=ManagedProperties):\n", "    \"\"\"\n", "    Base class for all objects in SymPy.\n", "\n", "    Conventions:\n", "\n", "    1) Always use ``.args``, when accessing parameters of some instance:\n", "\n", "    >>> from sympy import cot\n", "    >>> from sympy.abc import x, y\n", "\n", "    >>> cot(x).args\n", "    (x,)\n", "\n", "    >>> cot(x).args[0]\n", "    x\n", "\n", "    >>> (x*y).args\n", "    (x, y)\n", "\n", "    >>> (x*y).args[1]\n", "    y\n", "\n", "\n", "    2) Never use internal methods or variables (the ones prefixed with ``_``):\n", "\n", "    >>> cot(x)._args    # do not use this, use cot(x).args instead\n", "    (x,)\n", "\n", "    \"\"\"\n", "    __slots__ = ('_mhash',              # hash value\n", "                 '_args',               # arguments\n", "                 '_assumptions'\n", "                )\n", "\n", "    # To be overridden with True in the appropriate subclasses\n", "    is_number = False\n", "    is_Atom = False\n", "    is_Symbol = False\n", "    is_symbol = False\n", "    is_Indexed = False\n", "    is_Dummy = False\n", "    is_Wild = False\n", "    is_Function = False\n", "    is_Add = False\n", "    is_Mul = False\n", "    is_Pow = False\n", "    is_Number = False\n", "    is_Float = False\n", "    is_Rational = False\n", "    is_Integer = False\n", "    is_NumberSymbol = False\n", "    is_Order = False\n", "    is_Derivative = False\n", "    is_Piecewise = False\n", "    is_Poly = False\n", "    is_AlgebraicNumber = False\n", "    is_Relational = False\n", "    is_Equality = False\n", "    is_Boolean = False\n", "    is_Not = False\n", "    is_Matrix = False\n", "    is_Vector = False\n", "    is_Point = False\n", "    is_MatAdd = False\n", "    is_MatMul = False\n"]}, {"span_id": "Atom", "start_line": 1826, "end_line": 1839, "content": ["class Atom(Basic):\n", "    \"\"\"\n", "    A parent class for atomic things. An atom is an expression with no subexpressions.\n", "\n", "    Examples\n", "    ========\n", "\n", "    Symbol, Number, Rational, Integer, ...\n", "    But not: Add, Mul, Pow, ...\n", "    \"\"\"\n", "\n", "    is_Atom = True\n", "\n", "    __slots__ = ()\n"]}]}]}