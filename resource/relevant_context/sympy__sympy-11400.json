{"instance_id": "sympy__sympy-11400", "identified_spans": [{"file_path": "sympy/functions/elementary/trigonometric.py", "span_ids": ["sinc"], "content": [{"span_id": "sinc", "start_line": 1620, "end_line": 1658, "content": ["class sinc(TrigonometricFunction):\n", "    r\"\"\"Represents unnormalized sinc function\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import sinc, oo, jn, Product, Symbol\n", "    >>> from sympy.abc import x\n", "    >>> sinc(x)\n", "    sinc(x)\n", "\n", "    * Automated Evaluation\n", "\n", "    >>> sinc(0)\n", "    1\n", "    >>> sinc(oo)\n", "    0\n", "\n", "    * Differentiation\n", "\n", "    >>> sinc(x).diff()\n", "    (x*cos(x) - sin(x))/x**2\n", "\n", "    * Series Expansion\n", "\n", "    >>> sinc(x).series()\n", "    1 - x**2/6 + x**4/120 + O(x**6)\n", "\n", "    * As zero'th order spherical Bessel Function\n", "\n", "    >>> sinc(x).rewrite(jn)\n", "    jn(0, x)\n", "\n", "    References\n", "    ==========\n", "\n", "    .. [1] http://en.wikipedia.org/wiki/Sinc_function\n", "\n", "    \"\"\"\n"]}]}, {"file_path": "sympy/printing/ccode.py", "span_ids": ["CCodePrinter.__init__", "ccode", "CCodePrinter"], "content": [{"span_id": "CCodePrinter.__init__", "start_line": 103, "end_line": 109, "content": ["    def __init__(self, settings={}):\n", "        CodePrinter.__init__(self, settings)\n", "        self.known_functions = dict(known_functions)\n", "        userfuncs = settings.get('user_functions', {})\n", "        self.known_functions.update(userfuncs)\n", "        self._dereference = set(settings.get('dereference', []))\n", "        self.reserved_words = set(reserved_words)\n"]}, {"span_id": "ccode", "start_line": 283, "end_line": 396, "content": ["def ccode(expr, assign_to=None, **settings):\n", "    \"\"\"Converts an expr to a string of c code\n", "\n", "    Parameters\n", "    ==========\n", "\n", "    expr : Expr\n", "        A sympy expression to be converted.\n", "    assign_to : optional\n", "        When given, the argument is used as the name of the variable to which\n", "        the expression is assigned. Can be a string, ``Symbol``,\n", "        ``MatrixSymbol``, or ``Indexed`` type. This is helpful in case of\n", "        line-wrapping, or for expressions that generate multi-line statements.\n", "    precision : integer, optional\n", "        The precision for numbers such as pi [default=15].\n", "    user_functions : dict, optional\n", "        A dictionary where the keys are string representations of either\n", "        ``FunctionClass`` or ``UndefinedFunction`` instances and the values\n", "        are their desired C string representations. Alternatively, the\n", "        dictionary value can be a list of tuples i.e. [(argument_test,\n", "        cfunction_string)].  See below for examples.\n", "    dereference : iterable, optional\n", "        An iterable of symbols that should be dereferenced in the printed code\n", "        expression. These would be values passed by address to the function.\n", "        For example, if ``dereference=[a]``, the resulting code would print\n", "        ``(*a)`` instead of ``a``.\n", "    human : bool, optional\n", "        If True, the result is a single string that may contain some constant\n", "        declarations for the number symbols. If False, the same information is\n", "        returned in a tuple of (symbols_to_declare, not_supported_functions,\n", "        code_text). [default=True].\n", "    contract: bool, optional\n", "        If True, ``Indexed`` instances are assumed to obey tensor contraction\n", "        rules and the corresponding nested loops over indices are generated.\n", "        Setting contract=False will not generate loops, instead the user is\n", "        responsible to provide values for the indices in the code.\n", "        [default=True].\n", "\n", "    Examples\n", "    ========\n", "\n", "    >>> from sympy import ccode, symbols, Rational, sin, ceiling, Abs, Function\n", "    >>> x, tau = symbols(\"x, tau\")\n", "    >>> ccode((2*tau)**Rational(7, 2))\n", "    '8*sqrt(2)*pow(tau, 7.0L/2.0L)'\n", "    >>> ccode(sin(x), assign_to=\"s\")\n", "    's = sin(x);'\n", "\n", "    Simple custom printing can be defined for certain types by passing a\n", "    dictionary of {\"type\" : \"function\"} to the ``user_functions`` kwarg.\n", "    Alternatively, the dictionary value can be a list of tuples i.e.\n", "    [(argument_test, cfunction_string)].\n", "\n", "    >>> custom_functions = {\n", "    ...   \"ceiling\": \"CEIL\",\n", "    ...   \"Abs\": [(lambda x: not x.is_integer, \"fabs\"),\n", "    ...           (lambda x: x.is_integer, \"ABS\")],\n", "    ...   \"func\": \"f\"\n", "    ... }\n", "    >>> func = Function('func')\n", "    >>> ccode(func(Abs(x) + ceiling(x)), user_functions=custom_functions)\n", "    'f(fabs(x) + CEIL(x))'\n", "\n", "    ``Piecewise`` expressions are converted into conditionals. If an\n", "    ``assign_to`` variable is provided an if statement is created, otherwise\n", "    the ternary operator is used. Note that if the ``Piecewise`` lacks a\n", "    default term, represented by ``(expr, True)`` then an error will be thrown.\n", "    This is to prevent generating an expression that may not evaluate to\n", "    anything.\n", "\n", "    >>> from sympy import Piecewise\n", "    >>> expr = Piecewise((x + 1, x > 0), (x, True))\n", "    >>> print(ccode(expr, tau))\n", "    if (x > 0) {\n", "    tau = x + 1;\n", "    }\n", "    else {\n", "    tau = x;\n", "    }\n", "\n", "    Support for loops is provided through ``Indexed`` types. With\n", "    ``contract=True`` these expressions will be turned into loops, whereas\n", "    ``contract=False`` will just print the assignment expression that should be\n", "    looped over:\n", "\n", "    >>> from sympy import Eq, IndexedBase, Idx\n", "    >>> len_y = 5\n", "    >>> y = IndexedBase('y', shape=(len_y,))\n", "    >>> t = IndexedBase('t', shape=(len_y,))\n", "    >>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n", "    >>> i = Idx('i', len_y-1)\n", "    >>> e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n", "    >>> ccode(e.rhs, assign_to=e.lhs, contract=False)\n", "    'Dy[i] = (y[i + 1] - y[i])/(t[i + 1] - t[i]);'\n", "\n", "    Matrices are also supported, but a ``MatrixSymbol`` of the same dimensions\n", "    must be provided to ``assign_to``. Note that any expression that can be\n", "    generated normally can also exist inside a Matrix:\n", "\n", "    >>> from sympy import Matrix, MatrixSymbol\n", "    >>> mat = Matrix([x**2, Piecewise((x + 1, x > 0), (x, True)), sin(x)])\n", "    >>> A = MatrixSymbol('A', 3, 1)\n", "    >>> print(ccode(mat, A))\n", "    A[0] = pow(x, 2);\n", "    if (x > 0) {\n", "       A[1] = x + 1;\n", "    }\n", "    else {\n", "       A[1] = x;\n", "    }\n", "    A[2] = sin(x);\n", "    \"\"\"\n", "\n", "    return CCodePrinter(settings).doprint(expr, assign_to)\n"]}, {"span_id": "CCodePrinter", "start_line": 86, "end_line": 101, "content": ["class CCodePrinter(CodePrinter):\n", "    \"\"\"A printer to convert python expressions to strings of c code\"\"\"\n", "    printmethod = \"_ccode\"\n", "    language = \"C\"\n", "\n", "    _default_settings = {\n", "        'order': None,\n", "        'full_prec': 'auto',\n", "        'precision': 15,\n", "        'user_functions': {},\n", "        'human': True,\n", "        'contract': True,\n", "        'dereference': set(),\n", "        'error_on_reserved': False,\n", "        'reserved_word_suffix': '_',\n", "    }\n"]}]}]}