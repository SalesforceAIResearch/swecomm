{"instance_id": "django__django-11999", "identified_spans": [{"file_path": "django/db/models/base.py", "span_ids": ["Model._get_FIELD_display"], "content": [{"span_id": "Model._get_FIELD_display", "start_line": 941, "end_line": 944, "content": ["    def _get_FIELD_display(self, field):\n", "        value = getattr(self, field.attname)\n", "        # force_str() to coerce lazy strings.\n", "        return force_str(dict(field.flatchoices).get(value, value), strings_only=True)\n"]}]}, {"file_path": "django/db/models/fields/__init__.py", "span_ids": ["Field.contribute_to_class"], "content": [{"span_id": "Field.contribute_to_class", "start_line": 749, "end_line": 767, "content": ["    def contribute_to_class(self, cls, name, private_only=False):\n", "        \"\"\"\n", "        Register the field with the model class it belongs to.\n", "\n", "        If private_only is True, create a separate instance of this field\n", "        for every subclass of cls, even if cls is not an abstract model.\n", "        \"\"\"\n", "        self.set_attributes_from_name(name)\n", "        self.model = cls\n", "        cls._meta.add_field(self, private=private_only)\n", "        if self.column:\n", "            # Don't override classmethods with the descriptor. This means that\n", "            # if you have a classmethod and a field with the same name, then\n", "            # such fields can't be deferred (we don't have a check for this).\n", "            if not getattr(cls, self.attname, None):\n", "                setattr(cls, self.attname, self.descriptor_class(self))\n", "        if self.choices is not None:\n", "            setattr(cls, 'get_%s_display' % self.name,\n", "                    partialmethod(cls._get_FIELD_display, field=self))\n"]}]}]}