{"instance_id": "psf__requests-2317", "identified_spans": [{"file_path": "requests/compat.py", "span_ids": ["impl:47", "impl:59"], "content": []}, {"file_path": "requests/sessions.py", "span_ids": ["Session.request"], "content": [{"span_id": "Session.request", "start_line": 378, "end_line": 459, "content": ["    def request(self, method, url,\n", "        params=None,\n", "        data=None,\n", "        headers=None,\n", "        cookies=None,\n", "        files=None,\n", "        auth=None,\n", "        timeout=None,\n", "        allow_redirects=True,\n", "        proxies=None,\n", "        hooks=None,\n", "        stream=None,\n", "        verify=None,\n", "        cert=None,\n", "        json=None):\n", "        \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n", "        Returns :class:`Response <Response>` object.\n", "\n", "        :param method: method for the new :class:`Request` object.\n", "        :param url: URL for the new :class:`Request` object.\n", "        :param params: (optional) Dictionary or bytes to be sent in the query\n", "            string for the :class:`Request`.\n", "        :param data: (optional) Dictionary or bytes to send in the body of the\n", "            :class:`Request`.\n", "        :param json: (optional) json to send in the body of the\n", "            :class:`Request`.\n", "        :param headers: (optional) Dictionary of HTTP Headers to send with the\n", "            :class:`Request`.\n", "        :param cookies: (optional) Dict or CookieJar object to send with the\n", "            :class:`Request`.\n", "        :param files: (optional) Dictionary of ``'filename': file-like-objects``\n", "            for multipart encoding upload.\n", "        :param auth: (optional) Auth tuple or callable to enable\n", "            Basic/Digest/Custom HTTP Auth.\n", "        :param timeout: (optional) How long to wait for the server to send\n", "            data before giving up, as a float, or a (`connect timeout, read\n", "            timeout <user/advanced.html#timeouts>`_) tuple.\n", "        :type timeout: float or tuple\n", "        :param allow_redirects: (optional) Set to True by default.\n", "        :type allow_redirects: bool\n", "        :param proxies: (optional) Dictionary mapping protocol to the URL of\n", "            the proxy.\n", "        :param stream: (optional) whether to immediately download the response\n", "            content. Defaults to ``False``.\n", "        :param verify: (optional) if ``True``, the SSL cert will be verified.\n", "            A CA_BUNDLE path can also be provided.\n", "        :param cert: (optional) if String, path to ssl client cert file (.pem).\n", "            If Tuple, ('cert', 'key') pair.\n", "        \"\"\"\n", "\n", "        method = builtin_str(method)\n", "\n", "        # Create the Request.\n", "        req = Request(\n", "            method = method.upper(),\n", "            url = url,\n", "            headers = headers,\n", "            files = files,\n", "            data = data or {},\n", "            json = json,\n", "            params = params or {},\n", "            auth = auth,\n", "            cookies = cookies,\n", "            hooks = hooks,\n", "        )\n", "        prep = self.prepare_request(req)\n", "\n", "        proxies = proxies or {}\n", "\n", "        settings = self.merge_environment_settings(\n", "            prep.url, proxies, stream, verify, cert\n", "        )\n", "\n", "        # Send the request.\n", "        send_kwargs = {\n", "            'timeout': timeout,\n", "            'allow_redirects': allow_redirects,\n", "        }\n", "        send_kwargs.update(settings)\n", "        resp = self.send(prep, **send_kwargs)\n", "\n", "        return resp\n"]}]}]}