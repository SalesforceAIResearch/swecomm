<context>
<code-snippet location="doc/en/example/assertion/failure_demo.py:255-281">
class TestCustomAssertMsg:
    def test_single_line(self):
        class A:
            a = 1

        b = 2
        assert A.a == b, "A.a appears not to be b"

    def test_multiline(self):
        class A:
            a = 1

        b = 2
        assert (
            A.a == b
        ), "A.a appears not to be b\nor does not appear to be b\none of those"

    def test_custom_repr(self):
        class JSON:
            a = 1

            def __repr__(self):
                return "This is JSON\n{\n  'foo': 'bar'\n}"

        a = JSON()
        b = 2
        assert a.a == b, a
</code-snippet>
<code-snippet location="bench/manyparam.py:1-14">
import pytest


@pytest.fixture(scope="module", params=range(966))
def foo(request):
    return request.param


def test_it(foo):
    pass


def test_it2(foo):
    pass
</code-snippet>
<code-snippet location="doc/en/example/xfail_demo.py:1-38">
import pytest

xfail = pytest.mark.xfail


@xfail
def test_hello():
    assert 0


@xfail(run=False)
def test_hello2():
    assert 0


@xfail("hasattr(os, 'sep')")
def test_hello3():
    assert 0


@xfail(reason="bug 110")
def test_hello4():
    assert 0


@xfail('pytest.__version__[0] != "17"')
def test_hello5():
    assert 0


def test_hello6():
    pytest.xfail("reason")


@xfail(raises=IndexError)
def test_hello7():
    x = []
    x[1] = 1
</code-snippet>
<code-snippet location="src/_pytest/junitxml.py:328-353">
def record_xml_attribute(request: FixtureRequest) -> Callable[[str, object], None]:
    """Add extra xml attributes to the tag for the calling test.

    The fixture is callable with ``name, value``. The value is
    automatically XML-encoded.
    """
    from _pytest.warning_types import PytestExperimentalApiWarning

    request.node.warn(
        PytestExperimentalApiWarning("record_xml_attribute is an experimental feature")
    )

    _warn_incompatibility_with_xunit2(request, "record_xml_attribute")

    # Declare noop
    def add_attr_noop(name: str, value: object) -> None:
        pass

    attr_func = add_attr_noop

    xml = request.config._store.get(xml_key, None)
    if xml is not None:
        node_reporter = xml.node_reporter(request.node.nodeid)
        attr_func = node_reporter.add_attribute

    return attr_func
</code-snippet>
<code-snippet location="src/_pytest/junitxml.py:305-327">
def record_property(request: FixtureRequest) -> Callable[[str, object], None]:
    """Add extra properties to the calling test.

    User properties become part of the test report and are available to the
    configured reporters, like JUnit XML.

    The fixture is callable with ``name, value``. The value is automatically
    XML-encoded.

    Example::

        def test_function(record_property):
            record_property("example_key", 1)
    """
    _warn_incompatibility_with_xunit2(request, "record_property")

    def append_property(name: str, value: object) -> None:
        request.node.user_properties.append((name, value))

    return append_property


@pytest.fixture
</code-snippet>
<code-snippet location="src/_pytest/unittest.py:114-139">
def _make_xunit_fixture(
    obj: type, setup_name: str, teardown_name: str, scope: "_Scope", pass_self: bool
):
    setup = getattr(obj, setup_name, None)
    teardown = getattr(obj, teardown_name, None)
    if setup is None and teardown is None:
        return None

    @pytest.fixture(scope=scope, autouse=True)
    def fixture(self, request: FixtureRequest) -> Generator[None, None, None]:
        if _is_skipped(self):
            reason = self.__unittest_skip_why__
            pytest.skip(reason)
        if setup is not None:
            if pass_self:
                setup(self, request.function)
            else:
                setup()
        yield
        if teardown is not None:
            if pass_self:
                teardown(self, request.function)
            else:
                teardown()

    return fixture
</code-snippet>
<code-snippet location="src/_pytest/unittest.py:199-230">
def addError(
        self, testcase: "unittest.TestCase", rawexcinfo: "_SysExcInfoType"
    ) -> None:
        try:
            if isinstance(rawexcinfo[1], exit.Exception):
                exit(rawexcinfo[1].msg)
        except TypeError:
            pass
        self._addexcinfo(rawexcinfo)

    def addFailure(
        self, testcase: "unittest.TestCase", rawexcinfo: "_SysExcInfoType"
    ) -> None:
        self._addexcinfo(rawexcinfo)

    def addSkip(self, testcase: "unittest.TestCase", reason: str) -> None:
        try:
            skip(reason)
        except skip.Exception:
            self._store[skipped_by_mark_key] = True
            self._addexcinfo(sys.exc_info())

    def addExpectedFailure(
        self,
        testcase: "unittest.TestCase",
        rawexcinfo: "_SysExcInfoType",
        reason: str = "",
    ) -> None:
        try:
            xfail(str(reason))
        except xfail.Exception:
            self._addexcinfo(sys.exc_info())
</code-snippet>
<code-snippet location="src/_pytest/junitxml.py:287-304">
def _warn_incompatibility_with_xunit2(
    request: FixtureRequest, fixture_name: str
) -> None:
    """Emits a PytestWarning about the given fixture being incompatible with newer xunit revisions"""
    from _pytest.warning_types import PytestWarning

    xml = request.config._store.get(xml_key, None)
    if xml is not None and xml.family not in ("xunit1", "legacy"):
        request.node.warn(
            PytestWarning(
                "{fixture_name} is incompatible with junit_family '{family}' (use 'legacy' or 'xunit1')".format(
                    fixture_name=fixture_name, family=xml.family
                )
            )
        )


@pytest.fixture
</code-snippet>
<code-snippet location="src/_pytest/junitxml.py:389-392">
xml = request.config._store.get(xml_key, None)
    if xml is not None:
        record_func = xml.add_global_property  # noqa
    return record_func
</code-snippet>
<code-snippet location="src/_pytest/junitxml.py:366-387">
def record_testsuite_property(request: FixtureRequest) -> Callable[[str, object], None]:
    """
    Records a new ``<property>`` tag as child of the root ``<testsuite>``. This is suitable to
    writing global information regarding the entire test suite, and is compatible with ``xunit2`` JUnit family.

    This is a ``session``-scoped fixture which is called with ``(name, value)``. Example:

    .. code-block:: python

        def test_foo(record_testsuite_property):
            record_testsuite_property("ARCH", "PPC")
            record_testsuite_property("STORAGE_TYPE", "CEPH")

    ``name`` must be a string, ``value`` will be converted to a string and properly xml-escaped.
    """

    __tracebackhide__ = True

    def record_func(name: str, value: object) -> None:
        """noop function in case --junitxml was not passed in the command-line"""
        __tracebackhide__ = True
        _check_record_param_type("name", name)
</code-snippet>
<code-snippet location="src/_pytest/junitxml.py:230-251">
def append_collect_error(self, report: TestReport) -> None:
        # msg = str(report.longrepr.reprtraceback.extraline)
        assert report.longrepr is not None
        self.append(
            Junit.error(bin_xml_escape(report.longrepr), message="collection failure")
        )

    def append_collect_skipped(self, report: TestReport) -> None:
        self._add_simple(Junit.skipped, "collection skipped", report.longrepr)

    def append_error(self, report: TestReport) -> None:
        assert report.longrepr is not None
        if getattr(report.longrepr, "reprcrash", None) is not None:
            reason = report.longrepr.reprcrash.message
        else:
            reason = str(report.longrepr)

        if report.when == "teardown":
            msg = 'failed on teardown with "{}"'.format(reason)
        else:
            msg = 'failed on setup with "{}"'.format(reason)
        self._add_simple(Junit.error, msg, report.longrepr)
</code-snippet>
<code-snippet location="src/_pytest/nodes.py:241-271">
def __hash__(self) -> int:
        return hash(self._nodeid)

    def setup(self) -> None:
        pass

    def teardown(self) -> None:
        pass

    def listchain(self) -> List["Node"]:
        """ return list of all parent collectors up to self,
            starting from root of collection tree. """
        chain = []
        item = self  # type: Optional[Node]
        while item is not None:
            chain.append(item)
            item = item.parent
        chain.reverse()
        return chain

    def add_marker(
        self, marker: Union[str, MarkDecorator], append: bool = True
    ) -> None:
        """dynamically add a marker object to the node.

        :type marker: ``str`` or ``pytest.mark.*``  object
        :param marker:
            ``append=True`` whether to append the marker,
            if ``False`` insert at position ``0``.
        """
        from _pytest.mark import MARK_GEN
</code-snippet>
<code-snippet location="src/_pytest/unittest.py:14-43">
import _pytest._code
import pytest
from _pytest.compat import getimfunc
from _pytest.compat import is_async_function
from _pytest.compat import TYPE_CHECKING
from _pytest.config import hookimpl
from _pytest.fixtures import FixtureRequest
from _pytest.nodes import Collector
from _pytest.nodes import Item
from _pytest.outcomes import exit
from _pytest.outcomes import fail
from _pytest.outcomes import skip
from _pytest.outcomes import xfail
from _pytest.python import Class
from _pytest.python import Function
from _pytest.python import PyCollector
from _pytest.runner import CallInfo
from _pytest.skipping import skipped_by_mark_key
from _pytest.skipping import unexpectedsuccess_key

if TYPE_CHECKING:
    import unittest
    from typing import Type

    from _pytest.fixtures import _Scope

    _SysExcInfoType = Union[
        Tuple[Type[BaseException], BaseException, types.TracebackType],
        Tuple[None, None, None],
    ]
</code-snippet>
<code-snippet location="src/_pytest/unittest.py:232-257">
def addUnexpectedSuccess(
        self, testcase: "unittest.TestCase", reason: str = ""
    ) -> None:
        self._store[unexpectedsuccess_key] = reason

    def addSuccess(self, testcase: "unittest.TestCase") -> None:
        pass

    def stopTest(self, testcase: "unittest.TestCase") -> None:
        pass

    def _expecting_failure(self, test_method) -> bool:
        """Return True if the given unittest method (or the entire class) is marked
        with @expectedFailure"""
        expecting_failure_method = getattr(
            test_method, "__unittest_expecting_failure__", False
        )
        expecting_failure_class = getattr(self, "__unittest_expecting_failure__", False)
        return bool(expecting_failure_class or expecting_failure_method)

    def runtest(self) -> None:
        from _pytest.debugging import maybe_wrap_pytest_function_for_tracing

        assert self._testcase is not None

        maybe_wrap_pytest_function_for_tracing(self)
</code-snippet>
<code-snippet location="doc/en/example/assertion/failure_demo.py:123-160">
def test_attribute():
    class Foo:
        b = 1

    i = Foo()
    assert i.b == 2


def test_attribute_instance():
    class Foo:
        b = 1

    assert Foo().b == 2


def test_attribute_failure():
    class Foo:
        def _get_b(self):
            raise Exception("Failed to get attrib")

        b = property(_get_b)

    i = Foo()
    assert i.b == 2


def test_attribute_multiple():
    class Foo:
        b = 1

    class Bar:
        b = 2

    assert Foo().b == Bar().b


def globf(x):
    return x + 1
</code-snippet>
<code-snippet location="src/_pytest/unittest.py:142-164">
class TestCaseFunction(Function):
    nofuncargs = True
    _excinfo = None  # type: Optional[List[_pytest._code.ExceptionInfo]]
    _testcase = None  # type: Optional[unittest.TestCase]

    def setup(self) -> None:
        # a bound method to be called during teardown() if set (see 'runtest()')
        self._explicit_tearDown = None  # type: Optional[Callable[[], None]]
        assert self.parent is not None
        self._testcase = self.parent.obj(self.name)  # type: ignore[attr-defined]
        self._obj = getattr(self._testcase, self.name)
        if hasattr(self, "_request"):
            self._request._fillfixtures()

    def teardown(self) -> None:
        if self._explicit_tearDown is not None:
            self._explicit_tearDown()
            self._explicit_tearDown = None
        self._testcase = None
        self._obj = None

    def startTest(self, testcase: "unittest.TestCase") -> None:
        pass
</code-snippet>
<code-snippet location="doc/en/example/assertion/failure_demo.py:73-108">
def test_eq_set(self):
        assert {0, 10, 11, 12} == {0, 20, 21}

    def test_eq_longer_list(self):
        assert [1, 2] == [1, 2, 3]

    def test_in_list(self):
        assert 1 in [0, 2, 3, 4, 5]

    def test_not_in_text_multiline(self):
        text = "some multiline\ntext\nwhich\nincludes foo\nand a\ntail"
        assert "foo" not in text

    def test_not_in_text_single(self):
        text = "single foo line"
        assert "foo" not in text

    def test_not_in_text_single_long(self):
        text = "head " * 50 + "foo " + "tail " * 20
        assert "foo" not in text

    def test_not_in_text_single_long_term(self):
        text = "head " * 50 + "f" * 70 + "tail " * 20
        assert "f" * 70 not in text

    def test_eq_dataclass(self):
        from dataclasses import dataclass

        @dataclass
        class Foo:
            a: int
            b: str

        left = Foo(1, "b")
        right = Foo(1, "c")
        assert left == right
</code-snippet>
<code-snippet location="src/_pytest/mark/__init__.py:150-174">
for node in item.listchain():
            if not isinstance(node, (pytest.Instance, pytest.Session)):
                mapped_names.add(node.name)

        # Add the names added as extra keywords to current or parent items
        mapped_names.update(item.listextrakeywords())

        # Add the names attached to the current function through direct assignment
        function_obj = getattr(item, "function", None)
        if function_obj:
            mapped_names.update(function_obj.__dict__)

        # add the markers to the keywords as we no longer handle them correctly
        mapped_names.update(mark.name for mark in item.iter_markers())

        return cls(mapped_names)

    def __call__(self, subname: str) -> bool:
        subname = subname.lower()
        names = (name.lower() for name in self._names)

        for name in names:
            if subname in name:
                return True
        return False
</code-snippet>
<code-snippet location="doc/en/example/assertion/failure_demo.py:101-120">
@dataclass
        class Foo:
            a: int
            b: str

        left = Foo(1, "b")
        right = Foo(1, "c")
        assert left == right

    def test_eq_attrs(self):
        import attr

        @attr.s
        class Foo:
            a = attr.ib()
            b = attr.ib()

        left = Foo(1, "b")
        right = Foo(1, "c")
        assert left == right
</code-snippet>
<code-snippet location="doc/en/example/assertion/failure_demo.py:42-77">
class TestSpecialisedExplanations:
    def test_eq_text(self):
        assert "spam" == "eggs"

    def test_eq_similar_text(self):
        assert "foo 1 bar" == "foo 2 bar"

    def test_eq_multiline_text(self):
        assert "foo\nspam\nbar" == "foo\neggs\nbar"

    def test_eq_long_text(self):
        a = "1" * 100 + "a" + "2" * 100
        b = "1" * 100 + "b" + "2" * 100
        assert a == b

    def test_eq_long_text_multiline(self):
        a = "1\n" * 100 + "a" + "2\n" * 100
        b = "1\n" * 100 + "b" + "2\n" * 100
        assert a == b

    def test_eq_list(self):
        assert [0, 1, 2] == [0, 1, 3]

    def test_eq_list_long(self):
        a = [0] * 100 + [1] + [3] * 100
        b = [0] * 100 + [2] + [3] * 100
        assert a == b

    def test_eq_dict(self):
        assert {"a": 0, "b": 1, "c": 0} == {"a": 0, "b": 2, "d": 0}

    def test_eq_set(self):
        assert {0, 10, 11, 12} == {0, 20, 21}

    def test_eq_longer_list(self):
        assert [1, 2] == [1, 2, 3]
</code-snippet>
<code-snippet location="src/_pytest/junitxml.py:212-228">
def append_pass(self, report: TestReport) -> None:
        self.add_stats("passed")

    def append_failure(self, report: TestReport) -> None:
        # msg = str(report.longrepr.reprtraceback.extraline)
        if hasattr(report, "wasxfail"):
            self._add_simple(Junit.skipped, "xfail-marked test passes unexpectedly")
        else:
            assert report.longrepr is not None
            if getattr(report.longrepr, "reprcrash", None) is not None:
                message = report.longrepr.reprcrash.message
            else:
                message = str(report.longrepr)
            message = bin_xml_escape(message)
            fail = Junit.failure(message=message)
            fail.append(bin_xml_escape(report.longrepr))
            self.append(fail)
</code-snippet>
<code-snippet location="src/_pytest/junitxml.py:253-277">
def append_skipped(self, report: TestReport) -> None:
        if hasattr(report, "wasxfail"):
            xfailreason = report.wasxfail
            if xfailreason.startswith("reason: "):
                xfailreason = xfailreason[8:]
            self.append(
                Junit.skipped(
                    "", type="pytest.xfail", message=bin_xml_escape(xfailreason)
                )
            )
        else:
            assert report.longrepr is not None
            filename, lineno, skipreason = report.longrepr
            if skipreason.startswith("Skipped: "):
                skipreason = skipreason[9:]
            details = "{}:{}: {}".format(filename, lineno, skipreason)

            self.append(
                Junit.skipped(
                    bin_xml_escape(details),
                    type="pytest.skip",
                    message=bin_xml_escape(skipreason),
                )
            )
            self.write_captured_output(report)
</code-snippet>
<code-snippet location="src/_pytest/nodes.py:273-297">
if isinstance(marker, MarkDecorator):
            marker_ = marker
        elif isinstance(marker, str):
            marker_ = getattr(MARK_GEN, marker)
        else:
            raise ValueError("is not a string or pytest.mark.* Marker")
        self.keywords[marker_.name] = marker_
        if append:
            self.own_markers.append(marker_.mark)
        else:
            self.own_markers.insert(0, marker_.mark)

    def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:
        """
        :param name: if given, filter the results by the name attribute

        iterate over all markers of the node
        """
        return (x[1] for x in self.iter_markers_with_node(name=name))

    def iter_markers_with_node(
        self, name: Optional[str] = None
    ) -> Iterator[Tuple["Node", Mark]]:
        """
        :param name: if given, filter the results by the name attribute
</code-snippet>
<code-snippet location="src/_pytest/nodes.py:293-313">
def iter_markers_with_node(
        self, name: Optional[str] = None
    ) -> Iterator[Tuple["Node", Mark]]:
        """
        :param name: if given, filter the results by the name attribute

        iterate over all markers of the node
        returns sequence of tuples (node, mark)
        """
        for node in reversed(self.listchain()):
            for mark in node.own_markers:
                if name is None or getattr(mark, "name", None) == name:
                    yield node, mark

    @overload
    def get_closest_marker(self, name: str) -> Optional[Mark]:
        raise NotImplementedError()

    @overload  # noqa: F811
    def get_closest_marker(self, name: str, default: Mark) -> Mark:  # noqa: F811
        raise NotImplementedError()
</code-snippet>
<code-snippet location="src/_pytest/junitxml.py:25-46">
import py

import pytest
from _pytest import deprecated
from _pytest import nodes
from _pytest import timing
from _pytest._code.code import ExceptionRepr
from _pytest.compat import TYPE_CHECKING
from _pytest.config import Config
from _pytest.config import filename_arg
from _pytest.config.argparsing import Parser
from _pytest.fixtures import FixtureRequest
from _pytest.reports import TestReport
from _pytest.store import StoreKey
from _pytest.terminal import TerminalReporter
from _pytest.warnings import _issue_warning_captured

if TYPE_CHECKING:
    from typing import Type


xml_key = StoreKey["LogXML"]()
</code-snippet>
<code-snippet location="src/_pytest/mark/__init__.py:40-61">
def param(
    *values: object,
    marks: "Union[MarkDecorator, typing.Collection[Union[MarkDecorator, Mark]]]" = (),
    id: Optional[str] = None
) -> ParameterSet:
    """Specify a parameter in `pytest.mark.parametrize`_ calls or
    :ref:`parametrized fixtures <fixture-parametrize-marks>`.

    .. code-block:: python

        @pytest.mark.parametrize(
            "test_input,expected",
            [("3+5", 8), pytest.param("6*9", 42, marks=pytest.mark.xfail),],
        )
        def test_eval(test_input, expected):
            assert eval(test_input) == expected

    :param values: variable args of the values of the parameter set, in order.
    :keyword marks: a single mark or a list of marks to be applied to this parameter set.
    :keyword str id: the id to attribute to this parameter set.
    """
    return ParameterSet.param(*values, marks=marks, id=id)
</code-snippet>
<code-snippet location="doc/en/example/assertion/failure_demo.py:191-202">
def test_dynamic_compile_shows_nicely():
    import importlib.util
    import sys

    src = "def foo():\n assert 1 == 0\n"
    name = "abc-123"
    spec = importlib.util.spec_from_loader(name, loader=None)
    module = importlib.util.module_from_spec(spec)
    code = compile(src, name, "exec")
    exec(code, module.__dict__)
    sys.modules[name] = module
    module.foo()
</code-snippet>
<code-snippet location="src/_pytest/nodes.py:78-90">
def ischildnode(baseid: str, nodeid: str) -> bool:
    """Return True if the nodeid is a child node of the baseid.

    E.g. 'foo/bar::Baz' is a child of 'foo', 'foo/bar' and 'foo/bar::Baz', but not of 'foo/blorp'
    """
    base_parts = _splitnode(baseid)
    node_parts = _splitnode(nodeid)
    if len(node_parts) < len(base_parts):
        return False
    return node_parts[: len(base_parts)] == base_parts


_NodeType = TypeVar("_NodeType", bound="Node")
</code-snippet>
</context>