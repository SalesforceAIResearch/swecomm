{
    "instance_id": "pytest-dev__pytest-5227",
    "traj": [
        [
            {
                "id": 0,
                "timestamp": "2024-07-17T03:02:20.013610",
                "source": "user",
                "message": "Please fix the following issue for the repository in /workspace/pytest-dev__pytest__4.4.\nEnvironment has been set up for you to start working. You may assume all necessary tools are installed.\n\n# Problem Statement\nImprove default logging format\nCurrently it is:\r\n\r\n> DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\r\n\r\nI think `name` (module name) would be very useful here, instead of just the base filename.\r\n\r\n(It might also be good to have the relative path there (maybe at the end), but it is usually still very long (but e.g. `$VIRTUAL_ENV` could be substituted therein))\r\n\r\nCurrently it would look like this:\r\n```\r\nutils.py                   114 DEBUG    (0.000) SELECT \"app_url\".\"id\", \"app_url\".\"created\", \"app_url\".\"url\" FROM \"app_url\" WHERE \"app_url\".\"id\" = 2; args=(2,)\r\nmultipart.py               604 DEBUG    Calling on_field_start with no data\r\n```\r\n\r\n\r\nUsing `DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"` instead:\r\n\r\n```\r\nDEBUG    django.db.backends:utils.py:114 (0.000) SELECT \"app_url\".\"id\", \"app_url\".\"created\", \"app_url\".\"url\" FROM \"app_url\" WHERE \"app_url\".\"id\" = 2; args=(2,)\r\nDEBUG    multipart.multipart:multipart.py:604 Calling on_field_start with no data\r\n```\n\n\nIMPORTANT: You should ONLY interact with the environment provided to you AND NEVER ASK FOR HUMAN HELP.\nYou should NOT modify any existing test case files. If needed, you can add new test cases in a NEW file to reproduce the issue.\nYou SHOULD INCLUDE PROPER INDENTATION in your edit commands.\nWhen you think you have fixed the issue through code changes, please run the following command: <execute_bash> exit </execute_bash>.\n",
                "action": "message",
                "args": {
                    "content": "Please fix the following issue for the repository in /workspace/pytest-dev__pytest__4.4.\nEnvironment has been set up for you to start working. You may assume all necessary tools are installed.\n\n# Problem Statement\nImprove default logging format\nCurrently it is:\r\n\r\n> DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\r\n\r\nI think `name` (module name) would be very useful here, instead of just the base filename.\r\n\r\n(It might also be good to have the relative path there (maybe at the end), but it is usually still very long (but e.g. `$VIRTUAL_ENV` could be substituted therein))\r\n\r\nCurrently it would look like this:\r\n```\r\nutils.py                   114 DEBUG    (0.000) SELECT \"app_url\".\"id\", \"app_url\".\"created\", \"app_url\".\"url\" FROM \"app_url\" WHERE \"app_url\".\"id\" = 2; args=(2,)\r\nmultipart.py               604 DEBUG    Calling on_field_start with no data\r\n```\r\n\r\n\r\nUsing `DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"` instead:\r\n\r\n```\r\nDEBUG    django.db.backends:utils.py:114 (0.000) SELECT \"app_url\".\"id\", \"app_url\".\"created\", \"app_url\".\"url\" FROM \"app_url\" WHERE \"app_url\".\"id\" = 2; args=(2,)\r\nDEBUG    multipart.multipart:multipart.py:604 Calling on_field_start with no data\r\n```\n\n\nIMPORTANT: You should ONLY interact with the environment provided to you AND NEVER ASK FOR HUMAN HELP.\nYou should NOT modify any existing test case files. If needed, you can add new test cases in a NEW file to reproduce the issue.\nYou SHOULD INCLUDE PROPER INDENTATION in your edit commands.\nWhen you think you have fixed the issue through code changes, please run the following command: <execute_bash> exit </execute_bash>.\n",
                    "wait_for_response": false
                }
            },
            {
                "message": "No observation",
                "observation": "null",
                "content": "",
                "extras": {}
            }
        ],
        [
            {
                "id": 3,
                "timestamp": "2024-07-17T03:02:23.815312",
                "source": "agent",
                "message": "Running command: find /workspace/pytest-dev__pytest__4.4 -type f -name \"*.py\" | xargs grep -n \"DEFAULT_LOG_FORMAT\"",
                "action": "run",
                "args": {
                    "command": "find /workspace/pytest-dev__pytest__4.4 -type f -name \"*.py\" | xargs grep -n \"DEFAULT_LOG_FORMAT\"",
                    "thought": "Certainly! I'll work on improving the default logging format for the pytest repository. Let's start by examining the current implementation and then make the necessary changes.\n\nFirst, let's locate the file where the default log format is defined:",
                    "is_confirmed": "confirmed"
                }
            },
            {
                "id": 4,
                "timestamp": "2024-07-17T03:02:23.979797",
                "source": "agent",
                "message": "Command `find /workspace/pytest-dev__pytest__4.4 -type f -name \"*.py\" | xargs grep -n \"DEFAULT_LOG_FORMAT\"` executed with exit code 0.",
                "cause": 3,
                "observation": "run",
                "content": "/workspace/pytest-dev__pytest__4.4/src/_pytest/logging.py:18:DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\r\n/workspace/pytest-dev__pytest__4.4/src/_pytest/logging.py:111:        default=DEFAULT_LOG_FORMAT,\r\n/workspace/pytest-dev__pytest__4.4/src/_pytest/logging.py:156:        default=DEFAULT_LOG_FORMAT,",
                "extras": {
                    "command_id": -1,
                    "command": "find /workspace/pytest-dev__pytest__4.4 -type f -name \"*.py\" | xargs grep -n \"DEFAULT_LOG_FORMAT\"",
                    "exit_code": 0
                }
            }
        ],
        [
            {
                "id": 5,
                "timestamp": "2024-07-17T03:02:26.632012",
                "source": "agent",
                "message": "Running Python code interactively: open_file('/workspace/pytest-dev__pytest__4.4/src/_pytest/logging.py')",
                "action": "run_ipython",
                "args": {
                    "code": "open_file('/workspace/pytest-dev__pytest__4.4/src/_pytest/logging.py')",
                    "thought": "Thank you for the information. Now that we've located the file containing the DEFAULT_LOG_FORMAT, let's modify it to include the module name and improve the format as requested.\n\nLet's open the file and update the DEFAULT_LOG_FORMAT:",
                    "is_confirmed": "confirmed",
                    "kernel_init_code": "from agentskills import *"
                }
            },
            {
                "id": 6,
                "timestamp": "2024-07-17T03:02:27.093870",
                "source": "agent",
                "message": "Code executed in IPython cell.",
                "cause": 5,
                "observation": "run_ipython",
                "content": "[File: /workspace/pytest-dev__pytest__4.4/src/_pytest/logging.py (662 lines total)]\r\n(this is the beginning of the file)\r\n1|\"\"\" Access and control log capturing. \"\"\"\r\n2|from __future__ import absolute_import\r\n3|from __future__ import division\r\n4|from __future__ import print_function\r\n5|\r\n6|import logging\r\n7|import re\r\n8|from contextlib import contextmanager\r\n9|\r\n10|import py\r\n11|import six\r\n12|\r\n13|import pytest\r\n14|from _pytest.compat import dummy_context_manager\r\n15|from _pytest.config import create_terminal_writer\r\n16|from _pytest.pathlib import Path\r\n17|\r\n18|DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\r\n19|DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\r\n20|\r\n21|\r\n22|class ColoredLevelFormatter(logging.Formatter):\r\n23|    \"\"\"\r\n24|    Colorize the %(levelname)..s part of the log format passed to __init__.\r\n25|    \"\"\"\r\n26|\r\n27|    LOGLEVEL_COLOROPTS = {\r\n28|        logging.CRITICAL: {\"red\"},\r\n29|        logging.ERROR: {\"red\", \"bold\"},\r\n30|        logging.WARNING: {\"yellow\"},\r\n31|        logging.WARN: {\"yellow\"},\r\n32|        logging.INFO: {\"green\"},\r\n33|        logging.DEBUG: {\"purple\"},\r\n34|        logging.NOTSET: set(),\r\n35|    }\r\n36|    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\r\n37|\r\n38|    def __init__(self, terminalwriter, *args, **kwargs):\r\n39|        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\r\n40|        if six.PY2:\r\n41|            self._original_fmt = self._fmt\r\n42|        else:\r\n43|            self._original_fmt = self._style._fmt\r\n44|        self._level_to_fmt_mapping = {}\r\n45|\r\n46|        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\r\n47|        if not levelname_fmt_match:\r\n48|            return\r\n49|        levelname_fmt = levelname_fmt_match.group()\r\n50|\r\n51|        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\r\n52|            formatted_levelname = levelname_fmt % {\r\n53|                \"levelname\": logging.getLevelName(level)\r\n54|            }\r\n55|\r\n56|            # add ANSI escape sequences around the formatted levelname\r\n57|            color_kwargs = {name: True for name in color_opts}\r\n58|            colorized_formatted_levelname = terminalwriter.markup(\r\n59|                formatted_levelname, **color_kwargs\r\n60|            )\r\n61|            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\r\n62|                colorized_formatted_levelname, self._fmt\r\n63|            )\r\n64|\r\n65|    def format(self, record):\r\n66|        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\r\n67|        if six.PY2:\r\n68|            self._fmt = fmt\r\n69|        else:\r\n70|            self._style._fmt = fmt\r\n71|        return super(ColoredLevelFormatter, self).format(record)\r\n72|\r\n73|\r\n74|def get_option_ini(config, *names):\r\n75|    for name in names:\r\n76|        ret = config.getoption(name)  # 'default' arg won't work as expected\r\n77|        if ret is None:\r\n78|            ret = config.getini(name)\r\n79|        if ret:\r\n80|            return ret\r\n81|\r\n82|\r\n83|def pytest_addoption(parser):\r\n84|    \"\"\"Add options to control log capturing.\"\"\"\r\n85|    group = parser.getgroup(\"logging\")\r\n86|\r\n87|    def add_option_ini(option, dest, default=None, type=None, **kwargs):\r\n88|        parser.addini(\r\n89|            dest, default=default, type=type, help=\"default value for \" + option\r\n90|        )\r\n91|        group.addoption(option, dest=dest, **kwargs)\r\n92|\r\n93|    add_option_ini(\r\n94|        \"--no-print-logs\",\r\n95|        dest=\"log_print\",\r\n96|        action=\"store_const\",\r\n97|        const=False,\r\n98|        default=True,\r\n99|        type=\"bool\",\r\n100|        help=\"disable printing caught logs on failed tests.\",\r\n(562 more lines below)\r\n",
                "extras": {
                    "code": "open_file('/workspace/pytest-dev__pytest__4.4/src/_pytest/logging.py')"
                }
            }
        ],
        [
            {
                "id": 7,
                "timestamp": "2024-07-17T03:02:31.024452",
                "source": "agent",
                "message": "Running Python code interactively: edit_file_by_replace(\n    '/workspace/pytest-dev__pytest__4.4/src/_pytest/logging.py',\n    to_replace='DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"',\n    new_content='DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"'\n)",
                "action": "run_ipython",
                "args": {
                    "code": "edit_file_by_replace(\n    '/workspace/pytest-dev__pytest__4.4/src/_pytest/logging.py',\n    to_replace='DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"',\n    new_content='DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"'\n)",
                    "thought": "Thank you for showing the file content. Now, let's update the DEFAULT_LOG_FORMAT to include the module name and improve the format as requested. We'll modify line 18 of the file.",
                    "is_confirmed": "confirmed",
                    "kernel_init_code": "from agentskills import *"
                }
            },
            {
                "id": 8,
                "timestamp": "2024-07-17T03:02:31.618453",
                "source": "agent",
                "message": "Code executed in IPython cell.",
                "cause": 7,
                "observation": "run_ipython",
                "content": "[File: /workspace/pytest-dev__pytest__4.4/src/_pytest/logging.py (662 lines total after edit)]\r\n(this is the beginning of the file)\r\n1|\"\"\" Access and control log capturing. \"\"\"\r\n2|from __future__ import absolute_import\r\n3|from __future__ import division\r\n4|from __future__ import print_function\r\n5|\r\n6|import logging\r\n7|import re\r\n8|from contextlib import contextmanager\r\n9|\r\n10|import py\r\n11|import six\r\n12|\r\n13|import pytest\r\n14|from _pytest.compat import dummy_context_manager\r\n15|from _pytest.config import create_terminal_writer\r\n16|from _pytest.pathlib import Path\r\n17|\r\n18|DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\r\n19|DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\r\n20|\r\n21|\r\n22|class ColoredLevelFormatter(logging.Formatter):\r\n23|    \"\"\"\r\n24|    Colorize the %(levelname)..s part of the log format passed to __init__.\r\n25|    \"\"\"\r\n26|\r\n27|    LOGLEVEL_COLOROPTS = {\r\n28|        logging.CRITICAL: {\"red\"},\r\n29|        logging.ERROR: {\"red\", \"bold\"},\r\n30|        logging.WARNING: {\"yellow\"},\r\n31|        logging.WARN: {\"yellow\"},\r\n32|        logging.INFO: {\"green\"},\r\n33|        logging.DEBUG: {\"purple\"},\r\n34|        logging.NOTSET: set(),\r\n35|    }\r\n36|    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\r\n37|\r\n38|    def __init__(self, terminalwriter, *args, **kwargs):\r\n39|        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\r\n40|        if six.PY2:\r\n41|            self._original_fmt = self._fmt\r\n42|        else:\r\n43|            self._original_fmt = self._style._fmt\r\n44|        self._level_to_fmt_mapping = {}\r\n45|\r\n46|        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\r\n47|        if not levelname_fmt_match:\r\n48|            return\r\n49|        levelname_fmt = levelname_fmt_match.group()\r\n50|\r\n51|        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\r\n52|            formatted_levelname = levelname_fmt % {\r\n53|                \"levelname\": logging.getLevelName(level)\r\n54|            }\r\n55|\r\n56|            # add ANSI escape sequences around the formatted levelname\r\n57|            color_kwargs = {name: True for name in color_opts}\r\n58|            colorized_formatted_levelname = terminalwriter.markup(\r\n59|                formatted_levelname, **color_kwargs\r\n60|            )\r\n61|            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\r\n62|                colorized_formatted_levelname, self._fmt\r\n63|            )\r\n64|\r\n65|    def format(self, record):\r\n66|        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\r\n67|        if six.PY2:\r\n68|            self._fmt = fmt\r\n69|        else:\r\n70|            self._style._fmt = fmt\r\n71|        return super(ColoredLevelFormatter, self).format(record)\r\n72|\r\n73|\r\n74|def get_option_ini(config, *names):\r\n75|    for name in names:\r\n76|        ret = config.getoption(name)  # 'default' arg won't work as expected\r\n77|        if ret is None:\r\n78|            ret = config.getini(name)\r\n79|        if ret:\r\n80|            return ret\r\n81|\r\n82|\r\n83|def pytest_addoption(parser):\r\n84|    \"\"\"Add options to control log capturing.\"\"\"\r\n85|    group = parser.getgroup(\"logging\")\r\n86|\r\n87|    def add_option_ini(option, dest, default=None, type=None, **kwargs):\r\n88|        parser.addini(\r\n89|            dest, default=default, type=type, help=\"default value for \" + option\r\n90|        )\r\n91|        group.addoption(option, dest=dest, **kwargs)\r\n92|\r\n93|    add_option_ini(\r\n94|        \"--no-print-logs\",\r\n95|        dest=\"log_print\",\r\n96|        action=\"store_const\",\r\n97|        const=False,\r\n98|        default=True,\r\n99|        type=\"bool\",\r\n100|        help=\"disable printing caught logs on failed tests.\",\r\n(562 more lines below)\r\n[File updated (edited at line 18). Please review the changes and make sure they are correct (correct indentation, no duplicate lines, etc). Edit the file again if necessary.]\r\n",
                "extras": {
                    "code": "edit_file_by_replace(\n    '/workspace/pytest-dev__pytest__4.4/src/_pytest/logging.py',\n    to_replace='DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"',\n    new_content='DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"'\n)"
                }
            }
        ],
        [
            {
                "id": 9,
                "timestamp": "2024-07-17T03:02:36.007084",
                "source": "agent",
                "message": "All done! What's next on the agenda?",
                "action": "finish",
                "args": {
                    "outputs": {},
                    "thought": ""
                }
            },
            {
                "message": "No observation",
                "observation": "null",
                "content": "",
                "extras": {}
            }
        ]
    ],
    "info": {
        "submission": "diff --git a/src/_pytest/.backup.logging.py b/src/_pytest/.backup.logging.py\r\nnew file mode 100644\r\nindex 000000000..757cb2797\r\n--- /dev/null\r\n+++ b/src/_pytest/.backup.logging.py\r\n@@ -0,0 +1,662 @@\r\n+\"\"\" Access and control log capturing. \"\"\"\r\n+from __future__ import absolute_import\r\n+from __future__ import division\r\n+from __future__ import print_function\r\n+\r\n+import logging\r\n+import re\r\n+from contextlib import contextmanager\r\n+\r\n+import py\r\n+import six\r\n+\r\n+import pytest\r\n+from _pytest.compat import dummy_context_manager\r\n+from _pytest.config import create_terminal_writer\r\n+from _pytest.pathlib import Path\r\n+\r\n+DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\r\n+DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\r\n+\r\n+\r\n+class ColoredLevelFormatter(logging.Formatter):\r\n+    \"\"\"\r\n+    Colorize the %(levelname)..s part of the log format passed to __init__.\r\n+    \"\"\"\r\n+\r\n+    LOGLEVEL_COLOROPTS = {\r\n+        logging.CRITICAL: {\"red\"},\r\n+        logging.ERROR: {\"red\", \"bold\"},\r\n+        logging.WARNING: {\"yellow\"},\r\n+        logging.WARN: {\"yellow\"},\r\n+        logging.INFO: {\"green\"},\r\n+        logging.DEBUG: {\"purple\"},\r\n+        logging.NOTSET: set(),\r\n+    }\r\n+    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\r\n+\r\n+    def __init__(self, terminalwriter, *args, **kwargs):\r\n+        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\r\n+        if six.PY2:\r\n+            self._original_fmt = self._fmt\r\n+        else:\r\n+            self._original_fmt = self._style._fmt\r\n+        self._level_to_fmt_mapping = {}\r\n+\r\n+        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\r\n+        if not levelname_fmt_match:\r\n+            return\r\n+        levelname_fmt = levelname_fmt_match.group()\r\n+\r\n+        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\r\n+            formatted_levelname = levelname_fmt % {\r\n+                \"levelname\": logging.getLevelName(level)\r\n+            }\r\n+\r\n+            # add ANSI escape sequences around the formatted levelname\r\n+            color_kwargs = {name: True for name in color_opts}\r\n+            colorized_formatted_levelname = terminalwriter.markup(\r\n+                formatted_levelname, **color_kwargs\r\n+            )\r\n+            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\r\n+                colorized_formatted_levelname, self._fmt\r\n+            )\r\n+\r\n+    def format(self, record):\r\n+        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\r\n+        if six.PY2:\r\n+            self._fmt = fmt\r\n+        else:\r\n+            self._style._fmt = fmt\r\n+        return super(ColoredLevelFormatter, self).format(record)\r\n+\r\n+\r\n+def get_option_ini(config, *names):\r\n+    for name in names:\r\n+        ret = config.getoption(name)  # 'default' arg won't work as expected\r\n+        if ret is None:\r\n+            ret = config.getini(name)\r\n+        if ret:\r\n+            return ret\r\n+\r\n+\r\n+def pytest_addoption(parser):\r\n+    \"\"\"Add options to control log capturing.\"\"\"\r\n+    group = parser.getgroup(\"logging\")\r\n+\r\n+    def add_option_ini(option, dest, default=None, type=None, **kwargs):\r\n+        parser.addini(\r\n+            dest, default=default, type=type, help=\"default value for \" + option\r\n+        )\r\n+        group.addoption(option, dest=dest, **kwargs)\r\n+\r\n+    add_option_ini(\r\n+        \"--no-print-logs\",\r\n+        dest=\"log_print\",\r\n+        action=\"store_const\",\r\n+        const=False,\r\n+        default=True,\r\n+        type=\"bool\",\r\n+        help=\"disable printing caught logs on failed tests.\",\r\n+    )\r\n+    add_option_ini(\r\n+        \"--log-level\",\r\n+        dest=\"log_level\",\r\n+        default=None,\r\n+        help=\"logging level used by the logging module\",\r\n+    )\r\n+    add_option_ini(\r\n+        \"--log-format\",\r\n+        dest=\"log_format\",\r\n+        default=DEFAULT_LOG_FORMAT,\r\n+        help=\"log format as used by the logging module.\",\r\n+    )\r\n+    add_option_ini(\r\n+        \"--log-date-format\",\r\n+        dest=\"log_date_format\",\r\n+        default=DEFAULT_LOG_DATE_FORMAT,\r\n+        help=\"log date format as used by the logging module.\",\r\n+    )\r\n+    parser.addini(\r\n+        \"log_cli\",\r\n+        default=False,\r\n+        type=\"bool\",\r\n+        help='enable log display during test run (also known as \"live logging\").',\r\n+    )\r\n+    add_option_ini(\r\n+        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\r\n+    )\r\n+    add_option_ini(\r\n+        \"--log-cli-format\",\r\n+        dest=\"log_cli_format\",\r\n+        default=None,\r\n+        help=\"log format as used by the logging module.\",\r\n+    )\r\n+    add_option_ini(\r\n+        \"--log-cli-date-format\",\r\n+        dest=\"log_cli_date_format\",\r\n+        default=None,\r\n+        help=\"log date format as used by the logging module.\",\r\n+    )\r\n+    add_option_ini(\r\n+        \"--log-file\",\r\n+        dest=\"log_file\",\r\n+        default=None,\r\n+        help=\"path to a file when logging will be written to.\",\r\n+    )\r\n+    add_option_ini(\r\n+        \"--log-file-level\",\r\n+        dest=\"log_file_level\",\r\n+        default=None,\r\n+        help=\"log file logging level.\",\r\n+    )\r\n+    add_option_ini(\r\n+        \"--log-file-format\",\r\n+        dest=\"log_file_format\",\r\n+        default=DEFAULT_LOG_FORMAT,\r\n+        help=\"log format as used by the logging module.\",\r\n+    )\r\n+    add_option_ini(\r\n+        \"--log-file-date-format\",\r\n+        dest=\"log_file_date_format\",\r\n+        default=DEFAULT_LOG_DATE_FORMAT,\r\n+        help=\"log date format as used by the logging module.\",\r\n+    )\r\n+\r\n+\r\n+@contextmanager\r\n+def catching_logs(handler, formatter=None, level=None):\r\n+    \"\"\"Context manager that prepares the whole logging machinery properly.\"\"\"\r\n+    root_logger = logging.getLogger()\r\n+\r\n+    if formatter is not None:\r\n+        handler.setFormatter(formatter)\r\n+    if level is not None:\r\n+        handler.setLevel(level)\r\n+\r\n+    # Adding the same handler twice would confuse logging system.\r\n+    # Just don't do that.\r\n+    add_new_handler = handler not in root_logger.handlers\r\n+\r\n+    if add_new_handler:\r\n+        root_logger.addHandler(handler)\r\n+    if level is not None:\r\n+        orig_level = root_logger.level\r\n+        root_logger.setLevel(min(orig_level, level))\r\n+    try:\r\n+        yield handler\r\n+    finally:\r\n+        if level is not None:\r\n+            root_logger.setLevel(orig_level)\r\n+        if add_new_handler:\r\n+            root_logger.removeHandler(handler)\r\n+\r\n+\r\n+class LogCaptureHandler(logging.StreamHandler):\r\n+    \"\"\"A logging handler that stores log records and the log text.\"\"\"\r\n+\r\n+    def __init__(self):\r\n+        \"\"\"Creates a new log handler.\"\"\"\r\n+        logging.StreamHandler.__init__(self, py.io.TextIO())\r\n+        self.records = []\r\n+\r\n+    def emit(self, record):\r\n+        \"\"\"Keep the log records in a list in addition to the log text.\"\"\"\r\n+        self.records.append(record)\r\n+        logging.StreamHandler.emit(self, record)\r\n+\r\n+    def reset(self):\r\n+        self.records = []\r\n+        self.stream = py.io.TextIO()\r\n+\r\n+\r\n+class LogCaptureFixture(object):\r\n+    \"\"\"Provides access and control of log capturing.\"\"\"\r\n+\r\n+    def __init__(self, item):\r\n+        \"\"\"Creates a new funcarg.\"\"\"\r\n+        self._item = item\r\n+        # dict of log name -> log level\r\n+        self._initial_log_levels = {}  # Dict[str, int]\r\n+\r\n+    def _finalize(self):\r\n+        \"\"\"Finalizes the fixture.\r\n+\r\n+        This restores the log levels changed by :meth:`set_level`.\r\n+        \"\"\"\r\n+        # restore log levels\r\n+        for logger_name, level in self._initial_log_levels.items():\r\n+            logger = logging.getLogger(logger_name)\r\n+            logger.setLevel(level)\r\n+\r\n+    @property\r\n+    def handler(self):\r\n+        \"\"\"\r\n+        :rtype: LogCaptureHandler\r\n+        \"\"\"\r\n+        return self._item.catch_log_handler\r\n+\r\n+    def get_records(self, when):\r\n+        \"\"\"\r\n+        Get the logging records for one of the possible test phases.\r\n+\r\n+        :param str when:\r\n+            Which test phase to obtain the records from. Valid values are: \"setup\", \"call\" and \"teardown\".\r\n+\r\n+        :rtype: List[logging.LogRecord]\r\n+        :return: the list of captured records at the given stage\r\n+\r\n+        .. versionadded:: 3.4\r\n+        \"\"\"\r\n+        handler = self._item.catch_log_handlers.get(when)\r\n+        if handler:\r\n+            return handler.records\r\n+        else:\r\n+            return []\r\n+\r\n+    @property\r\n+    def text(self):\r\n+        \"\"\"Returns the log text.\"\"\"\r\n+        return self.handler.stream.getvalue()\r\n+\r\n+    @property\r\n+    def records(self):\r\n+        \"\"\"Returns the list of log records.\"\"\"\r\n+        return self.handler.records\r\n+\r\n+    @property\r\n+    def record_tuples(self):\r\n+        \"\"\"Returns a list of a stripped down version of log records intended\r\n+        for use in assertion comparison.\r\n+\r\n+        The format of the tuple is:\r\n+\r\n+            (logger_name, log_level, message)\r\n+        \"\"\"\r\n+        return [(r.name, r.levelno, r.getMessage()) for r in self.records]\r\n+\r\n+    @property\r\n+    def messages(self):\r\n+        \"\"\"Returns a list of format-interpolated log messages.\r\n+\r\n+        Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list\r\n+        are all interpolated.\r\n+        Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with\r\n+        levels, timestamps, etc, making exact comparisons more reliable.\r\n+\r\n+        Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments\r\n+        to the logging functions) is not included, as this is added by the formatter in the handler.\r\n+\r\n+        .. versionadded:: 3.7\r\n+        \"\"\"\r\n+        return [r.getMessage() for r in self.records]\r\n+\r\n+    def clear(self):\r\n+        \"\"\"Reset the list of log records and the captured log text.\"\"\"\r\n+        self.handler.reset()\r\n+\r\n+    def set_level(self, level, logger=None):\r\n+        \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value at the end of\r\n+        the test.\r\n+\r\n+        :param int level: the logger to level.\r\n+        :param str logger: the logger to update the level. If not given, the root logger level is updated.\r\n+\r\n+        .. versionchanged:: 3.4\r\n+            The levels of the loggers changed by this function will be restored to their initial values at the\r\n+            end of the test.\r\n+        \"\"\"\r\n+        logger_name = logger\r\n+        logger = logging.getLogger(logger_name)\r\n+        # save the original log-level to restore it during teardown\r\n+        self._initial_log_levels.setdefault(logger_name, logger.level)\r\n+        logger.setLevel(level)\r\n+\r\n+    @contextmanager\r\n+    def at_level(self, level, logger=None):\r\n+        \"\"\"Context manager that sets the level for capturing of logs. After the end of the 'with' statement the\r\n+        level is restored to its original value.\r\n+\r\n+        :param int level: the logger to level.\r\n+        :param str logger: the logger to update the level. If not given, the root logger level is updated.\r\n+        \"\"\"\r\n+        logger = logging.getLogger(logger)\r\n+        orig_level = logger.level\r\n+        logger.setLevel(level)\r\n+        try:\r\n+            yield\r\n+        finally:\r\n+            logger.setLevel(orig_level)\r\n+\r\n+\r\n+@pytest.fixture\r\n+def caplog(request):\r\n+    \"\"\"Access and control log capturing.\r\n+\r\n+    Captured logs are available through the following properties/methods::\r\n+\r\n+    * caplog.text            -> string containing formatted log output\r\n+    * caplog.records         -> list of logging.LogRecord instances\r\n+    * caplog.record_tuples   -> list of (logger_name, level, message) tuples\r\n+    * caplog.clear()         -> clear captured records and formatted log output string\r\n+    \"\"\"\r\n+    result = LogCaptureFixture(request.node)\r\n+    yield result\r\n+    result._finalize()\r\n+\r\n+\r\n+def get_actual_log_level(config, *setting_names):\r\n+    \"\"\"Return the actual logging level.\"\"\"\r\n+\r\n+    for setting_name in setting_names:\r\n+        log_level = config.getoption(setting_name)\r\n+        if log_level is None:\r\n+            log_level = config.getini(setting_name)\r\n+        if log_level:\r\n+            break\r\n+    else:\r\n+        return\r\n+\r\n+    if isinstance(log_level, six.string_types):\r\n+        log_level = log_level.upper()\r\n+    try:\r\n+        return int(getattr(logging, log_level, log_level))\r\n+    except ValueError:\r\n+        # Python logging does not recognise this as a logging level\r\n+        raise pytest.UsageError(\r\n+            \"'{}' is not recognized as a logging level name for \"\r\n+            \"'{}'. Please consider passing the \"\r\n+            \"logging level num instead.\".format(log_level, setting_name)\r\n+        )\r\n+\r\n+\r\n+# run after terminalreporter/capturemanager are configured\r\n+@pytest.hookimpl(trylast=True)\r\n+def pytest_configure(config):\r\n+    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\r\n+\r\n+\r\n+class LoggingPlugin(object):\r\n+    \"\"\"Attaches to the logging module and captures log messages for each test.\r\n+    \"\"\"\r\n+\r\n+    def __init__(self, config):\r\n+        \"\"\"Creates a new plugin to capture log messages.\r\n+\r\n+        The formatter can be safely shared across all handlers so\r\n+        create a single one for the entire test session here.\r\n+        \"\"\"\r\n+        self._config = config\r\n+\r\n+        # enable verbose output automatically if live logging is enabled\r\n+        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\r\n+            config.option.verbose = 1\r\n+\r\n+        self.print_logs = get_option_ini(config, \"log_print\")\r\n+        self.formatter = logging.Formatter(\r\n+            get_option_ini(config, \"log_format\"),\r\n+            get_option_ini(config, \"log_date_format\"),\r\n+        )\r\n+        self.log_level = get_actual_log_level(config, \"log_level\")\r\n+\r\n+        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\r\n+        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\r\n+        self.log_file_date_format = get_option_ini(\r\n+            config, \"log_file_date_format\", \"log_date_format\"\r\n+        )\r\n+        self.log_file_formatter = logging.Formatter(\r\n+            self.log_file_format, datefmt=self.log_file_date_format\r\n+        )\r\n+\r\n+        log_file = get_option_ini(config, \"log_file\")\r\n+        if log_file:\r\n+            self.log_file_handler = logging.FileHandler(\r\n+                log_file, mode=\"w\", encoding=\"UTF-8\"\r\n+            )\r\n+            self.log_file_handler.setFormatter(self.log_file_formatter)\r\n+        else:\r\n+            self.log_file_handler = None\r\n+\r\n+        self.log_cli_handler = None\r\n+\r\n+        self.live_logs_context = lambda: dummy_context_manager()\r\n+        # Note that the lambda for the live_logs_context is needed because\r\n+        # live_logs_context can otherwise not be entered multiple times due\r\n+        # to limitations of contextlib.contextmanager.\r\n+\r\n+        if self._log_cli_enabled():\r\n+            self._setup_cli_logging()\r\n+\r\n+    def _setup_cli_logging(self):\r\n+        config = self._config\r\n+        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\r\n+        if terminal_reporter is None:\r\n+            # terminal reporter is disabled e.g. by pytest-xdist.\r\n+            return\r\n+\r\n+        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\r\n+        # if capturemanager plugin is disabled, live logging still works.\r\n+        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\r\n+        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\r\n+        log_cli_date_format = get_option_ini(\r\n+            config, \"log_cli_date_format\", \"log_date_format\"\r\n+        )\r\n+        if (\r\n+            config.option.color != \"no\"\r\n+            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\r\n+        ):\r\n+            log_cli_formatter = ColoredLevelFormatter(\r\n+                create_terminal_writer(config),\r\n+                log_cli_format,\r\n+                datefmt=log_cli_date_format,\r\n+            )\r\n+        else:\r\n+            log_cli_formatter = logging.Formatter(\r\n+                log_cli_format, datefmt=log_cli_date_format\r\n+            )\r\n+        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\r\n+        self.log_cli_handler = log_cli_handler\r\n+        self.live_logs_context = lambda: catching_logs(\r\n+            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\r\n+        )\r\n+\r\n+    def set_log_path(self, fname):\r\n+        \"\"\"Public method, which can set filename parameter for\r\n+        Logging.FileHandler(). Also creates parent directory if\r\n+        it does not exist.\r\n+\r\n+        .. warning::\r\n+            Please considered as an experimental API.\r\n+        \"\"\"\r\n+        fname = Path(fname)\r\n+\r\n+        if not fname.is_absolute():\r\n+            fname = Path(self._config.rootdir, fname)\r\n+\r\n+        if not fname.parent.exists():\r\n+            fname.parent.mkdir(exist_ok=True, parents=True)\r\n+\r\n+        self.log_file_handler = logging.FileHandler(\r\n+            str(fname), mode=\"w\", encoding=\"UTF-8\"\r\n+        )\r\n+        self.log_file_handler.setFormatter(self.log_file_formatter)\r\n+\r\n+    def _log_cli_enabled(self):\r\n+        \"\"\"Return True if log_cli should be considered enabled, either explicitly\r\n+        or because --log-cli-level was given in the command-line.\r\n+        \"\"\"\r\n+        return self._config.getoption(\r\n+            \"--log-cli-level\"\r\n+        ) is not None or self._config.getini(\"log_cli\")\r\n+\r\n+    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\r\n+    def pytest_collection(self):\r\n+        with self.live_logs_context():\r\n+            if self.log_cli_handler:\r\n+                self.log_cli_handler.set_when(\"collection\")\r\n+\r\n+            if self.log_file_handler is not None:\r\n+                with catching_logs(self.log_file_handler, level=self.log_file_level):\r\n+                    yield\r\n+            else:\r\n+                yield\r\n+\r\n+    @contextmanager\r\n+    def _runtest_for(self, item, when):\r\n+        with self._runtest_for_main(item, when):\r\n+            if self.log_file_handler is not None:\r\n+                with catching_logs(self.log_file_handler, level=self.log_file_level):\r\n+                    yield\r\n+            else:\r\n+                yield\r\n+\r\n+    @contextmanager\r\n+    def _runtest_for_main(self, item, when):\r\n+        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\r\n+        with catching_logs(\r\n+            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\r\n+        ) as log_handler:\r\n+            if self.log_cli_handler:\r\n+                self.log_cli_handler.set_when(when)\r\n+\r\n+            if item is None:\r\n+                yield  # run the test\r\n+                return\r\n+\r\n+            if not hasattr(item, \"catch_log_handlers\"):\r\n+                item.catch_log_handlers = {}\r\n+            item.catch_log_handlers[when] = log_handler\r\n+            item.catch_log_handler = log_handler\r\n+            try:\r\n+                yield  # run test\r\n+            finally:\r\n+                if when == \"teardown\":\r\n+                    del item.catch_log_handler\r\n+                    del item.catch_log_handlers\r\n+\r\n+            if self.print_logs:\r\n+                # Add a captured log section to the report.\r\n+                log = log_handler.stream.getvalue().strip()\r\n+                item.add_report_section(when, \"log\", log)\r\n+\r\n+    @pytest.hookimpl(hookwrapper=True)\r\n+    def pytest_runtest_setup(self, item):\r\n+        with self._runtest_for(item, \"setup\"):\r\n+            yield\r\n+\r\n+    @pytest.hookimpl(hookwrapper=True)\r\n+    def pytest_runtest_call(self, item):\r\n+        with self._runtest_for(item, \"call\"):\r\n+            yield\r\n+\r\n+    @pytest.hookimpl(hookwrapper=True)\r\n+    def pytest_runtest_teardown(self, item):\r\n+        with self._runtest_for(item, \"teardown\"):\r\n+            yield\r\n+\r\n+    @pytest.hookimpl(hookwrapper=True)\r\n+    def pytest_runtest_logstart(self):\r\n+        if self.log_cli_handler:\r\n+            self.log_cli_handler.reset()\r\n+        with self._runtest_for(None, \"start\"):\r\n+            yield\r\n+\r\n+    @pytest.hookimpl(hookwrapper=True)\r\n+    def pytest_runtest_logfinish(self):\r\n+        with self._runtest_for(None, \"finish\"):\r\n+            yield\r\n+\r\n+    @pytest.hookimpl(hookwrapper=True)\r\n+    def pytest_runtest_logreport(self):\r\n+        with self._runtest_for(None, \"logreport\"):\r\n+            yield\r\n+\r\n+    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\r\n+    def pytest_sessionfinish(self):\r\n+        with self.live_logs_context():\r\n+            if self.log_cli_handler:\r\n+                self.log_cli_handler.set_when(\"sessionfinish\")\r\n+            if self.log_file_handler is not None:\r\n+                try:\r\n+                    with catching_logs(\r\n+                        self.log_file_handler, level=self.log_file_level\r\n+                    ):\r\n+                        yield\r\n+                finally:\r\n+                    # Close the FileHandler explicitly.\r\n+                    # (logging.shutdown might have lost the weakref?!)\r\n+                    self.log_file_handler.close()\r\n+            else:\r\n+                yield\r\n+\r\n+    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\r\n+    def pytest_sessionstart(self):\r\n+        with self.live_logs_context():\r\n+            if self.log_cli_handler:\r\n+                self.log_cli_handler.set_when(\"sessionstart\")\r\n+            if self.log_file_handler is not None:\r\n+                with catching_logs(self.log_file_handler, level=self.log_file_level):\r\n+                    yield\r\n+            else:\r\n+                yield\r\n+\r\n+    @pytest.hookimpl(hookwrapper=True)\r\n+    def pytest_runtestloop(self, session):\r\n+        \"\"\"Runs all collected test items.\"\"\"\r\n+        with self.live_logs_context():\r\n+            if self.log_file_handler is not None:\r\n+                with catching_logs(self.log_file_handler, level=self.log_file_level):\r\n+                    yield  # run all the tests\r\n+            else:\r\n+                yield  # run all the tests\r\n+\r\n+\r\n+class _LiveLoggingStreamHandler(logging.StreamHandler):\r\n+    \"\"\"\r\n+    Custom StreamHandler used by the live logging feature: it will write a newline before the first log message\r\n+    in each test.\r\n+\r\n+    During live logging we must also explicitly disable stdout/stderr capturing otherwise it will get captured\r\n+    and won't appear in the terminal.\r\n+    \"\"\"\r\n+\r\n+    def __init__(self, terminal_reporter, capture_manager):\r\n+        \"\"\"\r\n+        :param _pytest.terminal.TerminalReporter terminal_reporter:\r\n+        :param _pytest.capture.CaptureManager capture_manager:\r\n+        \"\"\"\r\n+        logging.StreamHandler.__init__(self, stream=terminal_reporter)\r\n+        self.capture_manager = capture_manager\r\n+        self.reset()\r\n+        self.set_when(None)\r\n+        self._test_outcome_written = False\r\n+\r\n+    def reset(self):\r\n+        \"\"\"Reset the handler; should be called before the start of each test\"\"\"\r\n+        self._first_record_emitted = False\r\n+\r\n+    def set_when(self, when):\r\n+        \"\"\"Prepares for the given test phase (setup/call/teardown)\"\"\"\r\n+        self._when = when\r\n+        self._section_name_shown = False\r\n+        if when == \"start\":\r\n+            self._test_outcome_written = False\r\n+\r\n+    def emit(self, record):\r\n+        ctx_manager = (\r\n+            self.capture_manager.global_and_fixture_disabled()\r\n+            if self.capture_manager\r\n+            else dummy_context_manager()\r\n+        )\r\n+        with ctx_manager:\r\n+            if not self._first_record_emitted:\r\n+                self.stream.write(\"\\n\")\r\n+                self._first_record_emitted = True\r\n+            elif self._when in (\"teardown\", \"finish\"):\r\n+                if not self._test_outcome_written:\r\n+                    self._test_outcome_written = True\r\n+                    self.stream.write(\"\\n\")\r\n+            if not self._section_name_shown and self._when:\r\n+                self.stream.section(\"live log \" + self._when, sep=\"-\", bold=True)\r\n+                self._section_name_shown = True\r\n+            logging.StreamHandler.emit(self, record)\r\ndiff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\r\nindex 757cb2797..08670d2b2 100644\r\n--- a/src/_pytest/logging.py\r\n+++ b/src/_pytest/logging.py\r\n@@ -15,7 +15,7 @@ from _pytest.compat import dummy_context_manager\r\n from _pytest.config import create_terminal_writer\r\n from _pytest.pathlib import Path\r\n \r\n-DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\r\n+DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\r\n DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\r\n \r\n ",
        "model_stats": {
            "accumulated_cost": 0.08219699999999999,
            "costs": [
                0.016443,
                0.017082,
                0.022067999999999997,
                0.026604
            ]
        }
    }
}