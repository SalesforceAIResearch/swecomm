diff --git a/sympy/simplify/trigsimp.py b/sympy/simplify/trigsimp.py
index 05d62b3440..1f1b20bf19 100644
--- a/sympy/simplify/trigsimp.py
+++ b/sympy/simplify/trigsimp.py
@@ -11,6 +11,7 @@
 from sympy.functions.elementary.trigonometric import TrigonometricFunction
 from sympy.functions.elementary.hyperbolic import HyperbolicFunction
 from sympy.functions import sin, cos, exp, cosh, tanh, sinh, tan, cot, coth
+from sympy.core.numbers import Rational, Float
 
 from sympy.strategies.core import identity
 from sympy.strategies.tree import greedy
@@ -293,7 +294,7 @@ def analyse_gens(gens, hints):
             # If hint tan is provided, also work with tan(x). Moreover, if
             # n > 1, also work with sin(k*x) for k <= n, and similarly for cos
             # (and tan if the hint is provided). Finally, any generators which
-            # the ideal does not work with but we need to accomodate (either
+            # the ideal does not work with but we need to accommodate (either
             # because it was in expr or because it was provided as a hint)
             # we also build into the ideal.
             # This selection process is expressed in the list ``terms``.
@@ -393,7 +394,7 @@ def analyse_gens(gens, hints):
                         ourgens.update(p.exclude().gens)
             # NOTE preserve order!
             realgens = [x for x in gens if x in ourgens]
-            # The generators of the ideal have now been (implicitely) split
+            # The generators of the ideal have now been (implicitly) split
             # into two groups: those involving ourgens and those that don't.
             # Since we took the transitive closure above, these two groups
             # live in subgrings generated by a *disjoint* set of variables.
@@ -719,6 +720,18 @@ def traverse(e):
                                    d))
                    }[method]
 
+    def handle_rational(expr):
+        if isinstance(expr, (Rational, Float)):
+            return expr
+        if expr.is_Mul:
+            return Mul(*[handle_rational(arg) for arg in expr.args])
+        if expr.is_Add:
+            return Add(*[handle_rational(arg) for arg in expr.args])
+        if expr.is_Pow and expr.exp.is_Rational:
+            base = handle_rational(expr.base)
+            return base ** expr.exp
+        return expr
+
     if recursive:
         w, g = cse(expr)
         g = trigsimpfunc(g[0], deep)
@@ -730,6 +743,8 @@ def traverse(e):
     else:
         result = trigsimpfunc(expr, deep)
 
+    result = handle_rational(result)
+
     if opts.get('compare', False):
         f = futrig(old)
         if f != result:
@@ -1164,13 +1179,15 @@ def _futrig(e, **kwargs):
             factor_terms, TR12(x), trigs)],  # expand tan of sum
         )]
     e = greedy(tree, objective=Lops)(e)
-
     return coeff*e
 
 
 def _is_Expr(e):
     """_eapply helper to tell whether ``e`` and all its args
     are Exprs."""
+    from sympy import Derivative
+    if isinstance(e, Derivative):
+        return _is_Expr(e.expr)
     if not isinstance(e, Expr):
         return False
     return all(_is_Expr(i) for i in e.args)
