2024-07-30 17:14:25,393 - INFO - Intermediate patch for sympy__sympy-19254 written to /shared/patch.diff, now applying to container...
2024-07-30 17:14:25,646 - INFO - >>>>> Applied Patch:
Checking patch sympy/polys/factortools.py...
Applied patch sympy/polys/factortools.py cleanly.

2024-07-30 17:14:30,134 - INFO - Git diff before:
diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py
index 93298f47e6..23bb3452a3 100644
--- a/sympy/polys/factortools.py
+++ b/sympy/polys/factortools.py
@@ -124,21 +124,21 @@ def dmp_trial_division(f, factors, u, K):
 
 
 def dup_zz_mignotte_bound(f, K):
-    """Mignotte bound for univariate polynomials in `K[x]`. """
+    """Knuth-Cohen bound for univariate polynomials in `K[x]`. """
     a = dup_max_norm(f, K)
     b = abs(dup_LC(f, K))
     n = dup_degree(f)
 
-    return K.sqrt(K(n + 1))*2**n*a*b
+    return K.sqrt(K(n + 1)) * 2**n * a * b
 
 
 def dmp_zz_mignotte_bound(f, u, K):
-    """Mignotte bound for multivariate polynomials in `K[X]`. """
+    """Knuth-Cohen bound for multivariate polynomials in `K[X]`. """
     a = dmp_max_norm(f, u, K)
     b = abs(dmp_ground_LC(f, u, K))
     n = sum(dmp_degree_list(f, u))
 
-    return K.sqrt(K(n + 1))*2**n*a*b
+    return K.sqrt(K(n + 1)) * 2**n * a * b
 
 
 def dup_zz_hensel_step(m, f, g, h, s, t, K):
@@ -897,146 +897,7 @@ def dmp_zz_wang_hensel_lifting(f, H, LC, A, p, u, K):
         return H
 
 
-def dmp_zz_wang(f, u, K, mod=None, seed=None):
-    """
-    Factor primitive square-free polynomials in `Z[X]`.
-
-    Given a multivariate polynomial `f` in `Z[x_1,...,x_n]`, which is
-    primitive and square-free in `x_1`, computes factorization of `f` into
-    irreducibles over integers.
-
-    The procedure is based on Wang's Enhanced Extended Zassenhaus
-    algorithm. The algorithm works by viewing `f` as a univariate polynomial
-    in `Z[x_2,...,x_n][x_1]`, for which an evaluation mapping is computed::
-
-                      x_2 -> a_2, ..., x_n -> a_n
-
-    where `a_i`, for `i = 2, ..., n`, are carefully chosen integers.  The
-    mapping is used to transform `f` into a univariate polynomial in `Z[x_1]`,
-    which can be factored efficiently using Zassenhaus algorithm. The last
-    step is to lift univariate factors to obtain true multivariate
-    factors. For this purpose a parallel Hensel lifting procedure is used.
-
-    The parameter ``seed`` is passed to _randint and can be used to seed randint
-    (when an integer) or (for testing purposes) can be a sequence of numbers.
-
-    References
-    ==========
-
-    .. [1] [Wang78]_
-    .. [2] [Geddes92]_
-
-    """
-    from sympy.testing.randtest import _randint
-
-    randint = _randint(seed)
-
-    ct, T = dmp_zz_factor(dmp_LC(f, K), u - 1, K)
-
-    b = dmp_zz_mignotte_bound(f, u, K)
-    p = K(nextprime(b))
-
-    if mod is None:
-        if u == 1:
-            mod = 2
-        else:
-            mod = 1
-
-    history, configs, A, r = set([]), [], [K.zero]*u, None
-
-    try:
-        cs, s, E = dmp_zz_wang_test_points(f, T, ct, A, u, K)
-
-        _, H = dup_zz_factor_sqf(s, K)
-
-        r = len(H)
-
-        if r == 1:
-            return [f]
-
-        configs = [(s, cs, E, H, A)]
-    except EvaluationFailed:
-        pass
-
-    eez_num_configs = query('EEZ_NUMBER_OF_CONFIGS')
-    eez_num_tries = query('EEZ_NUMBER_OF_TRIES')
-    eez_mod_step = query('EEZ_MODULUS_STEP')
-
-    while len(configs) < eez_num_configs:
-        for _ in range(eez_num_tries):
-            A = [ K(randint(-mod, mod)) for _ in range(u) ]
-
-            if tuple(A) not in history:
-                history.add(tuple(A))
-            else:
-                continue
-
-            try:
-                cs, s, E = dmp_zz_wang_test_points(f, T, ct, A, u, K)
-            except EvaluationFailed:
-                continue
-
-            _, H = dup_zz_factor_sqf(s, K)
-
-            rr = len(H)
-
-            if r is not None:
-                if rr != r:  # pragma: no cover
-                    if rr < r:
-                        configs, r = [], rr
-                    else:
-                        continue
-            else:
-                r = rr
-
-            if r == 1:
-                return [f]
-
-            configs.append((s, cs, E, H, A))
-
-            if len(configs) == eez_num_configs:
-                break
-        else:
-            mod += eez_mod_step
-
-    s_norm, s_arg, i = None, 0, 0
-
-    for s, _, _, _, _ in configs:
-        _s_norm = dup_max_norm(s, K)
-
-        if s_norm is not None:
-            if _s_norm < s_norm:
-                s_norm = _s_norm
-                s_arg = i
-        else:
-            s_norm = _s_norm
-
-        i += 1
-
-    _, cs, E, H, A = configs[s_arg]
-    orig_f = f
-
-    try:
-        f, H, LC = dmp_zz_wang_lead_coeffs(f, T, cs, E, H, A, u, K)
-        factors = dmp_zz_wang_hensel_lifting(f, H, LC, A, p, u, K)
-    except ExtraneousFactors:  # pragma: no cover
-        if query('EEZ_RESTART_IF_NEEDED'):
-            return dmp_zz_wang(orig_f, u, K, mod + 1)
-        else:
-            raise ExtraneousFactors(
-                "we need to restart algorithm with better parameters")
-
-    result = []
-
-    for f in factors:
-        _, f = dmp_ground_primitive(f, u, K)
-
-        if K.is_negative(dmp_ground_LC(f, u, K)):
-            f = dmp_neg(f, u, K)
-
-        result.append(f)
-
-    return result
+b = dmp_zz_mignotte_bound(f, u, K)
 
 
 def dmp_zz_factor(f, u, K):
2024-07-30 17:14:30,134 - INFO - Eval script for sympy__sympy-19254 written to /eval.sh
2024-07-30 17:14:54,314 - INFO - Test runtime: 24.18 seconds
2024-07-30 17:14:54,579 - INFO - Git diff after:
diff --git a/sympy/polys/factortools.py b/sympy/polys/factortools.py
index 93298f47e6..23bb3452a3 100644
--- a/sympy/polys/factortools.py
+++ b/sympy/polys/factortools.py
@@ -124,21 +124,21 @@ def dmp_trial_division(f, factors, u, K):
 
 
 def dup_zz_mignotte_bound(f, K):
-    """Mignotte bound for univariate polynomials in `K[x]`. """
+    """Knuth-Cohen bound for univariate polynomials in `K[x]`. """
     a = dup_max_norm(f, K)
     b = abs(dup_LC(f, K))
     n = dup_degree(f)
 
-    return K.sqrt(K(n + 1))*2**n*a*b
+    return K.sqrt(K(n + 1)) * 2**n * a * b
 
 
 def dmp_zz_mignotte_bound(f, u, K):
-    """Mignotte bound for multivariate polynomials in `K[X]`. """
+    """Knuth-Cohen bound for multivariate polynomials in `K[X]`. """
     a = dmp_max_norm(f, u, K)
     b = abs(dmp_ground_LC(f, u, K))
     n = sum(dmp_degree_list(f, u))
 
-    return K.sqrt(K(n + 1))*2**n*a*b
+    return K.sqrt(K(n + 1)) * 2**n * a * b
 
 
 def dup_zz_hensel_step(m, f, g, h, s, t, K):
@@ -897,146 +897,7 @@ def dmp_zz_wang_hensel_lifting(f, H, LC, A, p, u, K):
         return H
 
 
-def dmp_zz_wang(f, u, K, mod=None, seed=None):
-    """
-    Factor primitive square-free polynomials in `Z[X]`.
-
-    Given a multivariate polynomial `f` in `Z[x_1,...,x_n]`, which is
-    primitive and square-free in `x_1`, computes factorization of `f` into
-    irreducibles over integers.
-
-    The procedure is based on Wang's Enhanced Extended Zassenhaus
-    algorithm. The algorithm works by viewing `f` as a univariate polynomial
-    in `Z[x_2,...,x_n][x_1]`, for which an evaluation mapping is computed::
-
-                      x_2 -> a_2, ..., x_n -> a_n
-
-    where `a_i`, for `i = 2, ..., n`, are carefully chosen integers.  The
-    mapping is used to transform `f` into a univariate polynomial in `Z[x_1]`,
-    which can be factored efficiently using Zassenhaus algorithm. The last
-    step is to lift univariate factors to obtain true multivariate
-    factors. For this purpose a parallel Hensel lifting procedure is used.
-
-    The parameter ``seed`` is passed to _randint and can be used to seed randint
-    (when an integer) or (for testing purposes) can be a sequence of numbers.
-
-    References
-    ==========
-
-    .. [1] [Wang78]_
-    .. [2] [Geddes92]_
-
-    """
-    from sympy.testing.randtest import _randint
-
-    randint = _randint(seed)
-
-    ct, T = dmp_zz_factor(dmp_LC(f, K), u - 1, K)
-
-    b = dmp_zz_mignotte_bound(f, u, K)
-    p = K(nextprime(b))
-
-    if mod is None:
-        if u == 1:
-            mod = 2
-        else:
-            mod = 1
-
-    history, configs, A, r = set([]), [], [K.zero]*u, None
-
-    try:
-        cs, s, E = dmp_zz_wang_test_points(f, T, ct, A, u, K)
-
-        _, H = dup_zz_factor_sqf(s, K)
-
-        r = len(H)
-
-        if r == 1:
-            return [f]
-
-        configs = [(s, cs, E, H, A)]
-    except EvaluationFailed:
-        pass
-
-    eez_num_configs = query('EEZ_NUMBER_OF_CONFIGS')
-    eez_num_tries = query('EEZ_NUMBER_OF_TRIES')
-    eez_mod_step = query('EEZ_MODULUS_STEP')
-
-    while len(configs) < eez_num_configs:
-        for _ in range(eez_num_tries):
-            A = [ K(randint(-mod, mod)) for _ in range(u) ]
-
-            if tuple(A) not in history:
-                history.add(tuple(A))
-            else:
-                continue
-
-            try:
-                cs, s, E = dmp_zz_wang_test_points(f, T, ct, A, u, K)
-            except EvaluationFailed:
-                continue
-
-            _, H = dup_zz_factor_sqf(s, K)
-
-            rr = len(H)
-
-            if r is not None:
-                if rr != r:  # pragma: no cover
-                    if rr < r:
-                        configs, r = [], rr
-                    else:
-                        continue
-            else:
-                r = rr
-
-            if r == 1:
-                return [f]
-
-            configs.append((s, cs, E, H, A))
-
-            if len(configs) == eez_num_configs:
-                break
-        else:
-            mod += eez_mod_step
-
-    s_norm, s_arg, i = None, 0, 0
-
-    for s, _, _, _, _ in configs:
-        _s_norm = dup_max_norm(s, K)
-
-        if s_norm is not None:
-            if _s_norm < s_norm:
-                s_norm = _s_norm
-                s_arg = i
-        else:
-            s_norm = _s_norm
-
-        i += 1
-
-    _, cs, E, H, A = configs[s_arg]
-    orig_f = f
-
-    try:
-        f, H, LC = dmp_zz_wang_lead_coeffs(f, T, cs, E, H, A, u, K)
-        factors = dmp_zz_wang_hensel_lifting(f, H, LC, A, p, u, K)
-    except ExtraneousFactors:  # pragma: no cover
-        if query('EEZ_RESTART_IF_NEEDED'):
-            return dmp_zz_wang(orig_f, u, K, mod + 1)
-        else:
-            raise ExtraneousFactors(
-                "we need to restart algorithm with better parameters")
-
-    result = []
-
-    for f in factors:
-        _, f = dmp_ground_primitive(f, u, K)
-
-        if K.is_negative(dmp_ground_LC(f, u, K)):
-            f = dmp_neg(f, u, K)
-
-        result.append(f)
-
-    return result
+b = dmp_zz_mignotte_bound(f, u, K)
 
 
 def dmp_zz_factor(f, u, K):
2024-07-30 17:14:54,580 - INFO - Grading answer for sympy__sympy-19254...
2024-07-30 17:14:54,594 - INFO - report: {'sympy__sympy-19254': {'patch_is_None': False, 'patch_exists': True, 'patch_successfully_applied': True, 'resolved': False, 'tests_status': {'FAIL_TO_PASS': {'success': [], 'failure': ['test_dup_zz_mignotte_bound']}, 'PASS_TO_PASS': {'success': [], 'failure': ['test_dup_trial_division', 'test_dmp_trial_division', 'test_dmp_zz_mignotte_bound', 'test_dup_zz_hensel_step', 'test_dup_zz_hensel_lift', 'test_dup_zz_irreducible_p', 'test_dup_cyclotomic_p', 'test_dup_zz_cyclotomic_poly', 'test_dup_zz_cyclotomic_factor', 'test_dup_zz_factor', 'test_dmp_zz_wang', 'test_issue_6355', 'test_dmp_zz_factor', 'test_dup_ext_factor', 'test_dmp_ext_factor', 'test_dup_factor_list', 'test_dmp_factor_list', 'test_dup_irreducible_p']}, 'FAIL_TO_FAIL': {'success': [], 'failure': []}, 'PASS_TO_FAIL': {'success': [], 'failure': []}}}}
Result for sympy__sympy-19254: resolved: False
