+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   sympy/core/function.py

no changes added to commit (use "git add" and/or "git commit -a")
+ git show
commit 25fbcce5b1a4c7e3956e6062930f4a44ce95a632
Merge: 46469d714a 892b92a352
Author: Chris Smith <smichr@gmail.com>
Date:   Wed Jun 3 19:17:23 2020 -0500

    Merge pull request #19483 from mohitshah3111999/pythonLover
    
    formatted docstring of sympy.geometry.curve according to documentation

+ git diff 25fbcce5b1a4c7e3956e6062930f4a44ce95a632
diff --git a/sympy/core/function.py b/sympy/core/function.py
index c02df23315..ec47be2bf0 100644
--- a/sympy/core/function.py
+++ b/sympy/core/function.py
@@ -827,7 +827,450 @@ def _sage_(self):
                 raise AttributeError
 
         return func(*args)
+class Function(Application, Expr):
+    """
+    Base class for applied mathematical functions.
+
+    It also serves as a constructor for undefined function classes.
+
+    Examples
+    ========
+
+    First example shows how to use Function as a constructor for undefined
+    function classes:
+
+    >>> from sympy import Function, Symbol
+    >>> x = Symbol('x')
+    >>> f = Function('f')
+    >>> g = Function('g')(x)
+    >>> f
+    f
+    >>> f(x)
+    f(x)
+    >>> g
+    g(x)
+    >>> f(x).diff(x)
+    Derivative(f(x), x)
+    >>> g.diff(x)
+    Derivative(g(x), x)
+
+    Assumptions can be passed to Function, and if function is initialized with a
+    Symbol, the function inherits the name and assumptions associated with the Symbol:
+
+    >>> f_real = Function('f', real=True)
+    >>> f_real(x).is_real
+    True
+    >>> f_real_inherit = Function(Symbol('f', real=True))
+    >>> f_real_inherit(x).is_real
+    True
+
+    Note that assumptions on a function are unrelated to the assumptions on
+    the variable it is called on. If you want to add a relationship, subclass
+    Function and define the appropriate ``_eval_is_assumption`` methods.
+
+    In the following example Function is used as a base class for
+    ``my_func`` that represents a mathematical function *my_func*. Suppose
+    that it is well known, that *my_func(0)* is *1* and *my_func* at infinity
+    goes to *0*, so we want those two simplifications to occur automatically.
+    Suppose also that *my_func(x)* is real exactly when *x* is real. Here is
+    an implementation that honours those requirements:
+
+    >>> from sympy import Function, S, oo, I, sin
+    >>> class my_func(Function):
+    ...
+    ...     @classmethod
+    ...     def eval(cls, x):
+    ...         if x.is_Number:
+    ...             if x.is_zero:
+    ...                 return S.One
+    ...             elif x is S.Infinity:
+    ...                 return S.Zero
+    ...
+    ...     def _eval_is_real(self):
+    ...         return self.args[0].is_real
+    ...
+    >>> x = S('x')
+    >>> my_func(0) + sin(0)
+    1
+    >>> my_func(oo)
+    0
+    >>> my_func(3.54).n() # Not yet implemented for my_func.
+    my_func(3.54)
+    >>> my_func(I).is_real
+    False
+
+    In order for ``my_func`` to become useful, several other methods would
+    need to be implemented. See source code of some of the already
+    implemented functions for more complete examples.
+
+    Also, if the function can take more than one argument, then ``nargs``
+    must be defined, e.g. if ``my_func`` can take one or two arguments
+    then,
+
+    >>> class my_func(Function):
+    ...     nargs = (1, 2)
+    ...
+    >>>
+
+    """
+
+    @property
+    def _diff_wrt(self):
+        return False
+
+    @cacheit
+    def __new__(cls, *args, **options):
+        # Handle calls like Function('f')
+        if cls is Function:
+            return UndefinedFunction(*args, **options)
+
+        n = len(args)
+        if n not in cls.nargs:
+            # XXX: exception message must be in exactly this format to
+            # make it work with NumPy's functions like vectorize(). See,
+            # for example, https://github.com/numpy/numpy/issues/1697.
+            # The ideal solution would be just to attach metadata to
+            # the exception and change NumPy to take advantage of this.
+            temp = ('%(name)s takes %(qual)s %(args)s '
+                   'argument%(plural)s (%(given)s given)')
+            raise TypeError(temp % {
+                'name': cls,
+                'qual': 'exactly' if len(cls.nargs) == 1 else 'at least',
+                'args': min(cls.nargs),
+                'plural': 's'*(min(cls.nargs) != 1),
+                'given': n})
+
+        evaluate = options.get('evaluate', global_parameters.evaluate)
+        result = super().__new__(cls, *args, **options)
+        if evaluate and isinstance(result, cls) and result.args:
+            pr2 = min(cls._should_evalf(a) for a in result.args)
+            if pr2 > 0:
+                pr = max(cls._should_evalf(a) for a in result.args)
+                result = result.evalf(mlib.libmpf.prec_to_dps(pr))
+
+        return result
+
+    @classmethod
+    def _should_evalf(cls, arg):
+        """
+        Decide if the function should automatically evalf().
+
+        By default (in this implementation), this happens if (and only if) the
+        ARG is a floating point number.
+        This function is used by __new__.
+
+        Returns the precision to evalf to, or -1 if it shouldn't evalf.
+        """
+        from sympy.core.evalf import pure_complex
+        if arg.is_Float:
+            return arg._prec
+        if not arg.is_Add:
+            return -1
+        m = pure_complex(arg)
+        if m is None or not (m[0].is_Float or m[1].is_Float):
+            return -1
+        l = [i._prec for i in m if i.is_Float]
+        l.append(-1)
+        return max(l)
+
+    @classmethod
+    def class_key(cls):
+        from sympy.sets.fancysets import Naturals0
+        funcs = {
+            'exp': 10,
+            'log': 11,
+            'sin': 20,
+            'cos': 21,
+            'tan': 22,
+            'cot': 23,
+            'sinh': 30,
+            'cosh': 31,
+            'tanh': 32,
+            'coth': 33,
+            'conjugate': 40,
+            're': 41,
+            'im': 42,
+            'arg': 43,
+        }
+        name = cls.__name__
+
+        try:
+            i = funcs[name]
+        except KeyError:
+            i = 0 if isinstance(cls.nargs, Naturals0) else 10000
+
+        return 4, i, name
+
+    def _eval_evalf(self, prec):
+
+        def _get_mpmath_func(fname):
+            """Lookup mpmath function based on name"""
+            if isinstance(self, AppliedUndef):
+                # Shouldn't lookup in mpmath but might have ._imp_
+                return None
+
+            if not hasattr(mpmath, fname):
+                from sympy.utilities.lambdify import MPMATH_TRANSLATIONS
+                fname = MPMATH_TRANSLATIONS.get(fname, None)
+                if fname is None:
+                    return None
+            return getattr(mpmath, fname)
+
+        func = _get_mpmath_func(self.func.__name__)
+
+        # Fall-back evaluation
+        if func is None:
+            imp = getattr(self, '_imp_', None)
+            if imp is None:
+                return None
+            try:
+                return Float(imp(*[i.evalf(prec) for i in self.args]), prec)
+            except (TypeError, ValueError):
+                return None
+
+        # Convert all args to mpf or mpc
+        # Convert the arguments to *higher* precision than requested for the
+        # final result.
+        # XXX + 5 is a guess, it is similar to what is used in evalf.py. Should
+        #     we be more intelligent about it?
+        try:
+            args = [arg._to_mpmath(prec + 5) for arg in self.args]
+            def bad(m):
+                from mpmath import mpf, mpc
+                # the precision of an mpf value is the last element
+                # if that is 1 (and m[1] is not 1 which would indicate a
+                # power of 2), then the eval failed; so check that none of
+                # the arguments failed to compute to a finite precision.
+                # Note: An mpc value has two parts, the re and imag tuple;
+                # check each of those parts, too. Anything else is allowed to
+                # pass
+                if isinstance(m, mpf):
+                    m = m._mpf_
+                    return m[1] !=1 and m[-1] == 1
+                elif isinstance(m, mpc):
+                    m, n = m._mpc_
+                    return m[1] !=1 and m[-1] == 1 and \
+                        n[1] !=1 and n[-1] == 1
+                else:
+                    return False
+            if any(bad(a) for a in args):
+                raise ValueError  # one or more args failed to compute with significance
+        except ValueError:
+            return
+
+        with mpmath.workprec(prec):
+            v = func(*args)
+
+        return Expr._from_mpmath(v, prec)
+
+    def _eval_derivative(self, s):
+        # f(x).diff(s) -> x.diff(s) * f.fdiff(1)(s)
+        i = 0
+        l = []
+        for a in self.args:
+            i += 1
+            da = a.diff(s)
+            if da.is_zero:
+                continue
+            try:
+                df = self.fdiff(i)
+            except ArgumentIndexError:
+                df = Function.fdiff(self, i)
+            l.append(df * da)
+        return Add(*l)
+
+    def _eval_is_commutative(self):
+        return fuzzy_and(a.is_commutative for a in self.args)
+
+    def _eval_is_meromorphic(self, x, a):
+        if not self.args:
+            return True
+        if any(arg.has(x) for arg in self.args[1:]):
+            return False
+
+        arg = self.args[0]
+        if not arg._eval_is_meromorphic(x, a):
+            return None
+
+        return fuzzy_not(type(self).is_singular(arg.subs(x, a)))
 
+    _singularities = None  # indeterminate
+
+    @classmethod
+    def is_singular(cls, a):
+        """
+        Tests whether the argument is an essential singularity
+        or a branch point, or the functions is non-holomorphic.
+        """
+        ss = cls._singularities
+        if ss in (True, None, False):
+            return ss
+
+        return fuzzy_or(a.is_infinite if s is S.ComplexInfinity
+                        else (a - s).is_zero for s in ss)
+
+    def as_base_exp(self):
+        """
+        Returns the method as the 2-tuple (base, exponent).
+        """
+        return self, S.One
+
+    def _eval_aseries(self, n, args0, x, logx):
+        """
+        Compute an asymptotic expansion around args0, in terms of self.args.
+        This function is only used internally by _eval_nseries and should not
+        be called directly; derived classes can overwrite this to implement
+        asymptotic expansions.
+        """
+        from sympy.utilities.misc import filldedent
+        raise PoleError(filldedent('''
+            Asymptotic expansion of %s around %s is
+            not implemented.''' % (type(self), args0)))
+
+    def _eval_nseries(self, x, n, logx):
+        """
+        This function does compute series for multivariate functions,
+        but the expansion is always in terms of *one* variable.
+
+        Examples
+        ========
+
+        >>> from sympy import atan2
+        >>> from sympy.abc import x, y
+        >>> atan2(x, y).series(x, n=2)
+        atan2(0, y) + x/y + O(x**2)
+        >>> atan2(x, y).series(y, n=2)
+        -y/x + atan2(x, 0) + O(y**2)
+
+        This function also computes asymptotic expansions, if necessary
+        and possible:
+
+        >>> from sympy import loggamma
+        >>> loggamma(1/x)._eval_nseries(x,0,None)
+        -1/x - log(x)/x + log(x)/2 + O(1)
+
+        """
+        from sympy import Order
+        from sympy.sets.sets import FiniteSet
+        args = self.args
+        args0 = [t.limit(x, 0) for t in args]
+        if any(t.is_finite is False for t in args0):
+            from sympy import oo, zoo, nan
+            # XXX could use t.as_leading_term(x) here but it's a little
+            # slower
+            a = [t.compute_leading_term(x, logx=logx) for t in args]
+            a0 = [t.limit(x, 0) for t in a]
+            if any([t.has(oo, -oo, zoo, nan) for t in a0]):
+                return self._eval_aseries(n, args0, x, logx)
+            # Careful: the argument goes to oo, but only logarithmically so. We
+            # are supposed to do a power series expansion "around the
+            # logarithmic term". e.g.
+            #      f(1+x+log(x))
+            #     -> f(1+logx) + x*f'(1+logx) + O(x**2)
+            # where 'logx' is given in the argument
+            a = [t._eval_nseries(x, n, logx) for t in args]
+            z = [r - r0 for (r, r0) in zip(a, a0)]
+            p = [Dummy() for _ in z]
+            q = []
+            v = None
+            for ai, zi, pi in zip(a0, z, p):
+                if zi.has(x):
+                    if v is not None:
+                        raise NotImplementedError
+                    q.append(ai + pi)
+                    v = pi
+                else:
+                    q.append(ai)
+            e1 = self.func(*q)
+            if v is None:
+                return e1
+            s = e1._eval_nseries(v, n, logx)
+            o = s.getO()
+            s = s.removeO()
+            s = s.subs(v, zi).expand() + Order(o.expr.subs(v, zi), x)
+            return s
+        if (self.func.nargs is S.Naturals0
+                or (self.func.nargs == FiniteSet(1) and args0[0])
+                or any(c > 1 for c in self.func.nargs)):
+            e = self
+            e1 = e.expand()
+            if e == e1:
+                #for example when e = sin(x+1) or e = sin(cos(x))
+                #let's try the general algorithm
+                if len(e.args) == 1:
+                    # issue 14411
+                    e = e.func(e.args[0].cancel())
+                term = e.subs(x, S.Zero)
+                if term.is_finite is False or term is S.NaN:
+                    raise PoleError("Cannot expand %s around 0" % (self))
+                series = term
+                fact = S.One
+                _x = Dummy('x')
+                e = e.subs(x, _x)
+                for i in range(n - 1):
+                    i += 1
+                    fact *= Rational(i)
+                    e = e.diff(_x)
+                    subs = e.subs(_x, S.Zero)
+                    if subs is S.NaN:
+                        # try to evaluate a limit if we have to
+                        subs = e.limit(_x, S.Zero)
+                    if subs.is_finite is False:
+                        raise PoleError("Cannot expand %s around 0" % (self))
+                    term = subs*(x**i)/fact
+                    term = term.expand()
+                    series += term
+                return series + Order(x**n, x)
+            return e1.nseries(x, n=n, logx=logx)
+        arg = self.args[0]
+        l = []
+        g = None
+        # try to predict a number of terms needed
+        nterms = n + 2
+        cf = Order(arg.as_leading_term(x), x).getn()
+        if cf != 0:
+            nterms = (n/cf).ceiling()
+        for i in range(nterms):
+            g = self.taylor_term(i, arg, g)
+            g = g.nseries(x, n=n, logx=logx)
+            l.append(g)
+        return Add(*l) + Order(x**n, x)
+
+    def fdiff(self, argindex=1):
+        """
+        Returns the first derivative of the function.
+        """
+        if not (1 <= argindex <= len(self.args)):
+            raise ArgumentIndexError(self, argindex)
+        ix = argindex - 1
+        A = self.args[ix]
+        if A._diff_wrt:
+            if len(self.args) == 1 or not A.is_Symbol:
+                return Derivative(self, A)
+            for i, v in enumerate(self.args):
+                if i != ix and A in v.free_symbols:
+                    # it can't be in any other argument's free symbols
+                    # issue 8510
+                    break
+            else:
+                    return Derivative(self, A)
+
+        # See issue 4624 and issue 4719, 5600 and 8510
+        D = Dummy('xi_%i' % argindex, dummy_index=hash(A))
+        args = self.args[:ix] + (D,) + self.args[ix + 1:]
+        return Subs(Derivative(self.func(*args), D), D, A)
+
+    def _eval_as_leading_term(self, x):
+        """Stub that should be overridden by new Functions to return
+        the first non-zero term in a series if ever an x-dependent
+        argument whose leading term vanishes as x -> 0 might be encountered.
+        See, for example, cos._eval_as_leading_term.
+        """
+        from sympy import Order
+        args = [a.as_leading_term(x) for a in self.args]
+        o = Order(1, x)
+        if any(x in a.free_symbols and o.contains(a) for a in args):
+            # Whereas x and any finite number are contained in O(1, x
 
 class AppliedUndef(Function):
     """
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -e .
Obtaining file:///testbed
  Preparing metadata (setup.py): started
  Preparing metadata (setup.py): finished with status 'done'
Requirement already satisfied: mpmath>=0.19 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sympy==1.7.dev0) (1.3.0)
Installing collected packages: sympy
  Attempting uninstall: sympy
    Found existing installation: sympy 1.7.dev0
    Uninstalling sympy-1.7.dev0:
      Successfully uninstalled sympy-1.7.dev0
  Running setup.py develop for sympy
Successfully installed sympy-1.7.dev0
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv
+ git checkout 25fbcce5b1a4c7e3956e6062930f4a44ce95a632 sympy/core/tests/test_subs.py sympy/functions/elementary/tests/test_complexes.py
Updated 0 paths from 91f694b2d2
+ git apply -v -
Checking patch sympy/core/tests/test_subs.py...
Checking patch sympy/functions/elementary/tests/test_complexes.py...
Applied patch sympy/core/tests/test_subs.py cleanly.
Applied patch sympy/functions/elementary/tests/test_complexes.py cleanly.
+ PYTHONWARNINGS=ignore::UserWarning,ignore::SyntaxWarning
+ bin/test -C --verbose sympy/core/tests/test_subs.py sympy/functions/elementary/tests/test_complexes.py
Traceback (most recent call last):
  File "/testbed/bin/test", line 95, in <module>
    import sympy
  File "/testbed/sympy/__init__.py", line 51, in <module>
    from .core import (sympify, SympifyError, cacheit, Basic, Atom,
  File "/testbed/sympy/core/__init__.py", line 9, in <module>
    from .expr import Expr, AtomicExpr, UnevaluatedExpr
  File "/testbed/sympy/core/expr.py", line 4045, in <module>
    from .mul import Mul
  File "/testbed/sympy/core/mul.py", line 1978, in <module>
    from .numbers import Rational
  File "/testbed/sympy/core/numbers.py", line 3931, in <module>
    from .power import Pow, integer_nthroot
  File "/testbed/sympy/core/power.py", line 8, in <module>
    from .function import (_coeff_isneg, expand_complex, expand_multinomial,
  File "/testbed/sympy/core/function.py", line 1275
    class AppliedUndef(Function):
IndentationError: expected an indented block
+ git checkout 25fbcce5b1a4c7e3956e6062930f4a44ce95a632 sympy/core/tests/test_subs.py sympy/functions/elementary/tests/test_complexes.py
Updated 2 paths from 91f694b2d2
